<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ValenShi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://valenshi.top/"/>
  <updated>2019-08-29T01:55:49.636Z</updated>
  <id>http://valenshi.top/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>可持久化线段树（主席树）</title>
    <link href="http://valenshi.top/2019/08/28/dynamic-zx/"/>
    <id>http://valenshi.top/2019/08/28/dynamic-zx/</id>
    <published>2019-08-28T12:45:37.000Z</published>
    <updated>2019-08-29T01:55:49.636Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>主席树，又称可持久化线段树，属于可持久化数据结构。“主席”这一名词是由于发明者缩写为HJT，和某位主席拼音缩写相同（有些牵强），故将该数据结构称为主席树。<br>主席树既保留了线段树的灵活，也拥有了可持久化数据结构的特点，在处理某些特定问题时有着其它数据结构不具有的优势。<br>本文将首先介绍什么是“可持久化数据结构”，随后介绍主席树的思想，关于代码实现将结合例题讲解。</p><h4 id="可持久化数据结构"><a href="#可持久化数据结构" class="headerlink" title="可持久化数据结构"></a>可持久化数据结构</h4><p>可持久数据结构主要指的是我们可以查询历史版本的情况并支持插入，利用使用之前历史版本的数据结构来减少对空间的消耗（能够对历史进行修改的是函数式编程 [1]）。</p><p>我们经常会遇到这样的问题：我们需要维护一个数据结构，我们可以修改单一结点的值，查询单一结点的值，但是最关键的是我们可能还需要回退之前做过的某些操作。这里回退是指回到未做这些操作之前的状态。</p><p>在无回退操作的情况下，我们有大把的数据结构可供选择来解决这些问题。但是一旦涉及到回退操作，选择就少的多了。我们将支持回退操作的数据结构称为可持久化数据结构。</p><p>稍微思考一下如何可以在原来数据结构的基础上使其变得可持久化，有一个很简单的方案。我们每次操作都将重新建立一个新的数据结构，并将之前的操作都先在其上执行一次，之后执行该次操作。我们按操作执行顺序将这些数据结构维护成一个序列S，此时S[0]表示未经任何操作的初始数据结构。对于i&gt;0，S[i]表示在S[0]的基础上执行过序号1到i的所有操作后得到的新的数据结构。在这样的做法下，我们称S[i]为版本i，回退操作等价于切换到某个特定版本。若操作i表示切换为版本j，那么我们可以直接将S[i]设置为S[j]的克隆。</p><p>上面提到的做法下很容易发现可以使得任意数据结构都可以支持回退操作，但是缺点也是非常明显，空间和时间的复杂度都奇高。每一次操作都需要累加之前操作的时间复杂度，空间也是，我们为了保存各个版本需要耗费大量的内存。</p><p>先说明时间复杂度的优化，对于i号操作，我们完全可以直接克隆版本S[i-1]并在其上执行i号操作，这样时间复杂度基本上就向空间复杂度看齐了。下面我们就可以专注于空间复杂度的优化（对应的也就是时间复杂度的优化）。</p><p>数据结构是用于保存数据的，我们将其保存数据的单元称为结点，我们可以利用结点来刻画整个数据结构的骨架。数据结构基本分为两类，一类是稳定的，一类是不稳定的。稳定的数据结构，其特定是在修改的结点的值之后不会改变结点之间的关系，而不稳定的数据结构在结点值变更后需要重新维护结点之间的关联。稳定的数据结构有线段树，后缀数组，前缀树等等，不稳定的数据结构主要就是各种二叉平衡树。对于稳定的树状结构，若孩子没有保存指向父结点的指针，即由父亲负责记录所有的孩子，我们很容易发现，当我们对某个结点更改时（修改值，新增，删除等操作），我们只需要同时修改该结点的所有祖先结点即可，那我们是不是也可以只克隆这些结点而非整个数据结构呢？答案是肯定的。由于父亲维护孩子，因此一个孩子允许有多个父亲，故所有没有被直接影响的结点都可以继续复用。我们将部分树状数据结构（特定是稳定和父亲维护父子关系）的一次操作的空间复杂度优化到了O(h)，其中h是树状数据结构的高度。</p><p>当我们将上面的想法作用到线段树时，就得到了常说的主席树。其高度为$O(log_2(n))$，其中n为线段树维护的区间大小，同时其时间和空间复杂度均为$O(log_2(n)^2)$。</p><p><em>引用自：<a href="https://www.cnblogs.com/dalt/p/8324781.html" target="_blank" rel="noopener">陶无语的博客</a></em></p><h4 id="静态主席树"><a href="#静态主席树" class="headerlink" title="静态主席树"></a>静态主席树</h4><p>我们按照“是否支持修改”来将主席树划分为静态和动态。静态主席树一旦建树成功，就不再支持修改，只能够用于查询。静态主席树维护元素出现次数的前缀和。</p><blockquote><p>例题：洛谷P3834，查询区间第k大值<br>给定n个元素，共m个询问，每次询问给出[l ,r]和k，回答区间[l , r]内第k大元素值是多少。</p></blockquote><h5 id="建树："><a href="#建树：" class="headerlink" title="建树："></a>建树：</h5><p>考虑用主席树解决上述问题，给出如下建树步骤：</p><ol><li>新建一棵完整的空树，其根节点编号存放在root[0]内。</li><li>依次将n个元素插入到“版本0”的空树中，他们的“版本号”（根节点）存放在root[i]中。</li></ol><p>对于每一个“新版本”，我们都在原来基础上新增“需要修改的节点”，并将其根节点记录在root数组中。<br>如此我们的时空花费都与修改的路径成正比，即每次$O(log_2N)$。</p><p>当然这些都是从理论思想上来讲的，比较抽象；具体到这一题，我们令线段树维护区间内元素数量，每个节点有三个变量，分别是 ls , rs , sum，即左儿子编号，右儿子编号，区间内元素个数。<br>初始时sum都为0，随后将n个元素依次插入形成n棵新的线段树，而这n+1棵（包括编号为0的空树）构成了一棵静态主席树。<br>所以建树操作其实分为两步：BuildTree()建立一棵空树并返回根节点编号；updata()在原树基础上“增加一棵新树”，并返回该版本的根节点编号。</p><p>虽然不同历史版本的线段树节点之间有交叉以重复利用，但每个历史版本都有唯一且独立的根节点</p><h5 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h5><p>由于线段树维护的是区间内元素的数量，所以不同版本的线段树的对应节点是可以加减的，那么root[i] - root[j]意义就是“第 i 个版本的线段树比第 j 个版本的线段树多几个元素”。如果我们再加上区间范围限制[l , r]，那么我们也可以查询“第 i 个版本比第 j 个版本，在[l , r]上多几个元素”。</p><p>具体到本题，我们需要查询区间[l , r]内第k大的元素，已知线段树可以加减，那么对于询问(l , r , k)，我们就需要在root[l-1] 与 root[r]两棵线段树上找寻答案，不要忘记了这颗线段树是根据权值建立的，也就是所谓的权值线段树。那么在res个数中找第k个，显然二分（树上），参见代码。</p><h5 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h5><p>见附录部分code-1：洛谷P3834静态主席树模板-求区间第k大值</p><h4 id="动态主席树"><a href="#动态主席树" class="headerlink" title="动态主席树"></a>动态主席树</h4><p>静态主席树虽然支持历史查询，但其功能还是不太强大，因为其不支持更改。我们将支持修改的主席树称为动态主席树，但是这个功能添加起来并不容易。静态主席树还可以看作是线段树通过小修改得到，而动态主席树则是树套树。</p><p>思想依旧是维护元素出现次数的前缀和，可以类比差分数组，我们都知道前缀和数组是不支持修改的，如果要修改，就需要用 树状数组/线段树 来维护，这里也是类似。</p><p>我们考虑“外层用树状数组，内层用记录区间内数值出现次数的线段树”来实现支持修改的可持久化线段树，也即动态主席树。</p><p>在静态主席树上，可以通过两个权值线段树相减来求得区间第k大值，在这里我们仍旧是通过这种方法求区间第k大，不同的是我们需要保证所有线段树的数据是正确的（维护修改）。<br>如果我们用树状数组来维护不同版本的权值线段树的编号，那么对于“将位置 p 的 x 修改为 y”这一操作，我们需要修改共logN个版本的权值线段树，如此修改操作的时间复杂度是$O((log_2N)^2)$。<br>值得注意的是，此时空间复杂度 = 树状数组空间 * 权值线段树空间 = $N^2$，但是树状数组实际上只保存权值线段树的“版本号”而已，因此实际上用到的空间也就只有权值线段树上的$O(N(log_2N)^2)$个节点的空间，因此动态开点即可。</p><h5 id="例题2：洛谷P2617"><a href="#例题2：洛谷P2617" class="headerlink" title="例题2：洛谷P2617"></a>例题2：洛谷P2617</h5><p><strong>代码模板：</strong> 见附录部分code-2</p><h4 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h4><p>[1] 函数式编程：“函数式编程”是一种“编程范式”(programming paradigm)，也就是如何编写程序的方法论。它属于“结构化编程”的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。</p><p><em>引用自：<a href="https://www.cnblogs.com/aezero/p/4979890.html" target="_blank" rel="noopener">aezero的博客</a></em></p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p><strong>code-1：洛谷P3834静态主席树模板-求区间第k大值</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zxTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls,rs,sum;<span class="comment">//左右儿子,区间内元素个数</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(x) tr[x].ls</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(x) tr[x].rs</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[x].sum</span></span><br><span class="line">&#125; tr[N*<span class="number">40</span>];<span class="comment">//注意数组大小</span></span><br><span class="line"><span class="keyword">int</span> sz = <span class="number">0</span>;<span class="comment">//不同版本的树的总数 </span></span><br><span class="line"><span class="keyword">int</span> root[N];<span class="comment">//root[i]存放第i棵树的树根的编号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*建树,和普通线段树相同*/</span></span><br><span class="line">    <span class="keyword">int</span> rt = ++sz;sum(rt) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> rt;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ls(rt) = BuildTree(l,mid);</span><br><span class="line">    rs(rt) = BuildTree(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> pre,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*新建一棵树,其比pre树多一个元素x*/</span></span><br><span class="line">    <span class="keyword">int</span> rt = ++sz;</span><br><span class="line">    tr[rt] = tr[pre]; sum(rt)++;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> rt;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) ls(rt) = updata(ls(pre),l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> rs(rt) = updata(rs(pre),mid+<span class="number">1</span>,r,x);</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> pre,<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*  依次是:上一个树根,当前树根,区间左右端点,所求区间第k大</span></span><br><span class="line"><span class="comment">        返回该区间第k大数的下标 */</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> res = sum(ls(rt)) - sum(ls(pre));</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(res &gt;= k) <span class="keyword">return</span> ask(ls(pre),ls(rt),l,mid,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ask(rs(pre),rs(rt),mid+<span class="number">1</span>,r,k-res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i),tmp[i] = a[i];</span><br><span class="line">    <span class="comment">//离散化</span></span><br><span class="line">    sort(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">int</span> tot = unique(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+n)-tmp<span class="number">-1</span>;</span><br><span class="line">    root[<span class="number">0</span>] = BuildTree(<span class="number">1</span>,tot);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot,a[i])-tmp;</span><br><span class="line">        root[i] = updata(root[i<span class="number">-1</span>],<span class="number">1</span>,tot,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用主席树可以加减原理计算</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,l,r,k;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;k);</span><br><span class="line">        <span class="keyword">int</span> x = ask(root[l<span class="number">-1</span>],root[r],<span class="number">1</span>,tot,k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tmp[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>code2-洛谷P2617动态主席树</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="comment">/*线段树节点,要存放左右儿子编号,区间内元素个数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls,rs,sum;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(x) tr[x].ls</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(x) tr[x].rs</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[x].sum</span></span><br><span class="line">&#125;tr[N*<span class="number">400</span>];<span class="comment">//空间要N(logN)^2大小</span></span><br><span class="line"><span class="comment">/*因为要离散化,所以要提前读取所有操作*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,k;<span class="comment">//查询操作,询问区间[l,r]内第k大数的值</span></span><br><span class="line">    <span class="keyword">int</span> p,x;    <span class="comment">//修改操作,修改位置p位置上的元素为x</span></span><br><span class="line">&#125;qy[N];</span><br><span class="line"><span class="keyword">int</span> sz = N;<span class="comment">/*不同版本的线段树总数,</span></span><br><span class="line"><span class="comment">即动态申请节点编号,初始值要为N,因为前n个节点被使用*/</span></span><br><span class="line"><span class="keyword">int</span> a[N],n,m,tot = <span class="number">0</span>;<span class="comment">//tot离散化用</span></span><br><span class="line"><span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*对以rt为根的线段树,区间[l,r]内新增一个元素x*/</span></span><br><span class="line">    sum(rt) += d;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>; <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!ls(rt)) ls(rt) = ++sz;<span class="comment">//如果该子树没有子节点则新建</span></span><br><span class="line">    <span class="keyword">if</span>(!rs(rt)) rs(rt) = ++sz;<span class="comment">//动态申请节点</span></span><br><span class="line">    <span class="keyword">if</span>(p &lt;= mid) Insert(ls(rt),l,mid,p,d);</span><br><span class="line">    <span class="keyword">else</span> Insert(rs(rt),mid+<span class="number">1</span>,r,p,d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> p,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*向树状数组中的 线段树中 位置p值+d,要从l开始哦*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = l;x &lt;= n;x += x&amp;-x) Insert(x,<span class="number">1</span>,tot,p,y); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t1[N],t2[N],c1,c2;<span class="comment">//临时记录遍历路径</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*返回区间[l,r]内第k大元素的值(离散化后的)*/</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c1;i++) res -= sum(ls(t1[i]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c2;i++) res += sum(ls(t2[i]));</span><br><span class="line">    <span class="keyword">if</span>(res &gt;= k)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c1;i++) t1[i] = ls(t1[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c2;i++) t2[i] = ls(t2[i]);</span><br><span class="line">    <span class="keyword">return</span> ask(l,mid,k);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c1;i++) t1[i] = rs(t1[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c2;i++) t2[i] = rs(t2[i]);</span><br><span class="line"><span class="keyword">return</span> ask(mid+<span class="number">1</span>,r,k-res);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp[N*<span class="number">2</span>];<span class="comment">//离散化用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">c1 = c2 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*我们将树状数组上待查询的线段树的左儿子编号先存储*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l;i;i -= i&amp;-i) t1[++c1] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = r;i;i -= i&amp;-i) t2[++c2] = i;</span><br><span class="line"><span class="keyword">int</span> x = ask(<span class="number">1</span>,tot,k);<span class="comment">//注意查询区间是[1,tot] </span></span><br><span class="line"><span class="keyword">return</span> tmp[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i),tmp[++tot] = a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'C'</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;qy[i].p,&amp;qy[i].x);</span><br><span class="line">            tmp[++tot] = qy[i].x;<span class="comment">//先存储,方便离散化</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;qy[i].l,&amp;qy[i].r,&amp;qy[i].k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//离散化</span></span><br><span class="line">    sort(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot);</span><br><span class="line">    tot = unique(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot)-tmp<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p = lower_bound(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot,a[i])-tmp;</span><br><span class="line">        add(i,p,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(qy[i].l)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = qy[i].l, r = qy[i].r;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(l<span class="number">-1</span>,r,qy[i].k));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> p = lower_bound(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot,qy[i].x)-tmp;</span><br><span class="line">            <span class="keyword">int</span> pre = lower_bound(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot,a[qy[i].p])-tmp;</span><br><span class="line">            add(qy[i].p,pre,<span class="number">-1</span>); add(qy[i].p,p,<span class="number">1</span>); a[qy[i].p] = qy[i].x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;主席树，又称可持久化线段树，属于可持久化数据结构。“主席”这一名词是由于发明者缩写为HJT，和某位主席拼音缩写相同（有些牵强），故将该数据结
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>权值线段树</title>
    <link href="http://valenshi.top/2019/08/27/qz-tree/"/>
    <id>http://valenshi.top/2019/08/27/qz-tree/</id>
    <published>2019-08-27T04:38:59.000Z</published>
    <updated>2019-08-27T04:40:08.779Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>权值线段树是在普通线段树的基础上进行更改，利用值域建树而非定义域（下标）；这使得线段树具有了一些新的功能，本文就将从权值线段树的来历，用途以及算法流程方面来介绍该数据结构。最终我们会用两个例题来体现权值线段树的用途，当然该代码也作为参考模板。</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>线段树是将下标不断二分，使得树上每个节点对应一段区间，从而将区间操作拆分成有关若干节点的操作。权值线段树与之类似，都是将一段区间不断二分，并令树上每个节点对应一段区间，以此实现“将区间操作变为对树上某条路径的操作”，只不过这里划分的区间不再是下标，而是权值。</p><p>至此其实权值线段树的特点已经很明显了，一般的线段树对下标建树，而权值线段树对权值建树；普通线段树对下标上的值进行操作（加减乘除），而权值线段树对值所对应的下标进行操作。</p><h4 id="权值线段树的用途"><a href="#权值线段树的用途" class="headerlink" title="权值线段树的用途"></a>权值线段树的用途</h4><p>这就好比一个是对 <strong>定义域</strong> 建树，而另一个是对 <strong>值域</strong> 建树，所以权值线段树具有如下用途：</p><ul><li>统计范围内元素的个数（这里的范围是指值域上的范围，例如：求逆序对）。</li><li>查询序列中，下标大于r的 第一个大于 k 的数。</li></ul><p>只是对线段树进行简单的更改，就使其拥有了这些功能（虽然这些功能其它数据结构也能实现），可见线段树的灵活性。</p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>第一步：通常元素的值域范围很大，但是个数很少，所以一般会先对这n个数离散化处理，处理之后就只有tot个不同的值([1 , tot])。</p><p>第二步：对区间[1, tot]建立线段树。</p><p>第三步：按照题意进行操作。</p><h4 id="例题1：求逆序对"><a href="#例题1：求逆序对" class="headerlink" title="例题1：求逆序对"></a>例题1：求逆序对</h4><p><a href="https://www.luogu.org/problem/P1908" target="_blank" rel="noopener">测试地址：洛谷P1908</a><br>虽然我们有更好的求逆序对的方法，例如归并、CDQ分治、树状数组等，但是这题其实也很好的体现权值线段树的思路，作为入门还是很好理解的。</p><p>首先我们将较为分散的n个元素按照权值离散化，离散化之后这n个元素取值范围（映射集合）就在[1,tot]之间，而若  i &gt; j，那么 i 代表的元素一定比 j 代表的元素大。</p><p>接下来从前向后遍历原数组的n个元素，找到其离散化后的标号i，再统计线段树中&gt;i的元素个数有多少个，累加到答案即可。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">权值线段树模板 最后修改:2019/8/25 </span></span><br><span class="line"><span class="comment">洛谷P1908:给出n个数求逆序对数量 </span></span><br><span class="line"><span class="comment">由于值域过于分散,且数字太大,采用离散化方法 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,sum;</span><br><span class="line"><span class="comment">/* 左端点,右端点,[l,r]内元素总数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[x].sum</span></span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ll val;<span class="keyword">int</span> id;</span><br><span class="line"><span class="comment">/*元素的值,序号,用于离散化*/</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; rhs)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &lt; rhs.val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;tmp[N]; </span><br><span class="line"><span class="keyword">int</span> n,tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*对[l,r]建立一棵子树,该子树根节点是rt*/</span></span><br><span class="line">l(rt) = l, r(rt) = r, sum(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid);</span><br><span class="line">BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">/*查询大于等于y的数的个数*/</span> </span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt)) <span class="keyword">return</span> sum(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(y &lt;= mid) <span class="keyword">return</span> ask(rt*<span class="number">2</span>,y)+sum(rt*<span class="number">2</span>+<span class="number">1</span>); <span class="comment">//加上整段右区间 </span></span><br><span class="line"><span class="keyword">return</span> ask(rt*<span class="number">2</span>+<span class="number">1</span>,y);<span class="comment">//答案在右子树 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将p位置+1*/</span></span><br><span class="line"><span class="keyword">if</span>(l(rt) &lt;= p &amp;&amp; p &lt;= r(rt)) sum(rt)++;</span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt)) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= mid) updata(rt*<span class="number">2</span>,p);</span><br><span class="line"><span class="keyword">else</span> updata(rt*<span class="number">2</span>+<span class="number">1</span>,p);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//首先离散化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) tmp[i].val = a[i],tmp[i].id = i; </span><br><span class="line">sort(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+n); tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">1</span> || tmp[i].val != tmp[i<span class="number">-1</span>].val) ++tot;</span><br><span class="line">a[tmp[i].id] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//离散化之后值域[1,tot],以此为区间建树</span></span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,tot); </span><br><span class="line"><span class="comment">//下一步就是查询与更新了</span></span><br><span class="line">ll ans = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ans += ask(<span class="number">1</span>,a[i]+<span class="number">1</span>);<span class="comment">//在前i-1个数中,比a[i]大的有多少</span></span><br><span class="line">updata(<span class="number">1</span>,a[i]);<span class="comment">//值为a[i]的数+1 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="例题2：2019CCPC网络赛-B-array"><a href="#例题2：2019CCPC网络赛-B-array" class="headerlink" title="例题2：2019CCPC网络赛 B.array"></a>例题2：2019CCPC网络赛 B.array</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6703" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定1~n共n个数组成的序列，有m次操作，每次操作有两种可能：</p><ol><li>(1,pos)令 $a_{pos} = a_{pos}+1,000,000$。</li><li>(2, r , k) 回答不在$a_i(1&lt;= i &lt;= r)$内的，大于等于k的最小值。</li></ol><p>强制在线。<br><strong>解题思路：</strong><br>首先是理解题意，然后如果按照题目要求来解题，我们需要每次都通过遍历来排除[1,r]内的元素，显然会超时。由于题目中$a_i$是各不相同的，又是小于n的，因此我们可以将原问题转化为求“大于等于k的所有元素中，第一个下标大于r的元素的值”。对于这个问题我们每次需要询问所有值在[k,n+10]内，第一个下标大于r的即可。</p><p>于是我们可以通过建立权值线段树，线段树的下标是值$a_i$，值是下标i，对于每个操作1，就相当于把pos位置上的数删掉了。加上一些小剪枝就可以过。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="comment">/*区间[l,r]内元素个数为sum*/</span></span><br><span class="line"><span class="keyword">int</span> l,r,sum,mx;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mx(x) tr[x].mx</span></span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="comment">/*a数组存放序列,b数组离散化用</span></span><br><span class="line"><span class="comment">tot是离散化后不同元素个数 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ll a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> n,m,tot,t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*对[l,r]建立一棵根为rt的子树*/</span></span><br><span class="line">l(rt) = l, r(rt) = r , mx(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid);</span><br><span class="line">BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="comment">/*p位置值+1(值为p的元素的数量+1)*/</span></span><br><span class="line"><span class="comment">//printf("%d %d %d %d %d\n",rt,l(rt),r(rt),p,d);</span></span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">mx(rt) = d; <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= mid) Insert(rt*<span class="number">2</span>,p,d);</span><br><span class="line"><span class="keyword">else</span> Insert(rt*<span class="number">2</span>+<span class="number">1</span>,p,d); </span><br><span class="line">mx(rt) = max(mx(rt*<span class="number">2</span>),mx(rt*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> k,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">//printf("%d %d %d %d %d %d\n",rt,l(rt),r(rt),k,r,mx(rt));</span></span><br><span class="line"><span class="comment">/*返回[k,n]中第一个大于r的值*/</span></span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line"><span class="keyword">if</span>(mx(rt) &lt;= r) <span class="keyword">return</span> -INF;</span><br><span class="line"><span class="keyword">return</span> l(rt);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(k &lt;= mid &amp;&amp; mx(rt*<span class="number">2</span>) &gt; r) res = ask(rt*<span class="number">2</span>,k,r);</span><br><span class="line"><span class="keyword">if</span>(res &lt;= <span class="number">0</span>) <span class="keyword">return</span> ask(rt*<span class="number">2</span>+<span class="number">1</span>,k,r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,a+i);</span><br><span class="line">Insert(<span class="number">1</span>,a[i],i);<span class="comment">//a[i]下标为 i </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n+<span class="number">1</span>;i &lt;= n+<span class="number">10</span>;i++) Insert(<span class="number">1</span>,i,INF);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,op,pos,r,k;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op);</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;pos);</span><br><span class="line">pos ^= ans;</span><br><span class="line">Insert(<span class="number">1</span>,a[pos],INF);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;r,&amp;k);</span><br><span class="line">k ^= ans, r ^= ans;</span><br><span class="line">ans = ask(<span class="number">1</span>,k,r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;权值线段树是在普通线段树的基础上进行更改，利用值域建树而非定义域（下标）；这使得线段树具有了一些新的功能，本文就将从权值线段树的来历，用途以
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构域算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%9F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2019CCPC网络赛部分题解</title>
    <link href="http://valenshi.top/2019/08/25/2019ccpc/"/>
    <id>http://valenshi.top/2019/08/25/2019ccpc/</id>
    <published>2019-08-25T09:06:24.000Z</published>
    <updated>2019-08-26T02:40:36.542Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1001-amp"><a href="#1001-amp" class="headerlink" title="1001 ^&amp;^"></a>1001 ^&amp;^</h4><p><strong>题意简述：</strong><br>给定正整数a和b，找到一个最小的正整数c，使得(a^c)&amp;(b^c)最小。<br><strong>解题思路：</strong><br>两个数按位与最小结果肯定是0啊，所以对于a和b，如果它们对应二进制位上有0，则c置为0即可，因为0^0 = 0 , 这就保证了异或之后肯定有一个是0，再&amp;之后还是0；若它们对应二进制位都是1，则只能置c的对应二进制位为1了，因为1^1 = 0。</p><p>值得注意的是，所求结果c是正整数，所以如果当c = 0时，则需要从低位向高位，将0-1或1-0位时，c对应二进制位 = 1。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">ll a,b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((a&amp;(<span class="number">1l</span>l&lt;&lt;i)) &amp;&amp; (b&amp;(<span class="number">1l</span>l&lt;&lt;i))) c = c|(<span class="number">1l</span>l&lt;&lt;i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((a&amp;(<span class="number">1l</span>l&lt;&lt;i)) != (b&amp;(<span class="number">1l</span>l&lt;&lt;i)))&#123;</span><br><span class="line">                c = c|(<span class="number">1l</span>l&lt;&lt;i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;a,&amp;b);</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1002-array"><a href="#1002-array" class="headerlink" title="1002 array"></a>1002 array</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6703" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定1~n共n个数组成的序列，有m次操作，每次操作有两种可能：</p><ol><li>(1,pos)令 $a_{pos} = a_{pos}+1,000,000$。</li><li>(2, r , k) 回答不在$a_i(1&lt;= i &lt;= r)$内的，大于等于k的最小值。</li></ol><p>强制在线。<br><strong>解题思路：</strong><br>首先是理解题意，然后如果按照题目要求来解题，我们需要每次都通过遍历来排除[1,r]内的元素，显然会超时。由于题目中$a_i$是各不相同的，又是小于n的，因此我们可以将原问题转化为求“大于等于k的所有元素中，第一个下标大于r的元素的值”。对于这个问题我们每次需要询问所有值在[k,n+10]内，第一个下标大于r的即可。</p><p>于是我们可以通过建立权值线段树，线段树的下标是值$a_i$，值是下标i，对于每个操作1，就相当于把pos位置上的数删掉了。加上一些小剪枝就可以过。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="comment">/*区间[l,r]内元素个数为sum*/</span></span><br><span class="line"><span class="keyword">int</span> l,r,sum,mx;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mx(x) tr[x].mx</span></span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="comment">/*a数组存放序列,b数组离散化用</span></span><br><span class="line"><span class="comment">tot是离散化后不同元素个数 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ll a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> n,m,tot,t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*对[l,r]建立一棵根为rt的子树*/</span></span><br><span class="line">l(rt) = l, r(rt) = r , mx(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid);</span><br><span class="line">BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="comment">/*p位置值+1(值为p的元素的数量+1)*/</span></span><br><span class="line"><span class="comment">//printf("%d %d %d %d %d\n",rt,l(rt),r(rt),p,d);</span></span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">mx(rt) = d; <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= mid) Insert(rt*<span class="number">2</span>,p,d);</span><br><span class="line"><span class="keyword">else</span> Insert(rt*<span class="number">2</span>+<span class="number">1</span>,p,d); </span><br><span class="line">mx(rt) = max(mx(rt*<span class="number">2</span>),mx(rt*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> k,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">//printf("%d %d %d %d %d %d\n",rt,l(rt),r(rt),k,r,mx(rt));</span></span><br><span class="line"><span class="comment">/*返回[k,n]中第一个大于r的值*/</span></span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line"><span class="keyword">if</span>(mx(rt) &lt;= r) <span class="keyword">return</span> -INF;</span><br><span class="line"><span class="keyword">return</span> l(rt);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(k &lt;= mid &amp;&amp; mx(rt*<span class="number">2</span>) &gt; r) res = ask(rt*<span class="number">2</span>,k,r);</span><br><span class="line"><span class="keyword">if</span>(res &lt;= <span class="number">0</span>) <span class="keyword">return</span> ask(rt*<span class="number">2</span>+<span class="number">1</span>,k,r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,a+i);</span><br><span class="line">Insert(<span class="number">1</span>,a[i],i);<span class="comment">//a[i]下标为 i </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n+<span class="number">1</span>;i &lt;= n+<span class="number">10</span>;i++) Insert(<span class="number">1</span>,i,INF);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,op,pos,r,k;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op);</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;pos);</span><br><span class="line">pos ^= ans;</span><br><span class="line">Insert(<span class="number">1</span>,a[pos],INF);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;r,&amp;k);</span><br><span class="line">k ^= ans, r ^= ans;</span><br><span class="line">ans = ask(<span class="number">1</span>,k,r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1004-Path"><a href="#1004-Path" class="headerlink" title="1004 Path"></a>1004 Path</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6705" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>一共有n个点m条边和q次询问，每次询问给出一个整数k，请问在图中的所有路径中第k短的路径长度是多少？</p><p><strong>解题思路：</strong><br>刚开始思路有些不对，其实这题并不是求最短路或者A *  或怎样，据说是常见套路。<br>首先前m短的边就是这m条边，我们可以利用优先队列维护 路径，而一条路径由“起点，终点，路径长度，上一个点的编号，该边在上一个点所有边中的排名”构成。</p><p>这样每次从最小堆中弹出一条路径，该路径就是剩下所有路径中最短的一条；而且该路径只有“从当前终点出发走下一条最短边”和“返回到上一个节点par，然后从par走次短边”这两种可能会对最终答案有贡献，所以将这两条路径再压入最小堆即可，如此反复操作直至求得所有最短路径。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x:边的起点,y:终点,par:上一个点的编号,</span></span><br><span class="line"><span class="comment">rk:在上一个点的所有出边中名次,d:路径长度 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> x,y,par,rk;</span><br><span class="line">ll d;</span><br><span class="line">Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y,ll d,<span class="keyword">int</span> par,<span class="keyword">int</span> rk):x(x),y(y),d(d),par(par),rk(rk)&#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; B)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> d &gt; B.d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">ll dis[N];</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"><span class="keyword">int</span> t,n,m,qq,k;</span><br><span class="line"><span class="keyword">int</span> a[N],ord[N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,ll&gt; pa;</span><br><span class="line"><span class="built_in">vector</span>&lt;pa&gt; G[N];<span class="comment">//存储点的所有出边,按权值升序 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">Node e = q.top();q.pop();</span><br><span class="line">dis[++cnt] = e.d;</span><br><span class="line"><span class="keyword">if</span>(cnt &gt; k) <span class="keyword">break</span>;<span class="comment">//统计出来前k个即可</span></span><br><span class="line"><span class="comment">/*只有两种情况可能更新答案*/</span> </span><br><span class="line"><span class="keyword">if</span>(G[e.par].size() &gt; e.rk+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> x = e.x,y = G[e.x][e.rk+<span class="number">1</span>].second , par = x, rk = e.rk+<span class="number">1</span>;</span><br><span class="line">ll z = e.d - G[e.x][e.rk].first+G[e.x][rk].first;</span><br><span class="line">q.push(Node(x,y,z,par,rk));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(G[e.y].size()) </span><br><span class="line">q.push(Node(e.y,G[e.y][<span class="number">0</span>].second,e.d+G[e.y][<span class="number">0</span>].first,e.y,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;qq); k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) G[i].clear(),ord[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">G[x].push_back(make_pair(z,y));</span><br><span class="line">q.push(Node(x,y,z,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) sort(G[i].begin(),G[i].end());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= qq;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i),k = k&gt;a[i]?k:a[i];</span><br><span class="line">solve();<span class="comment">//预处理 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= qq;i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dis[a[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1006-Shuffle-Card"><a href="#1006-Shuffle-Card" class="headerlink" title="1006 Shuffle Card"></a>1006 Shuffle Card</h4><p><strong>解题思路：</strong><br>队友一发过了，听说是个模拟题，ccfnb。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,q,s;</span><br><span class="line"><span class="keyword">int</span> bk[Max];</span><br><span class="line"><span class="keyword">int</span> val[Max];</span><br><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; deq;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val[i]);</span><br><span class="line">        deq.push_back(val[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s);</span><br><span class="line">        deq.push_front(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!deq.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(!bk[deq.front()])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,deq.front());</span><br><span class="line">            bk[deq.front()] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        deq.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1007-Windows-Of-CCPC"><a href="#1007-Windows-Of-CCPC" class="headerlink" title="1007 Windows Of CCPC"></a>1007 Windows Of CCPC</h4><p><strong>题意简述：</strong><br>输出CCPC，当然是2 <em> 2矩阵输出，此为单元。如果n &gt; 1，那么就递归n - 1次，每次递归都把C替换成一个标准单元，把P替换为一个“反单元”（反单元即将标准单元中的C替换为P，P替换为C，即PPCP，也是2 </em> 2矩阵形式）作为新的矩阵。<br>给定n，输出结果。<br><strong>解题思路：</strong><br>就是简单的模拟，用数组，当然最好用putchar，否则可能会超时，还有就是n最大是10，可以输出到txt文件中肉眼观察一下是否正确再提交。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,k;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3400</span>;</span><br><span class="line"><span class="keyword">char</span> G[N][N];</span><br><span class="line"><span class="keyword">char</span> tmp[N][N]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    G[<span class="number">1</span>][<span class="number">1</span>] = G[<span class="number">1</span>][<span class="number">2</span>] = G[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">'C'</span>;</span><br><span class="line">    G[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">'P'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= (<span class="number">1</span>&lt;&lt;i);j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> z = <span class="number">1</span>;z &lt;= (<span class="number">1</span>&lt;&lt;i);z++)&#123;</span><br><span class="line">                <span class="keyword">int</span> r = <span class="number">2</span>*(j<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> c = <span class="number">2</span>*(z<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(G[j][z] == <span class="string">'C'</span>)&#123;</span><br><span class="line">                    tmp[r][c] = tmp[r][c+<span class="number">1</span>] = tmp[r+<span class="number">1</span>][c+<span class="number">1</span>] = <span class="string">'C'</span>;</span><br><span class="line">                    tmp[r+<span class="number">1</span>][c] = <span class="string">'P'</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tmp[r][c] = tmp[r][c+<span class="number">1</span>] = tmp[r+<span class="number">1</span>][c+<span class="number">1</span>] = <span class="string">'P'</span>;</span><br><span class="line">                    tmp[r+<span class="number">1</span>][c] = <span class="string">'C'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= (<span class="number">1</span>&lt;&lt;i);j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> z = <span class="number">1</span>;z &lt;= (<span class="number">1</span>&lt;&lt;i);z++)</span><br><span class="line">              G[j][z] = tmp[j][z];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1</span>&lt;&lt;k;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">1</span>&lt;&lt;k;j++) <span class="built_in">putchar</span>(G[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("out.txt","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1008-Fishing-Master"><a href="#1008-Fishing-Master" class="headerlink" title="1008 Fishing Master"></a>1008 Fishing Master</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6709" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>一共有n条鱼，钓任意一条鱼需要花费时间k，而煮熟一条鱼需要花费$t_i$ 时间，这n条鱼的顺序不固定，即我们每次可以钓我们想要的那条。在钓鱼的k时间内不能中断，即我们不能在钓鱼的时间内去煮或者拿出，当然一次只能煮一条鱼。请问煮熟这n条鱼最少花费多少时间？<br>tip：在钓上来一条鱼后，我们可以选择等锅里的鱼煮熟（如果需要的话），或者直接去钓鱼，回来再说，因为同一时刻我们手里可以有任意多条鱼，不局限于一条。极限情况就是我们先钓完n条鱼，再一条一条煮。</p><p><strong>解题思路：</strong><br>这题细节很多，题意很多地方稍不注意就会有歧义，所以做这种题之前一定要先了解清楚题意到底是什么规则以及要求什么。搞清楚了之后算法的设计就并不难想了，是贪心策略。<br>如果极限情况，我们花费的最多时间就是“先把n条鱼全部钓上来，再挨个煮”，花费的时间是$sum = n * k+\sum_{i = 1}^nt_i$，而我们能减少花费的时间，当且仅当我们在钓鱼的同时去煮鱼；而又由于钓鱼的时间段不能终止，所以就相当于我们有n-1段时间，每段时间大小为k，那么对于任意煮一条鱼的时间$t_i$：</p><ul><li>若$t_i$ 是 k 的倍数，$\frac{t_i}{k} = cnt$ 那么这cnt份时间完全被利用了，即sum -= cnt * k</li><li>若$t_i &gt; k$，那么说明我们可以先煮几段k，而剩下的部分再考虑是等待还是继续钓鱼，$\frac{t_i}{k} = cnt$，sum -= cnt <em> k , $t_i$ -= cnt </em> k</li><li>经过上面的操作之后，剩下的$t_i$就都是小于k的了，那么如果此时我们还剩res段时间，则挑最大的res个$t_i$来煮，这样就能最大化利用时间了，如果res = 0，则算法结束。</li></ul><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> tt,n;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll t[N],k,a[N];</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll ans = n*k;<span class="keyword">int</span> res = n<span class="number">-1</span>,tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i]%k == <span class="number">0</span> &amp;&amp; res) ans -= t[i],res -= t[i]/k;</span><br><span class="line">        <span class="keyword">else</span> a[++tot] = t[i]%k, cnt += t[i]/k;</span><br><span class="line">        ans += t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt;= res)&#123;</span><br><span class="line">        ans -= k*res;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    ans -= cnt*k;res -= cnt;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+tot);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = tot;i &gt;= <span class="number">1</span> &amp;&amp; res;i--)&#123;</span><br><span class="line">       <span class="comment">// printf("%lld %d %lld\n",b[i],res,ans);</span></span><br><span class="line">        ans -= a[i];res--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tt);</span><br><span class="line">    <span class="keyword">while</span>(tt--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>,&amp;n,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,t+i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,solve());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1001-amp&quot;&gt;&lt;a href=&quot;#1001-amp&quot; class=&quot;headerlink&quot; title=&quot;1001 ^&amp;amp;^&quot;&gt;&lt;/a&gt;1001 ^&amp;amp;^&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;题意简述：&lt;/strong&gt;&lt;br&gt;给定正整数a和b，找到一
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="权值线段树" scheme="http://valenshi.top/tags/%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="贪心策略" scheme="http://valenshi.top/tags/%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>JZOJ4920降雷皇(最长上升子序列数量)</title>
    <link href="http://valenshi.top/2019/08/24/JZOJ4920/"/>
    <id>http://valenshi.top/2019/08/24/JZOJ4920/</id>
    <published>2019-08-24T07:51:10.000Z</published>
    <updated>2019-08-24T07:52:38.529Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1742" target="_blank" rel="noopener">测试地址</a></p><h5 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h5><p>哈蒙有n条导线排成一排，每条导线有一个电阻值，神奇的电光只能从一根导线传到电阻比它大的上面，而且必须从左边向右传导，当然导线不必是连续的。</p><p>哈蒙想知道电光最多能通过多少条导线，还想知道这样的方案有多少。</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>第一问就是简单的LIS问题，即询问最长上升子序列的长度。第二问是询问最长上升子序列的数量，如果用暴力做法，只需要多开一个数组记录数量即可，时间复杂度O(N^2)；实际上我们可以利用BIT来代替枚举，使得时间复杂度至O(NlogN)。</p><p>我们用一个结构体Node{v,s}来表示当最长上升子序列长度为v时，方案数是s。那么对于每一个新元素x，我们只需要找出所有 <strong>电阻值小于x的</strong> 最长上升子序列的长度v以及数量s即可（符合BIT维护前缀和功能）。</p><p>当我们求出当前元素 x 的 v(最长上升子序列长度) 和 s(方案数) 后，用来更新ans，并将其插入树状数组第x个位置。由于题目保证x小于1e5，所以树状数组开到1e5即可。</p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*代码参考：信息学奥赛一本通P263*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll P = <span class="number">123456789</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ll v,s;</span><br><span class="line">Node()&#123;</span><br><span class="line">v = <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;tr[N],tmp,ans;</span><br><span class="line"><span class="keyword">int</span> n,ty;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> x,Node y)</span></span>&#123;</span><br><span class="line"><span class="comment">/*更改电阻值为x时的长度和方案数*/</span> </span><br><span class="line"><span class="keyword">while</span>(x &lt;= N)&#123;</span><br><span class="line"><span class="keyword">if</span>(y.v &gt; tr[x].v) tr[x] = y;<span class="comment">//如果长度变长,直接更新答案 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(y.v == tr[x].v) tr[x].s = (tr[x].s+y.s)%P;</span><br><span class="line">x += x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回当电阻 &lt;= x时,最长上升子序列的长度和方案数*/</span></span><br><span class="line">Node res;res.s = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[x].v &gt; res.v) res = tr[x];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tr[x].v == res.v) res.s = (res.s + tr[x].s)%P;</span><br><span class="line">x -= x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ckmax</span><span class="params">(Node &amp;x,<span class="keyword">const</span> Node&amp; y)</span></span>&#123;</span><br><span class="line"><span class="comment">/*更新最终答案,即最长上升子序列以及个数*/</span></span><br><span class="line"><span class="keyword">if</span>(x.v &lt; y.v) x = y;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x.v == y.v) x.s = (x.s+y.s)%P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;ty);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">tmp = ask(x<span class="number">-1</span>);<span class="comment">//因为这里保证x不超过1e5,所以不需要离散化 </span></span><br><span class="line">tmp.v++;</span><br><span class="line">ckmax(ans,tmp);<span class="comment">//更新答案 </span></span><br><span class="line">updata(x,tmp);<span class="comment">//更新树状数组 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans.v);</span><br><span class="line"><span class="keyword">if</span>(ty == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans.s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://ybt.ssoier.cn:8088/problem_show.php?pid=1742&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测试地址&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;题意简述&quot;&gt;&lt;a href=&quot;#题意简述&quot; c
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="LIS" scheme="http://valenshi.top/tags/LIS/"/>
    
      <category term="树状数组" scheme="http://valenshi.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Rikka with Coin 解题报告</title>
    <link href="http://valenshi.top/2019/08/22/hdu6685/"/>
    <id>http://valenshi.top/2019/08/22/hdu6685/</id>
    <published>2019-08-22T06:01:46.000Z</published>
    <updated>2019-08-22T06:02:19.831Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6685" target="_blank" rel="noopener">测试地址</a><br>本题为2019航电icpc暑期多校训练第9场的第6题。</p><h5 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h5><p>有10分，20分，50分，100分的硬币若干（反正够用），商店有n件商品（n&lt;101），每件商品的价格给出；请问要想可以买下任意一件商品，最少带多少个硬币？</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>我一开始思路是背包，然后觉得w（商品的价值）太大了，可能用大背包，就放弃了。原来这题需要转化一下思维，并不是用背包而是简单的遍历。首先我们需要明白，就是如若我们买一件物品需要用2个10分的硬币，那么我们换成一个10分一个20分的肯定是可以的，而且反而能买的价格更多了（从10,20变为10,20,30），同理：</p><ul><li>如果有4个20分的，就可以用1个10分，2个20分，1个50分的硬币代替。因为原来可以表示20,40,60,80,现在可以表示10,20,30,40,50,60,70,80,90,100。</li><li>如果有2个50分的，同理，可以用1个50，1个100替代。</li></ul><p>于是我们知道了10分，20分，50分的硬币最多需要1个，3个，1个，所以三层循环遍历所有可能的情况，对于每种情况，判断是否可以表出所有物品（当然不足的用100分的硬币替代）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= a;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= b;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= c;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>((x-i*<span class="number">10</span>-j*<span class="number">20</span>-k*<span class="number">50</span>)%<span class="number">100</span> == <span class="number">0</span>) </span><br><span class="line">res = min((x-i*<span class="number">10</span>-j*<span class="number">20</span>-k*<span class="number">50</span>)/<span class="number">100</span>,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = check2(w[i],a,b,c);</span><br><span class="line"><span class="keyword">if</span>(tmp == INF) <span class="keyword">return</span> INF; </span><br><span class="line"><span class="keyword">else</span> res = max(res,tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf("%d %d %d %d\n",res,a,b,c);</span></span><br><span class="line"><span class="keyword">return</span> res+a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(w[i]%<span class="number">10</span>)&#123;<span class="built_in">puts</span>(<span class="string">"-1"</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">3</span>;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= <span class="number">1</span>;k++)</span><br><span class="line">ans = min(ans,check(i,j,k));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,w+i);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6685&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测试地址&lt;/a&gt;&lt;br&gt;本题为2019航电icpc暑期多校训练第9场的第6题。&lt;/p&gt;
&lt;h5 i
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="思维" scheme="http://valenshi.top/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>2018徐州icpc网络赛A、B题解</title>
    <link href="http://valenshi.top/2019/08/21/2018xuzhou-icpc/"/>
    <id>http://valenshi.top/2019/08/21/2018xuzhou-icpc/</id>
    <published>2019-08-21T03:26:15.000Z</published>
    <updated>2019-08-21T03:48:15.352Z</updated>
    
    <content type="html"><![CDATA[<h4 id="A-Hard-to-prepare"><a href="#A-Hard-to-prepare" class="headerlink" title="A. Hard to prepare"></a>A. Hard to prepare</h4><p><a href="https://nanti.jisuanke.com/t/A2000" target="_blank" rel="noopener">测试地址</a><br>抱怨一下，这题目真的是长，题意理解起来有点费劲，当然费劲的只是因为题面长而不是表述不清。<br><strong>题意简述：</strong><br>从$[1,2^k-1]$中选出n个数，将n个数围成一圈，要求相邻的两个数NXOR大于0，即异或后按位取反的值大于0。问共有多少种不同的方案。</p><p><strong>解题思路：</strong><br>通过简单证明，我们会发现只有1按位取反的值才是0，所以两个数 异或 != 1 就可以相邻；而与x异或 = 1 的数，有且仅有一个。</p><p>首先如果不是环形，而是一条直线，那么一共 $2 ^ k  *  (2 ^ k - 1) ^ {n-1}$​ 种不同的方案，这里设A = ​2^k​。环形和直线不同之处在于，直线首尾的值异或可能 = 1，即我们之前的答案多算了首尾异或=1的情况。那么我们接下来就需要设法减去这些值。</p><p>我们通过动态规划思想来计算这些多加上的值。假设当前位置为 i ，直线首元素是a，尾元素是b，且a^b = 1；设x是位置 i 元素 = a时的方案数，y是位置 i 元素 = b时的方案数，z是位置 i 不等于a和b时的方案数。</p><p>那么我们初始状态（第2个位置时）x = 1 , y = 0 , z = A - 2；目标是求第n-1 位时的 y + z（首位是a，末位是b时，中间2~n-1位的不同排列情况数）。<br>那么易得：<br>x = x + z;<br>y = y + z;<br>z = z<em>(A-3)+(x+y) </em> (A-2).<br>于是我们从第3位递推到第n-1位即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,k;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = res*a%P;</span><br><span class="line">        a = a*a%P;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll A = qpow(<span class="number">2</span>,k);</span><br><span class="line">    ll ans = A*qpow(A<span class="number">-1</span>,n<span class="number">-1</span>)%P;</span><br><span class="line">    ll x = <span class="number">1</span>,y = <span class="number">0</span>,z = A<span class="number">-2</span>;</span><br><span class="line">    <span class="comment">/*x:当前位置数和A相同方案数,</span></span><br><span class="line"><span class="comment">y:当前位置数和B相同方案数,</span></span><br><span class="line"><span class="comment">z:当前位置的数和AB都不同的方案数。 </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; n;i++)&#123;</span><br><span class="line">        ll t1 = x+z,t2 = y+z;</span><br><span class="line">        z = z*(A<span class="number">-3</span>)%P+(x+y)*(A<span class="number">-2</span>)%P;</span><br><span class="line">        z = z%P;</span><br><span class="line">        x = t1%P, y = t2%P;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//  printf("%lld %lld %lld\n",ans,y,z);</span></span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">2</span>) ans = (ans - A*(y+z)%P+P)%P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="B-BE-GE-or-NE"><a href="#B-BE-GE-or-NE" class="headerlink" title="B. BE,GE or NE"></a>B. BE,GE or NE</h4><p><a href="https://nanti.jisuanke.com/t/A2001" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>这是一个博弈论题。有两个人，小K和小S在玩游戏，该游戏一共有n次操作，俩人轮流进行。初始给定一个数值m，每次操作有三种选择：加上a；减去b；若c为1，则m = -1。每次三选一，其中小K想使得最终值&gt;= k，而小S想使得最终值&lt;= l，否则两人平局。给定这n次操作的a,b,c值，请问两人都采取最优策略，最终结果是谁胜出或是平局？</p><p><strong>解题思路：</strong><br>首先每个决策的选举会影响之后的决策，即不满足无后效，因此我们不能单纯的从后向前推（从动态规划角度）。而从博弈论来看，如果当前局面可以转移到必胜态，则当前选手必胜，换到这题，就是使得当前选手得分最大或最小。由于得分只有200种可能，于是可能的状态只有1000 * 200 = 200,000种，记忆化搜索即可。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">250</span>];</span><br><span class="line"><span class="keyword">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="keyword">int</span> n,m,k,l;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; n) <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">if</span>(f[pos][sum+<span class="number">100</span>] != INF) <span class="keyword">return</span> f[pos][sum+<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">if</span>(pos&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = -INF;</span><br><span class="line">        <span class="keyword">if</span>(a[pos]) x = max(x,dfs(pos+<span class="number">1</span>,min(<span class="number">100</span>,sum+a[pos])));</span><br><span class="line">        <span class="keyword">if</span>(b[pos]) x = max(x,dfs(pos+<span class="number">1</span>,max(<span class="number">-100</span>,sum-b[pos])));</span><br><span class="line">        <span class="keyword">if</span>(c[pos]) x = max(x,dfs(pos+<span class="number">1</span>,-sum));</span><br><span class="line">        f[pos][sum+<span class="number">100</span>] = x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = INF;</span><br><span class="line">        <span class="keyword">if</span>(a[pos]) x = min(x,dfs(pos+<span class="number">1</span>,min(sum+a[pos],<span class="number">100</span>)));</span><br><span class="line">        <span class="keyword">if</span>(b[pos]) x = min(x,dfs(pos+<span class="number">1</span>,max(<span class="number">-100</span>,sum-b[pos])));</span><br><span class="line">        <span class="keyword">if</span>(c[pos]) x = min(x,dfs(pos+<span class="number">1</span>,-sum));</span><br><span class="line">        f[pos][sum+<span class="number">100</span>] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[pos][sum+<span class="number">100</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;k,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,a+i,b+i,c+i);</span><br><span class="line">    <span class="keyword">int</span> ans = dfs(<span class="number">1</span>,m);</span><br><span class="line">    <span class="keyword">if</span>(ans &gt;= k) <span class="built_in">puts</span>(<span class="string">"Good Ending"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ans &lt;= l) <span class="built_in">puts</span>(<span class="string">"Bad Ending"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Normal Ending"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;A-Hard-to-prepare&quot;&gt;&lt;a href=&quot;#A-Hard-to-prepare&quot; class=&quot;headerlink&quot; title=&quot;A. Hard to prepare&quot;&gt;&lt;/a&gt;A. Hard to prepare&lt;/h4&gt;&lt;p&gt;&lt;a href=
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="博弈论" scheme="http://valenshi.top/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
      <category term="动态规划" scheme="http://valenshi.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>第一章 基础数据结构模板</title>
    <link href="http://valenshi.top/2019/08/20/chapter1/"/>
    <id>http://valenshi.top/2019/08/20/chapter1/</id>
    <published>2019-08-20T15:37:44.000Z</published>
    <updated>2019-08-20T15:42:45.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-基础数据结构"><a href="#1-基础数据结构" class="headerlink" title="1 基础数据结构"></a>1 基础数据结构</h2><h3 id="1-1-并查集"><a href="#1-1-并查集" class="headerlink" title="1.1 并查集"></a>1.1 并查集</h3><h4 id="1-1-1-并查集“拓展域”"><a href="#1-1-1-并查集“拓展域”" class="headerlink" title="1.1.1 并查集“拓展域”"></a>1.1.1 并查集“拓展域”</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关押罪犯</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> par[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;B) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt; B.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; nodes[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == par[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> par[x] = Find(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    par[Find(x)] = Find(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;nodes[i].a,&amp;nodes[i].b,&amp;nodes[i].c);</span><br><span class="line">        par[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(nodes+<span class="number">1</span>,nodes+<span class="number">1</span>+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = nodes[i].a,y = nodes[i].b,d = nodes[i].c;</span><br><span class="line">        <span class="keyword">int</span> x_en = x+n, y_en = y+n;</span><br><span class="line">        <span class="keyword">if</span>(Find(x) == Find(y))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Merge(x,y_en);Merge(x_en,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-2-并查集“边带权”"><a href="#1-1-2-并查集“边带权”" class="headerlink" title="1.1.2 并查集“边带权”"></a>1.1.2 并查集“边带权”</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POJ1773</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">21000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,ans;</span><br><span class="line">&#125; q[MAXN];</span><br><span class="line"><span class="keyword">int</span> a[MAXN],par[MAXN],d[MAXN],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    a数组用来离散化，par[x]代表x的父节点编号，d[x]代表</span></span><br><span class="line"><span class="comment">    从x到根节点路径和，cnt也是用于离散化。</span></span><br><span class="line"><span class="comment">    这里根节点即集合的代表节点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x] == x) <span class="keyword">return</span> x;   <span class="comment">//找到根节点，返回</span></span><br><span class="line">    <span class="keyword">int</span> root = Find(par[x]);    <span class="comment">//临时存根节点</span></span><br><span class="line">    d[x] ^= d[par[x]];          <span class="comment">//路径压缩，距离数组d也应该更新</span></span><br><span class="line">    <span class="keyword">return</span> par[x] = root;       <span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">char</span> rs[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;q[i].l,&amp;q[i].r,rs);</span><br><span class="line">        <span class="keyword">if</span>(rs[<span class="number">0</span>] == <span class="string">'o'</span>) q[i].ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> q[i].ans = <span class="number">0</span>;</span><br><span class="line">        a[cnt++] = q[i].l<span class="number">-1</span>;    <span class="comment">//这里需要存l-1，为了使l也包含在内</span></span><br><span class="line">        a[cnt++] = q[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下两行代码离散化用</span></span><br><span class="line">    sort(a,a+cnt);</span><br><span class="line">    <span class="keyword">int</span> len = unique(a,a+cnt)-a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) par[i] = i; <span class="comment">//初始化爸爸数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;      </span><br><span class="line">        <span class="comment">//左右边界在离散化数组中的编号：</span></span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(a,a+len,q[i].l<span class="number">-1</span>)-a;</span><br><span class="line">        <span class="keyword">int</span> y = lower_bound(a,a+len,q[i].r)-a;  </span><br><span class="line">        <span class="comment">//左右边界的祖先分别为ta和tb</span></span><br><span class="line">        <span class="keyword">int</span> ta = Find(x),tb = Find(y);</span><br><span class="line">        <span class="keyword">if</span>(ta == tb)&#123;   <span class="comment">//如果已经在同一个集合内，则判断是否矛盾</span></span><br><span class="line">            <span class="keyword">if</span>((d[x]^d[y]) != q[i].ans)&#123;<span class="comment">//矛盾的条件就是事实和结果不同</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            par[ta] = tb;d[ta] = d[x]^d[y]^q[i].ans;</span><br><span class="line">            <span class="comment">//这里d[ta]的值需要推导一下。</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            我们将x所在的集合和y所在的集合合并，那么就需要更新d数组</span></span><br><span class="line"><span class="comment">            这里d[x]存放的是x到par[x]的距离，所以合并两个集合对于</span></span><br><span class="line"><span class="comment">            非根节点来说并无影响，关键是对于两个根d[ta]和d[tb]如何处理</span></span><br><span class="line"><span class="comment">            如果我们将ta代表的集合归于tb下，那么就需要更新d[ta],而已知</span></span><br><span class="line"><span class="comment">            ans = d[x]^d[y]^d[ta]，即x到y的总路径等于x到ta XOR y到tb XOR </span></span><br><span class="line"><span class="comment">            ta到tb；对上式变形，得：d[ta] = ans^d[x]^d[y],而后三者是已知，</span></span><br><span class="line"><span class="comment">            故可以求出d[ta]。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-倍增求LCA（最近公共祖先）"><a href="#1-2-倍增求LCA（最近公共祖先）" class="headerlink" title="1.2 倍增求LCA（最近公共祖先）"></a>1.2 倍增求LCA（最近公共祖先）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HDU2586求树上任意两个节点的路径的边权和  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2</span>*<span class="number">41000</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N],nex[N],edge[N],tot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;x ^= y;y^=x;x^=y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y,edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x],head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    deep[x]表示x的深度,anc[x][i]为x向上走2^i步的祖先 </span></span><br><span class="line"><span class="comment">    dis[x]为节点到根节点的距离,即边权或点权和 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="keyword">int</span> deep[N],anc[N][<span class="number">25</span>],dis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.初始化anc数组，</span></span><br><span class="line"><span class="comment">        2.初始化deep数组</span></span><br><span class="line"><span class="comment">        3.初始化dis数组</span></span><br><span class="line"><span class="comment">        以上三个都可以通过dfs来实现</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++)</span><br><span class="line">        anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(dis[y] || y == <span class="number">1</span>) <span class="keyword">continue</span>;<span class="comment">//防止重复访问</span></span><br><span class="line">        deep[y] = deep[x]+<span class="number">1</span>;</span><br><span class="line">        dis[y] = dis[x] + z;</span><br><span class="line">        anc[y][<span class="number">0</span>] = x;</span><br><span class="line">        dfs(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        先把深度调到一致，再按照二进制拆分思想找寻最近公共祖先</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(deep[u] &lt; deep[v]) swap(u,v);    <span class="comment">//u是较深的节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[anc[u][i]] &gt;= deep[v]) u = anc[u][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(anc[u][i] != anc[v][i])&#123;</span><br><span class="line">            u = anc[u][i];</span><br><span class="line">            v = anc[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> anc[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dis[u] + dis[v] <span class="number">-2</span>*dis[Lca(u,v)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">        <span class="built_in">memset</span>(deep,<span class="number">0</span>,<span class="keyword">sizeof</span> deep);</span><br><span class="line">        <span class="built_in">memset</span>(anc,<span class="number">0</span>,<span class="keyword">sizeof</span> anc);</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head);<span class="comment">//head也要初始化</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            addEdge(x,y,z);</span><br><span class="line">            addEdge(y,x,z);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x,y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-后缀数组"><a href="#1-3-后缀数组" class="headerlink" title="1.3 后缀数组"></a>1.3 后缀数组</h3><h4 id="1-3-1-求后缀数组"><a href="#1-3-1-求后缀数组" class="headerlink" title="1.3.1 求后缀数组"></a>1.3.1 求后缀数组</h4><p>$O(Nlog_2^N)$复杂度求后缀数组模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> sa[N],rank[N],tmp[N];</span><br><span class="line"><span class="comment">//比较(rank[i],rank[i+k])和(rank[j],rank[j+k]) </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rank[i] != rank[j]) <span class="keyword">return</span> rank[i] &lt; rank[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n ? rank[i+k] : <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n ? rank[j+k] : <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算字符串S的后缀数组 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line">n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="comment">//初始长度为1，rank直接取字符的编码</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rank[i] = i &lt; n ? S[i] : <span class="number">-1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//利用对长度为k的排序结果对长度为2k的排序</span></span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+n+<span class="number">1</span>,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + (compare_sa(sa[i<span class="number">-1</span>],sa[i])?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rank[i] = tmp[i];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str) != EOF)&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,sa[i]+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-求高度数组lcp"><a href="#1-3-2-求高度数组lcp" class="headerlink" title="1.3.2 求高度数组lcp"></a>1.3.2 求高度数组lcp</h4><p>时间复杂度为O(N)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sa[i]表示排名为i的后缀起始位置是多少</span></span><br><span class="line"><span class="comment">rank[i]表示起始位置是i的串排名是多少</span></span><br><span class="line"><span class="comment">rank[sa[i] ] = i , sa[rank[i] ] = i,rank与sa互逆 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">int</span> sa[N],rank[N],tmp[N],lcp[N];</span><br><span class="line"><span class="comment">//比较(rank[i],rank[i+k])和(rank[j],rank[j+k]) </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rank[i] != rank[j]) <span class="keyword">return</span> rank[i] &lt; rank[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n ? rank[i+k] : <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n ? rank[j+k] : <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算字符串S的后缀数组 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line">n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="comment">//初始长度为1，rank直接取字符的编码</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rank[i] = i &lt; n ? S[i] : <span class="number">-1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//利用对长度为k的排序结果对长度为2k的排序</span></span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+n+<span class="number">1</span>,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + (compare_sa(sa[i<span class="number">-1</span>],sa[i])?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rank[i] = tmp[i];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最长公共前缀模板,其中sa为后缀数组,求得结果存放在lcp </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(S);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rank[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>;lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*lcp[i] 表示起始位置为sa[i]与</span></span><br><span class="line"><span class="comment">起始位置为sa[i+1]的串的最长公共前缀长度*/</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rank[i]<span class="number">-1</span>];</span><br><span class="line"><span class="comment">/*此处j表示排在"以i开始的后缀"前面一名的子串的起始位置*/</span> </span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j + h &lt; n &amp;&amp; i+h &lt; n;h++)&#123;</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*h为以i开头的后缀与以j开头的后缀的"最长公共前缀"的长度*/</span> </span><br><span class="line">lcp[rank[i]<span class="number">-1</span>] = h;</span><br><span class="line"><span class="comment">/*于是以j开头的后缀 与以i开头的后缀 的 最长公共前缀的长度</span></span><br><span class="line"><span class="comment">被存放在lcp[rank[i]-1]中,因为lcp定义的就是: </span></span><br><span class="line"><span class="comment">lcp[k] 为排名为i的后缀与排名为i+1的后缀的最长公共前缀的长度*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str) != EOF)&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line">construct_lcp(str,sa,lcp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,lcp[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-基于平方分割的RMQ算法"><a href="#1-4-基于平方分割的RMQ算法" class="headerlink" title="1.4 基于平方分割的RMQ算法"></a>1.4 基于平方分割的RMQ算法</h3><p><strong>问题模型：</strong></p><blockquote><p>给定一个数列$a_1,a_2,…,a_n$，目标是在O（&radic;n）复杂度内实现以下两个功能：</p><ul><li>给定s，t，求$a_s,a_{s+1},…a_t$的最小值</li><li>给定i，x，把$a_i$的值变为x。</li></ul></blockquote><p><strong>基于平方分割的RMQ的复杂度：</strong><br>在更新值时，由于每个桶内有b个元素，所以复杂度是O(b) = O(&radic;n)<br>而查询为：O(n/b+b) = O(&radic;n+&radic;n) = O(&radic;n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> mi[MAXN/B];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">a[pos] = y;</span><br><span class="line">mi[pos/B] = min(mi[pos/B],y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = INF;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r &amp;&amp; l%B) ans = min(ans,a[l++]);</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r &amp;&amp; r%B) ans = min(ans,a[--r]);</span><br><span class="line"><span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line"><span class="keyword">int</span> b = l/B;</span><br><span class="line">ans = min(ans,mi[b]);</span><br><span class="line">l += B;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; MAXN/B;i++) mi[i] = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">mi[i/B] = min(mi[i/B],a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="keyword">int</span> op,x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;op,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>) updata(x,y);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; query(x,y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-ST表"><a href="#1-5-ST表" class="headerlink" title="1.5 ST表"></a>1.5 ST表</h3><h4 id="1-5-1一维st表"><a href="#1-5-1一维st表" class="headerlink" title="1.5.1一维st表"></a>1.5.1一维st表</h4><p><strong>问题模型：</strong></p><p>给定一个长度为n的序列，有m次询问，每次给定区间[L , R]，求区间内最大值。</p><p>我们设 <code>st[i][j]</code> 为从 i 开始的 $2^j$ 个数中的最大值。假设这n个数存放的序列a中，根据定义 <code>st[i][j]</code> = max{a[k] | $i &lt;= k &lt;= i+2^j - 1$}。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],st[N][<span class="number">25</span>],Log[N];<span class="comment">//2^20就过一百万了，完全够用 </span></span><br><span class="line"><span class="comment">//初始化st表 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">Log[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//预处理log函数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;<span class="comment">//涉及到位运算多加括号! </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)) &lt;= n;i++)&#123;</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> mx = max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"><span class="comment">//printf("%d %d\n",k,mx);</span></span><br><span class="line"><span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,l,r;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(l,r));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-2-二维st表"><a href="#1-5-2-二维st表" class="headerlink" title="1.5.2 二维st表"></a>1.5.2 二维st表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">令t1 = st[a][b][c];</span><br><span class="line">令t2 = st[a][b+c-(1&lt;&lt;k)+1][c];</span><br><span class="line">令t3 = st[a+c-(1&lt;&lt;k)+1][b][c];</span><br><span class="line">令t4 = st[a+c-(1&lt;&lt;k)+1][b+c-(1&lt;&lt;k)+1][c];</span><br><span class="line">ans = max&#123;t1 , t2 , t3 , t4&#125;；</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N],n,m,len,Log[N];</span><br><span class="line"><span class="keyword">int</span> st[<span class="number">3</span>][N][N][<span class="number">15</span>];<span class="comment">//0最小，1最大值 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mx = a;<span class="keyword">if</span>(mx &lt; b) mx = b;<span class="keyword">if</span>(mx &lt; c) mx = c;<span class="keyword">if</span>(mx &lt; d) mx = d;</span><br><span class="line"><span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mi = a;<span class="keyword">if</span>(mi &gt; b) mi = b;<span class="keyword">if</span>(mi &gt; c) mi = c;<span class="keyword">if</span>(mi &gt; d) mi = d;</span><br><span class="line"><span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++) </span><br><span class="line">st[<span class="number">0</span>][i][j][<span class="number">0</span>] = st[<span class="number">1</span>][i][j][<span class="number">0</span>] = a[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= <span class="number">12</span>;k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span> &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j + (<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span> &lt;= m;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> t1 = st[<span class="number">0</span>][i][j][k<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> t2 = st[<span class="number">0</span>][i+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][j][k<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> t3 = st[<span class="number">0</span>][i][j+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][k<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> t4 = st[<span class="number">0</span>][i+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][j+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][k<span class="number">-1</span>];</span><br><span class="line">st[<span class="number">0</span>][i][j][k] = min(t1,t2,t3,t4);</span><br><span class="line">t1 = st[<span class="number">1</span>][i][j][k<span class="number">-1</span>];</span><br><span class="line">t2 = st[<span class="number">1</span>][i+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][j][k<span class="number">-1</span>];</span><br><span class="line">t3 = st[<span class="number">1</span>][i][j+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][k<span class="number">-1</span>];</span><br><span class="line">t4 = st[<span class="number">1</span>][i+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][j+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][k<span class="number">-1</span>];</span><br><span class="line">st[<span class="number">1</span>][i][j][k] = max(t1,t2,t3,t4);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[len];</span><br><span class="line"><span class="keyword">int</span> t1 = st[<span class="number">0</span>][r][c][k];</span><br><span class="line"><span class="keyword">int</span> t2 = st[<span class="number">0</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c][k];</span><br><span class="line"><span class="keyword">int</span> t3 = st[<span class="number">0</span>][r][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line"><span class="keyword">int</span> t4 = st[<span class="number">0</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line"><span class="keyword">int</span> mi = min(t1,t2,t3,t4);</span><br><span class="line">t1 = st[<span class="number">1</span>][r][c][k];</span><br><span class="line">t2 = st[<span class="number">1</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c][k];</span><br><span class="line">t3 = st[<span class="number">1</span>][r][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line">t4 = st[<span class="number">1</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line"><span class="keyword">int</span> mx = max(t1,t2,t3,t4);</span><br><span class="line"><span class="comment">//printf("%d %d\n",mx,mi);</span></span><br><span class="line"><span class="keyword">return</span> mx - mi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n-len+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m-len+<span class="number">1</span>;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = ask(i,j,len);</span><br><span class="line">ans = ans &lt; tmp?ans:tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-莫队算法"><a href="#1-6-莫队算法" class="headerlink" title="1.6 莫队算法"></a>1.6 莫队算法</h3><p><strong>SPOJ D-query：</strong> 给定一个数组，每次询问一个区间内有多少个不同的元素。</p><p><strong>复杂度分析：</strong> 莫队算法是离线算法，可以解决一类离线的区间问题，对于序列上的区间询问问题，如果从 [l,r] 的答案能够 O(1) 扩展到 [l−1,r],[l+1,r],[l,r+1],[l,r−1] 的答案，那么可以在 $O(n\sqrt n)$ 的复杂度内求出所有询问的答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">31000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Q = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],m;</span><br><span class="line"><span class="keyword">int</span> ans,sum[<span class="number">1010000</span>];<span class="comment">//一个全局答案ans和标记数组sum是必要的 </span></span><br><span class="line"><span class="comment">//当然也可以离散化 </span></span><br><span class="line"><span class="keyword">int</span> len;<span class="comment">//块大小，在读入询问前需要先赋值 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,block,id;</span><br><span class="line">Query()&#123;&#125;</span><br><span class="line">Query(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> id):l(l),r(r),id(id)&#123;</span><br><span class="line">block = l/len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Query &amp;B) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(block == B.block) <span class="keyword">return</span> block&amp;<span class="number">1</span>? r &lt; B.r : r &gt; B.r;</span><br><span class="line"><span class="comment">//小优化，使得r呈波浪形 </span></span><br><span class="line"><span class="keyword">return</span> block &lt; B.block;</span><br><span class="line">&#125;</span><br><span class="line">&#125;query[Q];</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//增加或减少一个x位置上的数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">x = a[x]; </span><br><span class="line">sum[x] += v;</span><br><span class="line"><span class="keyword">if</span>(v &gt; <span class="number">0</span>) ans += sum[x] == <span class="number">1</span>;<span class="comment">//判等是为了防止重复计数 </span></span><br><span class="line"><span class="keyword">else</span> ans -= sum[x] == <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">len = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">query[i] = Query(x,y,i);</span><br><span class="line">&#125;</span><br><span class="line">sort(query+<span class="number">1</span>,query+<span class="number">1</span>+m);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>,r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l &lt; query[i].l) Move(l,<span class="number">-1</span>),l++;</span><br><span class="line"><span class="keyword">while</span>(l &gt; query[i].l) Move(l<span class="number">-1</span>,<span class="number">1</span>),l--;</span><br><span class="line"><span class="keyword">while</span>(r &gt; query[i].r) Move(r,<span class="number">-1</span>),r--;</span><br><span class="line"><span class="keyword">while</span>(r &lt; query[i].r) Move(r+<span class="number">1</span>,<span class="number">1</span>),r++;</span><br><span class="line">q.push(make_pair(-query[i].id,ans));<span class="comment">//大根堆变为小根堆 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.top().second;q.pop();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-二叉堆"><a href="#1-7-二叉堆" class="headerlink" title="1.7 二叉堆"></a>1.7 二叉堆</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左儿子：2*rt+1, 右儿子: 2*rt+2,时间复杂度O(N)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> heap[MAXN];</span><br><span class="line"><span class="keyword">int</span> sz = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//i是自己节点的编号 </span></span><br><span class="line"><span class="keyword">int</span> i = sz++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//p是父亲节点的编号</span></span><br><span class="line"><span class="keyword">int</span> p = (i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(heap[p] &lt;= x) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">heap[i] = heap[p];</span><br><span class="line">i = p; </span><br><span class="line">&#125;</span><br><span class="line">heap[i] = x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = heap[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//要提到根的数值x</span></span><br><span class="line"><span class="keyword">int</span> x = heap[--sz];</span><br><span class="line"><span class="comment">//从根开始向下交换 </span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i*<span class="number">2</span> + <span class="number">1</span> &lt; sz)&#123;</span><br><span class="line"><span class="comment">//左右儿子 </span></span><br><span class="line"><span class="keyword">int</span> a = i*<span class="number">2</span>+<span class="number">1</span>,b = i*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(b &lt; sz &amp;&amp; heap[b] &lt; heap[a]) a = b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(heap[a]  &gt;= x) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">heap[i] = heap[a];</span><br><span class="line">i = a;</span><br><span class="line">&#125;</span><br><span class="line">heap[i] = x;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-基础数据结构&quot;&gt;&lt;a href=&quot;#1-基础数据结构&quot; class=&quot;headerlink&quot; title=&quot;1 基础数据结构&quot;&gt;&lt;/a&gt;1 基础数据结构&lt;/h2&gt;&lt;h3 id=&quot;1-1-并查集&quot;&gt;&lt;a href=&quot;#1-1-并查集&quot; class=&quot;header
      
    
    </summary>
    
      <category term="ValenShi的ACM模板" scheme="http://valenshi.top/categories/ValenShi%E7%9A%84ACM%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>hdu6681 Rikka with Cake</title>
    <link href="http://valenshi.top/2019/08/19/hdu6681/"/>
    <id>http://valenshi.top/2019/08/19/hdu6681/</id>
    <published>2019-08-19T14:41:32.000Z</published>
    <updated>2019-08-20T12:47:48.178Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6681" target="_blank" rel="noopener">测试地址</a></p><h5 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h5><p>直接看样例其实就明白了，看图说话，就是给出一个左下角坐标为(0,0)，右上角为(n,m)的矩形；然后有k条线段，这些线段不重叠，都是从矩形内某一点出发到矩形某一边为止，这些线段共四种，都与坐标轴平行。<br><img src="/2019/08/19/hdu6681/1.png" alt="1"><br>请问这些线段将矩形分为了几个不连通的面？（图一是3个，图二是5个）</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>首先考虑到任意两条直线的x，y坐标都是不同的，所以不会出现重叠现象。观察得，肯定是相交的线段才能分割出新的面（一条横的线与几条竖线相交就会增加几个面）。<br>所以我们只需考虑，假设先将所有与y轴平行的线加入，然后对于每一条与x轴平行的线，有几条与其相交，最终答案就是这些交点个数再+1。</p><p>现在的问题就是对于每个与x轴平行的线，有多少与y轴平行的线与其相交。如果挨个计算并累加，计算完所有线段需要O(N^2)时间。其实我们会发现，找与(x , y)至左边界（L）的横线相交的线段，只需要找出 x’ &lt;= x &amp;&amp; y’ &lt;= y的向上方(U) 的线段以及 x’ &lt;= x &amp;&amp; y’ &gt;= y的向下 (D) 的线段的数量即可。这是二维偏序问题，是4个二维偏序问题。而二维偏序问题可以在$O(Nlog_2^N)$时间内用CDQ分治解决，写起来也不是很麻烦（还好不是三维）。</p><p>PS：呜呜呜正解是欧拉定理呜呜呜呜呜</p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,t;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">    Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y):x(x),y(y)&#123;t = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; B)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; B.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node U[N],D[N],R[N],L[N],tmp[N];</span><br><span class="line">Node TU[N];</span><br><span class="line"><span class="keyword">int</span> cu,cd,cr,cl,cnt;</span><br><span class="line"><span class="keyword">int</span> n,m,t,k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq1</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    cdq1(l,mid); cdq1(mid,r);</span><br><span class="line">    <span class="keyword">int</span> p = l,q = mid,tk = <span class="number">0</span>,tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; mid &amp;&amp; q &lt; r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(TU[p].y &lt;= TU[q].y)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!TU[p].t) tt++;</span><br><span class="line">            tmp[tk++] = TU[p++];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(TU[q].t) cnt += tt;</span><br><span class="line">            tmp[tk++] = TU[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; mid) tmp[tk++] = TU[p++];</span><br><span class="line">    <span class="keyword">while</span>(q &lt; r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(TU[q].t) cnt += tt;</span><br><span class="line">        tmp[tk++] = TU[q++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tk;i++) TU[i+l] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(Node a,Node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    对于L[i],有多少U中x &lt; L[i].x &amp;&amp; y &lt; L[i].y,</span></span><br><span class="line"><span class="comment">            有多少D中x &lt; L[i].x &amp;&amp; y &gt; L[i].y;</span></span><br><span class="line"><span class="comment">    对于R[i]有多少U中x &gt; R[i].x &amp;&amp; y &lt; R[i].y,</span></span><br><span class="line"><span class="comment">            有多少D中x &gt; R[i].x &amp;&amp; y &gt; R[i].y;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cu;i++) TU[i] = U[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cl;i++) TU[i+cu] = L[i],TU[i+cu].t = <span class="number">1</span>;</span><br><span class="line">    stable_sort(TU,TU+cu+cl);</span><br><span class="line">    cdq1(<span class="number">0</span>,cl+cu);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cd;i++) TU[i] = D[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cl;i++) TU[i+cd] = L[i],TU[i+cd].t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cl+cd;i++) TU[i].y *= <span class="number">-1</span>;</span><br><span class="line">    stable_sort(TU,TU+cd+cl);</span><br><span class="line">    cdq1(<span class="number">0</span>,cl+cd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cu;i++) TU[i] = U[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cr;i++) TU[i+cu] = R[i],TU[i+cu].t = <span class="number">1</span>;</span><br><span class="line">    stable_sort(TU,TU+cr+cu,cmp2);</span><br><span class="line">    <span class="comment">//for(int i = 0;i &lt; cr+cu;i++) printf("%d %d\n",TU[i].x,TU[i].y);</span></span><br><span class="line">    cdq1(<span class="number">0</span>,cr+cu);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cd;i++) TU[i] = D[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cr;i++) TU[i+cd] = R[i],TU[i+cd].t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cd+cr;i++) TU[i].y *= <span class="number">-1</span>;</span><br><span class="line">    stable_sort(TU,TU+cr+cd,cmp2);</span><br><span class="line">    cdq1(<span class="number">0</span>,cr+cd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        cu = cd = cr = cl = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;<span class="keyword">char</span> dir[<span class="number">5</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;x,&amp;y,dir);</span><br><span class="line">            <span class="keyword">if</span>(dir[<span class="number">0</span>] == <span class="string">'U'</span>) U[cu++] = Node(x,y);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dir[<span class="number">0</span>] == <span class="string">'D'</span>) D[cd++] = Node(x,y);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dir[<span class="number">0</span>] == <span class="string">'L'</span>) L[cl++] = Node(x,y);</span><br><span class="line">            <span class="keyword">else</span> R[cr++] = Node(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6681&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测试地址&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;题意简述&quot;&gt;&lt;a href=&quot;#题意简述&quot; class=
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="CDQ分治" scheme="http://valenshi.top/tags/CDQ%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>bzoj1093最大半连通子图</title>
    <link href="http://valenshi.top/2019/08/18/bzoj1093/"/>
    <id>http://valenshi.top/2019/08/18/bzoj1093/</id>
    <published>2019-08-18T12:51:15.000Z</published>
    <updated>2019-08-20T12:46:31.989Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.mfstem.org/contest/17/problem/B" target="_blank" rel="noopener">测试地址</a></p><h5 id="问题简述"><a href="#问题简述" class="headerlink" title="问题简述"></a>问题简述</h5><p>给出一个有向图，求其最大半连通子图的节点个数，以及不同的最大半连通子图的数目。<br>（子图、半连通图、最大半连通子图等定义请参照原题）</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>本题是《信息学奥赛一本通·提高篇》中，强连通分量章节的一道例题。本题思路其实很清晰也很明确，就是求最大半连通子图的节点数，以及有多少个这样的子图。可以得知，如果一个子图是强连通的，那么他一定是半连通的，所以对于所有的强连通分量，我们都缩为一个点，这样就得到了一个有向无环图（DAG）。<br>我们对得到的DAG进行建图得到G’，每个节点的“权值”就等于该强连通分量的顶点数；于是原问题就成了在 G’ 上找到权值最大的<strong>链</strong>（因为我们可以保证对于链上任意两点u和v，都单向或双向可达）。<br>找到了“最长链”之后，下一步是找<strong>不同的最长链的个数</strong> ，这一步用到类似DP的思想，即设f[i]为到节点 i 时，达到局部最长链时不同方案数，我们只需要在进行<strong>拓扑排序求最长链</strong> 的同时<strong>递推更新f[]</strong> 即可。</p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><p>虽然写代码时的思路很清晰，但是代码还是写的很乱，可读性很差；因为涉及变量太多、太乱，所以每个变量或数组的作用是什么并不是一目了然，但我也懒得写注释了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y;nex[tot] = head[x];head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head2[N],ver2[M],nex2[M],tot2 = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    ver2[++tot2] = y; nex2[tot2] = head2[x];head2[x] = tot2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Stack[N],top;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],num,co[N],col;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++num;</span><br><span class="line">Stack[++top] = u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> v = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">Tarjan(v);</span><br><span class="line">low[u] = min(low[u],low[v]);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!co[v]) low[u] = min(low[u],dfn[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[u] == dfn[u])&#123;</span><br><span class="line">co[u] = ++col;</span><br><span class="line"><span class="keyword">while</span>(Stack[top] != u)&#123;</span><br><span class="line">co[Stack[top]] = col;</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,P;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; e[M];</span><br><span class="line"><span class="keyword">int</span> du[N],dis[N],si[N];<span class="comment">//si[col]记录强连通分量col节点个数</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> mxnum,mxcol;</span><br><span class="line"><span class="keyword">int</span> f[N];<span class="comment">//到i距离为最长的方案数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(si,<span class="number">0</span>,<span class="keyword">sizeof</span> si);</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) si[co[i]]++,f[co[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++) <span class="keyword">if</span>(!du[i]) q.push(i),dis[i] = si[i];</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head2[x];i ;i = nex2[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> y = ver2[i];du[y]--;</span><br><span class="line">            <span class="keyword">if</span>(!du[y]) q.push(y);</span><br><span class="line">            <span class="keyword">if</span>(dis[y] &lt; dis[x]+si[y])&#123;</span><br><span class="line">                dis[y] = dis[x] + si[y];</span><br><span class="line">                f[y] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(dis[mxcol] &lt; dis[y]) mxcol = y;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dis[y] == dis[x]+si[y])</span><br><span class="line">                f[y] = (f[y]+f[x])%P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++)</span><br><span class="line">        <span class="keyword">if</span>(dis[i] == dis[mxcol]) mxnum = (mxnum+f[i])%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    num = col = top = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="keyword">sizeof</span> dfn);</span><br><span class="line">    <span class="built_in">memset</span>(co,<span class="number">0</span>,<span class="keyword">sizeof</span> co);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = head[i];j ;j = nex[j])&#123;</span><br><span class="line">            <span class="keyword">int</span> y = ver[j];</span><br><span class="line">            e[++cnt] = make_pair(co[i],co[y]);</span><br><span class="line">            <span class="comment">//printf("%d %d %d %d\n",co[i],co[y],i,y);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf("cnt %d\n",cnt);</span></span><br><span class="line">    sort(e+<span class="number">1</span>,e+<span class="number">1</span>+cnt);tot2 = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(du,<span class="number">0</span>,<span class="keyword">sizeof</span> du);</span><br><span class="line">    <span class="built_in">memset</span>(head2,<span class="number">0</span>,<span class="keyword">sizeof</span> head2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i].first != e[i].second &amp;&amp;</span><br><span class="line">         (e[i].first != e[i<span class="number">-1</span>].first || e[i].second != e[i<span class="number">-1</span>].second))</span><br><span class="line">            addEdge2(e[i].first,e[i].second), du[e[i].second]++;</span><br><span class="line">        <span class="comment">//printf("%d %d\n",e[i].first,e[i].second);</span></span><br><span class="line">    &#125;</span><br><span class="line">    topo();<span class="comment">//拓扑排序找出最长链</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>,dis[mxcol],mxnum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;P);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,a,b;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        addEdge(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.mfstem.org/contest/17/problem/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测试地址&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;问题简述&quot;&gt;&lt;a href=&quot;#问题简述&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="强连通分量" scheme="http://valenshi.top/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>大整数开方根模板</title>
    <link href="http://valenshi.top/2019/08/18/bigsqrt/"/>
    <id>http://valenshi.top/2019/08/18/bigsqrt/</id>
    <published>2019-08-18T12:50:54.000Z</published>
    <updated>2019-08-20T12:46:50.130Z</updated>
    
    <content type="html"><![CDATA[<p><strong>例1：</strong> 试判断n是否为完全平方数(Perfect square)，$n &lt;=10^{200}$。</p><p>本来想写一篇关于牛顿迭代法+高精度运算的C++版本的模板，但是涉及到高精度加减乘除，动辄300行代码以上，还是在网上找个JAVA的大整数开方根的模板凑合用吧。</p><p>用JAVA书写代码，需要注意的是时间和空间，内存超限很常见。</p><h4 id="大数开平方根模板"><a href="#大数开平方根模板" class="headerlink" title="大数开平方根模板"></a>大数开平方根模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static BigInteger sqrt(String x) &#123;</span><br><span class="line">        int mlen = x.length();    //被开方数的长度</span><br><span class="line">        int len;    //开方后的长度</span><br><span class="line">        BigInteger beSqrtNum = new BigInteger(x);//被开方数</span><br><span class="line">        BigInteger sqrtOfNum;    //存储开方后的数</span><br><span class="line">        BigInteger sqrtOfNumMul;    //开方数的平方</span><br><span class="line">        String sString;//存储sArray转化后的字符串</span><br><span class="line">        if(mlen%2 == 0)    len = mlen/2;</span><br><span class="line">        else    len = mlen/2+1;</span><br><span class="line">        char[] sArray = new char[len];</span><br><span class="line">        Arrays.fill(sArray, &apos;0&apos;);//开方数初始化为0</span><br><span class="line">        for(int pos=0; pos&lt;len; pos++)&#123;</span><br><span class="line">         //从最高开始遍历数组，每一位都转化为开方数平方后刚好不大于被开方数的程度</span><br><span class="line">            for(char num=&apos;1&apos;; num&lt;=&apos;9&apos;; num++)&#123;</span><br><span class="line">                sArray[pos] = num;</span><br><span class="line">                sString = String.valueOf(sArray);</span><br><span class="line">                sqrtOfNum = new BigInteger(sString);</span><br><span class="line">                sqrtOfNumMul = sqrtOfNum.multiply(sqrtOfNum);</span><br><span class="line">                if(sqrtOfNumMul.compareTo(beSqrtNum) == 1)&#123;</span><br><span class="line">                    sArray[pos]-=1;</span><br><span class="line">                    break;    </span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new BigInteger(String.valueOf(sArray));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断n是否为Perfect-square"><a href="#判断n是否为Perfect-square" class="headerlink" title="判断n是否为Perfect square"></a>判断n是否为Perfect square</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> T = cin.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cas = <span class="number">1</span>; cas &lt;= T; ++cas) &#123;</span><br><span class="line">            String str = cin.next();</span><br><span class="line">            BigInteger n = <span class="keyword">new</span> BigInteger(str);</span><br><span class="line">            BigInteger m = n.multiply(n.subtract(BigInteger.ONE)).shiftRight(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//System.out.println(n);</span></span><br><span class="line">            <span class="comment">//System.out.println(m);</span></span><br><span class="line">            <span class="keyword">boolean</span> nIsSquare = isSquare(n);</span><br><span class="line">            <span class="keyword">boolean</span> mIsSquare = isSquare(m);</span><br><span class="line">            <span class="keyword">if</span> (nIsSquare &amp;&amp; mIsSquare) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Arena of Valor"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nIsSquare &amp;&amp; !mIsSquare) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Hearth Stone"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!nIsSquare &amp;&amp; mIsSquare) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Clash Royale"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"League of Legends"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSquare</span><span class="params">(BigInteger n)</span> </span>&#123;</span><br><span class="line">        BigInteger low = BigInteger.ZERO;</span><br><span class="line">        BigInteger high = n;</span><br><span class="line">        <span class="keyword">while</span> (low.compareTo(high) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            BigInteger mid = low.add(high).shiftRight(<span class="number">1</span>);</span><br><span class="line">            BigInteger square = mid.multiply(mid);</span><br><span class="line">            <span class="keyword">int</span> result = square.compareTo(n);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                high = mid.subtract(BigInteger.ONE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid.add(BigInteger.ONE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>Molex的<a href="https://www.cnblogs.com/yzm10/p/9651696.html" target="_blank" rel="noopener">博客</a></li><li>2019焦作网络赛 J 题<a href="https://nanti.jisuanke.com/t/A2020" target="_blank" rel="noopener">Participate in E-sports</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;例1：&lt;/strong&gt; 试判断n是否为完全平方数(Perfect square)，$n &amp;lt;=10^{200}$。&lt;/p&gt;
&lt;p&gt;本来想写一篇关于牛顿迭代法+高精度运算的C++版本的模板，但是涉及到高精度加减乘除，动辄300行代码以上，还是在网上找个J
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>中国剩余定理（拓展）</title>
    <link href="http://valenshi.top/2019/08/18/realchina/"/>
    <id>http://valenshi.top/2019/08/18/realchina/</id>
    <published>2019-08-18T12:50:28.000Z</published>
    <updated>2019-08-20T12:47:04.538Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>在《孙子算经》中有这样一个问题：“今有物不知其数，三三数之剩二（除以3余2），五五数之剩三（除以5余3），七七数之剩二（除以7余2），问物几何？”这个问题称为“孙子问题”，该问题的一般解法国际上称为“中国剩余定理”。</p><p>中国剩余定理是数论四大定理之一，其重要性不容置疑，本文主要介绍中国剩余定理问题的经典模型，然后再对更一般的情况进行拓展，得到拓展中国剩余定理，当然最重要的是给出模板并附上模板使用说明书。</p><h4 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h4><p>若$m_1,m_2,…,m_n$是两两互质的正整数，M = $\prod_{i = 1}^{n} m_i$, $M_i = M/m_i$，$t_i$是线性同余方程$M_it_i \equiv1(mod\: m_i)$的一个解。对于任意的n个整数$a_1,a_2,…,a_n$，则同余方程组</p><p><img src="/2019/08/18/realchina/1.png" alt="1"></p><p>有整数解，方程组的解为$x = a_1M_1t_1 + a_2M_2t_2 + … + a_nM_nt_n$。并且在模M意义下有唯一解。</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>因为$M_i = M/m_i$是除$m_i$之外所有模数的倍数，所以$\forall k \neq i, a_iM_it_i \equiv 0(mod\:m_k)$。又因为$a_iM_it_i \equiv a_i(mod\: m_i)$，所以带入$x = \sum_{i = 1}^n a_iM_it_i$，原方程组成立。<br>证毕。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>中国剩余定理给出了模数两两互质的线性同余方程组的一个特殊解。方程组的通解可以表示为$x + kM(k \in Z)$。有些题目要求我们求出最小的非负整数解，只需把 x 对M取模，并让 x 落在0~M-1的范围内即可。</p><p>另外，即使模数不满足两两互质，我们也有办法判断线性同余方程组是否有解，并求出方程组的解。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 代码出自:洛谷用户sumijie 2019/8/18</span></span><br><span class="line"><span class="comment"> * 使用说明:</span></span><br><span class="line"><span class="comment"> *    1.ll为自定义类型,视题目数据而定,并不一定是__int128</span></span><br><span class="line"><span class="comment"> *    2.N为方程组中方程个数,视数据而定</span></span><br><span class="line"><span class="comment"> * 输入：</span></span><br><span class="line"><span class="comment"> *    输入第一行包含整数 n.</span></span><br><span class="line"><span class="comment"> *    接下来 n 行,每行两个非负整数 ai,bi</span></span><br><span class="line"><span class="comment"> * 输出:</span></span><br><span class="line"><span class="comment"> *    输出一行,为满足条件的最小非负整数x.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> __int128 ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;g,ll &amp;x,ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        g = a; x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b,a%b,g,y,x);</span><br><span class="line">    y-=(a/b)*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">ll a1,a2,n1,n2;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">abs</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;<span class="number">0</span>?x:-x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">china</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll d = a2 - a1;</span><br><span class="line">    ll g,x,y;</span><br><span class="line">    exgcd(n1,n2,g,x,y);</span><br><span class="line">    <span class="keyword">if</span> (d % g == <span class="number">0</span>) &#123;</span><br><span class="line">        x = ((x*d/g)%(n2/g)+(n2/g))%(n2/g);</span><br><span class="line">        a1 = x*n1 + a1;</span><br><span class="line">        n1 = (n1*n2)/g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;          <span class="comment">//方程个数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> as[N];<span class="comment">//余数</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ns[N];<span class="comment">//模数</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">realchina</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*返回线性同余方程组的最小非负整数解*/</span></span><br><span class="line">    a1 = as[<span class="number">0</span>];</span><br><span class="line">    n1 = ns[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        a2 = as[i];</span><br><span class="line">        n2 = ns[i];</span><br><span class="line">        china();</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;ns[i]&gt;&gt;as[i];<span class="comment">//输入模数和余数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">long</span> <span class="keyword">long</span>)realchina()&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>董永建，信息学竞赛一本通提高篇，福州：福建教育出版社，2018.6，401-403</li><li>洛谷网用户sumijie的<a href="https://www.luogu.org/blog/sumijie/solution-p4777" target="_blank" rel="noopener">博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;在《孙子算经》中有这样一个问题：“今有物不知其数，三三数之剩二（除以3余2），五五数之剩三（除以5余3），七七数之剩二（除以7余2），问物几
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数论" scheme="http://valenshi.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>矩阵快速幂模板</title>
    <link href="http://valenshi.top/2019/08/17/Matrix/"/>
    <id>http://valenshi.top/2019/08/17/Matrix/</id>
    <published>2019-08-17T02:28:50.000Z</published>
    <updated>2019-08-20T12:46:20.756Z</updated>
    
    <content type="html"><![CDATA[<p>矩阵快速幂常用于动态规划中的“矩阵加速链乘”里，可以将线性的递归式优化为$O(log_2N)$，是一种很常用的技巧。由于矩阵快速幂不像普通的整数快速幂一样方便记忆，因此整理模板以便需要时参考。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************</span></span><br><span class="line"><span class="comment"> 最后修改：2019/8/17 ValenShi</span></span><br><span class="line"><span class="comment"> 使用说明：</span></span><br><span class="line"><span class="comment">    1.注意矩阵是在Mod P下相乘</span></span><br><span class="line"><span class="comment">    2.矩阵为nn*nn的方阵,使用前需对nn赋值</span></span><br><span class="line"><span class="comment">    3.矩阵有效行列下标是1~nn</span></span><br><span class="line"><span class="comment">    4.注意memset头文件以及 long long</span></span><br><span class="line"><span class="comment"> *********************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> nn; <span class="comment">//nn 为矩阵大小 nn*nn</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mat</span>&#123;</span></span><br><span class="line">    ll v[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line">    Mat()&#123;<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span> v);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">Mul</span><span class="params">(<span class="keyword">const</span> Mat&amp; a,<span class="keyword">const</span> Mat&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 返回矩阵a*矩阵b的结果 */</span></span><br><span class="line">    Mat c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= nn;i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= nn;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= nn;k++)</span><br><span class="line">          c.v[i][j] = (c.v[i][j]+a.v[i][k]*b.v[k][j]%P)%P;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">qpow</span><span class="params">(Mat A,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 返回矩阵A^b后的结果(矩阵) */</span></span><br><span class="line">    Mat c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= nn;i++) c.v[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) c = Mul(c,A);</span><br><span class="line">        A = Mul(A,A);</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;矩阵快速幂常用于动态规划中的“矩阵加速链乘”里，可以将线性的递归式优化为$O(log_2N)$，是一种很常用的技巧。由于矩阵快速幂不像普通的整数快速幂一样方便记忆，因此整理模板以便需要时参考。&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>伸展树笔记</title>
    <link href="http://valenshi.top/2019/08/16/splay/"/>
    <id>http://valenshi.top/2019/08/16/splay/</id>
    <published>2019-08-16T14:08:15.000Z</published>
    <updated>2019-08-16T14:16:03.528Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><strong>前置知识：</strong></p><ul><li>树-&gt;二叉搜索树-&gt;平衡树-&gt;AVL树-&gt;Treap-&gt;伸展树</li><li>左单(双)旋、右单(双)旋、左右双旋</li></ul><p><strong>伸展树(Splay Tree)</strong> 是平衡二叉查找树的一种，具有二叉查找树的所有性质；伸展树又称Self-Adjusting Search Trees，即<strong>自调整的二叉搜索树</strong> 。与普通的二叉查找树相比，其维护更少的节点额外信息，空间性能更优且编程复杂度更低。它由Daniel Sleator 和 Robert Tarjan创造。在伸展树上的一般操作都基于<strong>伸展操作</strong>。</p><h4 id="需要伸展树的原因："><a href="#需要伸展树的原因：" class="headerlink" title="需要伸展树的原因："></a>需要伸展树的原因：</h4><p>各种查找树都有各自的优缺点以及适用范围。例如，对于一棵具有n个节点的平衡树，虽然其查找的时间复杂度不超过O(log n)，但是如果访问模式不均匀（询问点不随机），平衡树的效率就会受影响，此时我们需要额外的空间记录平衡信息，同时也加大了编程复杂度。<br>这些查找树的设计目标都是减少最坏情况下单次操作时间，但是如果我们的目标是使一系列查找操作的总时间最少，那我们更好的目标就是降低操作的摊平时间。此处的摊平时间指的是在一系列最坏情况下的操作序列中单次操作的平均时间。而伸展树就是为实现这一目标而设计的。</p><h4 id="和其他平衡树或具有明确限制的数据结构相比，伸展树的优点："><a href="#和其他平衡树或具有明确限制的数据结构相比，伸展树的优点：" class="headerlink" title="和其他平衡树或具有明确限制的数据结构相比，伸展树的优点："></a>和其他平衡树或具有明确限制的数据结构相比，伸展树的优点：</h4><ul><li>从摊平角度讲，它们忽略常量因子，因此绝对不会比有明确限制的数据结构差。而且它们可以依据适用情况进行调整，于是在<strong>使用模式不均匀</strong>的情况下更加有效。</li><li>由于无需存储限制信息，它们所需空间更小，实现起来也更加简洁。</li><li>它们的查找和更新算法概念简单，易于实现。</li></ul><h4 id="潜在的两个缺点："><a href="#潜在的两个缺点：" class="headerlink" title="潜在的两个缺点："></a>潜在的两个缺点：</h4><ul><li>它们需要更多的局部调整，尤其是在查找期间。（而其他有明确限制的查找树仅需要在更新期间进行调整，查找期间则不用）</li><li>一系列查找操作中的某一个可能会耗时较长。这在实际应用中需要作为是否选用的参考依据。</li></ul><h4 id="什么是伸展树："><a href="#什么是伸展树：" class="headerlink" title="什么是伸展树："></a>什么是伸展树：</h4><p>假设要对一个二叉搜索树执行一系列查找操作，为了使得总时间最小，那么被查找频率高的节点自然就要放在靠近根的位置。于是想到一个简单的设计方案，<strong>在每次查找之后对树进行重构，把被查找的条目搬到离树根近一点的位置。</strong> 顺着这个思路，splay诞生了。<br>splay是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列旋转把该节点搬移到树根，同时使得该条路径上的点尽量靠近树根。</p><h4 id="构建方法"><a href="#构建方法" class="headerlink" title="构建方法"></a>构建方法</h4><p><strong>两种可能的重构方法：</strong></p><ul><li>单旋：在查找完位于节点x中的条目之后，旋转链接x和其父节点的边。（除非x是根）</li><li>搬移至树根：在查找完位于节点x中的条目后，旋转链接x和其父节点的边，然后重复这个操作直至x成为树根。</li></ul><p><strong>注：</strong><br>上述两个方法是不一样的，一种是查找x后仅交换一次，另一个是将被查询的节点x旋转至树根。<br><strong>旋转示意图：</strong><br>其中三角形代表子树，而图示的树也可能是一棵更大的树的子树。<br><img src="/2019/08/16/splay/1.png" alt="1"></p><p><strong>上述两种重构方法的示意图：</strong><br>其中被查询节点是a。<br><img src="/2019/08/16/splay/2.png" alt="2"></p><p><strong>注：</strong></p><ul><li>若x为p(x)的左孩子，交换x和p(x)的位置，称为右旋。</li><li>若x为p(x)的右孩子，交换x和p(x)的位置，称为左旋。</li></ul><p><strong>不幸的是，上述两个重构方法在摊分效率方面表现的都不太好。</strong> 如果有很长的随机查询序列，那么上述两种重构方法的查询时间复杂度是O(N)。显然我们需要一种性能更强大的重构方法。</p><h4 id="伸展操作"><a href="#伸展操作" class="headerlink" title="伸展操作"></a>伸展操作</h4><p>我们采取的重构方法叫做splaying，即伸展，它和上述“搬移至树根”相似。它们都是沿着<strong>查询路径</strong> 做旋转倒置，将被查询的节点通过此方法移动到根节点。不同的是，伸展操作是按照该结构上的查找顺序<strong>成对旋转</strong> 。对于伸展树中的一个节点x，我们重复如下操作<strong>直到</strong> x 成为树的根节点。</p><p><strong><em>Splaying Step</em></strong><br><em>Case 1(zig)：</em> 如果p(x)是x的父节点，并且p(x)是树的根，那么旋转x和p(x)间的边。（此为最终步骤）<br><em>Case 2(zig-zig)：</em> 如果p(x)不是根节点，并且x和p(x)都是左儿子或者右儿子，那么旋转链接p(x)和g(x)的边，然后旋转链接x和p(x)的边。<br><em>Case 3(zig-zag)：</em> 如果p(x)不是根，并且x是左儿子 p(x)是右儿子，或者相反，那么旋转链接x和p(x)的边，然后旋转链接x和p(x)的新边。</p><p><strong>注：</strong><br>其中我们假设p(x)为x的父节点，g(x)为p(x)的父节点。下图三个操作a、b、c分别对应上述的zig、zig-zig、zig-zag。</p><p><img src="/2019/08/16/splay/3.png" alt="3"></p><p><strong>分析：</strong><br>对于深度为d的节点x做伸展操作，需要花费的时间和d成比例，即和查找x的时间成比例。伸展操作并不仅仅是将x移动到根节点，而是<strong>将查找路径上的节点的深度都粗略减少了一半。</strong> 如此一来使得伸展树的效率非同凡响。效率证明略，不过我们依然可以根据如下1种常规情况(Figures 4)及2种极端情况(Figures 5)下进行splaying操作后 树的构造来略窥一二。</p><p><img src="/2019/08/16/splay/4.png" alt="4"></p><p><img src="/2019/08/16/splay/5.png" alt="5"></p><h4 id="伸展树上的更新操作"><a href="#伸展树上的更新操作" class="headerlink" title="伸展树上的更新操作"></a>伸展树上的更新操作</h4><p>使用伸展树，我们可以继承标准的二叉搜索树的操作。考虑如下几个操作：<br><em>access(i,t):</em> &emsp;如果i在树t中，返回一个指向i位置的指针；否则，返回一个指向空节点的指针。<br><em>insert(i,t):</em> &emsp;向树t中插入一个元素i，假设此前i不存在。<br><em>delete(i,t):</em> &emsp;从树t中删除元素i，假设i存在。<br><em>join(t1,t2):</em> &emsp;将树t1和t2合并成一棵新的树并返回新树的树根。该操作假设t1中所有元素都小于t2中的元素。合并后删除t1和t2。<br><em>split(i,t):</em> &emsp;将t分成两棵子树t1和t2，所有小于等于i的元素在t1，所有大于i的元素在t2。然后删除树t。</p><p><strong>access(i,t)实现方法：</strong><br>我们从树t的根开始，按照二叉搜索树的查找方式向下查找；如果当前节点x包含待查目标i，则算法完成，我们对x进行splaying操作并返回指向x的指针。如果搜索到达了空节点（即待查目标不存在），那么我们对搜索路径的最后一个节点进行splaying操作，并返回一个空指针。如果树为空，则取消splaying操作。（Figures 6）</p><p><strong>join(t1,t2)实现方法：</strong><br>我们首先在t1中执行一次access(i,t1)，其中i是t1中最大的元素。于是在access后，t1的根包含i，并且它没有右儿子。于是我们可以将t2作为t1的右儿子连接，并返回处理后的树，join操作完成。(Figures 7)</p><p><strong>split(i,t)实现方法：</strong><br>我们首先执行一次access(i,t)，然后断开t和左右儿子的链接，左子树作为t1，右子树作为t2，并且考虑根是否包含等于i的元素。返回t1或t2，split操作完成。(Figures 7)</p><p><strong>insert(i,t)实现方法</strong><br>我们先对t进行一次split(i,t)，得到了两个子树t1和t2，这时我们把i作为一个新的根节点，t1作为i的左子树，t2作为其右子树。(Figures 8)</p><p><strong>delete(i,t)实现方法</strong><br>我们先执行一次access(i,t)，此时得到根节点t，这个时候对t的两个子树t1和t2执行join(t1,t2)，就完成了删除i节点。(Figures 8)</p><p><strong>小结：</strong><br>通过上述操作的实现方法，我们可以发现，实现join和split时用到了access，实现insert和delete时我们又用到了split和join，由此可见我们可以通过已实现的操作来搭建未实现的操作，这样更加简洁且降低了编程难度。</p><p><img src="/2019/08/16/splay/6.png" alt="6"></p><p><img src="/2019/08/16/splay/7.png" alt="7"></p><p>另外，对于insert和delete操作还有另一种稍加优化的方法，这里省略，复杂度分析同样省略，具体可以参照原文[1]。</p><p><strong>参考文献：</strong></p><p>[1]  Daniel D.Sleator , Robert Endre Tarjan, <em>A data structure for dynamic trees</em>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;前置知识：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树-&amp;gt;二叉搜索树-&amp;gt;平衡树-&amp;gt;AVL树-&amp;gt;T
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线段树区间修改-延迟标记</title>
    <link href="http://valenshi.top/2019/08/16/interval-tree/"/>
    <id>http://valenshi.top/2019/08/16/interval-tree/</id>
    <published>2019-08-16T14:04:57.000Z</published>
    <updated>2019-08-20T12:45:46.357Z</updated>
    
    <content type="html"><![CDATA[<h4 id="延迟标记"><a href="#延迟标记" class="headerlink" title="延迟标记"></a>延迟标记</h4><p>在线段树中，单点修改时，我们是将信息从叶节点向上依次更新它的父节点，直到根节点。如果在区间修改仍然按照这个策略，那么修改的时间复杂度为O(N)。<br>为了降低时间复杂度，我们可以在更新时只更新大区间，不向下更新到叶子节点，等查询时再更新。举个例子：我们将1-5的位置上每个数+100，重复10000次上述操作。<strong>我们加10000次100和直接+1000000是相等的效果，但是一个执行了10000次，而另一个只执行1次。</strong> 我们又知道计算机的计算效率和计算次数是相关的，所以我们可以利用该原理，当区间修改时不向下更新，直至查询时再更新。</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>以POJ3468为例，我们使用线段树+延迟标记技巧 来实现快速区间修改与区间查询。<br>具体做法是，我们为每个节点增加一个延迟标记add，如果add为0，则说明该点的所有子区间都已更新完成，否则说明其子区间仍需要+add。请注意，如果一个节点被打上“延迟标记”，说明该节点曾经被修改过，但其子节点尚未被更新，即延迟标记说明的是子节点的待更新情况。<br>具体实现时，我们可以使用一个函数spread来实现延迟标记向下传递。<br><strong>代码示例：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll sum,add;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(x) t[x].add</span></span><br><span class="line">&#125;t[MAXN*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN],n,m;</span><br><span class="line"><span class="comment">//将延迟标记向下更新一层 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(add(p))&#123;</span><br><span class="line">sum(p*<span class="number">2</span>) += (r(p*<span class="number">2</span>) - l(p*<span class="number">2</span>) + <span class="number">1</span>)*add(p);</span><br><span class="line">sum(p*<span class="number">2</span>+<span class="number">1</span>) += (r(p*<span class="number">2</span>+<span class="number">1</span>) - l(p*<span class="number">2</span>+<span class="number">1</span>) + <span class="number">1</span>)*add(p);</span><br><span class="line">add(p*<span class="number">2</span>) += add(p);</span><br><span class="line">add(p*<span class="number">2</span>+<span class="number">1</span>) += add(p);</span><br><span class="line">add(p) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建树  l和r是当前节点所代表的区间的左右端点 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">l(p) = l,r(p) = r,add(p) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">t[p].sum = a[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">build(p*<span class="number">2</span>,l,mid);</span><br><span class="line">build(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">t[p].sum = t[p*<span class="number">2</span>].sum + t[p*<span class="number">2</span>+<span class="number">1</span>].sum; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间更新 如果当前区间被包含 则延迟标记 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(p) &amp;&amp; r(p) &lt;= r)&#123;</span><br><span class="line">sum(p) += (r(p)-l(p)+<span class="number">1</span>)*d;</span><br><span class="line">add(p) += d;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">int</span> mid = (l(p)+r(p))/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) change(p*<span class="number">2</span>,l,r,d);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) change(p*<span class="number">2</span>+<span class="number">1</span>,l,r,d);</span><br><span class="line">sum(p) = sum(p*<span class="number">2</span>) + sum(p*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间查询 当查询到该区间时顺便更新 </span></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">//printf("%d %d\n",l(p),r(p));</span></span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(p) &amp;&amp; r(p) &lt;= r)&#123;</span><br><span class="line"><span class="keyword">return</span> sum(p);</span><br><span class="line">&#125;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">int</span> mid = (l(p) + r(p))/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) ans += ask(p*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) ans += ask(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'C'</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> l,r,d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;d);</span><br><span class="line">change(<span class="number">1</span>,l,r,d);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(<span class="number">1</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>参考书目：</strong><br>《算法竞赛进阶指南》李煜东.P209</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;延迟标记&quot;&gt;&lt;a href=&quot;#延迟标记&quot; class=&quot;headerlink&quot; title=&quot;延迟标记&quot;&gt;&lt;/a&gt;延迟标记&lt;/h4&gt;&lt;p&gt;在线段树中，单点修改时，我们是将信息从叶节点向上依次更新它的父节点，直到根节点。如果在区间修改仍然按照这个策略，那么修改的时
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Trie-字典树笔记</title>
    <link href="http://valenshi.top/2019/08/16/trie/"/>
    <id>http://valenshi.top/2019/08/16/trie/</id>
    <published>2019-08-16T14:03:30.000Z</published>
    <updated>2019-08-20T12:46:11.279Z</updated>
    
    <content type="html"><![CDATA[<p>Trie，又称字典树，是一种用于实现字符串快速检索的<strong>多叉树</strong>结构。Trie的每个节点都拥有若干个字符指针，若在插入或检索字符串时扫描到一个字符c，就沿着当前节点的c这个字符指针，走向该指针指向的节点。</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>一颗空Trie仅包含一个根节点，该节点的字符指针均指向空。</p><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p>若需要插入一个字符串S时，我们令一个指针P起初指向根节点。然后，依次扫描S中的每个字符c：</p><ul><li>若P的c字符指针指向一个已经存在的节点Q，则令 P = Q。</li><li>若P的c字符指针指向空，则新建一个节点Q，令P的c字符指针指向Q，然后令P = Q。</li></ul><p>当S的字符扫描完毕时，在当前节点P上标记它是一个字符串的末尾。</p><h5 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h5><p>当需要检索一个字符串S在Trie中是否存在时，我们令一个指针P起初指向根节点，然后依次扫描S中的每个字符c：</p><ul><li>若p的c字符指针指向空，则说明S没有被插入过Trie，结束检索。</li><li>若P的c字符指针指向一个已经存在的节点Q，则令P = Q</li></ul><p>若S中的字符扫描完毕时，当前节点P被标记为一个字符串的末尾，则说明S在Trie中存在，否则说明S没有被插入过。</p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><p>我们以一个简单的经典问题为例：有m次询问，每次询问给出一个操作符op和字符串S，若op = 1，则将S放入集合T，若op = 2，则回答T集合中是否有S字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">bool</span> End[SIZE];</span><br><span class="line"><span class="keyword">int</span> trie[SIZE][<span class="number">30</span>],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; len;k++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ch = str[k]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(trie[p][ch] == <span class="number">0</span>) trie[p][ch] = ++tot;</span><br><span class="line">        p = trie[p][ch];</span><br><span class="line">    &#125;</span><br><span class="line">    End[p] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str),p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; len;k++)&#123;</span><br><span class="line">        p = trie[p][str[k]-<span class="string">'0'</span>];</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> End[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> m,op;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>,&amp;op,s);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) insert(s);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(search(s)) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考书目：</strong></p><ul><li>《算法竞赛进阶指南》李煜东.P71</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Trie，又称字典树，是一种用于实现字符串快速检索的&lt;strong&gt;多叉树&lt;/strong&gt;结构。Trie的每个节点都拥有若干个字符指针，若在插入或检索字符串时扫描到一个字符c，就沿着当前节点的c这个字符指针，走向该指针指向的节点。&lt;/p&gt;
&lt;h5 id=&quot;初始化&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最短路径算法</title>
    <link href="http://valenshi.top/2019/08/16/dijkstra/"/>
    <id>http://valenshi.top/2019/08/16/dijkstra/</id>
    <published>2019-08-16T14:01:36.000Z</published>
    <updated>2019-08-20T12:45:27.305Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前置知识：</strong> 图的相关定义、图的存储</p><p><strong>摘要：</strong><br>最短路径算法中常用的有4个：Floyed-Warshall、Dijkstra、Bellman-Ford、SPFA。这几种算法区别在于适用范围，以及对于不同构造的图效率不同。由于边的权值可以为负，在边权为负的情况下Dijkstra算法无法使用。而Bellman-Ford算法虽然可以处理负边权图，但却不能处理负权回路的情况（文中有介绍）。<br>进一步的，我们可以将最短路径问题分为单源最短路径和多源最短路径问题。在学会处理这两个问题后，我们还将探讨如何记录并输出最短路径而不仅仅是求值；在走最短路径的基础上，我们还应能对等效路径（即最终结果相同的两条路径，这里表现为权值相同）做约束选择（即有第二权值）。</p><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>我们假设图中顶点个数为N，编号依次为1~N，边的个数为M。</p><p><strong>最短路问题：</strong> 在图中，给定两个顶点，在以这两个点为起点和终点的路径中，边的权值和最小的路径。<br><strong>稀疏图：</strong> 符合|E| = O(V)的图称为稀疏图。<br><strong>稠密图：</strong> 符合|E| = O(V^2)的图称为稠密图。在算法竞赛中，若|E|比|V|大一个数量级以上则可认为是稠密图。</p><h4 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h4><p>源，即起点的意思。单源最短路径问题就是求从一个起点出发到其它顶点的最短路径。这里我们假设起点为1（图中顶点编号为1~N），dist[ i ] 为从起点1到顶点i的最短路径。<br>求单源最短路径有3个算法：Dijkstra、Bellman-Ford和SPFA。其中SPFA是Bellman-Ford的优化版本，于是我们通常依据情况挑选适合的算法使用。</p><h5 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h5><p><strong>适用范围与效率：</strong><br>Dijkstra算法适用于所有边权值非负情况，其运行效率为O(N^2)，优化后效率为O(M* LogN)，适用于稠密图。</p><p><strong>算法流程：</strong> </p><ol><li>初始化dist[1] = 0，其余节点的dist值设为无穷大。</li><li>找出一个未被标记的、dist[x]最小的节点x，然后标记节点x。</li><li>扫描节点x的所有出边（x,y,z），若dist[y] &gt; dist[x]+z，则适用dist[x]+z更新dist[y]。</li></ol><p><strong>算法思想：</strong><br>Dijkstra算法基于贪心的思想。我们的做法就是不断通过已求出的最短路径dist[x]来更新和其相连的点y（假设(x,y,z)分别为起点、终点、边权）。在这种情况下，每个点y有可能被多个点x更新，于是我们取dist[x]+z值最小的作为dist[y]。<br><strong>正确性证明：</strong><br>在上述算法流程步骤2中，我们找出未被标记的、dist[x]最小的节点x来更新和x相连的点，这里所指的dist[x]即<strong>全局最小值</strong>。为什么使用全局最小值来更新和其相连的点可以达到目的呢？<br>首先，由于除了节点1外所有点的dist初始值都为无穷大，因此dist不是无穷大的点一定是被更新过了的；另外，dist为全局最小值的点，其dist一定不会再被更新，因为<strong>没有比其dist更小的点</strong>可以用来更新它。至此，我们已经证明了dist为全局最小值的点x一定是被更新过了的，且一定是不能再被更新了的，因此dist[x]即为节点1到x的最短路径，所以我们可以用x来更新其它点。</p><p><strong>优化：</strong><br>上述算法，在找全局最小值时采取遍历的方法，其查找与删除的效率为O(N)，加之使用邻接矩阵存储，遍历边也是O(N)，所以时间复杂度为O(N^2)。但是我们可以采用堆+邻接表的方式来优化。我们可以在O(log N)的复杂度下获取和删除全局最小值，最终可在O(M log N)时间内完成算法。</p><p><strong>代码示例：</strong><br>见附录部分code-1：二叉堆优化的Dijkstra算法模板</p><h5 id="Bellman-Ford算法与SPFA算法"><a href="#Bellman-Ford算法与SPFA算法" class="headerlink" title="Bellman-Ford算法与SPFA算法"></a>Bellman-Ford算法与SPFA算法</h5><p><strong>适用范围与效率：</strong><br>能处理带负权边的情况，不能处理存在负权回路的情况。其中Bellman-Ford效率为O(NM)，SPFA效率为O(KE)，其中K为常数，平均值为2。适用于稀疏图。<br><strong>算法介绍：</strong><br>可以注意到我们将Bellman-Ford算法和SPFA算法放在了一起整理，因为实际上SPFA是“队列优化的Bellman-Ford算法”，因此本质上思想相同。<br><strong>算法流程：</strong> </p><ol><li>扫描所有边(x,y,z)，若dist[y] &gt; dist[x] + z，则用dist[x] + z更新dist[y]。</li><li>重复上述步骤，直到没有更新操作为止。</li></ol><p><strong>算法思想：</strong><br>Bellman-Ford算法是基于迭代思想的。我们每一次都对所有的边进行一次更新操作，直至没有更新操作发生为止。每一次的更新操作都使得我们更接近答案，这种通过若干次重复操作不断逼近答案的思想就是迭代思想。算法的正确性很显然，不予证明。</p><p><strong>SPFA：</strong></p><ol><li>建立一个队列，最初队列中只包含起点。</li><li>取出队头节点x，扫描它所有出边（x,y,z)，若dist[y] &gt; dist[x] + z，则使用dist[x] + z更新dist[y]。同时，若y不在队列中，则把y入队。</li><li>重复上述步骤，直到队列为空。</li></ol><p>在这个优化中，我们采用队列保存了待扩展节点。每次入队相当于完成一次对dist数组的更新操作，一个节点可能会入队、出队多次。这个队列避免了Bellman-Ford算法中对不需要扩展节点的冗余扫描。在稀疏图上SPFA效率较高，为O(KM)级别，其中k是一个较小的常数。但是在稠密图或者特殊的网格图上，仍有可能退化为O(NM)。</p><p><strong>代码示例：</strong><br>见附录部分code-2：SPFA模板</p><h4 id="多源最短路径问题"><a href="#多源最短路径问题" class="headerlink" title="多源最短路径问题"></a>多源最短路径问题</h4><p>与单源最短路径问题对应，多源最短路径问题不局限于某一固定起点，而是可能在一次算法中询问任意两个点之间的最短路径，于是之前的3个算法就捉襟见肘了，显然，我们需要一种新的算法来解决这类问题，这个算法就是Floyd算法。</p><h5 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h5><p><strong>适用范围：</strong> 适用于求多源最短路径问题，适用于稠密图，时间复杂度为O(N^3)。<br><strong>算法思想：</strong><br>Floyd算法基于动态规划。设D[k,i,j]表示“经过若干个编号不超过k的节点”从i到j的最短路径长度。该问题可以划分为两个子问题，经过编号不超过k-1的节点从i到j，或者从i先到k再到j。于是有状态转移方程：<br>&emsp;&emsp;D[k,i,j] = min( D[k-1,i,j] , D[k-1,i,k] + D[k-1,k,j] )<br>初值为D[0,i,j] = A[i,j]其中A[i,j]为自定义的邻接矩阵。<br>上述算法中，k是阶段，所以必须置于最外层循环。i和j是附加状态，因此可以置于内层循环。算法的正确等价于动态规划的正确性证明，此处不予证明。<br><strong>优化：</strong><br>Floyd算法可进行空间优化，我们可以注意到第一维完全可以向背包问题中一样省略。最初，我们可以直接用D保存邻接矩阵。在最外层循环到k层时，内层有状态转移：<br>&emsp;&emsp;D[i,j] = min(D[i,j] , D[i,k] + D[k,j])<br>最终D[i,j]就保存了i到j的最短路径。<br><strong>代码示例：</strong><br>见附录部分code-3：Floyd算法模板。</p><h4 id="未解决的问题"><a href="#未解决的问题" class="headerlink" title="未解决的问题"></a>未解决的问题</h4><p>以下问题将在另一篇笔记中整理：</p><ul><li>如何保存并输出最短路径。</li><li>最短路径的变形，如：求连通性、求传递闭包、求路径最大权值最小。</li><li>节点有约束的最短路径问题。</li><li>如何判断负环。</li></ul><h4 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h4><ul><li>《算法竞赛进阶指南》,李煜东,P322-331.</li><li>《信息学奥赛一本通》,董永建,科学技术文献出版社,P471-485.</li><li>《挑战程序设计竞赛(第二版)》,人民邮电出版社,秋叶拓哉,P99.</li></ul><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p>code-1：二叉堆优化的Dijkstra算法模板<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    《算法竞赛进阶指南》P324</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],Next[M],d[N];</span><br><span class="line"><span class="keyword">int</span> n,m,tot;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">priority_queue&lt; pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//pair 第一维是dist的相反数，利用相反数使得大根堆变成小根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y,edge[tot] = z;</span><br><span class="line">    Next[tot] = head[x],head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);    <span class="comment">//初始化dist数组</span></span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);   <span class="comment">//初始化标记数组</span></span><br><span class="line">    d[s] = <span class="number">0</span>;   </span><br><span class="line">    q.push(make_pair(<span class="number">0</span>,s));</span><br><span class="line">    <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.top().second;q.pop();<span class="comment">//x为全最最小值节点编号</span></span><br><span class="line">        <span class="keyword">if</span>(vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//遍历所有边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i;i = Next[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line">            <span class="keyword">if</span>(d[y] &gt; d[x] + z)&#123;</span><br><span class="line">                d[y] = d[x]+z;</span><br><span class="line">                q.push(make_pair(-d[y],y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>code-2：SPFA算法模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//《算法竞赛进阶指南》P326</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[M],ver[M],Next[M],d[N];</span><br><span class="line"><span class="keyword">int</span> n,m,tot;</span><br><span class="line"><span class="keyword">bool</span> vis[N];    <span class="comment">//用来标记节点x是否在队列中</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;   <span class="comment">//辅助队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y,edge[tot] = z;</span><br><span class="line">    Next[tot] = head[x],head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();q.pop();</span><br><span class="line">        vis[x] = <span class="literal">false</span>;     <span class="comment">//表示x不在队列中了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i;i = Next[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">            <span class="keyword">if</span>(d[y] &gt; d[x]+z)&#123;</span><br><span class="line">                d[y] = d[x]+z;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y]) q.push(y),vis[y] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,z,s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        add(x,y,z);</span><br><span class="line">    &#125;</span><br><span class="line">    SPFA(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,d[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>code-3：Floyd算法模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> a&gt;b?b:a;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) d[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        d[x][y] = min(d[x][y],z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">                d[i][j] = min(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,d[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;前置知识：&lt;/strong&gt; 图的相关定义、图的存储&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;最短路径算法中常用的有4个：Floyed-Warshall、Dijkstra、Bellman-Ford、SPFA。这几种算法区别在于适用范围，
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最长上升子序列模板</title>
    <link href="http://valenshi.top/2019/08/16/lis/"/>
    <id>http://valenshi.top/2019/08/16/lis/</id>
    <published>2019-08-16T14:00:15.000Z</published>
    <updated>2019-08-20T12:45:04.094Z</updated>
    
    <content type="html"><![CDATA[<p>按照数据结构来划分的话，最长上升子序列(LIS)是属于线性DP，其作为动态规划经典入门模型，重要性也是不言而喻的。而LIS问题也有很多种变型，对于这些问题有的超过了动态规划的适用范围，有的需要对转移方程进行更改，需要具体问题具体分析。</p><p><strong>前置知识：</strong></p><ul><li>子序列的概念</li><li>动态规划一般步骤</li><li>二分查找</li></ul><blockquote><p>问题模型：给定一个长度为N的数列A，求数值单调递增的子序列长度最长是多少。</p></blockquote><p><strong>解题思路：</strong><br>状态表示：我们设F[i]表示以A[i]为结尾的“最长上升子序列”的长度。<br>阶段划分：子序列的结尾位置（数列A中的位置，从前到后）。<br>转移方程：F[i] = max{ f[j] + 1} (0 &lt;= j &lt; i 且 A[j] &lt; A[i])。<br>边界：F[0] = 0。<br>目标：max{F[i]} ( 0 &lt;= i &lt; = N)。</p><p>如此设计目标函数与转移方程，很显然可以得到正确结果，其效率是O(N^2)，代码实现也很简单。</p><p><strong>优化：</strong><br>首先考虑一下上述算法最耗时的地方在哪，显然我们每次都要用O(N)的时间遍历前i-1个位置上的元素来更新F[i]，而能更新F[i]的元素A[j]需要满足两个条件：A[j] &lt; A[i]且F[j] &gt;= F[i]，那么F[i]就可以被更新为F[j]+1。在这个过程中，A[j]也可以描述为“小于A[i]的所有元素中F的值最大的那个”，通过这个描述来找A[j]的效率是O(N)。<br>考虑另一种方式，我们新增一个辅助数组d，d[i] 表示“长度为i的最长上升子序列的最小结尾是多少”，那么很显然，d数组中的元素是严格递增的。且每当我们读取到A序列中的一个元素A[i]时，都有两种情况：</p><ol><li>A[i] &gt; d[len]，此时 d[++len] = A[i]。 </li><li>A[i] &lt;= d[len]，此时说明d数组中某个元素可以被A[i]更新，我们采用二分查找的方式更新d数组即可。</li></ol><p>其中len代表当前最长上升子序列的长度。<br>上述方法中，如果遇到情况1，那么效率是O(1)，情况2，效率就是O(log N)，总体来讲，对于大量数据，该优化效果还是很喜人的。</p><p><strong>优化的正确性说明：</strong><br>上述优化可以用堆栈思想来解释，也可以将其看作一个小技巧。借助于d数组，对于序列A中的每个元素A[i]，我们都可以快速找到“小于A[i]的所有元素中F的值最大的那个”，<strong>因为d[len]存放的就是最长上升子序列长度为len时的最小元素</strong> 。如果A[i] &lt;= d[len]，那么很显然当前的最长上升子序列长度len不能再增加了（因为A[i] 不能添加在A的子序列d[1] ~d[len] 的后面），且d数组可以被更新(再不济也可以将d[len] 更新为 A[i]，因为 A[i] &lt; d[len])。于是借助于d数组的特性，完成了优化，当然也有所牺牲。</p><p><strong>代码示例：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">b_search</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> s,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(s &lt; e)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = s+(e-s)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(d[mid] &gt;= x) e = mid;</span><br><span class="line">        <span class="keyword">else</span> s = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    d[<span class="number">1</span>] = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt;= d[len])  d[++len] = A[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> p = b_search(A[i],<span class="number">1</span>,len);</span><br><span class="line">            d[p] = A[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  for(int i = 0;i &lt; len;i++)  cout &lt;&lt; d[i+1]&lt;&lt;" ";</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ul><li>《算法竞赛进阶指南》,李煜东,P237.</li><li><a href="https://www.cnblogs.com/wxjor/p/5524447.html" target="_blank" rel="noopener">博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;按照数据结构来划分的话，最长上升子序列(LIS)是属于线性DP，其作为动态规划经典入门模型，重要性也是不言而喻的。而LIS问题也有很多种变型，对于这些问题有的超过了动态规划的适用范围，有的需要对转移方程进行更改，需要具体问题具体分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前置知识
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>“拓展域”与“边带权”并查集</title>
    <link href="http://valenshi.top/2019/08/16/bingchaji/"/>
    <id>http://valenshi.top/2019/08/16/bingchaji/</id>
    <published>2019-08-16T13:57:56.000Z</published>
    <updated>2019-08-20T12:44:45.408Z</updated>
    
    <content type="html"><![CDATA[<h5 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h5><ul><li>并查集</li><li>路径压缩与按秩合并</li></ul><h5 id="“边带权”并查集"><a href="#“边带权”并查集" class="headerlink" title="“边带权”并查集"></a>“边带权”并查集</h5><p>并查集实际上是由若干棵树构成的森林，我们可以在树中的每条边上记录一个权值，即维护一个数组d，用d[x]保存节点x到父节点fa[x]之前的边权。在每次路径压缩后，每个访问过的节点都会直接指向树根，如果我们同时更新这些节点的d值，就可以利用路径压缩的过程来统计每个节点到树根之间的路径上的一些信息。这就是所谓“边带权” 的并查集。</p><h5 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h5><blockquote><p>POJ1773<br>题目描述：见《算法竞赛进阶指南》P190</p></blockquote><p><strong>解题思路1：边带权</strong><br>本题可作为“边带权”和“扩展域”模板题整理。与一般的并查集不同的是，本题传递关系不止一种：</p><ul><li>若x1和x2奇偶性相同，x2与x3奇偶性也相同，则x1与x3奇偶性相同。</li><li>若x1和x2奇偶性相同，x2与x3奇偶性不同，则x1与x3奇偶性不同。</li><li>若x1和x2奇偶性不同，x2与x3奇偶性不同，则x1与x3奇偶性相同。</li></ul><p>另外，本题的N太大，而M却很小，可以使用离散化方法，所以顺便复习一下离散化。<br>为了处理本题的多种传递关系，我们可以采用一种“边带权”的并查集。具体操作是用边权d[x] = 0 表示 x 与 par[x] 奇偶性相同；为1表示 x 与 par[x] 奇偶性不同。于是在路径压缩时，就可以通过对路径上边权做异或运算，即可得到 x 与树根的奇偶性关系。<br>于是对于每一个询问的(l , r , ans)，我们假设回答”odd”时，ans = 1，“even”时ans = 0，我们令 x 、 y 分别代表l-1和r离散化后的序号，如果x和y在同一个集合，则判断d[x] ^ d[y] 是否等于 ans，若不等则冲突；如果x和y不在同一个集合内，则合并 x 和 y ，此时需要注意如何更新d数组。（代码 code - 1 详解）</p><p><strong>解题思路2：扩展域</strong><br>本题还可以使用“扩展域”的并查集。<br>我们把每个变量x拆分成两个节点x_odd和x_even。其中用 x_odd 表示1~x有奇数个1，x_even表示有偶数个。我们把这两个节点称为x的“奇数域”与“偶数域”。<br>对于每个问题，假设在离散化后的 l-1 与 r 的值分别是x和y，设ans表示该问题的回答（0代表回答偶数个，1代表回答奇数个）。</p><ul><li>若ans = 0，x_odd 与 y_even在同一个集合，则与答案矛盾；否则合并x_odd与y_odd，x_even与y_even，这表示[l , r]中有偶数个1。</li><li>若ans = 1，x_odd与y_odd在同一个集合，则与答案矛盾；否则合并x_odd与y_even，x_even与y_odd。</li></ul><p>代码见code - 2.</p><h5 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h5><ul><li>《算法竞赛进阶指南》,李煜东,P190.</li></ul><p><strong>代码示例：code - 1</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">21000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,ans;</span><br><span class="line">&#125; q[MAXN];</span><br><span class="line"><span class="keyword">int</span> a[MAXN],par[MAXN],d[MAXN],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    a数组用来离散化，par[x]代表x的父节点编号，d[x]代表</span></span><br><span class="line"><span class="comment">    从x到根节点路径和，cnt也是用于离散化。</span></span><br><span class="line"><span class="comment">    这里根节点即集合的代表节点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x] == x) <span class="keyword">return</span> x;   <span class="comment">//找到根节点，返回</span></span><br><span class="line">    <span class="keyword">int</span> root = Find(par[x]);    <span class="comment">//临时存根节点</span></span><br><span class="line">    d[x] ^= d[par[x]];          <span class="comment">//路径压缩，距离数组d也应该更新</span></span><br><span class="line">    <span class="keyword">return</span> par[x] = root;       <span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">char</span> rs[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;q[i].l,&amp;q[i].r,rs);</span><br><span class="line">        <span class="keyword">if</span>(rs[<span class="number">0</span>] == <span class="string">'o'</span>) q[i].ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> q[i].ans = <span class="number">0</span>;</span><br><span class="line">        a[cnt++] = q[i].l<span class="number">-1</span>;    <span class="comment">//这里需要存l-1，为了使l也包含在内</span></span><br><span class="line">        a[cnt++] = q[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下两行代码离散化用</span></span><br><span class="line">    sort(a,a+cnt);</span><br><span class="line">    <span class="keyword">int</span> len = unique(a,a+cnt)-a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) par[i] = i; <span class="comment">//初始化爸爸数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;      </span><br><span class="line">        <span class="comment">//左右边界在离散化数组中的编号：</span></span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(a,a+len,q[i].l<span class="number">-1</span>)-a;</span><br><span class="line">        <span class="keyword">int</span> y = lower_bound(a,a+len,q[i].r)-a;  </span><br><span class="line">        <span class="comment">//左右边界的祖先分别为ta和tb</span></span><br><span class="line">        <span class="keyword">int</span> ta = Find(x),tb = Find(y);</span><br><span class="line">        <span class="keyword">if</span>(ta == tb)&#123;   <span class="comment">//如果已经在同一个集合内，则判断是否矛盾</span></span><br><span class="line">            <span class="keyword">if</span>((d[x]^d[y]) != q[i].ans)&#123;<span class="comment">//矛盾的条件就是事实和结果不同</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            par[ta] = tb;d[ta] = d[x]^d[y]^q[i].ans;</span><br><span class="line">            <span class="comment">//这里d[ta]的值需要推导一下。</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            我们将x所在的集合和y所在的集合合并，那么就需要更新d数组</span></span><br><span class="line"><span class="comment">            这里d[x]存放的是x到par[x]的距离，所以合并两个集合对于</span></span><br><span class="line"><span class="comment">            非根节点来说并无影响，关键是对于两个根d[ta]和d[tb]如何处理</span></span><br><span class="line"><span class="comment">            如果我们将ta代表的集合归于tb下，那么就需要更新d[ta],而已知</span></span><br><span class="line"><span class="comment">            ans = d[x]^d[y]^d[ta]，即x到y的总路径等于x到ta XOR y到tb XOR </span></span><br><span class="line"><span class="comment">            ta到tb；对上式变形，得：d[ta] = ans^d[x]^d[y],而后三者是已知，</span></span><br><span class="line"><span class="comment">            故可以求出d[ta]。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>代码示例：code - 2</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2</span>*<span class="number">21000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,ans;</span><br><span class="line">&#125;Q[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],par[N];    <span class="comment">//a用于离散化，par是爸爸数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> par[x] = Find(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;Q[i].l,&amp;Q[i].r,str);</span><br><span class="line">        Q[i].ans = str[<span class="number">0</span>] == <span class="string">'o'</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        a[++t] = Q[i].l<span class="number">-1</span>;</span><br><span class="line">        a[++t] = Q[i].r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+t);</span><br><span class="line">    n = unique(a+<span class="number">1</span>,a+<span class="number">1</span>+t) - a- <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span>*n;i++) par[i] = i;</span><br><span class="line">    <span class="comment">//因为每个节点有两个扩展域，所以n需要*2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(a+<span class="number">1</span>,a+<span class="number">1</span>+n,Q[i].l<span class="number">-1</span>)-a;</span><br><span class="line">        <span class="keyword">int</span> y = lower_bound(a+<span class="number">1</span>,a+<span class="number">1</span>+n,Q[i].r)-a;</span><br><span class="line">        <span class="keyword">int</span> x_odd = x,x_even = x+n;</span><br><span class="line">        <span class="keyword">int</span> y_odd = y,y_even = y+n;</span><br><span class="line">        <span class="keyword">if</span>(Q[i].ans == <span class="number">0</span>)&#123;      </span><br><span class="line">            <span class="keyword">if</span>(Find(x_odd) == Find(y_even))&#123;    <span class="comment">//答案与事实不符</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            par[Find(x_odd)] = Find(y_odd);</span><br><span class="line">            par[Find(x_even)] = Find(y_even);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(Find(x_odd) == Find(y_odd))&#123;     <span class="comment">//答案与事实不符</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i<span class="number">-1</span>); </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            par[Find(x_odd)] = Find(y_even);    <span class="comment">//合并x为奇，y为偶</span></span><br><span class="line">            par[Find(x_even)] = Find(y_odd);    <span class="comment">//合并x为偶和y为奇</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;并查集&lt;/li&gt;
&lt;li&gt;路径压缩与按秩合并&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;“边带权”并查集&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>莫队算法</title>
    <link href="http://valenshi.top/2019/08/16/modui/"/>
    <id>http://valenshi.top/2019/08/16/modui/</id>
    <published>2019-08-16T13:55:49.000Z</published>
    <updated>2019-08-20T12:44:28.318Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>莫队算法大概有基础莫队、树形莫队、带修（带修改的）莫队等类型，本文仅介绍基础莫队。可以看作莫队算法的入门。<br>莫队算法据说是2010年国家集训队的莫涛发明的一个优化类的算法，由于莫涛经常打比赛做队长，大家都叫他莫队，该算法也被称为莫队算法。它使用指针移动以及分块的思想对朴素算法进行优化。<br>莫队算法是离线算法，可以解决一类离线的区间问题，对于序列上的区间询问问题，如果从 [l,r] 的答案能够 O(1) 扩展到 [l−1,r],[l+1,r],[l,r+1],[l,r−1] 的答案，那么可以在 O(n√n) 的复杂度内求出所有询问的答案。</p><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p><strong>SPOJ D-query：</strong> 给定一个数组，每次询问一个区间内有多少个不同的元素。<br><strong>解题思路：</strong> </p><ol><li>朴素思想<br>注意到询问没有强制在线，因此我们可以使用离线的方法。首先我们考虑此类问题，如果我们已经计算出[L , R]的答案以及中间结果，那么我们显然可以在常数时间内计算出[L-1,R] , [L+1 , R] , [L , R-1] , [L , R+1]的答案，即便所给的询问并不一定是这样相差为1的区间，但这也启发了我们要尽可能将区间范围相近的放在一起计算。</li><li>为什么将询问区间相近的放在一起计算可以节省时间呢？<br>因为我们通过两个指针（p和q）的左右移动来统计区间信息，显然对于程序的每次运行，这两个指针的移动次数越少越好，要想移动的尽量少，显然区间相近的放在一起最好。</li><li>如何排序？<br>按照以上思路，我们要做的就是对区间进行排序，使得范围相近的询问区间尽量放在一起；但是区间有两个关键字（左端点和右端点），如果我们按照左端点严格升序，再按照右端点严格升序，那么很容易就想到一些反例来证明这种方法不是最优的，例如：(1, 100), (2, 2), (3, 99), (4, 4), (5, 102), (6, 7)。显然严格升序是不好的，很容易被出题人针对，如果能适当的减少右端点的移动次数，那么即使左端点的移动次数增加些许也是可以接受的。因此我们就要设计一种均衡的算法，使得左右端点并不一定严格有序，但总体复杂度（指针移动次数）尽量小。<br>利用分块思想，我们可以实现上述目标。我们将长度为n的序列分为长度为$\sqrt{n}$的若干块，将区间<strong>按照左端点所在的块的序号进行排序，如果块号相同则按照右端点排序。</strong> 当然我们只是概念上分块，并不一定需要严格存储块。之后我们只需要按照排序好是顺序挨个计算即可。</li></ol><p>总结起来一共三步：分块、排序、计算。算法复杂度为$O(N \sqrt{N})$</p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>可以发现本文是应用型的，对于算法的正确性证明以及复杂度证明都没有涉及，这方面的原因之一是由于这是入门文章，写太多证明反而令初学者害怕，如果学有余力自然可以找相关证明；然后就是拓展，掌握了基本思想再去拓展就轻松很多了，拓展方向可以向树形莫队、带修莫队等常见类型拓展，同时注意比较莫队和其他数据结构的异同以及优劣。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">31000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Q = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],m;</span><br><span class="line"><span class="keyword">int</span> ans,sum[<span class="number">1010000</span>];<span class="comment">//一个全局答案ans和标记数组sum是必要的 </span></span><br><span class="line"><span class="comment">//当然也可以离散化 </span></span><br><span class="line"><span class="keyword">int</span> len;<span class="comment">//块大小，在读入询问前需要先赋值 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,block,id;</span><br><span class="line">Query()&#123;&#125;</span><br><span class="line">Query(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> id):l(l),r(r),id(id)&#123;</span><br><span class="line">block = l/len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Query &amp;B) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(block == B.block) <span class="keyword">return</span> block&amp;<span class="number">1</span>? r &lt; B.r : r &gt; B.r;</span><br><span class="line"><span class="comment">//小优化，使得r呈波浪形 </span></span><br><span class="line"><span class="keyword">return</span> block &lt; B.block;</span><br><span class="line">&#125;</span><br><span class="line">&#125;query[Q];</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//增加或减少一个x位置上的数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">x = a[x]; </span><br><span class="line">sum[x] += v;</span><br><span class="line"><span class="keyword">if</span>(v &gt; <span class="number">0</span>) ans += sum[x] == <span class="number">1</span>;<span class="comment">//判等是为了防止重复计数 </span></span><br><span class="line"><span class="keyword">else</span> ans -= sum[x] == <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">len = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">query[i] = Query(x,y,i);</span><br><span class="line">&#125;</span><br><span class="line">sort(query+<span class="number">1</span>,query+<span class="number">1</span>+m);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>,r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l &lt; query[i].l) Move(l,<span class="number">-1</span>),l++;</span><br><span class="line"><span class="keyword">while</span>(l &gt; query[i].l) Move(l<span class="number">-1</span>,<span class="number">1</span>),l--;</span><br><span class="line"><span class="keyword">while</span>(r &gt; query[i].r) Move(r,<span class="number">-1</span>),r--;</span><br><span class="line"><span class="keyword">while</span>(r &lt; query[i].r) Move(r+<span class="number">1</span>,<span class="number">1</span>),r++;</span><br><span class="line">q.push(make_pair(-query[i].id,ans));<span class="comment">//大根堆变为小根堆 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.top().second;q.pop();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] 张瑯小强的<a href="https://www.cnblogs.com/CsOH/p/5904430.html" target="_blank" rel="noopener">博客</a>，2019.7.4<br>[2] 例题测试地址<a href="https://vjudge.net/problem/SPOJ-DQUERY" target="_blank" rel="noopener">SPOJ-DQUERY</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;莫队算法大概有基础莫队、树形莫队、带修（带修改的）莫队等类型，本文仅介绍基础莫队。可以看作莫队算法的入门。&lt;br&gt;莫队算法据说是2010年国
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>逆元模板</title>
    <link href="http://valenshi.top/2019/08/16/inv/"/>
    <id>http://valenshi.top/2019/08/16/inv/</id>
    <published>2019-08-16T13:54:10.000Z</published>
    <updated>2019-08-20T12:47:13.449Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>本文主要介绍了几种求逆元的方法，但是对于证明并未给出，所以本文是偏于应用型的，其后附录部分的代码模板可以参考使用。其中最容易理解也最容易写的是费马小定理求逆元，然后更加常用的就是求阶乘的逆元了，通过O(N)的预处理，我们可以在常数时间内求出组合数C(n,m)在 mod P下的值。</p><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p><strong>1.1 定义：</strong> 逆元素是指一个可以取消另一给定元素运算的元素，在数学里，逆元素广义化了加法中的加法逆元和乘法中的倒数。</p><p><strong>1.2 数论中定义：</strong> 如果满足公式，a*b = 1（mod P），则a是b的逆元，同时b也是a的逆元。</p><p><strong>1.3 另一种定义：</strong> a*x  = 1 (mod P)，其中a与P互质，则称x的最小整数为a关于P的逆元。</p><h4 id="2-逆元的应用"><a href="#2-逆元的应用" class="headerlink" title="2.逆元的应用"></a>2.逆元的应用</h4><p><strong>2.1 除法模运算：</strong> 设c为b在对P取模状态下的逆元，在求(a/b)modP时，很可能会因为b过大而超过精度范围，这时候可以将除法转换成乘法来做，（a/b）mod P = (a <em> Invb) mod P = (a mod P)</em> (Invb mod P) mod P。</p><h4 id="3-求逆元的常用方法"><a href="#3-求逆元的常用方法" class="headerlink" title="3.求逆元的常用方法"></a>3.求逆元的常用方法</h4><h5 id="3-1-费马小定理"><a href="#3-1-费马小定理" class="headerlink" title="3.1 费马小定理"></a>3.1 费马小定理</h5><blockquote><p>费马小定理：若p为素数，则有$a^{P-1} \equiv 1(mod P)$<br>推论：$a * a^{P-2} \equiv 1(mod P)$<br>故$a^{P-2}$就是a关于P的一个逆元</p></blockquote><p><strong>3.1.1 代码实例：</strong> 见附录部分code-1。</p><p><strong>3.1.2 复杂度分析：</strong> 求单个逆元的时间复杂度是lg(Mod)。</p><h5 id="3-2-拓展欧几里得算法"><a href="#3-2-拓展欧几里得算法" class="headerlink" title="3.2 拓展欧几里得算法"></a>3.2 拓展欧几里得算法</h5><h5 id="3-3-逆元线性筛"><a href="#3-3-逆元线性筛" class="headerlink" title="3.3 逆元线性筛"></a>3.3 逆元线性筛</h5><blockquote><p>递推式：inv[i] = (Mod-Mod / i) <em> inv[Mod% i]%Mod<br>如果要保证结果为正： inv[i] = (Mod-Mod / i) </em> inv[Mod% i]%Mod<br>证明：</p></blockquote><p><strong>3.3.1 代码示例：</strong> 见附录部分code-2。<br><strong>3.3.2 复杂度分析：</strong> O(N)。</p><h5 id="3-4求阶乘的逆元"><a href="#3-4求阶乘的逆元" class="headerlink" title="3.4求阶乘的逆元"></a>3.4求阶乘的逆元</h5><blockquote><p>递推式：inv[i] = inv[i+1] * (i + 1) % Mod<br>证明：</p></blockquote><p><strong>3.4.1代码示例：</strong> 见附录部分code-3.。</p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p><strong>code-1：费马小定理求逆元</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 100010;</span><br><span class="line">const int P = 1e5+7;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll Finv[N];</span><br><span class="line">ll qpow(ll x,ll p,ll m)&#123;//快速幂算法 </span><br><span class="line">ll res = 1;</span><br><span class="line">while(p)&#123;</span><br><span class="line">if(p&amp;1)res =res*x%m;</span><br><span class="line">x = x*x%m;</span><br><span class="line">p &gt;&gt;= 1;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">void Init()&#123;//用来求逆元 </span><br><span class="line">Finv[1] = 1;</span><br><span class="line">for(int i = 2;i &lt; N;i++)</span><br><span class="line">Finv[i] = qpow(i,P-2,P);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Init();</span><br><span class="line">for(int i = 1;i &lt; N;i++)</span><br><span class="line">cout &lt;&lt; Finv[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>code-2：逆元线性筛</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int N = 100010;</span><br><span class="line">const int P = 1e5+7;</span><br><span class="line">ll inv[N];</span><br><span class="line">void Inv()&#123;</span><br><span class="line">inv[0] = inv[1] = 1;</span><br><span class="line">for(ll i = 2;i &lt; N;i++)&#123;</span><br><span class="line">inv[i] = (P - P/i)*inv[P%i]%P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Inv();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>code-3求阶乘的逆元</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll Finv[N],F[N];<span class="comment">//F存阶乘，Finv存对应逆元 </span></span><br><span class="line"><span class="function">ll <span class="title">Qpow</span><span class="params">(ll x,ll p,ll m)</span></span>&#123; </span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line"><span class="keyword">if</span>(p&amp;<span class="number">1</span>)res =res*x%m;</span><br><span class="line">x = x*x%m;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">F[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt; N;i++)</span><br><span class="line">F[i] = F[i<span class="number">-1</span>]*i%P; </span><br><span class="line">Finv[N<span class="number">-1</span>] = Qpow(F[N<span class="number">-1</span>],P<span class="number">-2</span>,P);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = N<span class="number">-1</span>;i &gt; <span class="number">0</span>;i--)</span><br><span class="line">Finv[i<span class="number">-1</span>] = Finv[i]*i%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; N;i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Finv[i]*F[i]%P &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;本文主要介绍了几种求逆元的方法，但是对于证明并未给出，所以本文是偏于应用型的，其后附录部分的代码模板可以参考使用。其中最容易理解也最容易写的
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数论" scheme="http://valenshi.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
