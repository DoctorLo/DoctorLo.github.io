<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ValenShi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://valenshi.top/"/>
  <updated>2020-02-16T03:25:54.334Z</updated>
  <id>http://valenshi.top/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Educational Codeforces Round 81 (Rated for Div. 2)</title>
    <link href="http://valenshi.top/2020/02/16/Edu-Cf81/"/>
    <id>http://valenshi.top/2020/02/16/Edu-Cf81/</id>
    <published>2020-02-16T03:25:23.000Z</published>
    <updated>2020-02-16T03:25:54.334Z</updated>
    
    <content type="html"><![CDATA[<h4 id="A-Display-The-Number"><a href="#A-Display-The-Number" class="headerlink" title="A. Display The Number"></a>A. Display The Number</h4><p><strong>题意简述</strong><br>众所周知 7 根数码管可以用于表示数字 0~9 ，现在给 n 根数码管，请问能表示的最大的数是多少？</p><p><strong>解题思路</strong><br>显然位数越大的数越大，相同位数时，高位大的数越大。那么最少用 2 根数码管能表示一个数字，即 1，所以我们尽量多的表示 1，可以表示 n/2 个1，如果 n 为奇数，那么剩下的 1 个数码管可以和最高位表示出 7，因此我们只需对 n 判奇偶即可。</p><p><strong>Code</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = n/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">string</span> ans = <span class="string">"1"</span>;</span><br><span class="line"><span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans = <span class="string">"7"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; cnt;i++) ans += <span class="string">"1"</span>;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; solve() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="B-Infinite-Prefixes"><a href="#B-Infinite-Prefixes" class="headerlink" title="B. Infinite Prefixes"></a>B. Infinite Prefixes</h4><p><strong>题意简述</strong><br>给定一个 01 串 s，定义串 t 是由若干个 s 组成，即 t = sssssss…。<br>对于 t 的前缀 pre，pre 中 <strong>cnt0 （字符 0 的数量） - cnt1（字符 1 的数量） = x</strong>，那么称 pre 是 t 的黄金前缀，请问给定整数 x 和字符串 s，t 共多少个黄金前缀？<br>注意：空串也是一个前缀！</p><p><strong>解题思路</strong><br>如果仅从题意来看的话应该就是构造性模拟题，但是前提是分类要正确，我刚开始就是分类过细导致漏掉某些情况。<br>我们可以利用前缀和思路，sum[i] 存放 s 串中以 i 为末尾的前缀 cnt0 - cnt1 的值。易得，若 x - sum[i] % sum[n] == 0，则说明我们可以在当前前缀前面添加若干个 s 串来使得其变为黄金前缀。但是如果 sum[n] &lt;= 0 那么就会出错，因为正数和负数取模结果是不一定的，所以当 sum[n] &lt;= 0 时需要单独处理。<br>上述做法只针对 x 是正数，若 x 是负数则把 s 串中 01 互换并把 x 取反即可。</p><p><strong>Code</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> pre[N];</span><br><span class="line"><span class="keyword">int</span> n,x;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;<span class="comment">//预处理将x转为正</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line"><span class="keyword">if</span>(str[i] == <span class="string">'1'</span>) str[i] = <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">else</span> str[i] = <span class="string">'1'</span>;</span><br><span class="line">x = -x;</span><br><span class="line">&#125; </span><br><span class="line">str = <span class="string">"#"</span> + str;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">//判断无穷解</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i] == <span class="string">'0'</span>) pre[i] = pre[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> pre[i] = pre[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(pre[i] == x) flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pre[n] == <span class="number">0</span> &amp;&amp; flag)&#123;<span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> ans = (!x)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(pre[n] &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>((x-pre[i]) &gt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>((pre[i]-x)%(-pre[n]) == <span class="number">0</span>) ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(x &gt;= pre[i] &amp;&amp; (x-pre[i])%pre[n] == <span class="number">0</span>) ans++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="C-Obtain-The-String"><a href="#C-Obtain-The-String" class="headerlink" title="C. Obtain The String"></a>C. Obtain The String</h4><p><strong>题意简述</strong><br>给定两个字符串 s 和 t，要求从 s 中选出若干个<strong>子序列</strong>，使得它们<strong>依次</strong>拼接后可以得到 t。<br>请问最少需要选几次子序列？（每次选定后 s 不变）</p><p><strong>解题思路</strong><br>理解题意后可以做出推论” 每次选取当前最长合法子序列一定是最优的“。<br>例如对于 s = “abcdef” , t = “adddecf”，那么第一次可选的有 “a” 和 “ad”，显而易见选 “ad” 更好，否则选了 “a” 之后第二次还是要选一次 “d”，多做了一次操作。<br>那么解题步骤可以总结为：nex[p , j] 记录 s 中位置 p 的下一个 j （j = a,b,c,d,…）所在的下标。于是我们可以遍历 t，刚开始 p = 0，然后 p = nex[p ,j]，当 p = -1时就说明当前子序列不能再拓展了。</p><p><strong>Code</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> f[N],nex[N][<span class="number">30</span>];</span><br><span class="line"><span class="built_in">string</span> s,t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*最少几次操作可以使得 z 变为 t */</span></span><br><span class="line">s = <span class="string">"#"</span> + s; t = <span class="string">"#"</span> + t;</span><br><span class="line"><span class="keyword">int</span> len = s.length();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">30</span>;i++) nex[len<span class="number">-1</span>][i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++) nex[i<span class="number">-1</span>][j] = nex[i][j];</span><br><span class="line">nex[i<span class="number">-1</span>][s[i]-<span class="string">'a'</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>; len = t.length();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,p = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">f[i] = f[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(~nex[p][t[i]-<span class="string">'a'</span>]) p = nex[p][t[i]-<span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">f[i]++, p = nex[<span class="number">0</span>][t[i]-<span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">-1</span>)&#123; <span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f[len<span class="number">-1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="D-Same-GCDs"><a href="#D-Same-GCDs" class="headerlink" title="D. Same GCDs"></a>D. Same GCDs</h4><p><strong>题意简述</strong><br>给定正整数 a 和 m，试求出 x 的个数，x 满足 0 &lt;= x &lt; m 且 gcd(a, m) = gcd(a+x, m) 。其中 1&lt;= a,m &lt;= 1e10。</p><p><strong>解题思路</strong><br>设 d = gcd(a, m)，易得 d|a , d|m , d|(a+x) , d|x 。<br>因而 x 满足：</p><ol><li>d|x</li><li>gcd( (x+a)/d , m/d ) = 1</li></ol><p>令 t = (x+a)/d，那么问题变为找到 t 的个数，使得 gcd(t , m/d) = 1，其中 a/d &lt;= t &lt;= (m+a)/d，化简得 0 &lt;= t &lt;= m/d。<br>即答案为 phi(m/d)。其中 phi(y) 为 y 的欧拉函数。</p><p><strong>Code</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line">ll a,m;</span><br><span class="line"><span class="function">ll <span class="title">Phi</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">ll res = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;<span class="number">1l</span>l*i*i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(n%i == <span class="number">0</span>) &#123;</span><br><span class="line">res -= res/i;</span><br><span class="line"><span class="keyword">while</span>(n%i == <span class="number">0</span>) n /= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n &gt; <span class="number">1</span>) res -= res/n;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%I64d%I64d"</span>,&amp;a,&amp;m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,Phi(m/gcd(a,m)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;A-Display-The-Number&quot;&gt;&lt;a href=&quot;#A-Display-The-Number&quot; class=&quot;headerlink&quot; title=&quot;A. Display The Number&quot;&gt;&lt;/a&gt;A. Display The Number&lt;/h4
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="构造" scheme="http://valenshi.top/tags/%E6%9E%84%E9%80%A0/"/>
    
      <category term="字符串" scheme="http://valenshi.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>强连通分量题集</title>
    <link href="http://valenshi.top/2020/02/16/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E9%A2%98%E9%9B%86/"/>
    <id>http://valenshi.top/2020/02/16/强连通分量题集/</id>
    <published>2020-02-16T03:21:36.000Z</published>
    <updated>2020-02-16T03:22:10.709Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/statusx.php?runidx=3239944" target="_blank" rel="noopener">一本通OJ</a><br><a href="http://www.mfstem.org/contest/17/problems" target="_blank" rel="noopener">灵动OJ</a></p><h4 id="A-受欢迎的牛-popular"><a href="#A-受欢迎的牛-popular" class="headerlink" title="A.受欢迎的牛(popular)"></a>A.受欢迎的牛(popular)</h4><p><strong>题意描述</strong><br>原题来自：USACO 2003 Fall</p><p>每一头牛的愿望就是变成一头最受欢迎的牛。现在有 N 头牛，给你 M 对整数 (A,B)，表示牛 A 认为牛 B 受欢迎。这种关系是具有传递性的，如果 A 认为 B 受欢迎，B 认为 C 受欢迎，那么牛 A 也认为牛 C 受欢迎。你的任务是求出有多少头牛被除自己之外的所有牛认为是受欢迎的。</p><p><strong>解题思路</strong><br>一头牛是受欢迎的，当且仅当其它所有牛都是它的粉丝。那么我们在这样一个有向图中，首先把强连通分量缩点，变成 DAG ，在新的图上，出度为 0 的点才有可能是受欢迎的。如果这样的点仅有一个，那么该点所代表的牛就都是受欢迎的，如果有不止一个，那么就不存在受欢迎的牛。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span>*N;</span><br><span class="line"><span class="comment">//建立有向图的同时建立它的反图</span></span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],edge[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> rhead[N],rver[M],rnex[M],redge[M],rtot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">rver[++rtot] = x,rnex[rtot] = rhead[y]; rhead[y] = rtot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* co[x]:节点x所属强连通的id,col则是用于计数</span></span><br><span class="line"><span class="comment">ts[x]:结束时间为x的节点编号,clk用于计数 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,cnt[N],deg[N];</span><br><span class="line"><span class="keyword">int</span> co[N],col,ts[N],clk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">co[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])</span><br><span class="line"><span class="keyword">if</span>(!co[ver[i]]) dfs(ver[i]);</span><br><span class="line">ts[++clk] = x;<span class="comment">//第 clk 个结束的是x</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rdfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">co[x] = col; ++cnt[col];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = rhead[x]; i ;i = rnex[i])</span><br><span class="line"><span class="keyword">if</span>(!co[rver[i]]) rdfs(rver[i],col);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Korasaju</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!co[i]) dfs(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) co[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i ;--i) </span><br><span class="line"><span class="keyword">if</span>(!co[ts[i]]) rdfs(ts[i],++col);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">Korasaju();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>;x &lt;= n;x++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])</span><br><span class="line"><span class="keyword">if</span>(co[x] != co[ver[i]]) deg[co[x]]++;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++)</span><br><span class="line"><span class="keyword">if</span>(!deg[i] &amp;&amp; ans)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"0"</span>); <span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!deg[i]) ans = cnt[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="B-最大半连通子图-semi"><a href="#B-最大半连通子图-semi" class="headerlink" title="B.最大半连通子图(semi)"></a>B.最大半连通子图(semi)</h4><p><strong>题意描述</strong><br>一个有向图 G=( V , E ) 称为半连通的 (Semi-Connected)，如果满足对于图中任意两点 u，v , 存在一条 u 到 v 的有向路径或者从 v 到 u 的有向路径。</p><p>若 G’=(V’,E’) 满足 V’属于 V， E’ 是 E 中所有跟 V’ 有关的边，则称 G’ 是 G 的一个导出子图。若 G’ 是 G 的导出子图，且 G’ 半连通，则称 G’ 为 G 的半连通子图。若 G’ 是 G 所有半连通子图中包含节点数最多的，则称 G’ 是 G 的最大半连通子图。</p><p>给定一个有向图 G，请求出 G 的最大半连通子图拥有的节点数 K，以及不同的最大半连通子图的数目 C。由于C可能比较大，仅要求输出 C 对 X 的余数。<br><strong>解题思路</strong><br>这道题首先要理解清楚半连通、半连通子图的概念，然后才能进行求解。这道题有两问，第一问求最大的半连通子图（节点数最多的），第二问求有多少种不同的最大半连通子图。</p><p>对于第一问可以通过先将原图缩点，变成一张 DAG，然后再用拓扑排序来寻找‘最长链’，这个最长链就是最大半连通子图，而在 topo 过程中我们还可以设置一个数组 f[i] 表示到节点 i 达到局部最长链的方案数。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> co[N],col,dfn[N],clk,low[N];</span><br><span class="line"><span class="keyword">int</span> n,m,X;</span><br><span class="line"><span class="keyword">int</span> Stack[N],top,cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;<span class="comment">//dfs序</span></span><br><span class="line">Stack[++top] = x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y]) Tarjan(y), low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!co[y]) low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[x] == low[x])</span><br><span class="line"><span class="keyword">for</span>(++col;Stack[top+<span class="number">1</span>] != x;top--)</span><br><span class="line">co[Stack[top]] = col,cnt[col]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[N]; <span class="comment">//到 x 距离最长时不同的方案数</span></span><br><span class="line"><span class="keyword">int</span> deg[N],dis[N]; </span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++) <span class="keyword">if</span>(!deg[i]) que.push(i),dis[i] = cnt[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++) f[i] = <span class="number">1</span>;<span class="comment">//这儿置1,但是下面要置0</span></span><br><span class="line"><span class="keyword">while</span>(que.size())&#123;</span><br><span class="line"><span class="keyword">int</span> x = que.front(); que.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i]; deg[y]--;</span><br><span class="line"><span class="keyword">if</span>(!deg[y]) que.push(y);</span><br><span class="line"><span class="keyword">if</span>(dis[y] &lt; dis[x] + cnt[y])</span><br><span class="line">dis[y] = dis[x]+cnt[y], f[y] = <span class="number">0</span>;<span class="comment">//要把 f[y] 置零</span></span><br><span class="line"><span class="keyword">if</span>(dis[y] == dis[x] + cnt[y])<span class="comment">//任何情况下都要从 x 上转移过来</span></span><br><span class="line">f[y] = (f[y]+f[x])%X;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pa[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line"><span class="comment">//建立新图</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>,tc = <span class="number">0</span>;x &lt;= n;x++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])</span><br><span class="line">pa[++tc].first = co[x],pa[tc].second = co[ver[i]];</span><br><span class="line">sort(pa+<span class="number">1</span>,pa+<span class="number">1</span>+m);</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head); tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x = pa[i].first, y = pa[i].second;</span><br><span class="line"><span class="keyword">int</span> xx = pa[i<span class="number">-1</span>].first, yy = pa[i<span class="number">-1</span>].second;</span><br><span class="line"><span class="keyword">if</span>(x != y &amp;&amp; (x != xx || y != yy))</span><br><span class="line">addEdge(x,y),deg[y]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建图后利用拓扑排序查找最长链以及不同个数</span></span><br><span class="line">topo();  <span class="keyword">int</span> mx = <span class="number">0</span>,ty = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++) mx = max(mx,dis[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++) <span class="keyword">if</span>(dis[i] == mx) ty = (ty+f[i])%X;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>,mx,ty);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;X);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y); addEdge(x,y);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="C-网络协议-net"><a href="#C-网络协议-net" class="headerlink" title="C.网络协议(net)"></a>C.网络协议(net)</h4><p><strong>题意描述</strong></p><p>出自 IOI 1996一些学校连接在一个计算机网络上。学校之间存在软件支援协议。每个学校都有它应支援的学校名单（学校 a 支援学校 b，并不表示学校 b 一定支援学校 a）。当某校获得一个新软件时，无论是直接得到还是网络得到，该校都应立即将这个软件通过网络传送给它应支援的学校。因此，一个新软件若想让所有连接在网络上的学校都能使用，只需将其提供给一些学校即可。</p><p><strong>任务a：</strong> 请编一个程序，根据学校间支援协议（各个学校的支援名单），计算最少需要将一个新软件直接提供给多少个学校，才能使软件通过网络被传送到所有学校；</p><p><strong>任务b：</strong> 如果允许在原有支援协议上添加新的支援关系。则总可以形成一个新的协议，使得此时只需将一个新软件提供给任何一个学校，其他所有学校就都可以通过网络获得该软件。编程计算最少需要添加几条新的支援关系。</p><p><strong>解题思路</strong><br>首先可以知道在一个强连通分量中，任意一个学校拥有资源，那么其它所有学校就都会拥有资源，所以我们可以通过先缩点，将原图变为 DAG 。在此之后可以通过计算入度为 0 的点的数目，这就是我们需要提供的学校数量。<br>第二问可以通过统计出度为 0 的点的数目，因此来统计至少需要添加多少条边才能使得 DAG 变为强连通图，当然要特判 DAG 仅有一个点的情况，此时无需添加额外的边。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> G[N][N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],co[N],col,clk;</span><br><span class="line"><span class="keyword">int</span> Stack[N],top;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line">Stack[++top] = x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!G[x][i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(!dfn[i]) Tarjan(i),low[x] = min(low[x],low[i]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!co[i]) low[x] = min(low[x],dfn[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[x] == dfn[x])</span><br><span class="line"><span class="keyword">for</span>(++col;Stack[top+<span class="number">1</span>] != x;--top)</span><br><span class="line">co[Stack[top]] = col;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> deg[N],deg2[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line"><span class="keyword">if</span>(G[i][j] &amp;&amp; co[i] != co[j]) deg[co[j]]++,deg2[co[i]]++;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>,res2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++) <span class="keyword">if</span>(!deg[i]) res++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++) <span class="keyword">if</span>(!deg2[i]) res2++;</span><br><span class="line">res2 = max(res,res2);</span><br><span class="line"><span class="keyword">if</span>(col == <span class="number">1</span>) res2 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,y;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; y;</span><br><span class="line"><span class="keyword">while</span>(y)</span><br><span class="line">G[i][y] = <span class="number">1</span>, <span class="built_in">cin</span> &gt;&gt; y;</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="D-消息的传递-message"><a href="#D-消息的传递-message" class="headerlink" title="D.消息的传递(message)"></a>D.消息的传递(message)</h4><p><strong>题意描述</strong><br>我们的郭嘉大大在曹操这过得逍遥自在，但是有一天曹操给了他一个任务，在建邺城内有N（&lt;=1000）个袁绍的奸细 将他们从 1 到 N 进行编号，同时他们之间存在一种传递关系，即若C[i, j] = 1，则奸细 i 能将消息直接传递给奸细 j。<br>现在，曹操要发布一个假消息，需要传达给所有奸细，而我们的郭嘉大大则需要传递给尽量少的奸细使所有的奸细都知道这一个消息，问我们至少要传给几个奸细？</p><p><strong>解题思路</strong><br>和上一题有些类似，只需要缩点后统计入度为 0 的点的数量即可。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1100</span>;</span><br><span class="line"><span class="keyword">int</span> G[N][N],dfn[N],low[N],clk,co[N],col;</span><br><span class="line"><span class="keyword">int</span> n,Stack[N],top;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line">Stack[++top] = x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!G[x][i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(!dfn[i]) Tarjan(i),low[x] = min(low[x],low[i]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!co[i]) low[x] = min(low[x],dfn[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[x] == dfn[x])</span><br><span class="line"><span class="keyword">for</span>(++col;Stack[top+<span class="number">1</span>] != x;top--)</span><br><span class="line">co[Stack[top]] = col;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> deg[N],ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;G[i][j]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line"><span class="keyword">if</span>(G[i][j] &amp;&amp; co[i] != co[j]) deg[co[j]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++) <span class="keyword">if</span>(!deg[i]) ans++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="E-间谍网络-spy"><a href="#E-间谍网络-spy" class="headerlink" title="E.间谍网络(spy)"></a>E.间谍网络(spy)</h4><p><strong>题意描述</strong><br>由于外国间谍的大量渗入，国家安全正处于高度的危机之中。如果A间谍手中掌握着关于B间谍的犯罪证据，则称A可以揭发B。有些间谍收受贿赂，只要给他们一定数量的美元，他们就愿意交出手中掌握的全部情报。所以，如果我们能够收买一些间谍的话，我们就可能控制间谍网中的每一分子。因为一旦我们逮捕了一个间谍，他手中掌握的情报都将归我们所有，这样就有可能逮捕新的间谍，掌握新的情报。</p><p>我们的反间谍机关提供了一份资料，包括所有已知的受贿的间谍，以及他们愿意收受的具体数额。同时我们还知道哪些间谍手中具体掌握了哪些间谍的资料。假设总共有n个间谍(n不超过3000)，每个间谍分别用1到3000的整数来标识。</p><p>请根据这份资料，判断我们是否有可能控制全部的间谍，如果可以，求出我们所需要支付的最少资金。否则，输出不能被控制的一个间谍。</p><p><strong>解题思路</strong><br>首先将原图强连通分量缩点，变为 DAG ，新点的权值为原图中强连通分量所有点权值的最小值；然后累加新图中入度为 0 的点的权值，如果有一个点入度为 0 且不受贿，那么就无解。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dfn[N],clk,co[N],col,low[N];</span><br><span class="line"><span class="keyword">int</span> Stack[N],top;</span><br><span class="line"><span class="keyword">int</span> w[N],n,m,p;</span><br><span class="line"><span class="keyword">int</span> spy[N],ct[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line">Stack[++top] = x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y]) Tarjan(y), low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!co[y]) low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[x] == low[x])</span><br><span class="line"><span class="keyword">for</span>(++col;Stack[top+<span class="number">1</span>] != x;top--)&#123;</span><br><span class="line">co[Stack[top]] = col;</span><br><span class="line"><span class="keyword">if</span>(w[Stack[top]] != INF) ct[col] = min(ct[col],w[Stack[top]]);</span><br><span class="line"><span class="keyword">else</span> spy[col] = min(spy[col],Stack[top]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> deg[N],ans,ans2 = INF;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>;x &lt;= n;x++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])</span><br><span class="line"><span class="keyword">if</span>(co[x] != co[ver[i]]) deg[co[ver[i]]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++)</span><br><span class="line"><span class="keyword">if</span>(!deg[i] &amp;&amp; ct[i] == INF)&#123;</span><br><span class="line">ans2 = min(ans2,spy[i]);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!deg[i]) ans += ct[i];</span><br><span class="line"><span class="keyword">if</span>(ans2 != INF) <span class="built_in">printf</span>(<span class="string">"NO\n%d\n"</span>,ans2);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"YES\n%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; N;i++) ct[i] = w[i] = spy[i] = INF;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n); <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= p;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y),w[x] = y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y),addEdge(x,y);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="F-抢掠计划-grab"><a href="#F-抢掠计划-grab" class="headerlink" title="F.抢掠计划(grab)"></a>F.抢掠计划(grab)</h4><p><strong>题意描述</strong></p><p>Siruseri 城中的道路都是单向的。不同的道路由路口连接。按照法律的规定， 在每个路口都设立了一个 Siruseri 银行的 ATM 取款机。<br>令人奇怪的是，Siruseri 的酒吧也都设在路口，虽然并不是每个路口都设有酒吧。<br>Banditji 计划实施 Siruseri 有史以来最惊天动地的 ATM 抢劫。他将从市中心出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆祝他的胜利。使用高超的黑客技术，他获知了每个 ATM 机中可以掠取的现金数额。<br>他希望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可以经过同一路口或道路任意多次。但只要他抢劫过某个ATM 机后，该ATM 机里面就不会再有钱了。</p><p><strong>解题思路</strong><br>对于一个强连通分量，我们只要经过它就可以将其中所有的钱都给取走，所以我们可以对强连通分量缩点，缩点后得到 DAG 。<br>对新图进行 SFPA 求从起点出发的单源最长路，然后再挑终点是酒吧的最长路即可。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,s,p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mon[N],w[N];</span><br><span class="line"><span class="keyword">bool</span> isBar[N],stop[N];</span><br><span class="line"><span class="keyword">int</span> dfn[N],clk,low[N],co[N],col;</span><br><span class="line"><span class="keyword">int</span> Stack[N],top;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line">Stack[++top] = x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y]) Tarjan(y),low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!co[y]) low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[x] == low[x])</span><br><span class="line"><span class="keyword">for</span>(++col;Stack[top+<span class="number">1</span>] != x;top--)&#123;</span><br><span class="line">co[Stack[top]] = col, w[col] += mon[Stack[top]];</span><br><span class="line">stop[col] |= isBar[Stack[top]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; edges[N];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N],vis[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">q.push(s); dis[s] = w[s];</span><br><span class="line"><span class="keyword">while</span>(q.size())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">vis[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(dis[y] &lt; dis[x] + w[y])&#123;</span><br><span class="line">dis[y] = dis[x] + w[y];</span><br><span class="line"><span class="keyword">if</span>(!vis[y]) q.push(y), vis[y] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>;x &lt;= n;x++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])</span><br><span class="line">edges[++cnt].first = co[x],edges[cnt].second = co[ver[i]];</span><br><span class="line">sort(edges+<span class="number">1</span>,edges+<span class="number">1</span>+cnt);</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head); tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x = edges[i].first, y = edges[i].second;</span><br><span class="line"><span class="keyword">int</span> xx = edges[i<span class="number">-1</span>].first, yy = edges[i<span class="number">-1</span>].second;</span><br><span class="line"><span class="keyword">if</span>(x != y &amp;&amp; (x != xx || y != yy)) addEdge(x,y);</span><br><span class="line">&#125;</span><br><span class="line">SPFA(co[s]);</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++) <span class="keyword">if</span>(stop[i]) ans = max(ans,dis[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y); addEdge(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,mon+i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;p);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= p;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x),isBar[x] = <span class="literal">true</span>;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="G-和平委员会-peace"><a href="#G-和平委员会-peace" class="headerlink" title="G.和平委员会(peace)"></a>G.和平委员会(peace)</h4><p><strong>题意描述</strong><br>原题来自：POI 2001</p><p>根据宪法，Byteland 民主共和国的公众和平委员会应该在国会中通过立法程序来创立。 不幸的是，由于某些党派代表之间的不和睦而使得这件事存在障碍。此委员会必须满足下列条件：</p><ul><li>每个党派都在委员会中恰有1个代表，如果2个代表彼此厌恶，则他们不能都属于委员会。</li><li>每个党在议会中有2个代表。代表从1编号到2n。 编号为 2i-1和 2i的代表属于第 i个党派。</li></ul><p>任务：写一程序读入党派的数量和关系不友好的代表对，计算决定建立和平委员会是否可能，若行，则列出委员会的成员表。</p><p><strong>解题思路</strong><br>这道题属于 2-SAT 问题，按照 2-SAT 问题的一般策略，对于两对党派(a, b) 、(x , y)，若 a 与 x 有矛盾，那么可以确定的是若 a 出席，则必定 y 出席，若 x 出席，则必定 b 出席。这对应着原命题与逆否命题，而其它命题虽然可能成立但并不能用“必须”修饰。<br>因此我们再利用 Tarjan 求强连通分量，即可解决2-SAT问题。</p><p>需要注意的是，边是有向的，也就是说添加的方向很重要，不可以随意添加。同时不能添加反向边，因为逆命题不一定成立。</p><p>由于 Tarjan 算法中不同连通块的颜色是按照拓扑排序来赋值的，也就是说颜色值越大的点越靠前（在拓扑排序中）；那么在本题中自然是优先选择同一个强连通分量的点，因此我们可以考虑优先输出颜色值大的点，这样我们就会按照拓扑排序的顺序挑选节点。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2</span>*<span class="number">8100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dfn[N],clk,co[N],col,low[N];</span><br><span class="line"><span class="keyword">int</span> Stack[N],top;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line">Stack[++top] = x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y]) Tarjan(y),low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!co[y]) low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[x] == low[x])</span><br><span class="line"><span class="keyword">for</span>(++col;Stack[top+<span class="number">1</span>] != x;top--)</span><br><span class="line">co[Stack[top]] = col;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i += <span class="number">2</span>) </span><br><span class="line"><span class="keyword">if</span>(co[i] == co[i+<span class="number">1</span>])&#123;<span class="built_in">puts</span>(<span class="string">"NIE"</span>); <span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i += <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span>(co[i] &lt; co[i+<span class="number">1</span>]) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i+<span class="number">1</span>);<span class="comment">//star</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m), n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">int</span> u = x%<span class="number">2</span> == <span class="number">0</span>?x<span class="number">-1</span>:x+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> v = y%<span class="number">2</span> == <span class="number">0</span>?y<span class="number">-1</span>:y+<span class="number">1</span>;</span><br><span class="line">addEdge(u,y); addEdge(v,x); <span class="comment">//star</span></span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://ybt.ssoier.cn:8088/statusx.php?runidx=3239944&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一本通OJ&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.mfstem.org
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="强连通分量" scheme="http://valenshi.top/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>树形动态规划题集</title>
    <link href="http://valenshi.top/2020/02/16/%E6%A0%91%E5%BD%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E9%9B%86/"/>
    <id>http://valenshi.top/2020/02/16/树形动态规划题集/</id>
    <published>2020-02-16T03:21:06.000Z</published>
    <updated>2020-02-16T03:22:51.005Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1579" target="_blank" rel="noopener">测试地址</a><br>部分题面可能复制有问题，图片没有复制，有疑惑见原题面。</p><h4 id="1575：【例-1】二叉苹果树"><a href="#1575：【例-1】二叉苹果树" class="headerlink" title="1575：【例 1】二叉苹果树"></a>1575：【例 1】二叉苹果树</h4><p><strong>问题描述</strong><br>有一棵二叉苹果树，如果数字有分叉，一定是分两叉，即没有只有一个儿子的节点。这棵树共 N 个节点，标号 1 至 N，树根编号一定为 1。</p><p>我们用一根树枝两端连接的节点编号描述一根树枝的位置。一棵有四根树枝的苹果树，因为树枝太多了，需要剪枝。但是一些树枝上长有苹果，给定需要保留的树枝数量，求最多能留住多少苹果。</p><p><strong>解题思路</strong><br>相当于从一棵二叉树上去掉一些子树，使得剩下 m 条边，目标是使得这 m 条边的总权值最大。剩 m 条边就相当于剩 m + 1 个点，我们转换成点来做。<br>设 f[i ,j] 表示节点 i 还剩 j 个点时最大总权值，目标状态是 f[1 , m+1] 。我们可以利用记忆化搜索，令 f[ i , j ] = MIN{ f[ ls , k] + f[rs , j - k -1] + w[ i ] }。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">440</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[M],nex[M],ver[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,f[N][N];</span><br><span class="line"><span class="keyword">int</span> ls[N],rs[N],w[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(ls[x]) rs[x] = y;</span><br><span class="line"><span class="keyword">else</span> ls[x] = y;</span><br><span class="line">w[y] = z;<span class="comment">//y 到其父亲的边权</span></span><br><span class="line">dfs(y,x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!ls[i] &amp;&amp; !rs[i]) <span class="keyword">return</span> w[i];</span><br><span class="line"><span class="keyword">if</span>(f[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> f[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= j<span class="number">-1</span>;k++)</span><br><span class="line">f[i][j] = max(f[i][j],DP(ls[i],k) + DP(rs[i],j-k<span class="number">-1</span>) + w[i]);</span><br><span class="line"><span class="keyword">return</span> f[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addEdge(x,y,z); addEdge(y,x,z);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,DP(<span class="number">1</span>,m+<span class="number">1</span>)); <span class="comment">//1号子树保留m+1个节点时最大值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1576：【例-2】选课"><a href="#1576：【例-2】选课" class="headerlink" title="1576：【例 2】选课 *"></a>1576：【例 2】选课 *</h4><p><strong>问题描述</strong><br>原题来自：CTSC 1997</p><p>大学实行学分制。每门课程都有一定的学分，学生只要选修了这门课并通过考核就能获得相应学分。学生最后的学分是他选修各门课的学分总和。</p><p>每个学生都要选择规定数量的课程。有些课程可以直接选修，有些课程需要一定的基础知识，必须在选了其他的一些课程基础上才能选修。例如《数据结构》必须在选修了《高级语言程序设计》后才能选修。我们称《高级语言程序设计》是《数据结构》的先修课。每门课的直接先修课最多只有一门。两门课也可能存在相同的先修课。为便于表述，每门课都有一个课号，课号依次为 1,2,3,⋯。</p><p>学生不可能学完大学开设的所有课程，因此必须在入学时选定自己要学的课程。每个学生可选课程的总数是给定的。请找出一种选课方案使得你能得到的学分最多，并满足先修课优先的原则。假定课程间不存在时间上的冲突。</p><p><strong>解题思路</strong><br>这题本质上是有树形依赖的分组背包问题。<br>首先用 0 号虚拟节点将森林合并为一棵树，注意 0 号节点不算一门课，没有学分也不消耗选课机会。<br>设 f[x , j] = 在以 x 为根的子树中选 j 门课能得到的最大学分。<br>那么显然 f[x , j] 就可以表示为“在以 x 为根的子树上选 j 门，在子树 y 上选 k 门”的最大值。即 f[x , j] = MAX{ f[x , j - k] + f[y , k]  }，因为用 x 的儿子对 f[x, j] 的更新无所谓先后顺序，所以上式可以成立。</p><p>除了 0 号节点以外， x 是必选的，所以回溯前要加上该门课的学分并消耗一次选课机会。<br><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">dfs(y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t = m;t &gt;= <span class="number">0</span>;t--)<span class="comment">//在子树 x 上选 t 门</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = t;j &gt;= <span class="number">0</span>;j--)<span class="comment">//在子树 y 选 j 门</span></span><br><span class="line">f[x][t] = max(f[x][t],f[x][t-j] + f[y][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x) <span class="keyword">for</span>(<span class="keyword">int</span> t = m;t &gt; <span class="number">0</span>;t--)<span class="comment">//如果不是 0 号节点,那么根节点是必选的</span></span><br><span class="line">f[x][t] = f[x][t<span class="number">-1</span>] + w[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f[<span class="number">0</span>][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,z;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;z); </span><br><span class="line">addEdge(x,i,z); w[i] = z;</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1577：【例-3】数字转换"><a href="#1577：【例-3】数字转换" class="headerlink" title="1577：【例 3】数字转换"></a>1577：【例 3】数字转换</h4><p><strong>问题描述</strong><br>如果一个数 x 的约数和 y （不包括他本身）比他本身小，那么 x 可以变成 y，y 也可以变成 x。例如 4 可以变为 3，1 可以变为 7。限定所有数字变换在不超过 n 的正整数范围内进行，求不断进行数字变换且不出现重复数字的最多变换步数。</p><p><strong>解题思路</strong><br>“约数和 y” 是指 x 的所有约数的累加的值是y。<br>从 1~n 挨个求出它们的约数和 y，然后由 y 向它们连线，最终构成一棵树。接下来就是求树上最长链问题，可以用两次 bfs 或者 dp 。</p><p><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getF</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>, i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">2</span>;i*i &lt; x;i++) <span class="keyword">if</span>(x%i == <span class="number">0</span>) res += i+x/i;</span><br><span class="line"><span class="keyword">if</span>(i*i == x) res += i;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,a[N];</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span> || y == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> leaf,mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(step &gt; mx) leaf = x,mx = step;</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">bfs(y,step+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x = getF(i);</span><br><span class="line"><span class="keyword">if</span>(x &gt; i) <span class="keyword">continue</span>;</span><br><span class="line">addEdge(x,i); addEdge(i,x);</span><br><span class="line">&#125;</span><br><span class="line">bfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">bfs(leaf,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1578：【例-4】战略游戏"><a href="#1578：【例-4】战略游戏" class="headerlink" title="1578：【例 4】战略游戏"></a>1578：【例 4】战略游戏</h4><p><strong>问题描述</strong><br>Bob 喜欢玩电脑游戏，特别是战略游戏。但是他经常无法找到快速玩过游戏的方法。现在他有个问题。</p><p>现在他有座古城堡，古城堡的路形成一棵树。他要在这棵树的节点上放置最少数目的士兵，使得这些士兵能够瞭望到所有的路。</p><p>注意：某个士兵在一个节点上时，与该节点相连的所有边都将能被瞭望到。</p><p>请你编一个程序，给定一棵树，帮 Bob 计算出他最少要放置的士兵数。</p><p><strong>解题思路</strong><br>这种题是“树的最大独立集”问题，也就是要求树上每一条边都至少有一个端点在集合内。这一类最值问题向来都是用动态规划解决的。<br>任何一个点的取舍都可以看作一个决策，而每个顶点为阶段，顶点取或不取为状态。设f[x , 0] = 第 x 个点不取时，以 x 为根的子树需要的最少士兵数目；f[ x,  1]表示取 x 点时，以 x 为根的子树需要的最少士兵数目。<br>如果 x 不取，那么它的所有子节点都一定要取；如果取 x，那么其字节点可取可不取。<br>所以状态转移方程为 $f[x , 0] = \sum f[y ,1]$，$f[x , 1] = \sum MIN(f[y , 0] , f[y ,1] ) + 1$</p><p><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,f[N][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>; f[x][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];~i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i]; </span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">dfs(y); </span><br><span class="line">f[x][<span class="number">0</span>] += f[y][<span class="number">1</span>];</span><br><span class="line">f[x][<span class="number">1</span>] += min(f[y][<span class="number">0</span>],f[y][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,k;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= k;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;y); </span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,min(f[<span class="number">1</span>][<span class="number">0</span>],f[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1579：-【例-5】皇宫看守"><a href="#1579：-【例-5】皇宫看守" class="headerlink" title="1579： 【例 5】皇宫看守 *"></a>1579： 【例 5】皇宫看守 *</h4><p><strong>问题描述</strong><br>太平王世子事件后，陆小凤成了皇上特聘的御前一品侍卫。</p><p>皇宫以午门为起点，直到后宫嫔妃们的寝宫，呈一棵树的形状，某些宫殿间可以互相望见。大内保卫森严，三步一岗，五步一哨，每个宫殿都要有人全天候看守，在不同的宫殿安排看守所需的费用不同。</p><p>可是陆小凤手上的经费不足，无论如何也没法在每个宫殿都安置留守侍卫。</p><p>帮助陆小凤布置侍卫，在看守全部宫殿的前提下，使得花费的经费最少。</p><p><strong>解题思路</strong><br>这题和上一题不同，上一次是每条边必须有一个端点被选，而这题是要求每个点的所有边中至少有一个边被选。换成点来说，就是与其相连的所有点（或其本身）中至少有一个被选。<br>那么我们就不能再“要么选 x ，要么选 x 的所有儿子”了；对于当前位置 x，我们可以分别从：</p><ul><li>x 的父亲被选了</li><li>x 的儿子有一个被选了</li><li>x 自己被选了</li></ul><p>三种情况来计算。我们设 f[x ,0|1|2 ]分别对应上述三种情况。对于当前节点 x ，我们既要考虑它的父亲，还要考虑它的儿子们，所以我们转移的时候既要加上它爹也要计算它儿子和孙子。具体状态设计和方程见代码吧，其中 d 是用来挑选一个费用最小的儿子。</p><p><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,w[N];</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>; f[x][<span class="number">2</span>] = w[x];</span><br><span class="line"><span class="keyword">int</span> d = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = w[x];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">dfs(y);</span><br><span class="line">f[x][<span class="number">0</span>] += min(f[y][<span class="number">1</span>],f[y][<span class="number">2</span>]);</span><br><span class="line">f[x][<span class="number">1</span>] += min(f[y][<span class="number">1</span>],f[y][<span class="number">2</span>]); </span><br><span class="line">f[x][<span class="number">2</span>] += min(f[y][<span class="number">0</span>],min(f[y][<span class="number">1</span>],f[y][<span class="number">2</span>]));</span><br><span class="line">d = min(d,f[y][<span class="number">2</span>] - min(f[y][<span class="number">1</span>],f[y][<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br><span class="line">f[x][<span class="number">1</span>] += d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,k,y;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x); <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;w[x],&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= k;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,min(f[<span class="number">1</span>][<span class="number">1</span>],f[<span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1580：加分二叉树"><a href="#1580：加分二叉树" class="headerlink" title="1580：加分二叉树"></a>1580：加分二叉树</h4><p><strong>题意描述</strong><br>原题来自：NOIP 2003</p><p>设一个 n 个节点的二叉树 tree 的中序遍历为 (1,2,3,⋯,n)，其中数字 1,2,3,⋯,n 为节点编号。每个节点都有一个分数（均为正整数），记第 i 个节点的分数为 di ，tree 及它的每个子树都有一个加分，任一棵子树 subtree（也包含 tree 本身）的加分计算方法如下：</p><p>记 subtree 的左子树加分为 l，右子树加分为 r，subtree 的根的分数为 a，则 subtree 的加分为：l×r+a</p><p>若某个子树为空，规定其加分为 1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。</p><p>试求一棵符合中序遍历为 (1,2,3,⋯,n) 且加分最高的二叉树 tree。</p><p>要求输出：</p><p>1、tree 的最高加分；</p><p>2、tree 的前序遍历。</p><p><strong>解题思路</strong><br>假设 f[i , j] 为中序遍历中 i 到 j 节点构成的子树最大得分是多少。那么显然就可以用类似区间 DP 的方法来解决，让跨度从小到大，起点也是从小到大，然后枚举中间节点即可。</p><p>但是输出前序遍历却不能直接用简洁的递归输出，而是需要加一行特判来处理边界情况。</p><p><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n,path[N][N];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll f[N][N],a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i == j || i+<span class="number">1</span> == j)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line"><span class="keyword">if</span>(i != j) <span class="built_in">printf</span>(<span class="string">"%d "</span>,j);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,path[i][j]);</span><br><span class="line">print(i,path[i][j]<span class="number">-1</span>); print(path[i][j]+<span class="number">1</span>,j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) f[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) path[i][i] = i,f[i][i] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>;l &lt;= n;l++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n-l;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = i+l;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i;k &lt;= j;k++)</span><br><span class="line"><span class="keyword">if</span>(f[i][j] &lt; f[i][k<span class="number">-1</span>]*f[k+<span class="number">1</span>][j] + a[k])&#123;</span><br><span class="line">f[i][j] = f[i][k<span class="number">-1</span>]*f[k+<span class="number">1</span>][j] + a[k];</span><br><span class="line">path[i][j] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[<span class="number">1</span>][n]);</span><br><span class="line">print(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1581：旅游规划"><a href="#1581：旅游规划" class="headerlink" title="1581：旅游规划"></a>1581：旅游规划</h4><p><strong>题意描述</strong><br>W 市的交通规划出现了重大问题，市政府下定决心在全市各大交通路口安排疏导员来疏导密集的车流。但由于人员不足，W 市市长决定只在最需要安排人员的路口安排人员。</p><p>具体来说，W 市的交通网络十分简单，由 n 个交叉路口和 n−1 条街道构成，交叉路口路口编号依次为 0,1,⋯,n−1 。任意一条街道连接两个交叉路口，且任意两个交叉路口间都存在一条路径互相连接。</p><p>经过长期调查，结果显示，如果一个交叉路口位于 W 市交通网最长路径上，那么这个路口必定拥挤不堪。所谓最长路径，定义为某条路径 p=(v1,v2,v3,⋯,vk)，路径经过的路口各不相同，且城市中不存在长度大于 k 的路径，因此最长路径可能不唯一。因此 Ｗ 市市长想知道哪些路口位于城市交通网的最长路径上。</p><p><strong>解题思路</strong><br>这道题就是求最长链上的节点，而最长链可能不止一条，所以就成了找出所有最长链上的所有节点，并按照升序输出。<br>我们知道两次 bfs 可以找到最长链的长度以及起点和终点，但是两次 bfs 却无法找到所有的最长链起点和终点。<br>我们可以通过 3 次 bfs 来找到所有的最长链以及其终点。首先通过第一遍 bfs 找到某一个叶子节点，然后第二次 bfs 找到所有以该叶子为起点的最长链，第三次 bfs 以其上次找到的某一条最长链的终点为起点，找到剩余的所有最长链。</p><p>由于树形结构上每一个节点都只有一个父亲，所以用 par 数组存放节点的父亲，这样就可以从终点找到该链上的所有节点。</p><p><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,par[N],leaf,mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(mx &lt; step)&#123;</span><br><span class="line">mx = step,leaf = x;</span><br><span class="line"><span class="keyword">while</span>(q.size()) q.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mx == step) q.push(x);</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">par[y] = x;</span><br><span class="line">bfs(y,step+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans[M], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">bfs(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//求最远叶子</span></span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">bfs(leaf,<span class="number">0</span>);<span class="comment">//从leaf出发的所有最远叶子</span></span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="built_in">memset</span>(par,<span class="number">0</span>,<span class="keyword">sizeof</span> par);</span><br><span class="line">bfs(leaf,<span class="number">0</span>);<span class="comment">//再求一边最远叶子,防止对称遗漏</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(q.size())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">ans[++cnt] = x;</span><br><span class="line"><span class="keyword">while</span>(par[x]) x = ans[++cnt] = par[x];</span><br><span class="line">&#125;</span><br><span class="line">sort(ans+<span class="number">1</span>,ans+<span class="number">1</span>+cnt);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++)</span><br><span class="line"><span class="keyword">if</span>(ans[i] != ans[i<span class="number">-1</span>]) <span class="built_in">cout</span> &lt;&lt; ans[i]<span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y); x++,y++;</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1582：周年纪念晚会"><a href="#1582：周年纪念晚会" class="headerlink" title="1582：周年纪念晚会"></a>1582：周年纪念晚会</h4><p><strong>题意描述</strong><br>Ural 州立大学的校长正在筹备学校的 8080 周年纪念聚会。由于学校的职员有不同的职务级别，可以构成一棵以校长为根的人事关系树。每个资源都有一个唯一的整数编号，从 1 到 N 编号，且对应一个参加聚会所获得的欢乐度。为使每个职员都感到快乐，校长设法使每个职员和其直接上司不会同时参加聚会。</p><p>你的任务是设计一份参加聚会者的名单，使总欢乐度最高。<br><strong>解题思路</strong><br>这题就是“没有上司的舞会”那一题，解法就相当于求森林中每棵树的最大点独立集，我们设 f[x ,0] 表示 x 不去时最大快乐值，f[x , 1] 表示 x 去时最大快乐值。<br>显然 x 要是不去那么 y 去或不去都可以，x 如果去那么所有的 y 都不能去，所以状态转移方程就很好想了，详见代码。</p><p><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> hp[N], n, x, y;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">2</span>],vis[N], ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">dfs(y);</span><br><span class="line">f[x][<span class="number">1</span>] = max(f[x][<span class="number">1</span>],f[y][<span class="number">0</span>]);</span><br><span class="line">f[x][<span class="number">0</span>] += max(f[y][<span class="number">0</span>],f[y][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">f[x][<span class="number">1</span>] += hp[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,hp+i);</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y) &amp;&amp; (x || y))&#123;</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">dfs(i); ans += max(f[i][<span class="number">1</span>],f[i][<span class="number">0</span>]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1583：叶子的染色"><a href="#1583：叶子的染色" class="headerlink" title="1583：叶子的染色"></a>1583：叶子的染色</h4><p><strong>题意描述</strong><br>原题来自：CQOI 2009</p><p>给一棵有 m 个节点的无根树，你可以选择一个度数大于 1 的节点作为根，然后给一些节点（根、内部节点、叶子均可）着以黑色或白色。你的着色方案应保证根节点到各叶子节点的简单路径上都包含一个有色节点，哪怕是叶子本身。</p><p>对于每个叶子节点 u，定义 cu 为从根节点到 u 的简单路径上最后一个有色节点的颜色。给出每个 cu  的值，设计着色方案使得着色节点的个数尽量少。</p><p><strong>解题思路</strong><br>题意非常绕，理解起来要花时间，另外题面描述的还丢三落四。<br>大意就是说有一棵树，我们要求从树根到每一个叶子节点的路径上的最后一个节点的颜色是指定的，我们给出所有指定的颜色 c[leaf] ；显然如果一棵子树的所有叶子节点都指定黑色，那么只需要给根节点染一个黑色就可以了（当然也可以给每个叶子节点都染黑色，但是不是最优解），我们题意就是求类似这样的最优解。</p><p>那么我们可以设 f[x , 0] 表示 x 染黑色时的最优解，f[x , 1] 表示 x 染白色时，以 x 为根的子树最少需要染几次色。</p><p>如果 x 是叶子节点，且要求染黑色，那么显然以 x 为根的子树最少需要染一次色，f[ x , 0] = 1，f[x , 1] = INF。</p><p>如果 x 不是叶子节点，那么显然 f[x, 0] += max{ f[y , 0] - 1 , f[y , 1] }，代表的实际含义是“如果 x 染黑色，那么就从 y 染黑色或 y 染白色中选一个最优解转移，显然如果 y 是黑色那么就可以少染一次（画图看）”</p><p><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x];head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,co[N],f[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>; f[x][<span class="number">0</span>] = f[x][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x &lt;= m) f[x][co[x]] = <span class="number">1</span>,f[x][co[x]^<span class="number">1</span>] = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; "--&gt;" &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">dfs(y);</span><br><span class="line">f[x][<span class="number">0</span>] += min(f[y][<span class="number">0</span>]<span class="number">-1</span>,f[y][<span class="number">1</span>]);</span><br><span class="line">f[x][<span class="number">1</span>] += min(f[y][<span class="number">1</span>]<span class="number">-1</span>,f[y][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">memset</span>(co,<span class="number">-1</span>,<span class="keyword">sizeof</span> co);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,co+i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">dfs(m+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; min(f[m+<span class="number">1</span>][<span class="number">0</span>],f[m+<span class="number">1</span>][<span class="number">1</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1584：骑士"><a href="#1584：骑士" class="headerlink" title="1584：骑士 **"></a>1584：骑士 **</h4><p><strong>题意描述</strong><br>原题来自：ZJOI 2008</p><p>Z 国的骑士团是一个很有势力的组织，帮会中聚集了来自各地的精英。他们劫富济贫，惩恶扬善，受到了社会各界的赞扬。</p><p>可是，最近发生了一件很可怕的事情：邪恶的 Y 国发起了一场针对 Z 国的侵略战争。战火绵延五百里，在和平环境中安逸了数百年的 Z 国又怎能抵挡得住 Y 国的军队。于是人们把所有希望都寄托在了骑士团身上，就像期待有一个真龙天子的降生，带领正义打败邪恶。</p><p>骑士团是肯定具备打败邪恶势力的能力的，但是骑士们互相之间往往有一些矛盾。每个骑士有且仅有一个他自己最厌恶的骑士（当然不是他自己），他是绝对不会与最厌恶的人一同出征的。</p><p>战火绵延，人们生灵涂炭，组织起一个骑士军团加入战斗刻不容缓！国王交给你了一个艰巨的任务：从所有骑士中选出一个骑士军团，使得军内没有矛盾的两人，即不存在一个骑士与他最痛恨的人一同被选入骑士团的情况，并且使这支骑士军团最富有战斗力。</p><p>为描述战斗力，我们将骑士按照 1 至 N 编号，给每位骑士估计一个战斗力，一个军团的战斗力为所有骑士的战斗力之和。</p><p><strong>解题思路</strong><br>本来看起来和“没有上司的舞会”很类似，但是这题会有环，有环的情况下如果还用原来的解法就有可能出错，所以需要处理一下。</p><p>解决这类问题的方法一般有两种，一种是基环树 DP，另一种是两次树形 DP。这里采用的是俩次树形 DP，首先用一次 dfs 找到当前子树的环上的一条边 edge，然后对这两条边的顶点为根分别做一次 DP，最终答案为 max( f[x, 0] , f[ y, 0] )，如果当前子树没有环（有重边），则正常 DP 即可，最终累加答案并输出。<br>这题对时限要求有点紧，在 bzoj 是可以过的，但是在一本通上过不了，在本校的 oj 也过不了。</p><p><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[N],f[N][<span class="number">2</span>] , ans = <span class="number">0</span>,mx;</span><br><span class="line"><span class="keyword">int</span> n,vis[N],edge ;</span><br><span class="line"><span class="keyword">int</span> Stack[N],top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>; Stack[++top] = x;</span><br><span class="line">f[x][<span class="number">1</span>] = a[x]; f[x][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">DP(y);</span><br><span class="line">f[x][<span class="number">0</span>] += max(f[y][<span class="number">0</span>],f[y][<span class="number">1</span>]);</span><br><span class="line">f[x][<span class="number">1</span>] += f[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> inStack[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;<span class="comment">//找到环上一边</span></span><br><span class="line">inStack[x] = <span class="literal">true</span>;<span class="comment">//正在遍历</span></span><br><span class="line"><span class="keyword">if</span>(edge) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(inStack[y]) edge = i;</span><br><span class="line"><span class="keyword">else</span> dfs(y,x);</span><br><span class="line">&#125;</span><br><span class="line">inStack[x] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span> + c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &gt; <span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,y;i &lt;= n;i++)&#123;</span><br><span class="line">a[i] = getInt(); y = getInt();</span><br><span class="line">addEdge(i,y); addEdge(y,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">top = edge = <span class="number">0</span>; dfs(i,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(!edge)&#123;</span><br><span class="line">DP(i); ans += max(f[i][<span class="number">0</span>],f[i][<span class="number">1</span>]);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">DP(ver[edge]); mx = f[ver[edge]][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">while</span>(top) vis[Stack[top--]] = <span class="literal">false</span>;</span><br><span class="line">DP(ver[edge^<span class="number">1</span>]); mx = max(f[ver[edge^<span class="number">1</span>]][<span class="number">0</span>],mx);</span><br><span class="line">ans += mx;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">print(ans);<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://ybt.ssoier.cn:8088/problem_show.php?pid=1579&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测试地址&lt;/a&gt;&lt;br&gt;部分题面可能复制有问题，图片没有复制，有疑惑见原题面。&lt;/p&gt;

      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="http://valenshi.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>四边形不等式应用</title>
    <link href="http://valenshi.top/2020/02/16/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E5%BA%94%E7%94%A8/"/>
    <id>http://valenshi.top/2020/02/16/四边形不等式应用/</id>
    <published>2020-02-16T03:20:52.000Z</published>
    <updated>2020-02-16T03:23:32.337Z</updated>
    
    <content type="html"><![CDATA[<h4 id="动态规划加速原理之四边形不等式"><a href="#动态规划加速原理之四边形不等式" class="headerlink" title="动态规划加速原理之四边形不等式"></a>动态规划加速原理之四边形不等式</h4><p>动态规划的四边形不等式优化是对特定形式的状态转移方程进行优化的一种方法，该方法可以将复杂度由 $O(n^3)$ 优化到 $O(n^2)$。</p><p>设我们有状态转移方程</p><script type="math/tex; mode=display">m(i ,j) =\left\{\begin{array}{rcl}min \{  m(i , k - 1) + m(k , j) + w(i , j) \} & & {i< j}\\0 & & i = j\\INF & & i > j\end{array} \right.</script><p><strong>w 满足区间包含的单调性：</strong><br>如果对于 i &lt;= i’ &lt; j &lt;= j’ 都有 w(i’ , j ) &lt;= w(i ,j’) ，那么称函数 w 满足关于区间包含的单调性。</p><p><strong>w 满足四边形不等式：</strong><br>如果对于 i &lt;= i’ &lt; j &lt;= j’ 都有 w(i , j ) + w(i’ , j’) &lt;= w(i ‘ , j ) + w( i , j’ )，我们称 w 满足四边形不等式。</p><p><strong>m 满足四边形不等式：</strong><br>如果 w 满足区间包含的单调性，同时又满足四边形不等式，那么 m 函数也满足四边形不等式。</p><p><strong>m 满足四边形不等式的应用：</strong><br>定义 s( i , j ) 为函数 m(i , j) 对应的决策变量的最大值。如果 m(i ,j) 满足四边形不等式，那么 s(i , j) 单调。<br>原状态转移方程可表示为：</p><script type="math/tex; mode=display">m(i ,j) = {  m(i , k - 1) + m(k , j) + w(i , j) }</script><p>其中 $s(i, j - 1) &lt;= k &lt;= s(i+1 , j)$ 。如此变将第三层枚举数量减少，时间复杂度优化到了 $O(n^2)$。</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><h5 id="例1：石子合并"><a href="#例1：石子合并" class="headerlink" title="例1：石子合并"></a>例1：石子合并</h5><p><strong>题意描述</strong><br>共 n 堆石子围成一圈，每次可以选定相邻两堆合并成一堆，得分为合并后的新堆的石子数量，请问将这 n 堆石子合并成一堆的最小值是多少？</p><h5 id="例2：HDU3480-Division"><a href="#例2：HDU3480-Division" class="headerlink" title="例2：HDU3480 Division"></a>例2：HDU3480 Division</h5><p><strong>题意简述</strong><br>给定 n 个元素，请将这 n 个元素分为 m 个集合，每个集合的得分为该集合内的（最大值-最小值）^2。请问最少得分是多少。</p><p><strong>解题思路</strong><br>因为我们可以任选元素放入子集，所以元素的顺序没有规定。我们将元素按照大小排序，这样选中连续的 k 个一定是所有大小为 k 的子集中得分最少的。可以通过反证法来证明，将这 k 个元素中的任一个替换都会使得得分增加。<br>可以用动态规划来解决，设 f[i ,j] 表示将前 j 个元素分为 j 个集合最少得分。那么 f[ i , j ] = min{ f[k , j-1] + w(k+1 , i) }，其中 w 为计算集合得分的函数，1 &lt;= k &lt; i。</p><p>这样做的时间复杂度为 O(N^3)，由于本题数据过大，因此会超时，可以考虑是否能用四边形不等式优化。</p><p><strong>判断是否能用四边形不等式优化</strong><br>假设 a &lt;= b &lt; c &lt;= d；由于序列是顺序排序，所以元素大小和下标成正比，因此用下标代替元素。</p><p>考虑 w( b , c) &lt; w(a , d)是否成立：显然由于元素是递增的，所以 $(d - a)^2 &gt; (c - b)^2$，即满足区间包含的单调性。<br>考虑w(a , c) + w(b , d) &lt;= w(a , d) + w(b , c)是否成立：<br>即 $(c-a)^2 + (d-b)^2 &lt;= (d-a)^2 + (c-b)^2$ 是否成立；<br>化简后即 $ac + bd &gt; ad + bc$ 是否成立；<br>即 b(d-c) &gt;= a(d-c) 是否成立；<br>由于 d &gt; c，b &gt; a，所以 上式成立，原式得证。</p><p>综上所述 w 函数既满足区间包含单调性又满足四边形不等式，所以可以用四边形不等式优化。</p><p><strong>利用 s 数组进行四边形不等式优化</strong></p><p>我们知道四边形不等式的优化主要在于减少了中间状态的枚举，我们设 s[i , j] 为 f[i ,j] 取最小值时的中间变量 k。<br>那么我们状态转移方程就可以变成 f[ i , j ] = min{ f[k , j-1] + w(k+1 , i) }，其中 s[i ,j-1] &lt;= k &lt; s[i+1 ,j] 。<br>初始化而言，f[i ,1] = w(i ,1)，即把前 i 个元素分为一个子集；s[i , 1] = 1，即前 i 个元素分为一个子集时起点为 1 。<br>因为集合的划分个数要从小到大，所以集合个数 j 就从 2 开始，放在最外层；第二层因为要用到 s[i+1 ,j] ，所以 i 要从后向前遍历更新；中间就是利用 s 数组进行四边形不等式优化了。</p><p>在用 s 数组替换原始范围时，一定要注意范围，尤其是边界范围是否一致，同时要注意 s 数组的加入是否会影响更新顺序。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ll;</span><br><span class="line">ll a[N],f[N][M];</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,m,s[N][M];</span><br><span class="line"><span class="function">ll <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">w</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a[r]-a[l])*(a[r]-a[l]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/* 计算并返回答案 */</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line"><span class="built_in">std</span>::sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) f[i][<span class="number">1</span>] = w(<span class="number">1</span>,i), s[i][<span class="number">1</span>] = <span class="number">1</span>,s[n+<span class="number">1</span>][i] = n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j &lt;= m;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= j;i--)&#123;</span><br><span class="line">f[i][j] = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = s[i][j<span class="number">-1</span>];k &lt;= s[i+<span class="number">1</span>][j];k++)</span><br><span class="line"><span class="keyword">if</span>(f[i][j] &gt;= f[k][j<span class="number">-1</span>] + w(k+<span class="number">1</span>,i))&#123;</span><br><span class="line">f[i][j] = f[k][j<span class="number">-1</span>] + w(k+<span class="number">1</span>,i);</span><br><span class="line">s[i][j] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> f[n][m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">1</span>;c &lt;= t;c++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,c,solve());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>动态规划加速原理之四边形不等式，赵爽</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;动态规划加速原理之四边形不等式&quot;&gt;&lt;a href=&quot;#动态规划加速原理之四边形不等式&quot; class=&quot;headerlink&quot; title=&quot;动态规划加速原理之四边形不等式&quot;&gt;&lt;/a&gt;动态规划加速原理之四边形不等式&lt;/h4&gt;&lt;p&gt;动态规划的四边形不等式优化是对特定形
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="动态规划" scheme="http://valenshi.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>割点和桥题集</title>
    <link href="http://valenshi.top/2020/02/16/%E5%89%B2%E7%82%B9%E5%92%8C%E6%A1%A5%E9%A2%98%E9%9B%86/"/>
    <id>http://valenshi.top/2020/02/16/割点和桥题集/</id>
    <published>2020-02-16T03:20:34.000Z</published>
    <updated>2020-02-16T03:24:05.687Z</updated>
    
    <content type="html"><![CDATA[<h4 id="分离的路径-rpaths"><a href="#分离的路径-rpaths" class="headerlink" title="分离的路径(rpaths)"></a>分离的路径(rpaths)</h4><p><strong>题意描述</strong><br>为了从 F个草场中的一个走到另一个，贝茜和她的同伴们不得不路过一些她们讨厌的可怕的树。<br>奶牛们已经厌倦了被迫走某一条路，所以她们想建一些新路，使每一对草场之间都会至少有两条相互分离的路径，这样她们就有多一些选择。<br>每对草场之间已经有至少一条路径，给出所有 R条双向路的描述，每条路连接了两个不同的草场，请计算最少的新建道路的数量。<br>路径由若干道路首尾相连而成，两条路径相互分离，是指两条路径没有一条重合的道路，但是两条分离的路径上可以有一些相同的草场。<br>对于同一对草场之间，可能已经有两条不同的道路，你也可以在它们之间再建一条道路，作为另一条不同的道路。</p><p><strong>解题思路</strong><br>本题就是希望能添加最少的边，使得原图变为边双连通图。<br>易得，在边双连通图中添加边是不会改变桥的数量的。所以我们可以先把边双连通分量缩点。缩点后的图只有点和桥，假设叶子节点的个数为 leaf 个，那么我们只需要添加 (leaf + 1) / 2 条边即可使其变为点双连通分量。（当然只有一个节点的图无需添加）</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dfn[N],clk,low[N],co[N],col;</span><br><span class="line"><span class="keyword">int</span> Stack[N],top,deg[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 对双连通分量进行染色、缩点 */</span></span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line">Stack[++top] = x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">Tarjan(y,i); </span><br><span class="line">low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="comment">//if(low[y] &gt; dfn[x]) bridge[i] = bridge[i^1] = true;</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>((i^<span class="number">1</span>) != e) low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[x] == low[x]) </span><br><span class="line"><span class="keyword">for</span>(++col;Stack[top+<span class="number">1</span>] != x;--top)</span><br><span class="line">co[Stack[top]] = col;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">Tarjan(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>;x &lt;= n;x++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i]; vis[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(!vis[i^<span class="number">1</span>] &amp;&amp; co[x] != co[y]) deg[co[x]]++,deg[co[y]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> leaf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++) <span class="keyword">if</span>(deg[i] == <span class="number">1</span>) leaf++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,leaf+<span class="number">1</span>&gt;&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y), addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="矿场搭建-mine"><a href="#矿场搭建-mine" class="headerlink" title="矿场搭建(mine)"></a>矿场搭建(mine)</h4><p><strong>题意描述</strong><br>煤矿工地可以看成是由隧道连接挖煤点组成的无向图。为安全起见，希望在工地发生事故时所有挖煤点的工人都能有一条出路逃到救援出口处。于是矿主决定在某些挖煤点设立救援出口，使得无论哪一个挖煤点坍塌之后，其他挖煤点的工人都有一条道路通向救援出口。<br>请写一个程序，用来计算至少需要设置几个救援出口，以及不同最少救援出口的设置方案总数。</p><p><strong>解题思路</strong><br>我们首先要画图来讨论不同情况下需要的出口个数，显而易见，出口个数是和割点相关的。</p><ul><li>如果原图是一个双连通分量，那么只需要添加 2 个出口，方案数按照组合原理共 sz * (sz-1) /2 种。</li><li>如果原图被 1 个割点分割成 2 个点双连通分量，那么每个双连通分量都需要一个出口，且这个出口不能放在割点上。</li><li>如果原图被 2 个割点分割成 3 个点双连通分量，那么中间的双连通分量（有两个割点的）不需要出口，其它两个点双连通分量只需要 1 个出口。出口不能放在割点上。</li><li>如果原图被多个割点分割成多个点双连通分量，与第三种情况类似。</li></ul><p>因此我们只需要统计出每个点双连通分量的节点数目（包括割点），以及每个点双连通分量中割点个数，即可统计出口数量以及方案数。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">550</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],vdcc,clk;</span><br><span class="line"><span class="keyword">int</span> Stack[N],top;</span><br><span class="line"><span class="keyword">bool</span> ct[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cuts[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line">Stack[++top] = x;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;<span class="comment">//用于统计子树个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">Tarjan(y,rt);</span><br><span class="line">low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">if</span>(low[y] &gt;= dfn[x])&#123;</span><br><span class="line"><span class="keyword">if</span>(++tot &gt; <span class="number">1</span> || x != rt) ct[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(++vdcc;Stack[top+<span class="number">1</span>] != y;top--)<span class="comment">//将 x 留在栈内</span></span><br><span class="line">cuts[vdcc].push_back(Stack[top]);</span><br><span class="line">cuts[vdcc].push_back(x);<span class="comment">//手动将 x 添加到连通分量中</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,st,ca = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = st;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i,i);</span><br><span class="line">ull ans1 = <span class="number">0</span>,ans2 = <span class="number">1</span>, sz, tot;</span><br><span class="line"><span class="keyword">if</span>(vdcc == <span class="number">1</span>)&#123;<span class="comment">//仅有一个连通分量，需要设置两个出口，方案数按组合原理计算</span></span><br><span class="line">sz = cuts[<span class="number">1</span>].size();</span><br><span class="line">ans1 = <span class="number">2</span>, ans2 = sz*(sz<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= vdcc;i++)&#123;</span><br><span class="line">tot = <span class="number">0</span>; sz = cuts[i].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; sz;j++) tot += ct[cuts[i][j]];<span class="comment">//统计割点个数</span></span><br><span class="line"><span class="keyword">if</span>(tot == <span class="number">1</span>) ++ ans1, ans2 *= sz<span class="number">-1</span>;<span class="comment">//只有一个割点时</span></span><br><span class="line"><span class="comment">//若有多个割点，那么该连通分量不需要设置出口，因为它可以去别的连通分量的出口</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: %llu %llu\n"</span>,ca,ans1,ans2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m) &amp;&amp; m != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; N;i++)</span><br><span class="line">head[i] = low[i] = dfn[i] = ct[i] = Stack[i] = <span class="number">0</span>,cuts[i].clear();</span><br><span class="line">tot = <span class="number">1</span>, top = vdcc = clk = <span class="number">0</span>; </span><br><span class="line">ca++; n = <span class="number">0</span>, st = N;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">n = max(n,max(x,y));</span><br><span class="line">st = min(st,min(x,y));</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="嗅探器-sniffer"><a href="#嗅探器-sniffer" class="headerlink" title="嗅探器(sniffer)"></a>嗅探器(sniffer)</h4><p><strong>题意描述</strong><br>某军搞信息对抗实战演习，红军成功地侵入了蓝军的内部网络，蓝军共有两个信息中心，红军计划在某台中间服务器上安装一个嗅探器，从而能够侦听到两个信息中心互相交换的所有信息，但是蓝军的网络相当的庞大，数据包从一个信息中心传到另一个信息中心可以不止有一条通路。<br>现在需要你尽快地解决这个问题，应该把嗅探器安装在哪个中间服务器上才能保证所有的数据包都能被捕获？</p><p><strong>解题思路</strong><br>在一个连通图中找到一个编号最小的节点，去掉该节点可以分隔 a 和 b 。那么这个节点肯定是割点，但是无向图中可能有多个割点，而且也不是每个割点都能分隔 a 和 b。所以这个割点必须在 a 和 b 之间，且能分隔 a 和 b。<br>利用 Tarjan 性质，如果我们以 a 为根开始执行，那么割点 y 必须满足dfn[y] &lt; dfn[b]（保证 y 在 b 前面，在 a 和 b 之间） 且 low[b] &gt;= dfn[a] （保证 a 和 b 中仅有一个割点）<br>由于题意要求是在某台中间服务器，所以还需要判断割点不能等于 a 或 b 。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x];head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],clk;</span><br><span class="line"><span class="keyword">int</span> ans = INF;</span><br><span class="line"><span class="keyword">int</span> n,a,b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="comment">// 标记出所有割点</span></span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">Tarjan(y,rt);</span><br><span class="line">low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">if</span>(low[y] &gt;= dfn[x])</span><br><span class="line"><span class="keyword">if</span>(dfn[y] &lt;= dfn[b] &amp;&amp; low[b] &gt;= dfn[a] &amp;&amp; x != a &amp;&amp; x != b)</span><br><span class="line">ans = min(ans,x);</span><br><span class="line">&#125;<span class="keyword">else</span> low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y) &amp;&amp; (x || y))</span><br><span class="line">addEdge(x,y), addEdge(y,x);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">Tarjan(a,a);</span><br><span class="line"><span class="keyword">if</span>(ans != INF) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No solution"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="旅游航道-route"><a href="#旅游航道-route" class="headerlink" title="旅游航道(route)"></a>旅游航道(route)</h4><p><strong>题意描述</strong><br>SGOI 旅游局在 SG-III 星团开设了旅游业务，每天有数以万计的地球人来这里观光，包括联合国秘书长，各国总统和 SGOI 总局局长等。<br>旅游线路四通八达，每天都有众多的载客太空飞船在星团的星球之间来往穿梭，他们保证了任意两个星球之间总是可以通过航道到达。但是，最近由于财政出现了困难，一些太空飞船也过于古老，又没有足够的资金购买新产品，所有只好取消一些航道。<br>如果某一条航道的删除使得一些星球不能到达，那么这条航道是不能删除的，称之为「主要航道」。<br>SGOI 旅游局局长希望知道主要航道的数目，但是航道较多，他不能手工计算，于是，他委托你写一个程序，计算主要航道数目。<br><strong>解题思路</strong><br>题意就是要求统计出桥的数量。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],clk;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">Tarjan(y,i);</span><br><span class="line">low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">if</span>(low[y] &gt; dfn[x]) ans++;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>((i^<span class="number">1</span>) != e) low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">Tarjan(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m) &amp;&amp; (n||m))&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) head[i] = dfn[i] = low[i] = <span class="number">0</span>;</span><br><span class="line">tot = <span class="number">1</span>; ans = clk = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="电力-power"><a href="#电力-power" class="headerlink" title="电力(power)"></a>电力(power)</h4><p><strong>题意描述</strong><br>求一个图删除一个点之后，联通块最多有多少。</p><p><strong>解题思路</strong><br>因为图不一定是连通的，所以我们要知道连通块的数量。如果图中存在割点，那么选择子树最多的那个割点删除，如果不存在割点，就优先删除某一个连通块中的一个节点，注意如果所有连通块都只有一个点，那么只能删掉一个连通块了。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],clk,vdcc;</span><br><span class="line"><span class="keyword">int</span> ct[N],Stack[N],top,num[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line">Stack[++top] = x;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">Tarjan(y,rt);</span><br><span class="line">low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">if</span>(low[y] &gt;= dfn[x])&#123;</span><br><span class="line"><span class="keyword">if</span>(++tot &gt; <span class="number">1</span> || x != rt) ct[x]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[x] == low[x])</span><br><span class="line"><span class="keyword">for</span>(++vdcc;Stack[top+<span class="number">1</span>] != x;top--)</span><br><span class="line">num[vdcc]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i,i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) ans = max(ct[i],ans);</span><br><span class="line"><span class="keyword">if</span>(ans)&#123; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans+vdcc); <span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= vdcc;i++) </span><br><span class="line"><span class="keyword">if</span>(num[i] &gt; <span class="number">1</span>)&#123;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,vdcc); <span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,vdcc<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m) &amp;&amp; (n||m))&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">num[i] = ct[i] = head[i] = dfn[i] = low[i] = <span class="number">0</span>;</span><br><span class="line">vdcc = clk = <span class="number">0</span>; tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y); x++,y++;</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Blockade"><a href="#Blockade" class="headerlink" title="Blockade"></a>Blockade</h4><p><strong>题意描述</strong><br>Byteotia 城市有 n个城镇，m条双向道路。每条道路连接两个不同的城镇，没有重复的道路，所有城镇连通。输出 n个数，代表如果把第 i个点去掉，将有多少对点不能互通。</p><p><strong>解题思路</strong><br>首先要用long long，中间变量也要用。<br>对于一个节点 x，如果删除它，那么：</p><ul><li>u 和其它所有节点不连通，且其它所有节点到 u 也不连通；</li><li>它的子树上的节点（不包括 u ）和其它所有节点不连通；</li><li>所有非 u 子树上的节点和 u 子树上的点不连通。</li></ul><p>只需要把上述分类情况累加起来即可得到答案，本题难点在于分类，要做到不遗漏、不重叠。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll ans[N];</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],clk;</span><br><span class="line"><span class="keyword">int</span> tmp[N],sz[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>; sz[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">Tarjan(y,rt);</span><br><span class="line">sz[x] += sz[y];</span><br><span class="line">low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">if</span>(low[y] &gt;= dfn[x])</span><br><span class="line"><span class="keyword">if</span>(++cnt &gt; <span class="number">1</span> || x != rt)&#123;</span><br><span class="line">ans[x] += (ll)(n-sz[y]<span class="number">-1</span>)*sz[y];</span><br><span class="line">tmp[x] += sz[y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line">ans[x] += (ll)tmp[x]*(n-tmp[x]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i,i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[i] + (n<span class="number">-1</span>)*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;分离的路径-rpaths&quot;&gt;&lt;a href=&quot;#分离的路径-rpaths&quot; class=&quot;headerlink&quot; title=&quot;分离的路径(rpaths)&quot;&gt;&lt;/a&gt;分离的路径(rpaths)&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;题意描述&lt;/strong&gt;&lt;br&gt;为了从
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="割点和桥" scheme="http://valenshi.top/tags/%E5%89%B2%E7%82%B9%E5%92%8C%E6%A1%A5/"/>
    
  </entry>
  
  <entry>
    <title>无向图的割点和桥</title>
    <link href="http://valenshi.top/2020/02/16/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%89%B2%E7%82%B9%E5%92%8C%E6%A1%A5/"/>
    <id>http://valenshi.top/2020/02/16/无向图的割点和桥/</id>
    <published>2020-02-16T03:20:25.000Z</published>
    <updated>2020-02-16T03:24:39.086Z</updated>
    
    <content type="html"><![CDATA[<p>两个割点之间的边不一定是割边，割边的两个端点不一定是割点。<br>边双连通分量一定是点双连通分量，点双连通分量不一定是边双连通分量。</p><h4 id="Tarjan算法求割点"><a href="#Tarjan算法求割点" class="headerlink" title="Tarjan算法求割点"></a>Tarjan算法求割点</h4><p><strong>判定条件</strong><br>一个顶点 u 是割点，当且仅当满足以下两个条件之一：</p><ul><li>u 为树根，且 u 有多于一个子树。因为如果只有一棵子树，去掉树根节点后肯定不会出现多颗子树，因此不可能为割点；而无向图 DFS 搜索树中不存在横叉边（从某一个节点指向搜索树中另一子树中某节点的边），所以若有多颗子树，这些子树间不会有边相连，因此 u 肯定是割点。</li><li>u 不为树根，且满足存在（u，v）为树枝边（即 u 为 v 在搜素树中的父亲），并使得 dfn[u] &lt;= low[v] 。因为删去 u 后 v 以及 v 的子树都不能到达 u 的祖先。</li></ul><p><strong>代码实现</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line">Stack[++top] = x;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;<span class="comment">//用于统计子树个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">Tarjan(y,rt);</span><br><span class="line">low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">if</span>(low[y] &gt;= dfn[x])&#123;</span><br><span class="line"><span class="keyword">if</span>(++tot &gt; <span class="number">1</span> || x != rt) ct[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(++vdcc;Stack[top+<span class="number">1</span>] != y;top--)<span class="comment">//将 x 留在栈内</span></span><br><span class="line">cuts[vdcc].push_back(Stack[top]);</span><br><span class="line">cuts[vdcc].push_back(x);<span class="comment">//手动将 x 添加到连通分量中</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Tarjan算法求割边"><a href="#Tarjan算法求割边" class="headerlink" title="Tarjan算法求割边"></a>Tarjan算法求割边</h4><p><strong>判断桥</strong><br>一条无向边（u，v）是桥，当且仅当（u，v）为树枝边，且满足 dfn[u] &lt; low[v] 。因为 v 要想到达 u 的父亲必须经过（u，v）这条边，所以删去这条边后图不连通。</p><p><strong>代码实现</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">Tarjan(y,i); </span><br><span class="line">low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">if</span>(low[y] &gt; dfn[x]) bridge[i] = bridge[i^<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>((i^<span class="number">1</span>) != e) low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="求双连通分量"><a href="#求双连通分量" class="headerlink" title="求双连通分量"></a>求双连通分量</h4><p>对于<strong>点双连通分量</strong>，在求割点的过程中就可以顺便求出。利用栈来存储当且双连通分量，当每遇到一个割点时就从栈中将当前的双连通分量弹出，可以染色（不能染割点）或放入 vector 数组中（可以包括割点）。需要注意一个割点可能属于多个双连通分量，因此割点不应弹出栈。代码同‘Tarjan算法求割点’。</p><p>对于<strong>边双连通分量</strong>，求法更为简单。只需要在求出所有的桥后，把桥边删除，原图就变成了多个连通块，每个连通块就是一个边双连通分量。桥不属于任何一个边双连通分量，其余的边和每个顶点都属于且只属于一个边双连通分量，可以用并查集实现。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>对于 Tarjan 算法，我们不仅仅要会利用其求强连通分量、割点或桥，还要明白其原理，对其做灵活的变化以使用更多的题型。例如 dfn 记录的是节点的时间戳，而 low 记录节点以或子树，以及和它们相邻的所有节点的最小时间戳；那么通过对比 dfn 值可以得知两个节点在搜索树中的位置关系，通过比对 low 值可以得知搜索树是否可以到达父亲节点等。</p><p>同时还需要注意 Tarjan 算法求割点的时候，对于树根节点，我们只有第二次得知其有双连通分量子树时才标记树根为割点，但实际上此时其属于两个双连通分量的割点，所以如果要保存双连通分量中的节点时要做些改变。对于一些同树根有关系的题目也要额外注意。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>董永建，信息学竞赛一本通提高篇，福州：福建教育出版社，2018.6，179-183</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;两个割点之间的边不一定是割边，割边的两个端点不一定是割点。&lt;br&gt;边双连通分量一定是点双连通分量，点双连通分量不一定是边双连通分量。&lt;/p&gt;
&lt;h4 id=&quot;Tarjan算法求割点&quot;&gt;&lt;a href=&quot;#Tarjan算法求割点&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="割点和桥" scheme="http://valenshi.top/tags/%E5%89%B2%E7%82%B9%E5%92%8C%E6%A1%A5/"/>
    
  </entry>
  
  <entry>
    <title>区间类动态规划题集</title>
    <link href="http://valenshi.top/2020/02/16/%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E9%9B%86/"/>
    <id>http://valenshi.top/2020/02/16/区间动态规划题集/</id>
    <published>2020-02-16T03:13:47.000Z</published>
    <updated>2020-02-16T03:14:38.386Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1574" target="_blank" rel="noopener">测试地址</a><br>本文题面皆是复制网页，如果有格式问题参考原题面。</p><h4 id="1569：【-例-1】石子合并"><a href="#1569：【-例-1】石子合并" class="headerlink" title="1569：【 例 1】石子合并"></a>1569：【 例 1】石子合并</h4><p><strong>题意描述</strong><br>将 n 堆石子绕圆形操场排放，现要将石子有序地合并成一堆。规定每次只能选相邻的两堆合并成新的一堆，并将新的一堆的石子数记做该次合并的得分。<br>请编写一个程序，读入堆数 n 及每堆的石子数，并进行如下计算：</p><p>1、选择一种合并石子的方案，使得做 n−1 次合并得分总和最大。</p><p>2、选择一种合并石子的方案，使得做 n−1 次合并得分总和最小。</p><p><strong>解题思路</strong><br>算是典型例题吧，环形上的 DP ，可以拆分成一维区间类的 DP ，具体做法是拼接两倍的区间长度，然后在这长度为 2n 的区间上进行动态规划。<br>具体到这题，可以采用‘跨度+起点+中转点’三层循环来解决。由于起点最多只能到n，跨度最多只能到 n-1 ，设 f[ i ，j ] = 将第 i 堆到 j 堆合并的最大得分，那么初始状态f[i ,i] = 0，目标状态为 MAX{ f[i ,i+n-1] }。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">440</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],sum[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N],g[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n&lt;&lt;<span class="number">1</span>;i++) g[i][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i+n] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n&lt;&lt;<span class="number">1</span>;i++) sum[i] = sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>;len &lt; n;len++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span>*n-len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = i+len;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i;k &lt; j;k++)&#123;</span><br><span class="line">f[i][j] = max(f[i][j],f[i][k]+f[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">g[i][j] = min(g[i][j],g[i][k]+g[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span>,mi = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">mx = max(mx,f[i][i+n<span class="number">-1</span>]),mi = min(g[i][i+n<span class="number">-1</span>],mi);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>,mi,mx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1570：【例-2】能量项链"><a href="#1570：【例-2】能量项链" class="headerlink" title="1570：【例 2】能量项链"></a>1570：【例 2】能量项链</h4><p><strong>题意描述</strong><br>原题来自：NOIP 2006</p><p>在 Mars 星球上，每个 Mars 人都随身佩带着一串能量项链。在项链上有 N 颗能量珠。能量珠是一颗有头标记和尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记必定等于后一颗珠子的头标记。因为只有这样，通过吸盘——Mars 人吸收能量的器官的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可被吸盘吸收的能量。如果一颗能量珠头标记为 m，尾标记为 r，后一颗能量珠头标记为 r，尾标记为 n，则聚合后释放出 m×r×n Mars单位的能量，新珠子头标记为 m，尾标记为 n。</p><p>当需要时，Mars 人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不一样的。请设计一个聚合顺序使得一串珠子聚合后释放出的总能量最大。</p><p>例如，设 N=4，四颗珠子头标记与尾标记分别为 (2,3),(3,5),(5,10),(10,2)。我们用记号 ⨂ 表示两颗珠子的聚合操作，(j⨂k) 表示 j,k 两颗珠子聚合后释放出的能量，则4,1两颗珠子聚合后所释放的能量为(4⨂1)=10×2×3=60，这一串项链可以得到最优值的一个聚合顺序所释放出的总能量为(((4⨂1)⨂2)⨂3)=10×2×3+10×3×5+10×5×10=710<br>现在给你一串项链，项链上有 n 颗珠子，相邻两颗珠子可以合并成一个，合并同时会放出一定的能量，不同珠子合并放出能量不相同，请问按怎样的次序合并才能使得释放的能量最多？</p><p><strong>解题思路</strong><br>解决思路和状态设计和上一题类似，唯一不同的地方在于本题最终一棵珠子也要首尾合并，等同于起点被计算了两次，所以跨度就可以达到 n 而非 n-1 ，其它完全等同于上一题。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (ll)a[i]*a[j]*a[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span>*n<span class="number">-2</span>;i++) f[i][i+<span class="number">2</span>] = Mul(i,i+<span class="number">1</span>,i+<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>;l &lt;= n;l++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span>*n-l;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = i+l;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i+<span class="number">1</span>;k &lt; j;k++)</span><br><span class="line">f[i][j] = max(f[i][j],f[i][k]+f[k][j]+Mul(i,j,k));</span><br><span class="line">&#125;</span><br><span class="line">ll mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) mx = max(mx,f[i][i+n]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,mx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i+n] = a[i];</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1571：【例-3】凸多边形的划分"><a href="#1571：【例-3】凸多边形的划分" class="headerlink" title="1571：【例 3】凸多边形的划分"></a>1571：【例 3】凸多边形的划分</h4><p><strong>题意描述</strong><br>给定一个具有 N 个顶点的凸多边形，将顶点从 1 至 N 标号，每个顶点的权值都是一个正整数。将这个凸多边形划分成 N−2 个互不相交的三角形，试求这些三角形顶点的权值乘积和至少为多少。</p><p><strong>解题思路</strong><br>首先要注意 1e9 <em> 1e9 </em> 1e9 = 1e27，爆longlong，我用了__int128，但不是所有 oj 都支持 int128 的，如果不支持还是要用高精度或 java 等方法。</p><p>将凸多边形拆分成一条链，并复制一份拼接在后面，我们就在这 2n 区间上 DP。<br>设 f[i ,j] = 从点 i 到 j 所构成的凸多边形中，割成三角形最少得分。<br>那么初始状态 f[i ,i+1] = 0，其它都是 INF（根据转移方程反推出来的！！！）<br>目标状态就是 f[i, i+n-1]。<br>状态转移方程就是 f[i ,j] = max{ f[i ,k] + f[k ,j] + Mul(i, j, k) }，其中 k 为 i 到 j 之间的点，Mul() 计算三个点的乘积。<br>也就是枚举三角形的顶点而已，把图形化为区间就容易想多了，不要老想着三角形。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int128 ll;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e30</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a[N],f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span> </span>&#123; <span class="keyword">return</span> a[i]*a[j]*a[k]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &gt; <span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n&lt;&lt;<span class="number">1</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n&lt;&lt;<span class="number">1</span>;j++) f[i][j] = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n&lt;&lt;<span class="number">1</span>;i++) f[i][i+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>;l &lt; n;l++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">2</span>*n-l;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = i+l;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i+<span class="number">1</span>;k &lt; j;k++)</span><br><span class="line">f[i][j] = min(f[i][j],f[i][k]+f[k][j]+Mul(i,j,k));</span><br><span class="line">&#125;</span><br><span class="line">ll mi = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) mi = min(mi,f[i][i+n<span class="number">-1</span>]);</span><br><span class="line">print(mi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,a+i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i+n] = a[i];</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1572：括号配对"><a href="#1572：括号配对" class="headerlink" title="1572：括号配对"></a>1572：括号配对</h4><p><strong>题意描述</strong><br>Hecy 又接了个新任务：BE 处理。BE 中有一类被称为 GBE。</p><p>以下是 GBE 的定义：</p><p>空表达式是 GBE<br>如果表达式 A 是 GBE，则 [A] 与 (A) 都是 GBE<br>如果 A 与 B 都是 GBE，那么 AB 是 GBE。</p><p><strong>解题思路</strong><br>设 f[i ,j] = 序列 i 到 j 需要补充多少括号；<br>初始值 f[i ,i] = 1；<br>目标为 f[1 , n]；<br>转移方程为 f[i, j] = f[i, k] + f[k+1 ,j]，k 为 i 和 j 中间位置；如果 s[i] == s[j] 那么 f[i , j] = f[i-1 , j-1]。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i] == <span class="string">'('</span> &amp;&amp; str[j] == <span class="string">')'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(str[i] == <span class="string">'['</span> &amp;&amp; str[j] == <span class="string">']'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>); str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(str) - <span class="number">1</span>;<span class="comment">// strlen()为字符个数+1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) f[i][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>;l &lt; n;l++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n-l;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = i+l; f[i][j] = INF;<span class="comment">//必须在这赋值 , 否则覆盖了f[2][1] = 0.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i;k &lt; j;k++)&#123;</span><br><span class="line">f[i][j] = min(f[i][j],f[i][k]+f[k+<span class="number">1</span>][j]);</span><br><span class="line"><span class="keyword">if</span>(check(i,j)) f[i][j] = min(f[i][j],f[i+<span class="number">1</span>][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[<span class="number">1</span>][n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1573：分离与合体"><a href="#1573：分离与合体" class="headerlink" title="1573：分离与合体"></a>1573：分离与合体</h4><p><strong>题意描述</strong><br>经过在机房里数日的切磋，LYD 从杜神牛那里学会了分离与合体，出关前，杜神牛给了他一个测试……</p><p>杜神牛造了 n 个区域，他们紧邻着排成一行，编号 1..n。在每个区域里都放着一把 OI 界的金钥匙，每一把都有一定的价值，LYD 当然想得到他们了。然而杜神牛规定 LYD 不能一下子把他们全部拿走，而是每次只可以拿一把。为了尽快得到所有金钥匙，LYD 自然就用上了刚学的分离与合体特技。</p><p>一开始 LYD 可以选择 1..n−1 中的任何一个区域进入，我们不妨把这个区域记为 k。进入后 LYD 会在 k 区域发生分离，从而分离成两个小 LYD。分离完成的同时会有一面墙在 k 区域和 k+1 区域间升起，从而把 1..k 和 k+1..n 阻断成两个独立的区间，并在各自区间内任选除区间末尾之外（即从 1..k−1 和 k+1..n−1中选取）的任意一个区域再次发生分离，这样就有了四个小小 LYD……重复以上所叙述的分离，直到每个小 LYD 发现自己所在的区间只剩下了一个区域，那么他们就可以抱起自己梦寐以求的 OI 金钥匙。</p><p>但是 LYD 不能就分成这么多个个体存在于世界上，这些小 LYD 还会再合体，合体的小 LYD 所在区间中间的墙会消失。合体会获得 ((合并后所在区间左右端区域里金钥匙价值之和)×(之前分离的时候所在区域的金钥匙价值))。</p><p>例如，LYD 曾在 1..3 区间中的 2 号区域分离成为 1..2 和 3..3 两个区间，合并时获得的价值就是 (( 1 号金钥匙价值 +3 号金钥匙价值)×( 2 号金钥匙价值))。</p><p>LYD 请你编程求出最终可以获得的最大总价值，并按照分离阶段从前到后，区域从左到右的顺序，输出发生分离区域编号。若有多种方案，选择分离区域尽量靠左的方案（也可以理解为输出字典序最小的）。</p><p>例如先打印一分为二的区域，然后从左到右打印二分为四的分离区域，然后是四分为八的……</p><p><strong>解题思路</strong><br>题意理解耗时间。<br>大意就是选取区间一点区间划分为左右部分，合并时得分为划分前（左端点+右端点） * 选取点的权值。<br>我们还是按照老办法，用跨度来 DP 就可以得到最大得分。<br>关于路径输出，因为本题中区间划分是同时进行的，就是说如果存在多段区间都可划分，那么它们是可以同时划分的，而题意又要求按照划分的先后和区域的左右输出，也就是说要先判断该节点是属于第几次划分的，由于我们 path 数组存放了区间的划分点，那么我们不断递归，递归树第 k 层就对应着第 k 次划分，而左右顺序取决于我们的递归顺序；因此我们可以通过传入变量 step 代表当前递归树的层数，num 代表当前要输出的是第几步划分出的区域，当 step = num 就说明满足条件。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">330</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[N],n,f[N][N];</span><br><span class="line"><span class="keyword">int</span> path[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> step,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt;= j) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(step == num) <span class="built_in">printf</span>(<span class="string">"%d "</span>,path[i][j]);</span><br><span class="line">print(i,path[i][j],step+<span class="number">1</span>,num); print(path[i][j]+<span class="number">1</span>,j,step+<span class="number">1</span>,num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>;l &lt; n;l++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n-l;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = i+l;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i;k &lt; j;k++)</span><br><span class="line"><span class="keyword">if</span>(f[i][j] &lt; f[i][k] + f[k+<span class="number">1</span>][j] + (a[i]+a[j])*a[k])&#123;</span><br><span class="line">f[i][j] = f[i][k] + f[k+<span class="number">1</span>][j] + (a[i]+a[j])*a[k];</span><br><span class="line">path[i][j] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll mx = f[<span class="number">1</span>][n];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,mx);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) print(<span class="number">1</span>,n,<span class="number">1</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1574：矩阵取数游戏"><a href="#1574：矩阵取数游戏" class="headerlink" title="1574：矩阵取数游戏"></a>1574：矩阵取数游戏</h4><p><strong>题意描述</strong><br>原题来自：NOIP 2007</p><p>帅帅经常和同学玩一个矩阵取数游戏：对于给定的 n×m 的矩阵，矩阵中每个元素 aij 均为非负整数。游戏规则如下：</p><p>1、每次取数时必须从每行各取走一个元素，共 n 个，m 次取完所有元素。</p><p>2、每次取走的各个元素只能是该元素所在行行首或行尾。</p><p>3、每次取数都有一个的分值，为每行取数得分之和，每行取数得分==被取走元素值×2i ，其中 i 表示第 i 次取数，从 1 开始计数。</p><p>4、游戏结束时，总得分为 m 次取数得分之和。</p><p>帅帅想让你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。<br><strong>解题思路</strong><br>要用大整数，或者int128.<br>注意，1&lt;&lt;40 是不行的！！！要对数字 1 强制类型转换！！！<br>由于每行可以单独计算，最后再累加，因此我们设 f[i ,j] = 当前行中从 i 到 j 的最大得分。<br>状态转移方程看代码。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int128 ll;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line">ll f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &gt; <span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = m;j &gt;= i;j--)&#123;</span><br><span class="line">ll b = (ll)<span class="number">1</span>&lt;&lt;(m-j+i<span class="number">-1</span>);</span><br><span class="line">f[i][j] = max(f[i<span class="number">-1</span>][j] + (ll)a[i<span class="number">-1</span>]*b,f[i][j+<span class="number">1</span>] + (ll)a[j+<span class="number">1</span>]*b);</span><br><span class="line">&#125;</span><br><span class="line">ll mx = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) mx = max(mx,f[i][i] + (ll)a[i]*((ll)<span class="number">1</span>&lt;&lt;m));</span><br><span class="line"><span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">ans += solve();</span><br><span class="line">&#125;</span><br><span class="line">print(ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://ybt.ssoier.cn:8088/problem_show.php?pid=1574&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测试地址&lt;/a&gt;&lt;br&gt;本文题面皆是复制网页，如果有格式问题参考原题面。&lt;/p&gt;
&lt;h4
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="http://valenshi.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>长链剖分</title>
    <link href="http://valenshi.top/2020/02/16/dsu/"/>
    <id>http://valenshi.top/2020/02/16/dsu/</id>
    <published>2020-02-16T02:48:15.000Z</published>
    <updated>2020-02-16T02:48:57.602Z</updated>
    
    <content type="html"><![CDATA[<h4 id="长链剖分"><a href="#长链剖分" class="headerlink" title="长链剖分"></a>长链剖分</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>长链剖分属于树链剖分的一种，可以把维护子树中只与深度有关的信息做到线性时间。</p><p>一般的树链剖分是指剖分轻重链，其依据子节点的个数进行剖分，可以使得我们可以在任意一个点向上跳跃不超过 log 次就能到达根节点，从而可以高效维护两点之间的链的信息。</p><p>而长链剖分则是依据子树的深度进行剖分，深度最大的作为重儿子，这样原树就可以被分成若干条互不重复的链，并且保证了重链尽量长。因此长链剖分可以维护树中和深度有关的信息。</p><h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><p>在长链剖分中，我们常用如下几个数组：</p><blockquote><p>par[x] : x 在树中的父亲。<br>deep[x]：x 在树中的深度。<br>len[x]：x 为根的子树最大深度。<br>son[x]：x 的重儿子，即u-&gt;son[u]为重边。<br>top[x]：x 所在重路径的顶部节点（深度最小）。</p></blockquote><p>这些数组可以通过一次 dfs 来更新。通过定义可知，如果 top[x] = x，那么 x 就是一条长（重）链的起点，此时 len[x] 就是该链的长度（节点数目）。</p><p>更新代码可以这样来写：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line">dfs(ver[i]);</span><br><span class="line"><span class="keyword">if</span>(len[son[x]] &lt; len[ver[i]]) son[x] = ver[i];</span><br><span class="line">&#125;</span><br><span class="line">len[x] = len[son[x]]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;<span class="comment">//也可以不更新top数组，在此直接压入q1</span></span><br><span class="line"><span class="keyword">if</span>(ver[i] == son[x]) top[son[x]] = top[x];</span><br><span class="line"><span class="keyword">else</span> top[ver[i]] = ver[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码是基于邻接表存储‘单向边构成的有根树’，如果是无根树则需加个标记位来防止重复访问。</p><h5 id="长链剖分的性质"><a href="#长链剖分的性质" class="headerlink" title="长链剖分的性质"></a>长链剖分的性质</h5><p><strong>性质一：</strong> 所有的链的长度之和是 O（N）级别</p><blockquote><p>证明：所有点在且仅在一条长（重）链之中，永远只会被计算一次，所以总长度与 N 成正比</p></blockquote><p><strong>性质二：</strong> 从任意一个点向上跳跃的次数最多 $\sqrt N$ 次。</p><blockquote><p>证明：按照定义，节点 y 的父亲 x 所在的重链的长度一定是不小于 y 所在的重链的，我们知道所有重链的长度之和是 O(N)级别，所以最坏情况就是 1+2+3+…+$\sqrt n$<br>，所以最多跳 $\sqrt N$次</p></blockquote><h4 id="例题应用"><a href="#例题应用" class="headerlink" title="例题应用"></a>例题应用</h4><h5 id="BAPC2019-A-Appeal-to-the-Audience"><a href="#BAPC2019-A-Appeal-to-the-Audience" class="headerlink" title="BAPC2019 A.Appeal to the Audience"></a>BAPC2019 A.Appeal to the Audience</h5><p><strong>题意简述</strong><br>给定一棵有 k 个叶子节点的二叉树，所有非叶子节点的值等于其左右儿子的最大值，现在给定 k 个整数，求把它们分配在 k 个叶子上，使得整颗树的总权值最大（总权值 = 除根节点外所有节点的权值和）</p><p><strong>解题思路</strong><br>要想使得总和最大，就要使最大值被计算的次数最多。要想某个数被计算的多，就要使得它经过尽量多的节点。于是我们的目标就是找到 k 条从长到短的链，这些链互不重合，且一端是叶子节点。</p><p>可以通过长链剖分来将这棵树分为 k 条互不相交的长链，然后按照长度分配元素（长度越大，分配给它的元素值越大）。</p><p><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">/* 邻接表代码 */</span></span><br><span class="line"><span class="keyword">int</span> head[N],nex[M],ver[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 快读代码 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &gt; <span class="string">'9'</span> || c &lt; <span class="string">'0'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len[N],son[N],top[N];</span><br><span class="line"><span class="comment">//依次为当前子树最大深度、重儿子编号、当前链顶节点编号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line">dfs(ver[i]);</span><br><span class="line"><span class="keyword">if</span>(len[son[x]] &lt; len[ver[i]]) son[x] = ver[i];</span><br><span class="line">&#125;</span><br><span class="line">len[x] = len[son[x]]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;<span class="comment">//也可以不更新top数组，在此直接压入q1</span></span><br><span class="line"><span class="keyword">if</span>(ver[i] == son[x]) top[son[x]] = top[x];</span><br><span class="line"><span class="keyword">else</span> top[ver[i]] = ver[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,k,a[N];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line">priority_queue&lt;ll&gt; q1,q2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">top[<span class="number">1</span>] = <span class="number">1</span>; dfs(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) </span><br><span class="line"><span class="keyword">if</span>(top[i] == i) q1.push(len[i]);</span><br><span class="line">q1.push(len[<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span>(q1.size())&#123;</span><br><span class="line">ans += <span class="number">1l</span>l * q1.top() * q2.top();</span><br><span class="line">q1.pop(); q2.pop();</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = getInt(); k = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= k;i++) x = getInt(),q2.push(x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,y;i &lt;= n;i++) y = getInt(), addEdge(y+<span class="number">1</span>,i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Dominant-Indices"><a href="#Dominant-Indices" class="headerlink" title="Dominant Indices"></a>Dominant Indices</h5><p><a href="http://codeforces.com/problemset/problem/1009/F" target="_blank" rel="noopener">测试地址</a></p><p><strong>题意简述</strong><br>给定一颗编号为 1~n 的有根树，根节点编号为 1 。设 $d_{x,i}$ 表示以 x 为根的子树中，距 x 为 i 的节点的数目。求出对于每个节点 x，使 $d_{x,i}$ 最大的 i ，若有多种可能，则输出最小的 i。</p><p><strong>解题思路</strong><br>这道题刚开始以为就是 dfs，但是 dfs 中转移的时间太高了。看题解是用指针数组（* f[N]）来实现 O(1) 时间复杂度内转移的，其效率是由指针的赋值很快保证的，其正确性是由 f[x] = f[son[x] ] + 1 来保证的，即</p><blockquote><p>若 tmp[x, j] 表示距离 x 为 j 的节点数目，那么显然tmp[x, j] = tmp[son[x] , j-1]，其中 1 &lt;= j &lt;= n， 所以直接将 tmp[son[x] ] + 1 赋值给 tmp[ x ] 即可。<br>而我们这里用 dfs 从下往上更新，所以更新到 x 时， son[x] 已经计算完成，它的数据就没必要特意保存，所以即使用指针会修改原数据也无所谓。</p></blockquote><p>不过虽然转移的效率很高，但是回溯的过程中还需要合并，如果我们对每个子树都暴力合并的话，时间复杂度还是很高（主要是因为我们每次只能利用指针 O(1) 转移一次，所以要选最长的转移才最划算），所以我们可以用长链剖分，先将当前子树 x 所有的值合并到 x 所在在重链（长链）上，这样每次合并的次数等于短链的长度，然后只要通过 O(1) 转移长链即可。这样等同于每个点都合并了一次，所以总的时间复杂度为 O(N) 。</p><p><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span> + c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,len[N],son[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(ver[i] == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs(ver[i],x);</span><br><span class="line"><span class="keyword">if</span>(len[son[x]] &lt; len[ver[i]]) son[x] = ver[i];</span><br><span class="line">&#125;</span><br><span class="line">len[x] = len[son[x]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans[N],*f[N],tmp[N],*idx = tmp;</span><br><span class="line"><span class="comment">//f 数组是指针数组，可以利用偏移量实现 O(1) 转移,而 idx 代表当前在 tmp 数组的起点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">f[x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(son[x]) f[son[x]] = f[x]+<span class="number">1</span>, DP(son[x],x), ans[x] = ans[son[x]]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(y == fa || y == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">f[y] = idx; idx += len[y]; DP(y,x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= len[y];j++)&#123;</span><br><span class="line">f[x][j] += f[y][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>((j &lt; ans[x] &amp;&amp; f[x][j] &gt;= f[x][ans[x]]) || (j &gt; ans[x] &amp;&amp; f[x][j] &gt; f[x][ans[x]]))</span><br><span class="line">ans[x] = j;<span class="comment">//这里的判断句要保证取f[x][ans[x]]是最大值,且ans[x]尽量小</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f[x][ans[x]] == <span class="number">1</span>) ans[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>); </span><br><span class="line">f[<span class="number">1</span>] = idx; idx += len[<span class="number">1</span>];</span><br><span class="line">DP(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.cnblogs.com/zhoushuyu/p/9468669.html" target="_blank" rel="noopener">租酥雨的博客</a></li><li><a href="https://www.cnblogs.com/cjyyb/p/9479258.html" target="_blank" rel="noopener">yyb的博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;长链剖分&quot;&gt;&lt;a href=&quot;#长链剖分&quot; class=&quot;headerlink&quot; title=&quot;长链剖分&quot;&gt;&lt;/a&gt;长链剖分&lt;/h4&gt;&lt;h5 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="树链剖分" scheme="http://valenshi.top/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>Leanote与mongodb布置总结</title>
    <link href="http://valenshi.top/2020/02/14/leanote/"/>
    <id>http://valenshi.top/2020/02/14/leanote/</id>
    <published>2020-02-14T11:57:25.000Z</published>
    <updated>2020-02-14T11:57:53.022Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h4><p>Leanote 是一款类似于印象笔记的开源的笔记项目，具体介绍请访问 <a href="https://github.com/leanote/leanote" target="_blank" rel="noopener">Github</a> 该项目。</p><p>在 Github 上该项目有着详细的中文版的介绍以及安装步骤，但是由于 Linux 不熟练，我还是遇到了如下问题：</p><ol><li>虽然根据说明可以成功部署并运行，但是一旦断开会话或关闭终端，mongodb 与 leanote 都会停止工作。</li><li>如何用 fork 命令使得 mongodb 在后台运行。</li><li>如何使用 nohup 命令使得 run.sh 脚本在后台运行。</li><li>如何编写一个 shell 脚本来实现开机自启、一键启动、停止。</li></ol><p>本文主要目的是总结在 Linux 环境下工作的经验，详细记录刚掌握的知识点。</p><h4 id="mongodb-与非关系型数据库"><a href="#mongodb-与非关系型数据库" class="headerlink" title="mongodb 与非关系型数据库"></a>mongodb 与非关系型数据库</h4><p>mongodb 是非关系型数据库的一种，与 MySql 等关系型数据库相比，它的特点有：</p><ol><li>高并发，读写能力强</li><li>弱化数据结构一致性，使用更加灵活</li><li>有良好的拓展性（mysql 等很难横向拓展）</li><li>通用性差 , 没有 sql 语句那样通用的语句             </li><li>操作灵活导致容易出错和混乱             </li><li>没有外键关联等复杂的操作</li></ol><p>总的来说，关系型数据库（mysql）适合存储结构化数据，例如：用户账号、地址等信息；而非关系型数据库适合存储非结构化的数据，例如：文章、评论等。更加具体的区别与用法不做展开。</p><p>总的来说，mongodb 上手轻松，使用简单，而本文用到的指令仅仅三四个。</p><h5 id="mongodb-的安装与配置"><a href="#mongodb-的安装与配置" class="headerlink" title="mongodb 的安装与配置"></a>mongodb 的安装与配置</h5><p>首先去 <a href="http://www.mongodb.org/downloads" target="_blank" rel="noopener">mongodb官网</a> 下载压缩包，或者点击下载<a href="https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.1.tgz" target="_blank" rel="noopener">mongodb-linux-x86_64-3.0.1.tgz</a>。</p><p>下载完成后，只需做两步工作：解压与配置环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; tar -xzvf mongodb-linux-x86_64-3.0.1.tgz/</span><br></pre></td></tr></table></figure></p><p>为了快速使用 mongodb 命令, 可以配置环境变量。编辑 ~/.profile 或 /etc/profile 文件， 将 mongodb/bin 路径加入即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; sudo vim /etc/profile</span><br></pre></td></tr></table></figure></p><p>在 /etc/profile 中添加以下行，注意把用户名（user1）和相应的文件目录名（mongodb-linux-x86_64-3.0.1）替换成自己系统中的名称：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/home/user1/mongodb-linux-x86_64-3.0.1/bin</span><br></pre></td></tr></table></figure></p><p>保存修改后，在终端运行以下命令使环境变量生效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; source /etc/profile</span><br></pre></td></tr></table></figure></p><h5 id="测试-mongodb-安装"><a href="#测试-mongodb-安装" class="headerlink" title="测试 mongodb 安装"></a>测试 mongodb 安装</h5><p>先在 /home/user1 下新建一个目录 data 存放 mongodb 数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/user1/data</span><br></pre></td></tr></table></figure></p><p>用以下命令启动 mongodb：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --dbpath /home/user1/data</span><br></pre></td></tr></table></figure></p><p>这时 mongod 已经启动，<strong>重新打开</strong>一个终端, 键入 mongo 进入交互程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&gt; mongo</span><br><span class="line">&gt; show dbs</span><br><span class="line">...数据库列表</span><br></pre></td></tr></table></figure></p><p>至此 mongodb 就安装完成。</p><h4 id="使-mongodb-和-leanote-在后台运行"><a href="#使-mongodb-和-leanote-在后台运行" class="headerlink" title="使 mongodb 和 leanote 在后台运行"></a>使 mongodb 和 leanote 在后台运行</h4><p>由于按照 github 上的 leanote 安装说明，mongodb 和 leanote 是会随着会话和终端的关闭而停止运行，现在的目的是使它们不受会话关闭的影响，在后台运行。</p><p>我们可以时使用 <code>nohup command &gt;/dev/null 2&gt;&amp;1 &amp;</code> 命令来使得 mongodb 和 leanote 在后台运行。</p><p>对于 mongodb ，我们还可以配置 config 文件，通过在启动 mongod 时指定配置文件来实现后台运行，配置文件 mongodb.conf 内容如下：（路径需要自己修改）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#数据库路径</span><br><span class="line">dbpath=/usr/local/mongodb/data</span><br><span class="line">#日志输出文件路径</span><br><span class="line">logpath=/usr/local/mongodb/logs/mongodb.log</span><br><span class="line">#错误日志采用追加模式</span><br><span class="line">logappend=true</span><br><span class="line">#启用日志文件，默认启用</span><br><span class="line">journal=true</span><br><span class="line">#这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false</span><br><span class="line">quiet=true</span><br><span class="line">#端口号 默认为27017</span><br><span class="line">port=27017</span><br><span class="line">#允许远程访问</span><br><span class="line">#bind_ip=0.0.0.0</span><br><span class="line">#开启子进程</span><br><span class="line">fork=true</span><br><span class="line">#开启认证，必选先添加用户</span><br><span class="line">auth=true</span><br></pre></td></tr></table></figure><p>此时在 mongodb.conf 同一目录下执行 <code>mongod --conf mongodb.conf</code> 即可在后台启动数据库，此时可以通过 mongo 来访问数据库。<br>需要注意的是，mongod 命令不会帮你创建文件夹，所以 data 以及 logs 等目录是需要创建好再填写的，否则会报错 <code>ERROR: child process failed, exited with error number 1</code> 。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>至此已经可以较为简便的实现 mongod 与 leanote 的后台运行，并且每次服务器重启后我们都可以通过两条命令来启动。本次实践新接触了一个非关系型数据库 mongod 以及一些 linux 命令，下面目标是可以通过编写 Shell 脚本来使得工作更加简化，例如实现开机自启等。</p><p>本文不是教程，是笔记，当然如果已经成功搭建了 leanote ，想要使其在后台运行，还是可以参考本文的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h4&gt;&lt;p&gt;Leanote 是一款类似于印象笔记的开源的笔记项目，具体介绍请访问 &lt;a href=&quot;https://github.com
      
    
    </summary>
    
      <category term="Linux" scheme="http://valenshi.top/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Liunx 使进程在后台运行的几种方法</title>
    <link href="http://valenshi.top/2020/02/14/nohup/"/>
    <id>http://valenshi.top/2020/02/14/nohup/</id>
    <published>2020-02-14T10:33:06.000Z</published>
    <updated>2020-02-14T10:34:00.022Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Liunx-使进程在后台运行的几种方法"><a href="#Liunx-使进程在后台运行的几种方法" class="headerlink" title="Liunx 使进程在后台运行的几种方法"></a>Liunx 使进程在后台运行的几种方法</h4><p>现在有如下两个目标：</p><ul><li>使进程让出前台终端，让我们可以继续通过终端与系统进行交互。</li><li>使进程不再受终端关闭的影响，即系统在终端关闭后不再向进程发送 SIGHUP 信号或即使发送了信号程序也不会退出。</li></ul><p>首先要明白什么是进程、进程组、会话、终端、作业等名词。</p><h5 id="为什么进程会被终止"><a href="#为什么进程会被终止" class="headerlink" title="为什么进程会被终止"></a>为什么进程会被终止</h5><p>用户注销或者网络断开时，SIGHUP 信号会被发送到会话所属的子进程，而 SIGHUP 的默认处理方式是终止收到该信号的进程。所以若程序中没有捕捉该信号，当终端关闭后，会话所属进程就会退出。</p><h5 id="利用-amp-符号"><a href="#利用-amp-符号" class="headerlink" title="利用 &amp; 符号"></a>利用 &amp; 符号</h5><p>将 &amp; 附在命令后面可以使进程在后台执行，不占用前台界面。它实际上是在会话中开启了一个后台作业，但是此时如果终端被关闭了，进程还是会退出，这是因为 &amp; 只有让进程退出前台终端的功能，无法让进程不受 SIGHUP 的影响。</p><h5 id="nohup-命令"><a href="#nohup-命令" class="headerlink" title="nohup 命令"></a>nohup 命令</h5><p>nohup 可以使得进程不受 SIGHUP 信号的影响，但是执行<code>nohup php test.php</code> 后会发现，进程还是会一直占用着前台终端，不过此时如果终端被关闭或连接断开，程序还是会继续执行。另外此时当前文件夹还会多出一个 nohup.out 文件。</p><p>这是因为 nohup 仅仅让进程不受 SIGHUP 信号影响，并不会让出前台，而且它还会在命令执行的目录下生成 nohup.out 用于存储进程输出。如果不需要输出，且不想创建 nohup.out 文件，可以将标准输出和标准错误重定向。</p><p>我们常将 &amp; 和 nohup 搭配一起使用，执行命令如下：<code>nohup command &gt;/dev/null 2&gt;&amp;1 &amp;</code> ，这样就可以既不占用前台，又不会受 SIGHUP 信号影响，同时也不会创建输出文件。</p><h5 id="setsid-命令"><a href="#setsid-命令" class="headerlink" title="setsid 命令"></a>setsid 命令</h5><p>setsid 是另一个让进程在后台执行的命令，它的作用是让进程打开一个新的会话并运行进程，使用方式为 setsid command。</p><p>前面的做法都是使得进程忽略 SIGHUP 信号的影响，而 setsid 则干脆让进程新打开一个会话并在其中运行，那么原会话终端状态就不会影响该进程了。不过 setsid 并没有为进程分配一个输出终端，所以进程还是会输出到当前终端上。</p><p>不过 setsid 在 shell 脚本中表现的会有不同，具体可另行查找资料。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>除了上述做法之外，还可以利用 screen ，tmux 等会话工具来实现进程的后台运行，这里不做介绍。<br>本文主要解决了如何使进程不受终端和会话的影响，通过忽视 SIGHUB 信号从而实现在后台运行，上述的每个命令用法可能并不仅仅如此，并没有展开介绍每个命令的所有用法。同时本文介绍也仅仅是所有方案中的一部分。</p><p>参考资料：<a href="http://www.sohu.com/a/306275405_760387" target="_blank" rel="noopener">让 Linux 进程在后台可靠运行的几种方法 </a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Liunx-使进程在后台运行的几种方法&quot;&gt;&lt;a href=&quot;#Liunx-使进程在后台运行的几种方法&quot; class=&quot;headerlink&quot; title=&quot;Liunx 使进程在后台运行的几种方法&quot;&gt;&lt;/a&gt;Liunx 使进程在后台运行的几种方法&lt;/h4&gt;&lt;p&gt;现在
      
    
    </summary>
    
      <category term="Linux" scheme="http://valenshi.top/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>USACO 2019 December Contest, Silver 题解</title>
    <link href="http://valenshi.top/2019/12/17/usaco2019de/"/>
    <id>http://valenshi.top/2019/12/17/usaco2019de/</id>
    <published>2019-12-17T12:07:25.000Z</published>
    <updated>2019-12-17T12:09:03.975Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-MooBuzz"><a href="#1-MooBuzz" class="headerlink" title="1.MooBuzz"></a>1.MooBuzz</h4><h5 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h5><p>Farmer John 的奶牛们最近成为了一个简单的数字游戏“FizzBuzz”的狂热玩家。这个游戏的规则很简单：奶牛们站成一圈，依次从一开始报数，每头奶牛在轮到她的时候报一个数。如果一头奶牛将要报的数字是 3 的倍数，她应当报“Fizz”来代替这个数。如果一头奶牛将要报的数字是 5 的倍数，她应当报“Buzz”来代替这个数。如果一头奶牛将要报的数字是 15 的倍数，她应当报“FizzBuzz”来代替这个数。于是这个游戏的开始部分的记录为：<br>1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16</p><p>由于词汇的匮乏，奶牛们玩的 FizzBuzz 中用“Moo”代替了 Fizz、Buzz、FizzBuzz。于是奶牛版的游戏的开始部分的记录为：</p><p>1, 2, Moo, 4, Moo, Moo, 7, 8, Moo, Moo, 11, Moo, 13, 14, Moo, 16</p><p>给定 N（1≤N≤1e9），请求出这个游戏中第 N 个被报的数。</p><h5 id="A-possible-solution"><a href="#A-possible-solution" class="headerlink" title="A possible solution"></a>A possible solution</h5><p>利用容斥原理+二分判断。我们假设 n 个数里共有 cnt 个被跳过的数，那么报的第 n 个数就是 n+cnt ，由于 n 和 cnt 都具有单调性，所以我们可以利用二分判定来解决。<br>其中容斥原理很容易想到，cnt 显然等于 n 内 3 的倍数 + 5 的倍数 +15的倍数，但是15 = 3 * 5，所以15不需要重复统计（已经在 3 的倍数中统计过了）。但是我们重复统计了 3 和 5 的公倍数（统计了 2 次），于是我们就要减去同时是 3 的倍数和 5 的倍数 的 个数即可得到cnt。<br>在O(1)时间内求出cnt后，我们就可以在O(logN)时间内用二分搜索解决此题。</p><h5 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">int</span> tn;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">ll a = n/<span class="number">3</span>, b = n/<span class="number">5</span>;</span><br><span class="line">ll c = n/<span class="number">15</span>;</span><br><span class="line">ll cnt = a + b - c;</span><br><span class="line"><span class="keyword">return</span> n-cnt &gt;= tn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"moobuzz.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"moobuzz.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; tn ;</span><br><span class="line">ll l = <span class="number">1</span>,r = INF;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">ll mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Meetings"><a href="#2-Meetings" class="headerlink" title="2.Meetings"></a>2.Meetings</h4><h5 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h5><p>有两个牛棚位于一维数轴上的点 0 和 L 处（1≤L≤1e9）。同时有 N 头奶牛（1≤N≤5e4）位于数轴上不同的位置（将牛棚和奶牛看作点）。每头奶牛 i 初始时位于某个位置 xi，并朝着正向或负向以一个单位每秒的速度移动，用一个等于 1 或 −1 的整数 di 表示。每头奶牛还拥有一个在范围 [1,1e3] 内的重量。所有奶牛始终以恒定的速度移动，直到以下事件之一发生：<br>如果奶牛 i 移动到了一个牛棚，则奶牛 i 停止移动。<br>当奶牛 i 和 j 占据了相同的点的时候，并且这一点不是一个牛棚，则发生了相遇。此时，奶牛 i 被赋予奶牛 j 先前的速度，反之亦然。注意奶牛可能在一个非整数点相遇。<br>令 T 等于停止移动的奶牛（由于到达两个牛棚之一）的重量之和至少等于所有奶牛的重量之和的一半的最早时刻。请求出在时刻 0…T（包括时刻T）之间发生的奶牛对相遇的总数。</p><h5 id="A-possible-solution-1"><a href="#A-possible-solution-1" class="headerlink" title="A possible solution"></a>A possible solution</h5><p>这道题与 Ants 那题类似。如果不考虑重量，那么我们可以忽略每头牛的个性，从整体来看，如果两头牛相遇可以看作他们“穿过”对方并继续前进；如果每头牛有不同的重量，那么它们就有了个性，不能再等价于“穿过”对方。<br>这个时候我们可以从两个角度来考虑：</p><ol><li>首先如果有 x 头牛回窝，那么一定是靠近端点的 x 头牛。原因很简单，这是一个一维的空间，前面的牛不回窝后面的就会被堵住过不去。所以每个端点回窝的重量顺序就确定了。</li><li>在 t 时刻内，一头牛只可能和与他迎面走来的 2 <em> t 距离内的牛相遇。这个时候我们不需要考虑重量，所以每个牛可以看作“穿过”相遇的对方继续前进，那么显然 t 时刻内这两头牛相向而行 2 </em> t 的距离。</li></ol><p>通过第一个推论我们可以求出 T （二分或者优先队列），通过第二个推论我们可以根据 T 来求出相遇的牛的总数。</p><h5 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,l;</span><br><span class="line">ll sum;</span><br><span class="line"><span class="keyword">int</span> w[N],px[N],d[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="comment">//t时刻到家的重量是否达到一半</span></span><br><span class="line"><span class="keyword">int</span> tw = <span class="number">0</span>, c1 = <span class="number">0</span>, c2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(d[i] == <span class="number">1</span> &amp;&amp; l - px[i] &lt;= t) c1++;</span><br><span class="line"><span class="keyword">if</span>(d[i] == <span class="number">-1</span> &amp;&amp; px[i] &lt;= t) c2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c2;i++) tw += w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt; n-c1;i--) tw += w[i];</span><br><span class="line"><span class="comment">//printf("%d %d %d %d %d\n",t,c1,c2,tw,sum);</span></span><br><span class="line"><span class="keyword">return</span> tw*<span class="number">2</span> &lt; sum;</span><br><span class="line">&#125;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>,r = tot;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid] &gt;= x) r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; " " &lt;&lt; l &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(ll t)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">//相遇次数</span></span><br><span class="line">tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(d[i] == <span class="number">-1</span>) a[++tot] = px[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(d[i] == <span class="number">1</span>) res += bsearch(px[i]+<span class="number">2</span>*t+<span class="number">1</span>) - bsearch(px[i]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> w,x,d;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; rhs) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt; rhs.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;nodes[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"meetings.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"meetings.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;l);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;nodes[i].w,&amp;nodes[i].x,&amp;nodes[i].d);</span><br><span class="line">sort(nodes+<span class="number">1</span>,nodes+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) w[i] = nodes[i].w,px[i] = nodes[i].x,d[i] = nodes[i].d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) sum += w[i];</span><br><span class="line"><span class="keyword">int</span> tl = <span class="number">0</span>,tr = l; </span><br><span class="line"><span class="keyword">while</span>(tl &lt;= tr)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = tl+tr&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) tl = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> tr = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; l &lt;&lt; endl;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,calc(tl));<span class="comment">//计算 l 秒内碰头次数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Milk-Visits"><a href="#3-Milk-Visits" class="headerlink" title="3.Milk Visits"></a>3.Milk Visits</h4><h5 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h5><p>Farmer John 计划建造 N（1≤N≤1e5）个农场，用 N−1 条道路连接，构成一棵树（也就是说，所有农场之间都互相可以到达，并且没有环）。每个农场有一头奶牛，品种为更赛牛或荷斯坦牛之一。<br>Farmer John 的 M 个朋友（1≤M≤1e5）经常前来拜访他。在朋友 i 拜访之时，Farmer John 会与他的朋友沿着从农场 Ai 到农场 Bi 之间的唯一路径行走（可能有 Ai=Bi）。除此之外，他们还可以品尝他们经过的路径上任意一头奶牛的牛奶。由于 Farmer John 的朋友们大多数也是农场主，他们对牛奶有着极强的偏好。他的有些朋友只喝更赛牛的牛奶，其余的只喝荷斯坦牛的牛奶。任何 Farmer John 的朋友只有在他们访问时能喝到他们偏好的牛奶才会高兴。</p><p>请求出每个朋友在拜访过后是否会高兴。</p><h5 id="A-possible-solution-2"><a href="#A-possible-solution-2" class="headerlink" title="A possible solution"></a>A possible solution</h5><p>一条道路只有 3 种情况，全是 H 牛，全是 G 牛或者两者兼有。那么如果节点 x 是 H 牛我们就令其w =  -1，如果是 G 牛就等于1。那么这一段路径上所有点的 w 相加，如果等于 d，就说明全是G牛；如果等于 -d，就说明全是 H 牛；否则就说明两者都有。<br>至于快速求两点间距离可以用倍增求LCA。</p><h5 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">char</span> ty[N];</span><br><span class="line"><span class="keyword">int</span> n,m,w[N];</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dis[N],anc[N][<span class="number">25</span>],dep[N],sum[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++) </span><br><span class="line">anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(dis[y] || y == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">dis[y] = dis[x] + z;</span><br><span class="line">anc[y][<span class="number">0</span>] = x;</span><br><span class="line">sum[y] = sum[x] + w[y];</span><br><span class="line">dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[x] &lt; dep[y]) swap(x,y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(dep[anc[x][i]] &gt;= dep[y]) x = anc[x][i];</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(anc[x][i] != anc[y][i])&#123;</span><br><span class="line">x = anc[x][i]; y = anc[y][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"milkvisits.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"milkvisits.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,ty+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line"><span class="keyword">if</span>(ty[i] == <span class="string">'G'</span>) w[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> w[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y,<span class="number">1</span>); addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">dep[<span class="number">0</span>] = <span class="number">-1</span>; dfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;x,&amp;y,s);</span><br><span class="line"><span class="keyword">int</span> fa = lca(x,y);</span><br><span class="line"><span class="keyword">int</span> d = dis[x]+dis[y] - <span class="number">2</span>*dis[fa] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sw = sum[x]+sum[y] - <span class="number">2</span>*sum[fa]+w[fa];</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'H'</span> &amp;&amp; sw != d) <span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'G'</span> &amp;&amp; sw != -d) <span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-MooBuzz&quot;&gt;&lt;a href=&quot;#1-MooBuzz&quot; class=&quot;headerlink&quot; title=&quot;1.MooBuzz&quot;&gt;&lt;/a&gt;1.MooBuzz&lt;/h4&gt;&lt;h5 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; c
      
    
    </summary>
    
    
      <category term="lca" scheme="http://valenshi.top/tags/lca/"/>
    
      <category term="树上倍增" scheme="http://valenshi.top/tags/%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/"/>
    
      <category term="二分搜索" scheme="http://valenshi.top/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Python之字符串处理与格式输出</title>
    <link href="http://valenshi.top/2019/12/08/python-str/"/>
    <id>http://valenshi.top/2019/12/08/python-str/</id>
    <published>2019-12-08T06:04:03.000Z</published>
    <updated>2019-12-08T06:06:12.096Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>大多数语言都有字符串（String）这一数据类型，在Python中String类型的关键字为 str ，其属于扁平序列、不可改变序列，因此对其的操作需要一些技巧。<br>本文将以方便算法竞赛的角度来整理Python中 str 类型的使用方法，分别从字符串操作与格式化输出两个角度来整理。</p><h4 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h4><h5 id="标准的序列操作"><a href="#标准的序列操作" class="headerlink" title="标准的序列操作"></a>标准的序列操作</h5><p>这里的序列类型就不单单是指字符串了，而是指包含字符串的一种类型。序列类型大体可分为容器序列与扁平序列。<br><strong>容器序列</strong>实际上放的是对象引用，因此可以存放不同类型的数据；<br><strong>扁平序列</strong>存放的是对象的值，是一段连续的内存空间，因此要求对象必须是相同的数据类型才行，如字符、数字、字节。字符串是扁平序列。</p><p>当然，按照<strong>是否可修改</strong>还可以分为可变序列与不可变序列，不可变序列有<code>tuple、str、bytes</code>；可变序列有<code>list、bytearray</code> 等。字符串是不可变序列。</p><p>以上序列都有一些通用的操作，如：索引、切片、加法乘法；当然对于不同的序列这些操作意义也不同。</p><p><strong>索引：</strong> 和类C语言一样，序列中的元素都是有序排列的，拥有自己的编号（从0开始），我们可以通过索引来得到对应位置上的元素。<br>索引也可以是负值，负索引代表从后向前数，如 -3 表示倒数第三个元素，以此类推。</p><p><strong>切片：</strong> Python中有着分片操作符[ : ]，[begin : end]将会返回子序列 [begin,end)，其中end位置上的元素取不到，所以end是个超尾。<br>切片的索引同样支持负值，负索引表示倒数第几个元素，需要注意的是起始下标应在终止下标之前，否则将会返回空。</p><p><strong>代码示例：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"abcdefg"</span></span><br><span class="line">print(s)</span><br><span class="line"><span class="comment">#索引</span></span><br><span class="line">print(s[<span class="number">2</span>])<span class="comment">#输出索引为2的元素 'c'</span></span><br><span class="line">print(s[<span class="number">-2</span>])<span class="comment">#输出倒数第2个元素 'f'</span></span><br><span class="line"><span class="comment">#切片</span></span><br><span class="line">print(s[<span class="number">2</span>:<span class="number">6</span>])<span class="comment">#输出[2,6)位置的子串 "cdef"</span></span><br><span class="line">print(s[<span class="number">-4</span>:<span class="number">-2</span>])<span class="comment">#输出[倒数第4个元素,倒数第2个元素)子串 "de"</span></span><br></pre></td></tr></table></figure></p><p>字符串的 ‘+’与 ‘ * ‘ 分别是拼接与复制，一试便知，不再赘述。</p><h5 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h5><p>前面说过，python中的str属于不可修改序列，即不可以通过索引赋值的方式来修改元素；也就是说 <code>s[2] = &#39;x&#39;</code> 这样的写法是不允许的。那么如果想修改怎么办呢？这里挑几种方便的写法整理：<br><strong>重新赋值：</strong> 具体思路是，通过将需要修改的目标位置用切片切出来，然后替换再拼接，具体代码如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"abcdefg"</span></span><br><span class="line">print(s)</span><br><span class="line">s = s[:<span class="number">4</span>] + <span class="string">"x"</span> + s[<span class="number">5</span>:]</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure></p><p><strong>使用replace函数：</strong> 可以通过调用字符串方法replace( s , t )将字符串内的所有子串 s 替换为 t 后返回。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"abcdefgabc"</span></span><br><span class="line">print(s)</span><br><span class="line"><span class="comment">#将abcdefabc替换为xxxdefxxx</span></span><br><span class="line">s2 = s.replace(<span class="string">"abc"</span>,<span class="string">"xxx"</span>)</span><br><span class="line">print(s2)</span><br></pre></td></tr></table></figure></p><p>还可以通过将字符串转化为列表后修改元素，再用 join 方法转回字符串来达成修改目的，具体选择哪种方法按需求来看。</p><h5 id="ASCII码与字符的转换"><a href="#ASCII码与字符的转换" class="headerlink" title="ASCII码与字符的转换"></a>ASCII码与字符的转换</h5><p>在一些情形下，尤其是算法竞赛中，快速实现字符转ASCII码是十分重要的，在Python中不能直接对字符用加法或减法来实现转换，而是要通过ord() 和 chr() 函数来实现转换：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(ord(<span class="string">'a'</span>))<span class="comment">#输出字符 a 的ASCII码</span></span><br><span class="line">print(chr(<span class="number">98</span>))<span class="comment">#输出ASCII码为 98 的字符</span></span><br></pre></td></tr></table></figure></p><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><p>对于字符串的输出可以通过调用print()来实现，但是在算法竞赛等一些情况下，这样是不够的，因为我们往往对输出的格式有着严格的要求。</p><h5 id="基本的转换说明符"><a href="#基本的转换说明符" class="headerlink" title="基本的转换说明符"></a>基本的转换说明符</h5><p>% 字符 标记转换说明符的开始，例如<code>print(&quot;Hello, %s &quot; % &quot;egg&quot;)            # Hello, egg</code> ，这段代码将字符串中的 %s 替换成了字符串 “egg” ；这就是字符串格式化操作符 % 的基本使用方式。<br>如果要在格式化字符串里包含%，那么必须使用%%，这样Python就不会将百分号误以为是转换说明符了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"There is %d people."</span> % <span class="number">32</span>) <span class="comment"># There is 32 people.</span></span><br><span class="line">print(<span class="string">"Hello%%, %s "</span> % <span class="string">"egg"</span>)<span class="comment"># Hello%, egg</span></span><br></pre></td></tr></table></figure></p><h5 id="字段宽度和精度"><a href="#字段宽度和精度" class="headerlink" title="字段宽度和精度"></a>字段宽度和精度</h5><p>指定宽度和精度同C语言类似，都是类似%.3f以及%5d<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"An egg is %.2f yuan"</span> % <span class="number">0.8</span>)        <span class="comment"># An egg is 0.80 yuan</span></span><br><span class="line">print(<span class="string">"An egg is %5d yuan"</span> % <span class="number">1</span>)<span class="comment"># An egg is     1 yuan</span></span><br></pre></td></tr></table></figure></p><h5 id="符号、对齐和用0填充"><a href="#符号、对齐和用0填充" class="headerlink" title="符号、对齐和用0填充"></a>符号、对齐和用0填充</h5><p>在字符宽度和精度值之前还可以放一个“标志”，该表示可以是<code>0 + -</code> </p><ul><li>如果是0则表示不足的位置用前导零填充</li><li>‘-‘ 表示左对齐数值</li><li>‘+’ 表示输出符号（不管是正数还是负数）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"An egg is %05d yuan"</span> % <span class="number">1</span>)<span class="comment"># An egg is 00001 yuan</span></span><br><span class="line">print(<span class="string">"An egg is %-5d yuan"</span> % <span class="number">1</span>)<span class="comment"># An egg is 1     yuan</span></span><br><span class="line">print(<span class="string">"An egg is %+d yuan"</span> % <span class="number">1</span>)<span class="comment">#An egg is +1 yuan</span></span><br></pre></td></tr></table></figure><h5 id="输出不止一个元素"><a href="#输出不止一个元素" class="headerlink" title="输出不止一个元素"></a>输出不止一个元素</h5><p>你可能注意到了上述例子都是只输出一个值，一个元素；在C语言中我们可以通过逗号来分隔需要输出的不同元素，那么在Python中如何办到呢？<br>在Python中，只有元组和字典可以格式化一个以上的值；如果用列表或者其它序列代替元组，那么序列会被解释为一个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用元组来输出一个以上的值</span></span><br><span class="line">print(<span class="string">"An egg is %d yuan,two eggs are %d yuan."</span>% (<span class="number">1</span>,<span class="number">2</span>)) </span><br><span class="line"><span class="comment"># An egg is 1 yuan,two eggs are 2 yuan.</span></span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>Magnus Lie Hetland，Python基础教程第二版·修定版，北京：人民邮电出版社，45-47</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;大多数语言都有字符串（String）这一数据类型，在Python中String类型的关键字为 str ，其属于扁平序列、不可改变序列，因此对
      
    
    </summary>
    
      <category term="Python学习笔记" scheme="http://valenshi.top/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python字符串" scheme="http://valenshi.top/tags/Python%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>2019CSP-J普及组复赛题解</title>
    <link href="http://valenshi.top/2019/11/26/2019CSP-J/"/>
    <id>http://valenshi.top/2019/11/26/2019CSP-J/</id>
    <published>2019-11-26T12:11:19.000Z</published>
    <updated>2019-11-26T12:13:00.868Z</updated>
    
    <content type="html"><![CDATA[<h4 id="A-数字游戏"><a href="#A-数字游戏" class="headerlink" title="A.数字游戏"></a>A.数字游戏</h4><p><strong>题意描述</strong><br>小 K 同学向小 P 同学发送了一个长度为 8 的 01 字符串来玩数字游戏，小 P 同学想 要知道字符串中究竟有多少个 1。<br> 注意：01 字符串为每一个字符是 0 或者 1 的字符串，如“101”（不含双引号）为一 个长度为 3 的 01 字符串。</p><p><strong>解题思路</strong><br>签到题。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;str[i];i++) <span class="keyword">if</span>(str[i] == <span class="string">'1'</span>) cnt++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="B-公车换乘"><a href="#B-公车换乘" class="headerlink" title="B.公车换乘"></a>B.公车换乘</h4><p><strong>题意描述</strong><br>著名旅游城市 B 市为了鼓励大家采用公共交通方式出行，推出了一种地铁换乘公交 车的优惠方案：在搭乘一次地铁后可以获得一张优惠票，有效期为 45 分钟，在有效期内可以 消耗这张优惠票，免费搭乘一次票价不超过地铁票价的公交车。在有效期内指 开始乘公交车的时间与开始乘地铁的时间之差小于等于 45 分钟，即：$t_{bus} - t_{subway} ≤ 45$。<br>搭乘地铁获得的优惠票可以累积，即可以连续搭乘若干次地铁后再连续使用优 惠票搭乘公交车。搭乘公交车时，如果可以使用优惠票一定会使用优惠票；如果有多张优惠票满 足条件，则优先消耗获得最早的优惠票。<br>现在你得到了小轩最近的公共交通出行记录，你能帮他算算他的花费吗？</p><p><strong>解题思路</strong><br>一道模拟题，显而易见需要按照时间升序，因为如果超过45分钟就无效了。基于此应该想到可以利用优先队列（或类似）的数据结构来维护，每次坐公交，在所有价值大于本次票价的优惠券中优先使用过期时间最早的（不用就过期了！），价值最低的优惠券。一旦票过期了，就删掉，但是如果票只是价值不够，那可能后面还会有用，所以还要压回去。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> ty;</span><br><span class="line">ll t,price;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; rhs) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t == rhs.t) <span class="keyword">return</span> price &gt; rhs.price;</span><br><span class="line"><span class="keyword">return</span> t &gt; rhs.t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;rd[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"><span class="built_in">stack</span>&lt;Node&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">sort(rd+<span class="number">1</span>,rd+<span class="number">1</span>+n);</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(!rd[i].ty)&#123;</span><br><span class="line">res += rd[i].price, q.push(rd[i]);</span><br><span class="line"><span class="keyword">continue</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">Node x = q.top(); q.pop();</span><br><span class="line"><span class="keyword">if</span>(rd[i].t - x.t &gt; <span class="number">45</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(x.price &lt; rd[i].price)&#123;</span><br><span class="line">s.push(x); <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) res += rd[i].price;</span><br><span class="line"><span class="keyword">while</span>(s.size()) q.push(s.top()), s.pop(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;rd[i].ty,&amp;rd[i].price,&amp;rd[i].t);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="C-纪念品"><a href="#C-纪念品" class="headerlink" title="C.纪念品"></a>C.纪念品</h4><p><strong>题意描述</strong><br>小伟突然获得一种超能力，他知道未来 T 天 N 种纪念品每天的价格。某个纪念品 的价格是指购买一个该纪念品所需的金币数量，以及卖出一个该纪念品换回的金币数量。<br> 每天，小伟可以进行以下两种交易<strong>无限次</strong>：<br>任选一个纪念品，若手上有足够金币，以当日价格购买该纪念品；卖出持有的任意一个纪念品，以当日价格换回金币。<br> 每天卖出纪念品换回的金币可以<strong>立即</strong>用于购买纪念品，当日购买的纪念品也可以<strong>当日卖出</strong>换回金币。当然，一直持有纪念品也是可以的。<br>T 天之后，小伟的超能力消失。因此他一定会在第 T 天卖出<strong>所有</strong>纪念品换回金币。<br>小伟现在有 M 枚金币，他想要在超能力消失后拥有尽可能多的金币。 </p><p><strong>解题思路</strong><br>本题思路可以根据数据范围来想。这是一道动态规划题。<br>刚开始想到的是建立一张全图，但是后来发现节点数量不是 N 而是 NT ，并且总价值也不一定只能走一条路。<br>后来发现可以用动态规划解决，首先设 f[x]: 第x天能够赚到最多多少钱。那么显然f[1] = m，并且 f 是递增的。重点在于状态转移，f[ i ] 肯定是由 f[ 1~i-1 ] 推出来的，因为单独一个 f[i-1] 无法表示所有状态。<br>假设当前处于状态 j （j &lt; i），那么将第 j 天物品的价格看作花费，第 i 天的物品价格看作价值，这就是一个完全背包问题，背包容量是当天的金币数 f[j] 。<br>于是我们两层循环O(T^2)来计算 f[i] ，而每次计算需要O(MN) 做完全背包，但是实际测试效率还行，可能是数据太弱了。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e2</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,m;</span><br><span class="line"><span class="keyword">int</span> val[N][N];</span><br><span class="line"><span class="keyword">int</span> f[N];<span class="comment">//第 x 天最多有多少钱</span></span><br><span class="line"><span class="keyword">int</span> tmp[M],mx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">f[<span class="number">1</span>] = m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> day = <span class="number">2</span>;day &lt;= t;day++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; day;i++)&#123;</span><br><span class="line"><span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span> tmp); mx = m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v = val[i][j]; v &lt;= f[i];v++)&#123;</span><br><span class="line">tmp[v] = max(tmp[v-val[i][j]]+val[day][j],tmp[v]);</span><br><span class="line">mx = max(mx,tmp[v]+f[i]-v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f[day] = max(f[day],mx);</span><br><span class="line">&#125;</span><br><span class="line">f[day] = max(f[day],f[day<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for(int i = 1;i &lt;= t;i++) printf("%d\n",f[i]);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[t]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;t,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= t;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val[i][j]);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="D-加工零件"><a href="#D-加工零件" class="headerlink" title="D.加工零件"></a>D.加工零件</h4><p><strong>题意描述</strong></p><p>凯凯的工厂正在有条不紊地生产一种神奇的零件，神奇的零件的生产过程自然也很 神奇。工厂里有 𝑛 位工人，工人们从 1∼𝑛编号。某些工人之间存在双向的零件传送带。保证每两名工人之间最多只存在一条传送带。<br>如果 𝑥 号工人想生产一个被加工到第 𝐿(𝐿&gt;1) 阶段的零件，则所有与 𝑥 号工人 有传送带直接相连的工人，都需要生产一个被加工到第 𝐿 −1 阶段的零件（但 𝑥 号工 人自己无需生产第 𝐿 −1 阶段的零件）。<br>如果 𝑥 号工人想生产一个被加工到第 1 阶段的零件，则所有与 𝑥 号工人有传送 带直接相连的工人，都需要为 𝑥 号工人提供一个原材料。<br>轩轩是 1 号工人。现在给出 𝑞 张工单，第 𝑖 张工单表示编号为 𝑎𝑖的工人想生产 一个第 𝐿𝑖阶段的零件。轩轩想知道对于每张工单，他是否需要给别人提供原材料。他知道聪明的你一定可以帮他计算出来！</p><p><strong>解题思路</strong><br>经过推导可以发现，如果 a 号节点到 1 号节点（以下只用编号简写）之间存在一条小于 L 的路径，且它们的差为偶数（包括0），那么 1 就要提供原材料。<br>但是问题在于 1 到 a 之间可能不止一条路径，而 L 也不一定是奇或者偶，于是我们需要保存 a 到 1 的<strong>最短奇路径</strong>与<strong>最短偶路径</strong>。<br>在图论中，如果边权为1，那么求奇偶最短路径的好方法就是用分层图来做，具体做法是建立双层图，如果从起点不在同一层，则路径一定是奇，否则一定为偶；这样做的好处是不用额外的辅助代码，只要在建图时多加两条边就行了。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[M],ver[M],nex[M] ,tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="keyword">int</span> dis[N],vis[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[a] &lt;= l &amp;&amp; !((dis[a]&amp;<span class="number">1</span>) ^ (l&amp;<span class="number">1</span>))) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(dis[a+n] &lt;= l &amp;&amp; !((dis[a+n]&amp;<span class="number">1</span>) ^ (l&amp;<span class="number">1</span>))) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">que.push(s);</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(que.size())&#123;</span><br><span class="line"><span class="keyword">int</span> x = que.front(); que.pop();</span><br><span class="line">vis[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(dis[y] &gt; dis[x]+z)&#123;</span><br><span class="line">dis[y] = dis[x]+z;</span><br><span class="line"><span class="keyword">if</span>(!vis[y]) que.push(y),vis[y] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = getInt(); m = getInt(); q = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">addEdge(x,y+n,<span class="number">1</span>); addEdge(y+n,x,<span class="number">1</span>);</span><br><span class="line">addEdge(x+n,y,<span class="number">1</span>); addEdge(y,x+n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">SPFA(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//for(int i = 1;i &lt;= n&lt;&lt;1;i++) cout &lt;&lt; dis[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,a,l;i &lt;= q;i++)&#123;</span><br><span class="line">a = getInt(); l = getInt();</span><br><span class="line"><span class="keyword">if</span>(solve(a,l)) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;A-数字游戏&quot;&gt;&lt;a href=&quot;#A-数字游戏&quot; class=&quot;headerlink&quot; title=&quot;A.数字游戏&quot;&gt;&lt;/a&gt;A.数字游戏&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;题意描述&lt;/strong&gt;&lt;br&gt;小 K 同学向小 P 同学发送了一个长度为 8 的 01 
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="http://valenshi.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="图论" scheme="http://valenshi.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="分层图" scheme="http://valenshi.top/tags/%E5%88%86%E5%B1%82%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>CodeForce#600（Div2）解题报告</title>
    <link href="http://valenshi.top/2019/11/24/cf600/"/>
    <id>http://valenshi.top/2019/11/24/cf600/</id>
    <published>2019-11-24T04:30:03.000Z</published>
    <updated>2019-11-24T04:36:10.475Z</updated>
    
    <content type="html"><![CDATA[<h4 id="A-Single-Push"><a href="#A-Single-Push" class="headerlink" title="A. Single Push"></a>A. Single Push</h4><p><strong>题意简述：</strong><br>给定两个序列 a 和 b，要求从序列 a 中选出连续的一段[l , r] ，对这段上的每个位置+k（k &gt;= 0），试问只操作一次能否使得序列 a 变为序列 b 。<br><strong>解题思路：</strong><br>由于只能操作一次，所以难度大大下降，因此只需要顺序判断 a 是否只有一个区间和 b 不同，且差值全部相同且为负。<br><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span> + c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = a[i]-b[i];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(a[i] &amp;&amp; a[i] != a[i<span class="number">-1</span>]) cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt &lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">t = getInt();</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">n = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) b[i] = getInt();</span><br><span class="line"><span class="keyword">if</span>(solve()) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="B-Silly-Mistake"><a href="#B-Silly-Mistake" class="headerlink" title="B. Silly Mistake"></a>B. Silly Mistake</h4><p><strong>题意简述：</strong><br>定义一个连续的序列是合法的，当且仅当：</p><ul><li>有一个正数，就有一个负数，例如有 5 ，就要有 -5；</li><li>负数之前必须有它的正数，即 5 只能在 -5 前面；</li><li>每个数对仅出现一次，即 5 ，-5，5，-5是不合格法的。</li></ul><p>给定一个序列 a，其中ai &lt;= 1e6，请问可以将序列a分为多少个合法的子序列，并输出每个子序列的长度，若不存在划分方法，则输出-1，否则输出任意满足条件的答案。</p><p><strong>解题思路：</strong><br>需要在O(N)时间内解决，就是模拟题，只需要每次遍历到一个数就判断当且序列是否合法就行了，若合法就划分，否则或退出输出-1，或继续加入元素。<br>需要注意若用前缀和作为判断条件可能会超 int，需要用longlong，另外对于每个条件分支一定要仔细划分，避免遗漏出错。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp;(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span>+ c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[N],d[N],tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line">__int64 sum[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) sum[i] = sum[i<span class="number">-1</span>] + a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,pre = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(num[a[i]] != <span class="number">0</span> || vis[a[i]] &gt; pre) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">num[a[i]]++; vis[a[i]] = i;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num[-a[i]] != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">num[-a[i]]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum[i] == <span class="number">0</span>) d[++tot] = i-pre,pre = i;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sum[i] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!tot || sum[n]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tot);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; tot;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,d[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d[tot]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line"><span class="comment">// freopen("out","w",stdout);</span></span><br><span class="line">n = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line"><span class="keyword">if</span>(!solve()) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="C-Sweets-Eating"><a href="#C-Sweets-Eating" class="headerlink" title="C. Sweets Eating"></a>C. Sweets Eating</h4><p><strong>题意简述：</strong><br>给定一个序列 a，给定 m ，对于 k（k从1到n） ，要求从序列 a 中挑出k个元素，分为若干组，每组最多有m个元素，使得第一组 <em> 1，第二组 </em> 2，依次类推，使得它们的总和最小。</p><p><strong>解题思路：</strong><br>首先对序列 a 排序，易得要想总和最小，应该选出最小的 k 个元素。<br>假设要求的是 f(k) ，那么需要解决的是如何才能快速的从 f(k) 转移到 f(k+1)，如果暴力转移，是 O(k) 复杂度，因为要加上每一组最小的元素放到高一组去。我们可以利用前缀和来优化，具体做法是开一个sum数组，sum[i] 记录 %m 为 i 的元素和，我们从小到大依次将 a 序列中的元素加入，就可以在O(1)转移。</p><p><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span> + c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line">ll sum[N],ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;k++)&#123;</span><br><span class="line">ans[k] = ans[k<span class="number">-1</span>] + sum[k%m] + a[k];</span><br><span class="line">sum[k%m] += a[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">printf</span>(<span class="string">"%I64d "</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line"><span class="comment">// freopen("out","w",stdout);</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="D-Harmonious-Graph"><a href="#D-Harmonious-Graph" class="headerlink" title="D. Harmonious Graph"></a>D. Harmonious Graph</h4><p><strong>题意简述</strong><br>一个有 N 个点的无向图，节点分别标号为1~N。要求如果图中存在 l —&gt; r 的路径，那么对于所有的 m (l &lt; m &lt; r)都满足 l —&gt; m 。给定一张无向图，试问最少添加多少条边才能使得其满足要求。</p><p><strong>解题思路</strong><br>思路不难想，因为只要求若(l , r)是连通的，那么对于 l 到 r 内的所有点都应（至多）延伸出一条线构成一个连通分量，易得一张图最多需要 N-2 条边；很容易想到用并查集来做，将相连通的点放在同一个集合，分配一个编号。然后记录每个集合（连通分量）最后一个点的位置 ed ，然后只需要从前往后依次遍历，若当前节点在另一个集合的范围内，则合并两个集合并将 ans++；若当前集合可以更新有边界，则更新。<br>思路是正确的，但是被卡了好多次，错了很多细节，首先就是求集合‘编号’需要调用Find()函数，而不是直接访问par[]数组，par[]数组只是一个辅助数组而已；然后还有就是通过Merge()函数后，集合的编号可能会改变，因此按照集合的编号来存有边界是不合理的，应该再转化为按照位置来存。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> par[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(par[x] == x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> par[x] = Find(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = Find(x), b = Find(y);</span><br><span class="line"><span class="keyword">if</span>(a == b) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(a &lt; b) swap(a,b);</span><br><span class="line">par[a] = b;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span>+c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> vis[N],ed[N],ls[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) par[i] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">Merge(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt; <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(!ed[Find(i)]) ed[Find(i)] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) ls[i] = ed[Find(i)];</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>,last = ls[x] ,ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt; last &amp;&amp; Merge(x,i)) ans++;</span><br><span class="line"><span class="keyword">if</span>(ls[i] &gt; last)&#123;</span><br><span class="line">last = ls[i]; x = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;A-Single-Push&quot;&gt;&lt;a href=&quot;#A-Single-Push&quot; class=&quot;headerlink&quot; title=&quot;A. Single Push&quot;&gt;&lt;/a&gt;A. Single Push&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;题意简述：&lt;/strong&gt;&lt;b
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="并查集" scheme="http://valenshi.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="前缀和" scheme="http://valenshi.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>STL之map容器速率测试</title>
    <link href="http://valenshi.top/2019/11/16/mapDemo/"/>
    <id>http://valenshi.top/2019/11/16/mapDemo/</id>
    <published>2019-11-16T03:46:09.000Z</published>
    <updated>2019-11-16T03:46:50.788Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>不止一次在使用 map 时被卡时限，map 是 c++ 的 STL 中一个常用且方便的容器，其是基于树来实现的，它的插入与查找效率实际上更接近O(log N )（N为插入的元素个数）。当然在 c++ 的 STL 中还有用哈希实现的无序关联容器，这里不做讨论。<br>在实际应用中，常常会有人把 map 时间复杂度看作O(1)，确实在大多数时候 map 表现是令人满意的，但在大量使用的时候，map却不尽人意。</p><p>我们将测试如下几种情形下使用 map 容器的效率（时间）：</p><ul><li>仅插入元素（元素类型为int）</li><li>插入以及查找（元素类型为int）<h4 id="测试环境准备"><a href="#测试环境准备" class="headerlink" title="测试环境准备"></a>测试环境准备</h4></li></ul><p>为了给定一个对照的标准，先给出如下数据：</p><ul><li>测试机空循环 1e6 次平均花费 0.0641 s</li><li>测试机读取 1e6 个int型数据（快读+从文件输入）平均花费 0.2142 s</li></ul><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><h5 id="仅插入元素"><a href="#仅插入元素" class="headerlink" title="仅插入元素"></a>仅插入元素</h5><p><strong>本机平均花费时间：</strong> 1.1015 s<br><strong>测试代码</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> gap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">mp[i*gap%P] = <span class="number">1</span>; gap += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="插入以及查找元素"><a href="#插入以及查找元素" class="headerlink" title="插入以及查找元素"></a>插入以及查找元素</h5><p><strong>本机平均花费时间：</strong> 1.238 s<br><strong>测试代码</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> gap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">mp[i*gap%P] = <span class="number">1</span>; gap += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(mp.count(i));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总体上测试结果是符合预期的，虽然 STL 容器已经很优化的，但是毕竟还是用树来实现的，达不到 O(1) 的时间复杂度，所以如果是对时限要求很高的话，最好还是采用手动写哈希表。<br>上述设计的实验有很多缺陷，如未对 long long转化、取模 以及其它多余的操作进行排除影响，另外本来还测试了char、string、set等类型的元素，但是要设计一个好的测试代码太麻烦了，就删了，总的结论来说就是 int 是所有测试的数据类型中最慢的一种（甚至慢于 set 和 string ，如果只考虑插入和查找）。<br>最终结论就是如果需要一个 O(1) 时间复杂度的插入和查找（int 类型的元素），那么就用哈希表。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;不止一次在使用 map 时被卡时限，map 是 c++ 的 STL 中一个常用且方便的容器，其是基于树来实现的，它的插入与查找效率实际上更接
      
    
    </summary>
    
    
      <category term="map" scheme="http://valenshi.top/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>最大流笔记</title>
    <link href="http://valenshi.top/2019/11/15/maxFlow/"/>
    <id>http://valenshi.top/2019/11/15/maxFlow/</id>
    <published>2019-11-15T05:19:48.000Z</published>
    <updated>2019-11-15T05:21:49.131Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>正如可以通过将道路交通图模型化为有向图来找到从一个城市到另一个城市之间的最短路，我们也可以将一个有向图看作一个“流网络”，并使用它来回答关于物料流动方面的问题。这种流网络可以用来建模很多实际问题，包括液体在管道中的流动、装配线上的部件的流动、电网中电流的流动和通信网络中信息的流动。<br>本文首先介绍网络流中的相关概念，然后给出最大流问题的一般解法思路，以及优化后的算法。我们应该将主要精力放在思维锻炼和题目分析上，而不要过于执着于那些经典算法的细节优化。本文中整理的算法在算法竞赛中已经够用。</p><h4 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h4><p><strong>流网络：</strong> 流网络 G = (V , E) 是一个有向图，图中每条边 (u , v) 都有一个非负的<strong>容量值c(u , v)</strong> 。而且，如果边集合 E 包含一条边(u , v) ，则图中不存在反向边(v , u)。</p><p><strong>源节点s和汇点t：</strong> 在流网络的所有节点中，我们分辨出两个特殊的节点，分别是源点s和汇点t；源点是所有路径的起点，而汇点是路径的终点。在某些情况下，源点和汇点需要人为指定。</p><p><strong>流网络 G 中的流：</strong> G中流的大小（值）用 f 表示，f(u , v)表示从点 u 到点 v 的流的大小。整张图的流是 $|f| = \sum_{v \epsilon V}f(s, v) - \sum_{v \epsilon V}f(v ,s)$（前后两个 v 含义不同），即从源点 s 流出的流量和，或称为流入汇点 t 的流量和。</p><p><strong>容量限制：</strong> 对于所有的节点$u, v \epsilon V$，要求$0 &lt;= f(u , v) &lt;= c(u , v)$<br><strong>流量守恒：</strong> 对于所有的节点 $u \epsilon V$ - { s , t }，要求流入 u 的流量等于流出 u 的流量，即：</p><script type="math/tex; mode=display">\sum_{v \epsilon V}f(v,u) = \sum_{v \epsilon V}f(u,v)</script><p>（前后两个 v 的含义不同，一个是入边的起点，一个是出边的终点）</p><p><strong>问题模型：</strong> 在最大流问题中，给定一个流网络G 、一个源节点s、一个汇点t，我们希望找到值最大的一个流。</p><h4 id="Edmonds-Karp算法"><a href="#Edmonds-Karp算法" class="headerlink" title="Edmonds-Karp算法"></a>Edmonds-Karp算法</h4><p>若一条从源点 s 到汇点 t 的路径上的各条边的剩余容量都大于 0，则称这条路径为一条增广路径。显然，可以让一股流沿着增广路径从 s 流到 t，使网络的流量增大。Edmonds-Karp算法思想就是不断用BFS寻找增广路，直至网络上不存在增广路为止。<br>该算法的时间复杂度为$O(nm^2)$。然而在实际运用中则远远达不到这个上界，效率较高，一般能够处理 $10^3 - 10^4$规模的网络。</p><p><strong>算法思路：</strong><br>这里介绍的是利用 bfs 寻找增广路的Edmonds-Karp增广路算法。在该算法中，我们不断的寻找增广路，并增加增广路上的流；重复这一步骤直至不存在增广路。<br>在每轮寻找增广路的过程中，Edmonds-Karp算法只考虑图中所有 f(x ,y) &lt; c(x, y)的边，用BFS找到任意一条从 s 到 t 的路径，同时计算出路径上各边的剩余容量的最小值 minf，则网络的流量就可以增加 minf。</p><p>需要注意的是，当一条边的流量 f(x ,y) &gt; 0时，根据斜对称性质，它的反向边流量 f(y ,x) &lt; 0，此时必定有 f(y , x) &lt; c(y ,x)。故Edmonds-Karp算法在BFS时除了原图的边集 E 外，还应考虑遍历 E 中每条边的反向边。<br>具体实现时，本文采用邻接表“成对存储”技巧（即’2’和’3’是一对，’4’和’5’是一对）。每条边只记录剩余容量 c-f 即可，当一条边 (x ,y) 流过大小为 e 的流时，令 (x ,y) 的容量减少 e，(y ,x) 的容量增加 e 。</p><p><strong>代码模板：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;<span class="comment">//最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e3</span>+<span class="number">10</span>;<span class="comment">//最大边数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;<span class="comment">//int范围内的无穷大</span></span><br><span class="line"><span class="keyword">int</span> head[N], edge[M], ver[M], nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;<span class="comment">// 共n个点,m条边,s是源点,t是汇点</span></span><br><span class="line"><span class="keyword">int</span> pre[N],incf[N];<span class="comment">//增广路上各边的最小剩余容量</span></span><br><span class="line"><span class="keyword">bool</span> vis[N];<span class="comment">//标记数组</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(s); vis[s] = <span class="literal">true</span>;</span><br><span class="line">incf[s] = INF;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(!z || vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">incf[y] = min(incf[x],z);</span><br><span class="line">pre[y] = i;<span class="comment">//记录前驱*边*</span></span><br><span class="line">q.push(y); vis[y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(y == t) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//找到一条增广路</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回最大流的值*/</span></span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(bfs())&#123;</span><br><span class="line"><span class="keyword">int</span> x = t;</span><br><span class="line"><span class="keyword">while</span>(x != s)&#123;</span><br><span class="line"><span class="keyword">int</span> i = pre[x];<span class="comment">//前驱 *边* </span></span><br><span class="line">edge[i] -= incf[t];</span><br><span class="line">edge[i^<span class="number">1</span>] += incf[t];</span><br><span class="line">x = ver[i^<span class="number">1</span>];<span class="comment">//前驱点 = 反向边的终点</span></span><br><span class="line">&#125;</span><br><span class="line">flow += incf[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addEdge(x,y,z); addEdge(y,x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,EK());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>算法正确性需要用到最小割来证明，详见《挑战程序设计竞赛第二版》P212。</p><h4 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h4><p> 在任意时刻，网络中所有节点以及剩余容量大于0的边构成的子图被称为残量网络。Edmonds-Karp每轮可能会遍历整个残量网络，但只找出 1 条增广路，还有进一步优化的空间。<br> 在宽度优先遍历时，我们可以计算出<strong>节点的层次d[x]</strong> ，它表示 s 到 x 最少需要经过的边数。在残量网络中，满足d[y] = d[x] + 1 的边(x ,y) 构成的子图被称为<strong>分层图</strong> 。分层图显然是一张有向无环图。</p><p> Dinic 算法不断重复以下步骤，直到残量网络中 s 不能到达 t：</p><ol><li>在残量网络上 BFS 求出节点的层次，构造分层图</li><li>在分层图上 DFS 寻找增广路，在回溯时实时更新剩余容量。另外，每个点可以流向多条出边，同时还加入了若干剪枝，详情参考代码示例。</li></ol><p>Dinic 算法的时间复杂度是$O(n^2m)$。实际运用中远远达不到这个上界，可以说是比较容易实现的效率最高的网络流算法之一，一般能够处理$10^4 - 10^5$规模的网络。特别地，Dinic算法求解二分图最大匹配的时间复杂度为$O(m\sqrt n)$，实际表现则更快。</p><p> <strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;<span class="comment">//int所能表示的最大范围的一半</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5</span>*N;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[M],ver[M],nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> d[N];<span class="comment">//记录节点的层次</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*利用bfs来求出节点的层次，构造分层图*/</span></span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="keyword">while</span>(q.size()) q.pop();</span><br><span class="line">q.push(s); d[s] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(q.size())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(!z || d[y]) <span class="keyword">continue</span>;</span><br><span class="line">q.push(y);</span><br><span class="line">d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(y == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 利用递归在分层图上找增广路,返回本次增广的流量 */</span></span><br><span class="line"><span class="keyword">if</span>(x == t) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> res = flow, k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(z &amp;&amp; d[y] == d[x]+<span class="number">1</span>)&#123;</span><br><span class="line">k = dinic(y,min(res,z));<span class="comment">//递归</span></span><br><span class="line"><span class="keyword">if</span>(!k) d[y] = <span class="number">0</span>;<span class="comment">//剪枝,去掉增广完毕的点</span></span><br><span class="line">edge[i] -= k; edge[i^<span class="number">1</span>] += k;</span><br><span class="line">res -= k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow - res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addEdge(x,y,z); addEdge(y,x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>,maxflow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(bfs())</span><br><span class="line"><span class="keyword">while</span>(flow = dinic(s,INF)) maxflow += flow;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,maxflow);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="ISAP算法"><a href="#ISAP算法" class="headerlink" title="ISAP算法"></a>ISAP算法</h4><p>ISAP算法没有正式的名称，首次出现于 Ahuja和Orlin的经典教材《Network Flows：Theory，Algorithms and Applications》中，作者称它是一种：改进版的SAP（Improved SAP，ISAP）“。</p><p>该算法基于这样一个事实：每次增广后，任意节点到汇点（在残量网络中）的最短距离都不会减小。这样，我们可以用一个函数d(x)来表示残量网络中节点 x 到汇点的距离的下界（在Dinic中是用数组 d[]），然后在增广过程中不断修正这个下界（而不是像Dinic 算法那样多次增广以后才重建层次图），则增广的时候和 Dinic 类似，只允许沿着 d(y) = d(x) + 1 的有向边 (x , y) 走。</p><p>严格的说，算法中的 d 函数是满足如下两个条件的非负函数，即 d(t) = 0；对于残量网络中的任意弧 (x ,y)，d(x) &lt;= d(y) + 1。不难证明，只要满足这两个条件，d(x) 就是 x~t 距离的下界。而且当 d(s) &gt;= n时，残量网络中不存在 s-t 路。</p><p><strong>算法思路</strong><br>和 Dinic 算法类似，找增广路的过程是从 s 开始沿着“允许弧”（即在残量网络中的，满足 d[x] = d[y] + 1 的弧 x —&gt; y）往前走（ISAP 算法中叫Advance）如果走不动了怎么办？在Dinic算法中，直接“往回走一步”即可，因为如果找不到增广路，会重新构造层次图；但在ISAP中，并没有一个“一次性修改所有距离标号”的过程，只能边增广边修改。具体来说，在从结点 x 往回走的时候，把 d(x) 修改为 min{d(y) | (x , y)  是残量网络中的弧 } + 1（ISAP算法叫 Retreat）即可。注意，如果残量网络中从 x 出发没有弧，则设 d(x) = n。<br>ISAP算法看上去不难理解，但是实现起来却有诸多细节。首先，我们需要使用一种“当<br>前弧”的数据结构加速 允许弧 的査找，其次，还需要一个 gap 数组维护每个距离标号<br>结点编号。当把一个结点的距离标号从 x 改成 y 的时候,把 gap[x] 减1,gap[y]加1,然后<br>检查 gap[x] 是否为0。如果是 0 的话,说明 s-t 不连通，算法终止。这就是所谓的 gap 优化。最后，初始距离标号可以统一设为 0 ，也可以用逆向BFS找，单次运行时效率相差不大，但如果是多次求解小规模网络流，加上BFS以后速度往往会有明显提升。</p><p>数据结构方面，只多了两个数组：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[N];        <span class="comment">//可增广路的上一条弧</span></span><br><span class="line"><span class="keyword">int</span> gap[N];       <span class="comment">//距离标号计数</span></span><br></pre></td></tr></table></figure></p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5</span>*N;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">/*以下6行是数组模拟邻接表部分*/</span></span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot;</span><br><span class="line"><span class="keyword">int</span> cur[N],dis[N],gap[N],pre[N];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gap[k]:k层有多少个节点</span></span><br><span class="line"><span class="comment">pre[x]:x点前一条边的编号</span></span><br><span class="line"><span class="comment">cur[]是临时数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y, edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;</span><br><span class="line"><span class="keyword">int</span> que[N],front,rear;<span class="comment">//手工模拟队列，节省部分时间</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">front = rear = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">dis[i] = <span class="number">-1</span>,cur[i] = head[i],gap[i]= <span class="number">0</span>;</span><br><span class="line">dis[t] = <span class="number">0</span>;  que[rear++] = t;</span><br><span class="line"><span class="keyword">while</span>(front != rear)&#123;</span><br><span class="line"><span class="keyword">int</span> x = que[front++];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(dis[y] == <span class="number">-1</span>) </span><br><span class="line">que[rear++] = y, dis[y] = dis[x] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ~dis[t];<span class="comment">//-1的补码是11111111,按位取反后是0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ISAP</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = s, ans = <span class="number">0</span>, i;<span class="comment">//时刻注意i不能被覆盖！！！</span></span><br><span class="line">bfs(n);<span class="comment">//一次bfs从汇点向前更新层次数组dis</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= n;i++) gap[dis[i]]++;</span><br><span class="line"><span class="keyword">while</span>(dis[s] &lt; n)&#123;</span><br><span class="line"><span class="keyword">if</span>(k == t)&#123;</span><br><span class="line"><span class="keyword">int</span> mi = INF, loc = t;</span><br><span class="line"><span class="keyword">while</span>(loc != s)&#123;</span><br><span class="line">mi = min(mi,edge[pre[loc]]);</span><br><span class="line">loc = ver[pre[loc]^<span class="number">1</span>];<span class="comment">//前一个顶点</span></span><br><span class="line">&#125;</span><br><span class="line">loc = t;</span><br><span class="line"><span class="keyword">while</span>(loc != s)&#123;</span><br><span class="line">edge[pre[loc]] -= mi;</span><br><span class="line">edge[pre[loc]^<span class="number">1</span>] += mi;</span><br><span class="line">loc = ver[pre[loc]^<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">ans += mi, k = s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = cur[k];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(z &amp;&amp; dis[k] == dis[y]+<span class="number">1</span>)&#123;</span><br><span class="line">pre[y] = cur[k] = i; k = y;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> m = n;</span><br><span class="line"><span class="keyword">for</span>(i = head[k];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(z &amp;&amp; dis[y] &lt; m) m = dis[y], cur[k] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(--gap[dis[k]] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">dis[k] = m+<span class="number">1</span>, ++gap[dis[k]];</span><br><span class="line"><span class="keyword">if</span>(k != s) k = ver[pre[k]^<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;s,&amp;t))&#123;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">0</span> ,<span class="keyword">sizeof</span> head); tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addEdge(x,y,z); addEdge(y,x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ISAP(n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>刘汝佳，算法竞赛入门经典训练指南，北京：清华大学出版社，2012，362-363.</li><li>李煜东，算法竞赛进阶指南，郑州：河南电子音像出版社，2017，410-415.</li><li>秋叶拓哉，挑战程序设计竞赛第2版，北京：人民邮电出版社，2013，209-215.</li><li>Thomas H.Cormen，算法导论（原书第3版），北京：机械工业出版社，2013，414-417.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;正如可以通过将道路交通图模型化为有向图来找到从一个城市到另一个城市之间的最短路，我们也可以将一个有向图看作一个“流网络”，并使用它来回答关于
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="图论" scheme="http://valenshi.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="最大流" scheme="http://valenshi.top/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>伙伴算法</title>
    <link href="http://valenshi.top/2019/11/13/buddy-system/"/>
    <id>http://valenshi.top/2019/11/13/buddy-system/</id>
    <published>2019-11-13T12:13:59.000Z</published>
    <updated>2019-11-13T12:16:54.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="伙伴系统（Buddy-System）"><a href="#伙伴系统（Buddy-System）" class="headerlink" title="伙伴系统（Buddy System）"></a>伙伴系统（Buddy System）</h4><p><strong>伙伴系统的特点</strong></p><ul><li>整个可分配的分区大小为 $2^u$。</li><li>需要的分区大小为 $2^{u-1} &lt; s &lt;= 2^u$时，把整个块分配给该进程。</li></ul><p><strong>分配分区的过程：</strong><br>如果 $s &lt;= 2^{i-1}$，则将大小为$2^i$的当前空闲分区划分为两个大小为$2^{i-1}$的空闲分区<br>重复划分过程，直至$2^{i-1} &lt; s &lt;= 2^i$，并把一个空闲分区分配给该进程。</p><h4 id="伙伴系统的实现"><a href="#伙伴系统的实现" class="headerlink" title="伙伴系统的实现"></a>伙伴系统的实现</h4><p><strong>数据结构：</strong></p><ul><li>空闲块按照大小和起始地址组成二维数组。</li><li>初始状态：只有一个大小为$2^u$的空闲块。</li></ul><p><strong>分配过程：</strong></p><ul><li>由大到小在空闲块数组中找到最小的可用空闲块。</li><li>如果空闲块过大，对可用的空闲块进行二等分，直到得到合适的可用的空闲块。</li></ul><p><strong>分配样例图示：</strong><br><img src="/2019/11/13/buddy-system/1.png" alt="1"></p><p><strong>释放过程：</strong></p><ul><li>把释放的空闲块放入空闲数组</li><li>合并满足合并条件的空闲块</li></ul><p><strong>合并条件：</strong></p><ul><li>大小相同，例如都是$2^i$</li><li>地址相邻</li><li>低地址空闲块起始地址为$2^{i+1}$的位数</li></ul><h4 id="伙伴算法的优缺点"><a href="#伙伴算法的优缺点" class="headerlink" title="伙伴算法的优缺点"></a>伙伴算法的优缺点</h4><p><strong>优点：</strong></p><ul><li>较好的解决外部碎片问题</li><li>当需要分配若干个内存页面时，用于DMA的内存页面必须连续，伙伴算法很好的满足了这个要求</li><li>只要请求的块不超过512个页面（2k），内核就尽量分配连续的页面。</li><li>针对大内存分配设计</li></ul><p><strong>缺点：</strong></p><ul><li>合并的要求过于严格，只能是满足伙伴关系的块才能合并</li><li>碎片问题：一个连续的内存中仅仅一个页面被占用，导致整个内存区都不具备合并条件</li><li>浪费问题：伙伴算法只能分配2的幂次方内存区，当需要的内存为$2^i+1$ K 时，例如需要 9K 时，就需要分配16K的内存空间，剩下的 7K 浪费了。</li><li>算法的效率问题：伙伴算法中涉及了比较多的计算还有链表和位图的操作，开销比较大，如果每次合并$2^n$大小的块为$2^{n+1}$的小，那么大小为$2^n$的块会减少，如果随后系统又需要$2^n$大小的块，就又要拆分，这样的立即合并和拆分过程无效率。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;伙伴系统（Buddy-System）&quot;&gt;&lt;a href=&quot;#伙伴系统（Buddy-System）&quot; class=&quot;headerlink&quot; title=&quot;伙伴系统（Buddy System）&quot;&gt;&lt;/a&gt;伙伴系统（Buddy System）&lt;/h4&gt;&lt;p&gt;&lt;stron
      
    
    </summary>
    
      <category term="计算机操作系统" scheme="http://valenshi.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="内存分配" scheme="http://valenshi.top/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下vim简单入门</title>
    <link href="http://valenshi.top/2019/10/26/vim-use/"/>
    <id>http://valenshi.top/2019/10/26/vim-use/</id>
    <published>2019-10-26T02:34:59.000Z</published>
    <updated>2019-10-26T02:36:02.627Z</updated>
    
    <content type="html"><![CDATA[<h4 id="安装vim"><a href="#安装vim" class="headerlink" title="安装vim"></a>安装vim</h4><p>在ubuntu的命令行下输入<code>sudo apt install vim</code> 以获得vim。如遇到报错，可复制报错信息去百度寻找对应解决策略。</p><h4 id="vim的使用"><a href="#vim的使用" class="headerlink" title="vim的使用"></a>vim的使用</h4><p>vim编辑器有三种：命令模式，末行模式，插入模式。</p><p>打开vim时默认的是<strong>命令模式</strong>，此状态下敲击键盘视为输入命令而非字符。若想进入<strong>插入模式</strong>，则要在命令模式下输入 i ，此时可以输入字符，编辑文本；输入完毕后，按ESC可退回到命令模式。<br>命令模式只有一些简单的命令，更多命令需要使用末行模式；在命令模式下输入” : “（不含引号）可进入末行模式，末行模式可以进行更多灵活的操作。</p><p>以上是三种模式的异同以及切换方法。</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>以下复制老师的笔记：</p><p><strong>模式切换</strong></p><ol><li>输入i进入插入模式</li><li>在插入模式中按ESC进入命令模式</li><li>在命令模式中输入 “ : “ 进入末行模式</li></ol><p><strong>保存：</strong></p><ol><li>命令模式中输入ZZ</li><li>在末行模式中输入:wq</li></ol><p><strong>编译：</strong></p><ol><li>g++ -o test test.cpp -Wall</li></ol><p><strong>定位：</strong></p><ol><li>:i 定位到第 i 行</li><li>:/x 定位到x第一次出现的行</li></ol><p><strong>删除行（命令模式下）：</strong></p><ol><li>dd删除当前行</li><li>d2d删除包含当前行的2行，向下的</li></ol><p><strong>撤回：</strong></p><ol><li>命令模式下输入 u</li></ol><p><strong>复制（命令模式下）：</strong></p><ol><li>yy，与dd功能相似</li><li>粘贴时按p</li></ol><h4 id="配置vim"><a href="#配置vim" class="headerlink" title="配置vim"></a>配置vim</h4><p>此时vim可以正常使用，但是界面有些不友好，没有行号，缩进也很难看，更没有自动补全等。<br>我们可以通过在末行模式中输入一些命令来使得界面以及操作更加友好，例如添加行号，设置缩进等，但是这样需要每次打开vim都要重新配置，所以为了方便起见，可以修改配置文件达到自动配置的目的。</p><p>首先通过 <code>cd ~</code> 进入用户根目录，然后<code>vim .vimrc</code> 新建一个隐藏文件<code>.vimrc</code>，并打开编辑；输入如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">set nu          //显示行号</span><br><span class="line">set ts=4        //制表符宽度</span><br><span class="line">set history=1000    </span><br><span class="line">set showmatch   //高亮显示匹配的括号</span><br><span class="line">set ruler       //显示尺寸</span><br><span class="line">set mouse=a     //启用鼠标选择</span><br><span class="line">set autoindent  //自动缩进</span><br><span class="line">set cindent     //自动缩进</span><br><span class="line">set nobackup    //禁止生成临时文件</span><br><span class="line">set smartindent //自动缩进</span><br><span class="line">set shiftwidth=4    //自动缩进的长度</span><br><span class="line">set expandtab   //tab变空格</span><br><span class="line"></span><br><span class="line">//以下是自动补全</span><br><span class="line">inoremap&#123; &#123;&#125;&lt;ESC&gt;i&lt;CR&gt;&lt;ESC&gt;O</span><br><span class="line">inoremap( ()&lt;ESC&gt;i</span><br><span class="line">inoremap[ []&lt;ESC&gt;i</span><br><span class="line">inoremap&apos; &apos;&apos;&lt;ESC&gt;i</span><br><span class="line">inoremap&quot; &quot;&quot;&lt;ESC&gt;i</span><br><span class="line"></span><br><span class="line">set encoding=utf-8</span><br><span class="line">set softtabstop=4</span><br><span class="line"></span><br><span class="line">//定义F6快捷编译运行，在命令模式下</span><br><span class="line">map &lt;F6&gt; :cal CR() &lt;CR&gt;</span><br><span class="line">func! CR()</span><br><span class="line">exec &quot;w&quot;</span><br><span class="line">exec &quot;!g++ % -o %&lt;&quot;</span><br><span class="line">exec &quot;! ./%&lt;&quot;</span><br><span class="line">endfunc</span><br></pre></td></tr></table></figure></p><p>输入完成后按ESC进入命令模式，再 :wq 保存退出即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;安装vim&quot;&gt;&lt;a href=&quot;#安装vim&quot; class=&quot;headerlink&quot; title=&quot;安装vim&quot;&gt;&lt;/a&gt;安装vim&lt;/h4&gt;&lt;p&gt;在ubuntu的命令行下输入&lt;code&gt;sudo apt install vim&lt;/code&gt; 以获得vim。如遇到
      
    
    </summary>
    
      <category term="Linux" scheme="http://valenshi.top/categories/Linux/"/>
    
    
      <category term="vim" scheme="http://valenshi.top/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>单调栈与单调队列</title>
    <link href="http://valenshi.top/2019/10/17/ddz/"/>
    <id>http://valenshi.top/2019/10/17/ddz/</id>
    <published>2019-10-17T05:42:19.000Z</published>
    <updated>2019-10-17T05:42:57.769Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>单调栈和单调队列都可以看作是一种对栈和队列的特殊用法，即要求栈或队列中的元素具有单调性，递增或递减。那么很显然这种数据结构就是基于栈和队列实现的，即它既保留了栈的先进后出（队列就是保留先进先出），又具有单调性。而我们在某些时候正需要其这种性质，我们在讲解了单调栈和单调队列的定义、特性、构造方法后，会各给出一道例题来体现它们的用法。</p><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><h5 id="单调栈的概念"><a href="#单调栈的概念" class="headerlink" title="单调栈的概念"></a>单调栈的概念</h5><p>单调栈是一种特殊的栈，栈内的所有元素都保持着单调性，即单调递增或单调递减。</p><h5 id="单调栈的性质"><a href="#单调栈的性质" class="headerlink" title="单调栈的性质"></a>单调栈的性质</h5><ul><li>单调性。若是单调递增栈，则从栈顶到栈底的元素是严格递增的。若是单调递减栈，则从栈顶到栈底的元素是严格递减的。</li><li>靠近栈底的元素先进栈，越靠后的元素越后进栈。</li></ul><p>单调栈和普通的栈一样，都只能在栈顶操作，压入或弹出。而我们需要通过一些约束来使得栈内元素具有单调性，从而构成单调栈。</p><h5 id="构造单调栈"><a href="#构造单调栈" class="headerlink" title="构造单调栈"></a>构造单调栈</h5><p>以单调递增栈为例：对于当前元素e，若e大于栈顶元素，则进栈，否则弹出栈顶元素，再次进行比较，重复直至栈顶元素小于e或栈为空为止，此时将e压入栈。<br>对于弹出的元素，我们并不需要重新压回，因为一般情况下它们都属于被“淘汰”的元素，后面压入的元素一般又“新鲜”又“美味”，即时间上和数值上都比其优秀。</p><h5 id="例题HDU1506"><a href="#例题HDU1506" class="headerlink" title="例题HDU1506"></a>例题HDU1506</h5><p>先思考一个问题，如果题目中的矩形的高度都是单调递增的，如何得到最优解？显然有一个贪心的策略，就是以每一个矩形的高度作为最终大矩形的高度，看最宽能是多少，然后统计最优解。<br>但如果进来的下一矩形比上一个低，它其实相当于限制了之前矩形的高度，那么之前矩形比这个矩形高出的高度在以后的统计中就没有丝毫用处了，如果我们在这个时候把以之前矩形的高度作为最终高度的答案统计掉，那么反正以后的统计和上一个矩形没有关系，还不如把他删除。<br>这样，我们实际上就得到了单调栈的模型，只需要维护一个单调栈，在维护单调性的弹出操作时统计宽度，更新答案即可在O(n) 时间内得到最优解。<br>为了方便把最后剩下的，以及单调递增的矩形也统计进去，我们假设a[n+1]的位置有一个高度为0的矩形，最后将它加入单调栈时他会将所有矩形都弹出，那么答案也就完成最后的更新了。</p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><p>见附录部分code-1</p><h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>单调队列的概念和单调栈类似，只是把先进后出改成先进先出就可以了。其具有先进先出的特性并且队列中元素具有单调性。<br>单调是一种思想，当我们解决问题的时候发现有许多冗杂无用的状态时，我们可以采用单调思想，用单调队列或类似于单调队列的方法去除冗杂状态，保存我们想要的状态。</p><h5 id="单调队列的性质"><a href="#单调队列的性质" class="headerlink" title="单调队列的性质"></a>单调队列的性质</h5><ul><li>单调队列的最优选择在队首。</li><li>队列元素具有单调性。</li><li>去除冗余状态（无用状态）。</li><li>维护区间最值。</li></ul><h5 id="单调队列的构造方法"><a href="#单调队列的构造方法" class="headerlink" title="单调队列的构造方法"></a>单调队列的构造方法</h5><ul><li>维护队首（对于上题就是如果队首已经是当前元素的m个之前，则队首就应该被删了,head++）</li><li>在队尾插入（每插入一个就要从队尾开始往前去除冗杂状态，保持单调性）</li></ul><p>假如对于序列A：a1,  a2 , … an 建立一个单调递减栈维护长度为m的字段最大值，那么对于当前元素e，若队首元素小于e，那么其位置上不占优势（要被踢出长度为m的字段），而且其数值上也不占优势（比新来的e要小），所以其就要被舍弃。重复这一操作，直至队首元素大于元素e，那么说明其还有用，就保留。<br>举个应用例子：</p><p>数列为：6 4 10 10 8 6 4 2 12 14<br>N=10,K=3;<br>那么我们构造一个长度为3的单调递减队列：<br>首先，那6和它的位置0放入队列中，我们用(6,0)表示，每一步插入元素时队列中的元素如下<br>插入6：(6,0);<br>插入4：(6,0),(4,1);<br>插入10：(10,2);<br>插入第二个10，保留后面那个：(10,3);<br>插入8：(10,3),(8,4);<br>插入6：(10,3),(8,4),(6,5);<br>插入4，之前的10已经超出范围所以排掉：(8,4),(6,5),(4,6);<br>插入2，同理：(6,5),(4,6),(2,7);<br>插入12：(12,8);<br>插入14：(14,9);<br>那么f(i)就是第i步时队列当中的首元素：6,6,10,10,10,10,8,6,12,14同理，最小值也可以用单调队列来做。</p><h5 id="例题Poj-2823"><a href="#例题Poj-2823" class="headerlink" title="例题Poj 2823"></a>例题Poj 2823</h5><p>给定一个数列，从左至右输出每个长度为m的数列段内的最小数和最大数。数列长度：$N&lt;=10^6，m&lt;=N$<br><strong>解题思路：</strong><br>我们知道，暴力枚举的过程中，有一个地方是重复比较了，就是在找当前的f(i)的时候，i的前面其它m-1个数在算f(i-1)的时候我们就比较过了。当你一个个往下找时，每一次都是少一个然后多一个，如果少的不是最大值，然后再问新加进来的，看起来很省时间对吧，那么如果少了的是最大值呢？第二个最大值是什么？？那么我们能不能保存上一次的结果呢？当然主要是i的前k-1个数中的最大值了。答案是可以，这就要用到单调队列。</p><h5 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h5><p>见附录部分code-2</p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><h5 id="code-1：-HDU1506"><a href="#code-1：-HDU1506" class="headerlink" title="code-1： HDU1506"></a>code-1： HDU1506</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],n,Stack[N],w[N];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="function">ll <span class="title">max</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(Stack,<span class="number">0</span>,<span class="keyword">sizeof</span> Stack);</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;ans = <span class="number">0</span>;a[n+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(Stack[top] &lt; a[i])&#123;</span><br><span class="line">Stack[++top] = a[i];</span><br><span class="line">w[top] = <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">ll sumw = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(Stack[top] &gt; a[i])&#123;</span><br><span class="line">sumw += w[top];</span><br><span class="line">ans = max(ans,sumw*Stack[top]);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line">Stack[++top] = a[i];w[top] = sumw + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="code-2-Poj2823"><a href="#code-2-Poj2823" class="headerlink" title="code-2 Poj2823"></a>code-2 Poj2823</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;v[<span class="number">1010000</span>]; <span class="comment">//x表示值，y表示位置 可以理解为下标</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1010000</span>],n,m,mx[<span class="number">1010000</span>],mn[<span class="number">1010000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,head=<span class="number">1</span>,tail=<span class="number">0</span>;<span class="comment">// 默认起始位置为1 因为插入是v[++tail]故初始化为0</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail &amp;&amp; v[tail].x&gt;=a[i]) tail--;</span><br><span class="line">        v[++tail].x=a[i],v[tail].y=i;</span><br><span class="line">                <span class="comment">// 根据题目 前m-1个先直接进入队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail &amp;&amp; v[tail].x&gt;=a[i]) tail--;</span><br><span class="line">        v[++tail].x=a[i],v[tail].y=i;</span><br><span class="line">        <span class="keyword">while</span>(v[head].y&lt;i-m+<span class="number">1</span>) head++;</span><br><span class="line">        mn[i-m+<span class="number">1</span>]=v[head].x;</span><br><span class="line">               <span class="comment">// 道理同上，当然了 要把已经超出范围的从head开始排出</span></span><br><span class="line">               <span class="comment">//  然后每个队首则是目前m个数的最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmax</span><span class="params">()</span> <span class="comment">//最大值同最小值的道理，只不过是维护的是递减队列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail &amp;&amp; v[tail].x&lt;=a[i]) tail--;</span><br><span class="line">        v[++tail].x=a[i],v[tail].y=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail &amp;&amp; v[tail].x&lt;=a[i]) tail--;</span><br><span class="line">        v[++tail].x=a[i],v[tail].y=i;</span><br><span class="line">        <span class="keyword">while</span>(v[head].y&lt;i-m+<span class="number">1</span>) head++;</span><br><span class="line">        mx[i-m+<span class="number">1</span>]=v[head].x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    getmin();</span><br><span class="line">    getmax();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n-m+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"%d"</span>,mn[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" %d"</span>,mn[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n-m+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"%d"</span>,mx[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" %d"</span>,mx[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;单调栈和单调队列都可以看作是一种对栈和队列的特殊用法，即要求栈或队列中的元素具有单调性，递增或递减。那么很显然这种数据结构就是基于栈和队列实
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="单调栈" scheme="http://valenshi.top/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
      <category term="单调队列" scheme="http://valenshi.top/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>后缀数组题集</title>
    <link href="http://valenshi.top/2019/10/17/lcp-problems/"/>
    <id>http://valenshi.top/2019/10/17/lcp-problems/</id>
    <published>2019-10-17T05:13:33.000Z</published>
    <updated>2019-10-17T05:19:45.526Z</updated>
    
    <content type="html"><![CDATA[<p>sa[i]：排名为i的后缀起始位置是多少。<br>rank[i]：从 i 位置起始的后缀在所有后缀中字典序排序后序号，与sa互逆。<br>lcp[i]：S[sa[i] ,…] 与 S[sa[i+1] , …]的最长公共前缀。</p><h4 id="Musical-Theme"><a href="#Musical-Theme" class="headerlink" title="Musical Theme"></a>Musical Theme</h4><p><a href="http://poj.org/problem?id=1743" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给n个数组成的串，求是否有多个“相似”且不重叠的子串的长度大于等于5，两个子串相似当且仅当长度相等且每一位的数字差都相等。</p><p><strong>解题思路</strong><br>本题题意有些难理解。就是利用后缀数组+高度数组解决最长不重复子串问题，解法很套路，就是二分+判断。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POJ1743</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sa[N],rk[N],lcp[N],tmp[N];</span><br><span class="line"><span class="keyword">int</span> len,k;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= len?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= len?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line">len = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; len?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+len,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]]+compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j + h &lt; len &amp;&amp; i + h &lt; len;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(lcp[<span class="number">1</span>] &gt;= x) pre = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!pre &amp;&amp; lcp[i] &gt;= x) pre = i;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= x)<span class="comment">//注意一下到底是i还是i-1</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(sa[pre] - sa[i]) &gt; x) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(a,sa);</span><br><span class="line">construct_lcp(a,sa,lcp);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = n;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(++r &lt; <span class="number">5</span>) r = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n)&#123;</span><br><span class="line"><span class="comment">//注意，该模板必须从下标0开始存！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) b[i] = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) a[i] = b[i]-b[i<span class="number">-1</span>]+<span class="number">100</span>;</span><br><span class="line">a[<span class="number">0</span>] = b[<span class="number">0</span>]+<span class="number">100</span>; solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Milk-Patterns"><a href="#Milk-Patterns" class="headerlink" title="Milk Patterns"></a>Milk Patterns</h4><p><a href="http://poj.org/problem?id=3261" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>求可重叠的，出现k次的最长重复子串。<br><strong>解题思路</strong><br>这个就是可重叠的最长重复子串了，要求求出最长的，重复出现k次以上的子串，通过题意以及样例观察可知，是允许子串重复的。解决方法和上题类似，也是后缀数组+二分。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POJ3261</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,a[N],kk;</span><br><span class="line"><span class="keyword">int</span> rk[N],sa[N],lcp[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//别把全局变量的k覆盖了！！！</span></span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= x) cnt++;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt &gt;= kk) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt &gt;= kk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(a,sa);</span><br><span class="line">construct_lcp(a,sa,lcp);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line"><span class="comment">//for(int i = 1;i &lt;= n;i++) printf("%d ",lcp[i]);</span></span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;kk) != EOF)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="不同子串的个数"><a href="#不同子串的个数" class="headerlink" title="不同子串的个数"></a>不同子串的个数</h4><p><a href="https://www.luogu.org/problem/P2408" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给定一个字符串，求其所有子串中，不同的子串数量。</p><p><strong>解题思路</strong><br>利用后缀数组+高度数组求解。已知高度数组lcp，那么首先可以知道第一个sa[1]有n - sa[1]个不同子串；而2~n，每个sa[i] 有 n - sa[i] - lcp[i-1] 个不同子串。累加即可，注意结果可能爆 int。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P2408不同子串的个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> sa[N],lcp[N],tmp[N],k,rk[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line">sum = n - sa[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">sum += n - sa[i] - lcp[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line">construct_lcp(str,sa,lcp);</span><br><span class="line">calc();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">freopen(<span class="string">"123.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"222.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Substring"><a href="#Substring" class="headerlink" title="Substring"></a>Substring</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5769" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给定一个字符串，求所有不同的，且包含<strong>字符x</strong>的子串数量。</p><p><strong>解题思路</strong><br>和上一题有些类似，但是我们需要确保每一个被统计的子串包含字符x。那么我们可以用一个数组pos[p]来记录 p 后面第一个字符 x 的位置，那么我们从头开始统计时，sa[1]有n - pos[ sa[1] ] 个合法子串，其它位置有 n - max(pos[ sa[i] ] , sa[i] + lcp[i])个合法子串，将它们累加起来即可。<br>这题选G++编译器就超时，选C++就可以通过，猜测可能和STL有关。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hdu5769,G++超时,C++AC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">char</span> str[N],lv[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> rk[N],sa[N],lcp[N],tmp[N],k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pos[N];<span class="comment">//pos[x]:x后面第一个lv出现的位置</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line">construct_lcp(str,sa,lcp);</span><br><span class="line">pos[n] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(str[i] == lv[<span class="number">0</span>]) pos[i] = i;</span><br><span class="line"><span class="keyword">else</span> pos[i] = pos[i+<span class="number">1</span>];</span><br><span class="line">sum = n - pos[sa[<span class="number">1</span>]];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">sum += n - max(pos[sa[i]],sa[i]+lcp[i<span class="number">-1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>,++idx,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">freopen(<span class="string">"123.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"222.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,lv,str);</span><br><span class="line">n = <span class="built_in">strlen</span>(str);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Life-Forms"><a href="#Life-Forms" class="headerlink" title="Life Forms"></a>Life Forms</h4><p><a href="http://poj.org/problem?id=3294" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给定n个字符串，请问它们之间出现次数超过一半的最长公共子串是什么？如果有多个，按字典序输出。</p><p><strong>解题思路</strong><br>利用后缀数组+高度数组求解。我们将n个字符串拼接中一个“母串”，中间用不同的字符间隔；然后对母串求高度数组lcp，我们依旧是用二分搜索判定长度p是否合法，每次判定从前向后用O(N)时间遍历统计一遍即可。当我们得到最长的合法长度 p 后，再利用类似的方法输出所有的子串。</p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> str,s;</span><br><span class="line"><span class="keyword">int</span> n,k,len;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> sa[N],rk[N],lcp[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line">    <span class="keyword">int</span> ri = i+k &lt;= len?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> rj = j+k &lt;= len?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="built_in">string</span> S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line">    len = S.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line">        sa[i] = i;</span><br><span class="line">        rk[i] = i &lt; len ? S[i]:<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//k一定不能设置成局部变量导致覆盖全局变量！！！</span></span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= len;k *= <span class="number">2</span>)&#123;</span><br><span class="line">        sort(sa,sa+len+<span class="number">1</span>,compare_sa);</span><br><span class="line">        tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++)</span><br><span class="line">            tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="built_in">string</span> S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line">    len = S.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line">        <span class="keyword">for</span>(;j+h &lt; len &amp;&amp; i+h &lt; len;h++)</span><br><span class="line">            <span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">        lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">110</span>],idx[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    vis[idx[sa[<span class="number">1</span>]]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &lt; p)&#123;</span><br><span class="line">            cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!vis[idx[sa[i]]]) cnt++,vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= n/<span class="number">2</span>+<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    vis[idx[sa[<span class="number">1</span>]]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= len+<span class="number">1</span>;i++)&#123;  <span class="comment">//lcp[len+1] = 0,作为结束标志</span></span><br><span class="line">        <span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &lt; p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt;= n/<span class="number">2</span>+<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = sa[i<span class="number">-1</span>];j &lt; sa[i<span class="number">-1</span>]+p;j++) <span class="built_in">cout</span> &lt;&lt; str[j];</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!vis[idx[sa[i]]]) cnt++,vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    construct_sa(str,sa);</span><br><span class="line">    construct_lcp(str,sa,lcp);</span><br><span class="line">    <span class="comment">/*sa[i]：存放排名第i的后缀的起始位置*/</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"?"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> print(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; str; <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">2</span>,tot = <span class="number">0</span>; str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s; str += s+<span class="keyword">char</span>(++cnt);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= s.length();j++) idx[tot++] = i;</span><br><span class="line">        &#125; </span><br><span class="line">        solve();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Maximum-repetition-substring"><a href="#Maximum-repetition-substring" class="headerlink" title="Maximum repetition substring"></a>Maximum repetition substring</h4><p><strong>题意简述</strong><br>求一个字符串中，重复次数最多的连续重复子串是什么（循环次数最多的循环子串）。要求输出字典序最小的。</p><p>例如：ccabababc中，连续循环次数最多的子串是ababab。</p><p><strong>解题思路</strong><br>这题我对照题解写了很久，思想勉强搞懂。<br>先说做法，是枚举长度len（从1到n），然后判断以 len 为循环长度的 连续循环次数 最多的 子串 长度 是多少；假设这个子串长度是 l ，那么它的连续循环次数就是 l/len。<br>我们考虑如何求子串长度 l 。如果有一个字符串的循环节长度为len，那么必然有s[1,n-len] = s[len , n]，因此，如果字符串 s[len, n] 与 s[ 2 <em> len, n] 的公共前缀长度为 lcp，那么 s[len ,n] 的循环节个数为lcp / len + 1（加上的一个是开头为计算在lcp内的循环节 ）。<br>因此我们只需要对s[0] , s[len] ,s[2 </em> len] … , 判断相差 len 的两个相邻后缀的 lcp，就可以计算该子串循环节个数。这是由于如果一个子串的循环节长度为 len，且循环至少两次，那么显然它会包含相邻的两个len，否则就构不成循环了。当然可能起点并不在len的倍数位置上，因此我们还需要向前拓展一下。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> cse = <span class="number">0</span>,n;</span><br><span class="line"><span class="keyword">int</span> k,rk[N],lcp[N],sa[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]]+compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>],Log[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = lcp[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)</span><br><span class="line">st[i][j] = min(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &gt; r) swap(l,r); r--;</span><br><span class="line"><span class="keyword">int</span> kk = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> min(st[l][kk],st[r-(<span class="number">1</span>&lt;&lt;kk)+<span class="number">1</span>][kk]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mxtc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> q[N],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i+len &lt; n;i += len)&#123;</span><br><span class="line"><span class="keyword">int</span> l = ask(rk[i],rk[i+len]);</span><br><span class="line"><span class="keyword">int</span> res = l/len+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> pre = i - (len-l%len);</span><br><span class="line"><span class="keyword">if</span>(pre &gt;= <span class="number">0</span> &amp;&amp; ask(rk[pre],rk[pre+len]) &gt;= len) res++;</span><br><span class="line"><span class="keyword">if</span>(mxtc &lt; res) mxtc = res,cnt = <span class="number">0</span>,q[++cnt] = len;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(mxtc == res &amp;&amp; len != q[cnt]) q[++cnt] = len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAns</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= cnt;j++)</span><br><span class="line"><span class="keyword">if</span>(ask(rk[sa[i]],rk[sa[i]+q[j]]) &gt;= q[j]*(mxtc<span class="number">-1</span>))&#123;</span><br><span class="line">str[sa[i]+q[j]*mxtc] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">puts</span>(str+sa[i]); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line">construct_lcp(str,sa,lcp);<span class="comment">//lcp[n]是恒等于0的</span></span><br><span class="line"><span class="comment">/*下一步求重复次数最多的连续重复子串*/</span></span><br><span class="line">st_init();</span><br><span class="line">mxtc = cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) calc(i); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: "</span>,++cse);</span><br><span class="line">printAns();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str) != EOF)&#123;</span><br><span class="line">n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span> &amp;&amp; str[<span class="number">0</span>] == <span class="string">'#'</span>) <span class="keyword">break</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Common-Substrings"><a href="#Common-Substrings" class="headerlink" title="Common Substrings"></a>Common Substrings</h4><p><a href="http://poj.org/problem?id=3415" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给定2个字符串A和B，以及一个整数k。目标是求出这两个字符串中公共子串的数量，例如A:xx , B:xx，k = 1，那么公共子串数量就是5。<br><strong>解题思路</strong><br>将A和B拼接在一起，中间用一个未出现过的字符间隔，新串S = A+’#’+B；然后对S求高度数组，利用高度数组来求解。<br>对于属于 B 的每一个后缀，统计它与所有属于 A 的后缀的 lcp（最长公共前缀），并统计lcp-m+1，这就是该后缀和 A 的公共子串数量。这样做的复杂度是O(N^2)。</p><p>我们可以利用单调栈来在 O(N) 时间内解决；我们从前向后遍历lcp数组，将属于A的后缀的 lcp 压入栈；由于两个字符串的后缀是取它们中间的最小值，所以我们应该维护单调递减栈，同时需要维护的是 sum，sum代表当前 A 中相同的子串数量，也就是说如果当前后缀属于 B ，则直接加上sum即可。</p><p>由于我们是顺序遍历的，只统计了A对B的贡献，再反过来统计一次B对A的贡献即可。<br><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> A[N],B[N];</span><br><span class="line"><span class="keyword">int</span> rk[N],tmp[N],lcp[N],sa[N],k;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = i+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j =sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> idx[N];<span class="comment">//初始化为0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ll h,cnt;</span><br><span class="line">&#125;Stack[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(A,sa);</span><br><span class="line">construct_lcp(A,sa,lcp);</span><br><span class="line">ll ans = <span class="number">0</span>,sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ll cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top &amp;&amp; Stack[top].h &gt;= lcp[i<span class="number">-1</span>])&#123;</span><br><span class="line">cnt += Stack[top].cnt;</span><br><span class="line">sum -= Stack[top].cnt * (Stack[top].h-m+<span class="number">1</span>);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= m)&#123;</span><br><span class="line">cnt += idx[sa[i<span class="number">-1</span>]] == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt) Stack[++top] = Node&#123;lcp[i<span class="number">-1</span>],cnt&#125;;</span><br><span class="line">sum += (lcp[i<span class="number">-1</span>]-m+<span class="number">1</span>)*cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(idx[sa[i]] == <span class="number">1</span>) ans += sum;</span><br><span class="line">&#125;</span><br><span class="line">top = <span class="number">0</span>; sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ll cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top &amp;&amp; Stack[top].h &gt;= lcp[i<span class="number">-1</span>])&#123;</span><br><span class="line">cnt += Stack[top].cnt;</span><br><span class="line">sum -= Stack[top].cnt * (Stack[top].h-m+<span class="number">1</span>);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= m)&#123;</span><br><span class="line">cnt += idx[sa[i<span class="number">-1</span>]] == <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt) Stack[++top] = Node&#123;lcp[i<span class="number">-1</span>],cnt&#125;;</span><br><span class="line">sum += (lcp[i<span class="number">-1</span>]-m+<span class="number">1</span>)*cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!idx[sa[i]]) ans += sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m) != EOF &amp;&amp; m)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,A);</span><br><span class="line"><span class="built_in">memset</span>(idx,<span class="number">0</span>,<span class="keyword">sizeof</span> idx);</span><br><span class="line">n = <span class="built_in">strlen</span>(A); </span><br><span class="line">idx[n] = <span class="number">2</span>; A[n++] = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) idx[i] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,A+n);</span><br><span class="line">n = <span class="built_in">strlen</span>(A);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;sa[i]：排名为i的后缀起始位置是多少。&lt;br&gt;rank[i]：从 i 位置起始的后缀在所有后缀中字典序排序后序号，与sa互逆。&lt;br&gt;lcp[i]：S[sa[i] ,…] 与 S[sa[i+1] , …]的最长公共前缀。&lt;/p&gt;
&lt;h4 id=&quot;Musical-Them
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="后缀数组" scheme="http://valenshi.top/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
