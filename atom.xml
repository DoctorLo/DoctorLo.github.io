<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ValenShi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://valenshi.top/"/>
  <updated>2019-10-09T10:48:57.678Z</updated>
  <id>http://valenshi.top/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最小生成树相关问题</title>
    <link href="http://valenshi.top/2019/10/09/MSTs/"/>
    <id>http://valenshi.top/2019/10/09/MSTs/</id>
    <published>2019-10-09T10:47:52.000Z</published>
    <updated>2019-10-09T10:48:57.678Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>在对最小生成树算法有一定理解后，我们对典型的最小生成树题型应该不难解决，但是对于由最小生成树模型变形而来的几种模型，我们仍需做一次总结与记录。<br>首先我们需要提出最小生成树几个性质，便于推导算法；然后我们将介绍6种最小生成树相关问题模型，并讨论一般解法与更优解法；其中有的解法显而易见，接受起来也很简单，但有的解法却需要从理论上逻辑严密的进行推导，构造算法并证明算法的正确性，这部分难度稍大。<br>这6个相关问题分别是：增量最小生成树，最小瓶颈生成树，最小瓶颈路，每对节点的最小瓶颈路，次小生成树，最小有向生成树。</p><h4 id="图论中的2个性质："><a href="#图论中的2个性质：" class="headerlink" title="图论中的2个性质："></a>图论中的2个性质：</h4><ul><li><strong>切割性质：</strong> 假定所有边权均不相同。设S为既非空集也非全集的V的子集，边e是满足一个端点在S内，另一个端点不在S内的所有边中权值最小的一个，则图G的所有生成树均包含e。</li><li><strong>回路性质：</strong> 假定所有边权值均不相同。设C是图G中任意回路，边e是C上权值最大的边，则图G的所有生成树均不包含e。</li></ul><p>在此不给出证明。</p><h4 id="增量最小生成树"><a href="#增量最小生成树" class="headerlink" title="增量最小生成树"></a>增量最小生成树</h4><p><strong>问题描述：</strong><br>从包含n个点的空图开始，依次加入m条带权边。每加入一条边，输出当前图中的最小生成树权值（如果当前图不连通，则输出无解）。<br><strong>解题思路：</strong><br>如果每次重新求完整的最小生成树问题，总时间复杂度高达O(m^2 log n)。根据回路的性质，可以得到如下改进算法：</p><blockquote><p>每次求出新的最小生成树后，把其它的边删除。由于每次只需计算一个n条边（原生成树有 n - 1条，新加入一条）的图的最小生成树，Kruskal算法的时间复杂度降为O(n log n)，总时间复杂度为O(nm log n)。</p></blockquote><p>这个算法可以进一步改进:</p><blockquote><p>加入一条边e = (u, v)之后，图中恰好包含一个环。根据回路性质，删除该回路上权值最大的边即可，因此只需在加边之前的MST上找到u到v的唯一路径上的权值最大的边，再和e比较，删除权值较大的一条。由于路径唯一，可以用DFS或BFS找到这条u到v的路径，总时间复杂度为O(nm)。</p></blockquote><h4 id="最小瓶颈生成树"><a href="#最小瓶颈生成树" class="headerlink" title="最小瓶颈生成树"></a>最小瓶颈生成树</h4><p><strong>问题描述：</strong><br>给出加权无向图，求一棵生成树，使得最大边权值尽量小。</p><p><strong>解题思路：</strong><br>由于只关心最大边权值，我们可以从一个空图开始，按照权值从小到大的顺序依次加入各条边，则图第一次连通时，该图的最小生成树就是原图的最小瓶颈生成树。可以发现，原图的最小生成树就是一棵最小瓶颈生成树（但不是每棵最小瓶颈生成树都是最小生成树）。</p><h4 id="最小瓶颈路"><a href="#最小瓶颈路" class="headerlink" title="最小瓶颈路"></a>最小瓶颈路</h4><p><strong>问题描述：</strong><br>给定加权无向图的两个节点u和v，求出从u到v的一条路径，使得路径上最长边尽量短。</p><p><strong>解题思路：</strong><br>这个问题可以用二分法+BFS解决，但我们有更好的算法。先求出这个图的最小生成树，则起点和终点在树上的唯一路径就是我们要找的路径，这条路径上的最长边就是问题的答案。</p><h4 id="每对结点间的最小瓶颈路"><a href="#每对结点间的最小瓶颈路" class="headerlink" title="每对结点间的最小瓶颈路"></a>每对结点间的最小瓶颈路</h4><p><strong>问题描述：</strong><br>给出加权无向图，求每两个节点u和v之间的最小瓶颈路的最大边长f(u,v)。</p><p><strong>解题思路：</strong></p><blockquote><p>先求最小生成树。接下来，用DFS把最小生成树变成有根树，同时计算f(u,v)，当新访问一个节点u时，考虑所有已经访问过的老节点x，更新f(x,u) = max(f(x,v) , w(u,v))，其中v是u的父节点。每个f(u,v)只需经过常数时间计算，因此是时间复杂度为O(n^2)。</p></blockquote><h4 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a>次小生成树</h4><p><strong>问题描述：</strong><br>把所有生成树按照权值之和从大到小的顺序排列，求排在第二位的生成树。注意，如果最小生成树不唯一，次小生成树的权值与最小生成树相同。</p><p><strong>解题思路：</strong> </p><blockquote><p>次小生成树不会与最小生成树完全相同，因此可以枚举最小生成树中不在次小生成树中出现的边。注意最小生成树只有n-1条边，所以只需枚举n-1次。每次在剩下的边里求一次最小生成树，则这n-1棵“缺一条边的图”的最小生成树中权最小的就是原图的次小生成树。</p></blockquote><p>还有一种更好的方法：</p><blockquote><p>枚举要加入哪条新边。在最小生成树上加一条边u-v之后，图上会出现一条回路，因此删除的边必须在最小生成树上u到v的路径上，且是这条路径上的最长边。可以证明，次小生成树一定可以由最小生成树加一条边再删一条边得到（称为边交换），因此只需按照“每对节点之间的最小瓶颈路”的方法求出每对节点u和v在最小生成树中唯一路径的最大边权maxcost[u][v]，则剩下的部分只需要O(m)时间（枚举所有m-n+1条边进行交换，每次花O(1)时间求出新生成树的权值）。总时间复杂度为O(n^2)。</p></blockquote><h4 id="最小有向生成树"><a href="#最小有向生成树" class="headerlink" title="最小有向生成树"></a>最小有向生成树</h4><p><strong>问题描述：</strong><br>给定一个有向带权图G和其中一个节点u，找出一个以u为根节点，权和最小的有向生成树。有向生成树（directed spanning tree）也叫树形图（arborescence），是指一个类似树的有向图，满足以下条件：</p><ul><li>恰好有一个入度为0的点，称为根节点</li><li>其它节点的入度均为1</li><li>可以从根节点到达其它所有节点</li></ul><p>不难发现，如果树形图的节点数为n，它的边数一定为n-1，且树形图中不存在有向环。</p><p><strong>解题思路：</strong><br>固定根的最小树形图可以用朱-刘算法解决。</p><blockquote><p>首先是预处理，删除自环并判断根节点是否可以到达其它所有节点。如果不是，输出无解并终止程序。<br>接下来是算法的主过程：<br>首先，给所有非根节点选择一条权最小的入边。如果选出来的n-1条边不构成圈，则可以证明这些边就形成了一个最小树形图，否则把每个圈各收缩成一个点，继续上述过程。<br>缩圈之后，圈上所有边都消失了，因此在最终答案里需要加上这些边权之和。但这样做有个问题：假设在算法的某次迭代中，把圈C收缩为人工节点v，则在下一次迭代中，给v选择的入弧将与在圈C中的入弧发生冲突。（假设X在圈中已经有了入弧Y-&gt;X）因此如果收缩之后又选了一个入弧Z-&gt;X，必须把弧Y-&gt;X从最小树形图中删除。这等价于把弧Z-&gt;X的权值减少了Y-&gt;X的权值。</p></blockquote><h5 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h5><ul><li>刘汝佳，算法竞赛入门经典训练指南，北京：清华大学出版社，2012，343-344</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;在对最小生成树算法有一定理解后，我们对典型的最小生成树题型应该不难解决，但是对于由最小生成树模型变形而来的几种模型，我们仍需做一次总结与记录。&lt;br&gt;首先我们需要提出最小生成树几个性质，便于推导算法；然后我们将介绍6种最小生成
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线段树题集</title>
    <link href="http://valenshi.top/2019/10/07/segmentTree-problems/"/>
    <id>http://valenshi.top/2019/10/07/segmentTree-problems/</id>
    <published>2019-10-07T09:47:28.000Z</published>
    <updated>2019-10-07T09:51:23.835Z</updated>
    
    <content type="html"><![CDATA[<h4 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h4><p><strong>题意简述</strong><br>给定一数列，规定有两种操作，一是修改某个元素，二是求区间的连续和。<br><strong>解题思路</strong><br>线段树单点修改，区间查询的模板。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll dat;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dat(x) t[x].dat</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*为区间[l,r]建立以rt为根节点的子树*/</span></span><br><span class="line">l(rt) = l, r(rt) = r,dat(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid);</span><br><span class="line">BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">dat(rt) += val; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt) + r(rt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= mid) Add(rt*<span class="number">2</span>,p,val);</span><br><span class="line"><span class="keyword">else</span> Add(rt*<span class="number">2</span>+<span class="number">1</span>,p,val);</span><br><span class="line">dat(rt) = dat(rt*<span class="number">2</span>) + dat(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(rt) == l &amp;&amp; r(rt) == r) <span class="keyword">return</span> dat(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt) + r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> ask(rt*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r &lt;= mid) <span class="keyword">return</span> ask(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> ask(rt*<span class="number">2</span>,l,mid)+ask(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,k,a,b;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;k,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">if</span>(k) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(<span class="number">1</span>,a,b));</span><br><span class="line"><span class="keyword">else</span> Add(<span class="number">1</span>,a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="A-Simple-Problem-with-Integers"><a href="#A-Simple-Problem-with-Integers" class="headerlink" title="A Simple Problem with Integers"></a>A Simple Problem with Integers</h4><p><strong>题意简述</strong><br>这是一道模板题。</p><p>给定数列 a[1],a[2],…,a[n]，你需要依次进行 q 个操作，操作有两类：</p><p>C l r x：给定 l,r,x，对于所有 i∈[l,r]，将 a[i] 加上 x（换言之，将 a[l],a[l+1],…,a[r] 分别加上 x）；</p><p>Q l r：给定 l,r，求 ∑ri=la[i] 的值（换言之，求 a[l]+a[l+1]+⋯+a[r] 的值）。<br><strong>解题思路</strong><br>这题也是POJ3468。可以用很多种方法解决，是个练手的模板题。线段树区间修改+区间查询，延迟标记的简单使用。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll sum,add;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(x) t[x].add</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">l(rt) = l, r(rt) = r;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum(rt) = a[l]; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid); BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将延迟标记向下传一层*/</span></span><br><span class="line"><span class="keyword">if</span>(!add(p)) <span class="keyword">return</span>;</span><br><span class="line">sum(p*<span class="number">2</span>) += (r(p*<span class="number">2</span>)-l(p*<span class="number">2</span>)+<span class="number">1</span>)*add(p);</span><br><span class="line">sum(p*<span class="number">2</span>+<span class="number">1</span>) += (r(p*<span class="number">2</span>+<span class="number">1</span>)-l(p*<span class="number">2</span>+<span class="number">1</span>)+<span class="number">1</span>)*add(p);</span><br><span class="line">add(p*<span class="number">2</span>) += add(p); add(p*<span class="number">2</span>+<span class="number">1</span>) += add(p);</span><br><span class="line">add(p) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="comment">/*[l,r]内所有位置上元素都+val*/</span> </span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">sum(rt) += (r(rt)-l(rt)+<span class="number">1</span>)*val;</span><br><span class="line">add(rt) += val; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">spread(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) change(rt*<span class="number">2</span>,l,r,val);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) change(rt*<span class="number">2</span>+<span class="number">1</span>,l,r,val);</span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*回答[l,r]区间和*/</span> </span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> sum(rt);</span><br><span class="line">spread(rt); ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) res += ask(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) res += ask(rt*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,l,r,x;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'C'</span>)&#123;</span><br><span class="line">l = getInt(); r = getInt(); x = getInt();</span><br><span class="line">change(<span class="number">1</span>,l,r,x);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">l = getInt(); r = getInt();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(<span class="number">1</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="最大数"><a href="#最大数" class="headerlink" title="最大数"></a>最大数</h4><p><strong>题意简述</strong><br>原题来自：JSOI 2008</p><p>给定一个正整数数列 a1,a2,a3,⋯,an ，每一个数都在 0∼p–1 之间。可以对这列数进行两种操作：</p><p>添加操作：向序列后添加一个数，序列长度变成 n+1；</p><p>询问操作：询问这个序列中最后 L 个数中最大的数是多少。</p><p>程序运行的最开始，整数序列为空。写一个程序，读入操作的序列，并输出询问操作的答案。<br><strong>解题思路</strong><br>因为最多有N个数，那么先根据[1 , N]建立线段树，提前把位置空出来就好了，now指针记录最后一个位置，每次把新加入的元素插入++now，而询问最后L个数的最大值，则用ask(now - L , now)来查询即可，其它的就是线段树上维护区间最大值。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll mx;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mx(x) t[x].mx</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">l(rt) = l, r(rt) = r, mx(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid); BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">mx(rt) = val; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &gt; mid) change(rt*<span class="number">2</span>+<span class="number">1</span>,p,val);</span><br><span class="line"><span class="keyword">else</span> change(rt*<span class="number">2</span>,p,val);</span><br><span class="line">mx(rt) = max(mx(rt*<span class="number">2</span>),mx(rt*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> mx(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt) + r(rt)&gt;&gt;<span class="number">1</span> , res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) res = ask(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) res = max(res,ask(rt*<span class="number">2</span>+<span class="number">1</span>,l,r));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m,p,ans,now;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;p);</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,N<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%d"</span>,op,&amp;x);</span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'A'</span>) change(<span class="number">1</span>,++now,(x*<span class="number">1l</span>l+ans)%p);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans = ask(<span class="number">1</span>,now-x+<span class="number">1</span>,now));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="花神游历各国"><a href="#花神游历各国" class="headerlink" title="花神游历各国*"></a>花神游历各国*</h4><p><strong>题意简述</strong><br>原题来自：BZOJ 3211</p><p>花神喜欢步行游历各国，顺便虐爆各地竞赛。花神有一条游览路线，它是线型的，也就是说，所有游历国家呈一条线的形状排列，花神对每个国家都有一个喜欢程度（当然花神并不一定喜欢所有国家）。</p><p>每一次旅行中，花神会选择一条旅游路线，它在那一串国家中是连续的一段，这次旅行带来的开心值是这些国家的喜欢度的总和，当然花神对这些国家的喜欢程序并不是恒定的，有时会突然对某些国家产生反感，使他对这些国家的喜欢度 δ 变为 $\sqrtδ$（可能是花神虐爆了那些国家的 OI，从而感到乏味）。</p><p>现在给出花神每次的旅行路线，以及开心度的变化，请求出花神每次旅行的开心值。</p><p><strong>解题思路</strong><br>我刚开始想的是如何把修改延迟，但是后来发现不太容易实现。很容易的发现的就是1e9开根10次后就是1了（当然还有下取整），所以题目范围内所有数最多开根10次就会变成1或0，也就是说我们可以记录每个点被修改了多少次，如果已经修改了10次以上，那么再修改也无意义了。<br>于是我们可以每次修改都修改到叶子节点（因为无法延迟或整段修改），同时记录每个节点被修改了多少次，如果一段区间修改次数最小的节点都修改了10次，那么这一段区间就都不用修改了；这就会大大降低时间复杂度，因为每一个节点最多被修改10次，O(10NlogN)。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,mi;</span><br><span class="line">ll sum;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mi(x) t[x].mi</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">l(rt) = l,r(rt) = r,mi(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum(rt) = a[l]; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid); BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(mi(rt) &gt; <span class="number">10</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">sum(rt) = a[l(rt)] = <span class="built_in">sqrt</span>(a[l(rt)]); </span><br><span class="line">mi(rt)++; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt) + r(rt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) change(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) change(rt*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">mi(rt) = min(mi(rt*<span class="number">2</span>),mi(rt*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> sum(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>; ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) res += ask(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) res += ask(rt*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,op,l,r;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;op,&amp;l,&amp;r);</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(<span class="number">1</span>,l,r));</span><br><span class="line"><span class="keyword">else</span> change(<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="维护序列"><a href="#维护序列" class="headerlink" title="维护序列*"></a>维护序列*</h4><p><strong>题意简述</strong><br>原题来自：AHOI 2009</p><p>老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。</p><p>有长为 n 的数列，不妨设为 a1,a2,⋯,an 。有如下三种操作形式：</p><p>把数列中的一段数全部乘一个值；</p><p>把数列中的一段数全部加一个值；</p><p>询问数列中的一段数的和，由于答案可能很大，你只需输出这个数模 P 的值。</p><p><strong>解题思路</strong><br>这个如果修改操作只有 2 或 1，那么就是一个区间修改-延迟标记的模板题，但是它把“乘”和“加”操作放在了一起，当然还是需要用延迟标记来做，add表示待加上的值，mul表示待乘的值。<br>有一个问题，就是我们在向下传递延迟标记时，是先传递加法呢，还是乘法呢？其实问题的根源不在这，而在于我们在做乘法时，对加法的延迟标记也要乘 val，即 add = add * val，因为满足结合律。搞完这点剩下就是写起来比较麻烦而已，没别的难点了</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll add,mul,sum;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x) t[x].mul</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(x) t[x].add</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,P;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">l(rt) = l, r(rt) = r, add(rt) = <span class="number">0</span>, mul(rt) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum(rt) = a[l]; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid); BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread_add</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将累加标记向下传一层*/</span></span><br><span class="line"><span class="keyword">if</span>(!add(p)) <span class="keyword">return</span>;</span><br><span class="line">sum(p*<span class="number">2</span>) = (sum(p*<span class="number">2</span>) + (r(p*<span class="number">2</span>) - l(p*<span class="number">2</span>)+<span class="number">1</span>)*add(p)%P)%P;</span><br><span class="line">sum(p*<span class="number">2</span>+<span class="number">1</span>) = (sum(p*<span class="number">2</span>+<span class="number">1</span>) + (r(p*<span class="number">2</span>+<span class="number">1</span>) - l(p*<span class="number">2</span>+<span class="number">1</span>)+<span class="number">1</span>)*add(p)%P)%P;</span><br><span class="line">add(p*<span class="number">2</span>) = (add(p*<span class="number">2</span>) + add(p))%P; </span><br><span class="line">add(p*<span class="number">2</span>+<span class="number">1</span>) = (add(p*<span class="number">2</span>+<span class="number">1</span>)+add(p))%P; </span><br><span class="line">add(p) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread_mul</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将累乘标记向下传一层,累乘标记对累加标记也有影响*/</span> </span><br><span class="line"><span class="keyword">if</span>(mul(p) == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">sum(p*<span class="number">2</span>) = sum(p*<span class="number">2</span>)*mul(p)%P;</span><br><span class="line">sum(p*<span class="number">2</span>+<span class="number">1</span>) = sum(p*<span class="number">2</span>+<span class="number">1</span>)*mul(p)%P;</span><br><span class="line">mul(p*<span class="number">2</span>) = mul(p*<span class="number">2</span>)*mul(p)%P;</span><br><span class="line">mul(p*<span class="number">2</span>+<span class="number">1</span>) = mul(p*<span class="number">2</span>+<span class="number">1</span>)*mul(p)%P;</span><br><span class="line"><span class="comment">/*更新add标记*/</span> </span><br><span class="line">add(p*<span class="number">2</span>) = add(p*<span class="number">2</span>)*mul(p)%P;</span><br><span class="line">add(p*<span class="number">2</span>+<span class="number">1</span>) = add(p*<span class="number">2</span>+<span class="number">1</span>)*mul(p)%P; </span><br><span class="line">mul(p) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">add(rt) = add(rt)*val%P;<span class="comment">//更新add标记！ </span></span><br><span class="line">sum(rt) = sum(rt)*val%P;</span><br><span class="line">mul(rt) = mul(rt)*val%P;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">spread_mul(rt);spread_add(rt); </span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) Mul(rt*<span class="number">2</span>,l,r,val);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) Mul(rt*<span class="number">2</span>+<span class="number">1</span>,l,r,val);</span><br><span class="line">sum(rt) = (sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>))%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">sum(rt) = (sum(rt) + (r(rt)-l(rt)+<span class="number">1</span>)*val % P)%P;</span><br><span class="line">add(rt) = (add(rt)+val)%P; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">spread_mul(rt); spread_add(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) Add(rt*<span class="number">2</span>,l,r,val);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) Add(rt*<span class="number">2</span>+<span class="number">1</span>,l,r,val);</span><br><span class="line">sum(rt) = (sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>))%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> sum(rt)%P;</span><br><span class="line">spread_mul(rt); spread_add(rt) ;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) res += ask(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) res += ask(rt*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> res%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;P);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,a+i), a[i] %= P;</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,op,t,g,c;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op);</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;t,&amp;g,&amp;c);</span><br><span class="line">Mul(<span class="number">1</span>,t,g,c);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;t,&amp;g,&amp;c);</span><br><span class="line">Add(<span class="number">1</span>,t,g,c);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t,&amp;g);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(<span class="number">1</span>,t,g));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;区间和&quot;&gt;&lt;a href=&quot;#区间和&quot; class=&quot;headerlink&quot; title=&quot;区间和&quot;&gt;&lt;/a&gt;区间和&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;题意简述&lt;/strong&gt;&lt;br&gt;给定一数列，规定有两种操作，一是修改某个元素，二是求区间的连续和。&lt;br&gt;&lt;str
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="线段树" scheme="http://valenshi.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>一维RMQ问题题集</title>
    <link href="http://valenshi.top/2019/10/07/st-problems/"/>
    <id>http://valenshi.top/2019/10/07/st-problems/</id>
    <published>2019-10-07T05:10:12.000Z</published>
    <updated>2019-10-07T05:13:59.758Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/index.php" target="_blank" rel="noopener">书本配套OJ</a><br><a href="http://www.mfstem.org/" target="_blank" rel="noopener">本校OJ</a></p><p>ST表使用说明：</p><ul><li>常用于离线问题，或当作辅助数据结构，查询时间非常优秀，O(1)</li><li>二维st表也很好实现，不过本题集中未涉及</li><li>st表内也可以维护的是下标而非值，在某些时候很有用</li></ul><h4 id="数列区间最大值"><a href="#数列区间最大值" class="headerlink" title="数列区间最大值"></a>数列区间最大值</h4><p><strong>题意简述</strong><br>输入一串数字，给你 M 个询问，每次询问就给你两个数字 X,Y，要求你说出 X 到 Y 这段区间内的最大数。<br><strong>解题思路</strong><br>st表模板题。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>] ,Log[N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'-'</span> &amp;&amp; (c &lt;<span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i]= Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)&#123;</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="最敏捷的机器人"><a href="#最敏捷的机器人" class="headerlink" title="最敏捷的机器人"></a>最敏捷的机器人</h4><p><strong>题意简述</strong><br>Wind 设计了很多机器人。但是它们都认为自己是最强的，于是，一场比赛开始了……</p><p>机器人们都想知道谁是最敏捷的，于是它们进行了如下一个比赛。首先，他们面前会有一排共 n 个数，它们比赛看谁能最先把每连续 k 个数中最大和最小值写下来，当然，这些机器人运算速度都很快，它们比赛的是谁写得快。</p><p>但是 Wind 也想知道答案，你能帮助他吗？<br><strong>解题思路</strong><br>st表模板题，不过还要维护一下最小值，多开一个数组即可。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>] ,Log[N], st2[N][<span class="number">22</span>];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'-'</span> &amp;&amp; (c &lt;<span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i]= Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st2[i][<span class="number">0</span>] = st[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)&#123;</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">st2[i][j] = min(st2[i][j<span class="number">-1</span>],st2[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> mx = max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"><span class="keyword">int</span> mi = min(st2[l][k],st2[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,mx,mi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n-m+<span class="number">1</span>;i++) ask(i,i+m<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="与众不同"><a href="#与众不同" class="headerlink" title="与众不同*"></a>与众不同*</h4><p><strong>题意简述</strong><br>A 是某公司的 CEO，每个月都会有员工把公司的盈利数据送给 A，A 是个与众不同的怪人，A 不注重盈利还是亏本，而是喜欢研究「完美序列」：一段连续的序列满足序列中的数互不相同。<br>A 想知道区间 [L,R] 之间最长的完美序列长度。</p><p><strong>解题思路</strong><br>我们可以通过标记数组在O(N)时间内求出每个位置“作为结束位置”时的最长完美序列长度，以及它的起点。<br>设last[ x ] 表示 x 上次出现的位置；bgn[ p ]表示以位置 p 为末尾的完美序列的起点位置；len[p] 表示以位置 p 为末尾的完美序列的长度。显然我们可以在一次遍历内更新完毕上述三个数组，O(N)。<br>那么对于任意区间[ L , R ]，其内的最长完美序列长度仅有 2 种可能，一种是终点在区间内，起点不在；另一种是起点和终点都在区间内。此时我们已经可以通过一次遍历来求答案了，但是复杂度最差O(N)，不可取。由于bgn[]是单调递增的，所以对于某个位置 pos，[ L , pos-1] 所有位置上的起点都小于 L，[pos , R]上所有位置上的起点都大于L，那么我们可以通过ST表维护 [pos ,R] 上的最大的 len 值，在O(1)时间内求出，那么答案就是max(pos-L , ask(pos , R) )。</p><p>我们可以通过二分搜索来查找 pos ,复杂度 O(log N)，根据len数组构造st表，O(NlogN)，总时间复杂度O( (N+M)logN )。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">1e6</span>;</span><br><span class="line"><span class="comment">/*last[x]为x上一次出现的位置;</span></span><br><span class="line"><span class="comment">bgn[p]为以位置p结尾的起点位置;len[p]为以p结尾的完美序列长度*/</span></span><br><span class="line"><span class="keyword">int</span> last[SZ],bgn[N],len[N];</span><br><span class="line"><span class="keyword">int</span> a[N],Log[N],st[N][<span class="number">22</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_st</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = len[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;<span class="number">1</span>&lt;&lt;j &lt;= n;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(bgn[mid] &gt;= x) r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">bgn[i] = max(bgn[i<span class="number">-1</span>],last[a[i]+B]+<span class="number">1</span>);<span class="comment">//起始位置必须合法 </span></span><br><span class="line">len[i] = i - bgn[i] + <span class="number">1</span>;</span><br><span class="line">last[a[i]+B] = i;</span><br><span class="line">&#125;</span><br><span class="line">init_st();<span class="comment">//建立len数组的st表 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,p,res;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);x++,y++; </span><br><span class="line">p = bsearch(x,y,x);<span class="comment">//找到[x,y]内第一个bgn大于等于x的位置 </span></span><br><span class="line"><span class="keyword">if</span>(p &lt;= y) res = max(p-x,ask(p,y));</span><br><span class="line"><span class="keyword">else</span> res = p-x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="天才的记忆"><a href="#天才的记忆" class="headerlink" title="天才的记忆"></a>天才的记忆</h4><p><strong>代码示例：</strong> 模板模板，题面和思路不说了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>] ,Log[N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'-'</span> &amp;&amp; (c &lt;<span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i]= Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)&#123;</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt();;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">init(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Balanced-Lineup"><a href="#Balanced-Lineup" class="headerlink" title="Balanced Lineup"></a>Balanced Lineup</h4><p><strong>代码示例：</strong> 和“敏捷的机器人”一样，都是要维护最大以及最小值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>] ,Log[N], st2[N][<span class="number">22</span>];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'-'</span> &amp;&amp; (c &lt;<span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i]= Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st2[i][<span class="number">0</span>] = st[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)&#123;</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">st2[i][j] = min(st2[i][j<span class="number">-1</span>],st2[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> mx = max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"><span class="keyword">int</span> mi = min(st2[l][k],st2[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mx-mi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">ask(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="选择客栈"><a href="#选择客栈" class="headerlink" title="选择客栈*"></a>选择客栈*</h4><p><strong>题意描述</strong><br>丽江河边有 n 家很有特色的客栈，客栈按照其位置顺序从 1 到 n 编号。</p><p>每家客栈都按照某一种色调进行装饰（总共 k 种，用整数 0 k−1 表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。</p><p>两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。</p><p>晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 p 。</p><p>他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 p 元的咖啡店小聚。</p><p><strong>解题思路</strong><br>没看正解是啥，我没用到st表，不过倒是用到了求RMQ的步骤。<br>共三个辅助数组，col[k] 表示当前第k种颜色客栈的数量；val[x]表示客栈x的最低消费；mip[x]表示 [x, n] 内第一个最低消费小于等于 p 元的客栈位置。<br>如果第一个人入住客栈x，第二个人能够入住的旅店的位置一定是大于等于mip[x]的，并且要颜色和 x 相同，即col[ a[i] ]种选择方案。所以我们只需要从前往后顺序遍历一遍并统计答案即可，复杂度O(N)。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> col[K];</span><br><span class="line"><span class="keyword">int</span> n,m,p;</span><br><span class="line"><span class="keyword">int</span> a[N],val[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'-'</span> &amp;&amp; (c &lt;<span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mip[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">mip[n+<span class="number">1</span>] = n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(val[i] &gt; p) mip[i] = mip[i+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> mip[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">1</span>; ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> now = mip[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = pre;j &lt; now;j++) col[a[j]]--;</span><br><span class="line"><span class="comment">//printf("%d %d %d\n",pre,now,col[a[i]]);</span></span><br><span class="line">ans += col[a[i]]; pre = now;</span><br><span class="line"><span class="keyword">if</span>(now == i) ans--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt(); p = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= n;i++)&#123;</span><br><span class="line">a[i] = getInt(); val[i] = getInt(); </span><br><span class="line">col[a[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://ybt.ssoier.cn:8088/index.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;书本配套OJ&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.mfstem.org/&quot; target=&quot;_blan
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="st表" scheme="http://valenshi.top/tags/st%E8%A1%A8/"/>
    
      <category term="RMQ问题" scheme="http://valenshi.top/tags/RMQ%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>树状数组题集</title>
    <link href="http://valenshi.top/2019/10/06/BIT-problems/"/>
    <id>http://valenshi.top/2019/10/06/BIT-problems/</id>
    <published>2019-10-06T12:46:38.000Z</published>
    <updated>2019-10-07T11:19:59.049Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/index.php" target="_blank" rel="noopener">书本配套OJ</a><br><a href="http://www.mfstem.org/contests" target="_blank" rel="noopener">我校OJ</a><br><strong>树状数组知识点：</strong></p><ul><li>单点修改，区间求和，O(logN)。</li><li>区间修改，区间求和，O(logN)。</li><li>二维树状数组单点修改，子矩阵求和，时间复杂度O(logN * logN)，空间O(N^2)。</li></ul><p>与线段树相比功能比较单一，不够灵活，但胜在简短易写，可以用来打辅助。</p><p><strong>注意事项</strong></p><ul><li>树状数组修改的下标不能为0，因为 lowbit(0) = 0，这就死循环了。</li><li>注意树状数组的空间，这是由值域来决定的，而不是定义域。</li></ul><h4 id="数列操作"><a href="#数列操作" class="headerlink" title="数列操作"></a>数列操作</h4><p><strong>题目描述</strong><br>给定n个数列,规定有两种操作，一是修改某个元素，二是求子数列[a,b]的连续和。数列元素个数最多10万个，询问操作最多10万次。<br><strong>解题思路</strong><br>模板题。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,m; </span><br><span class="line">ll A[N],c[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">/*把第x位置上的数+y*/</span></span><br><span class="line"><span class="keyword">for</span>(;x &lt;= n;x += x&amp;-x) c[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回[1,x]元素和*/</span></span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x) res += c[x];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">int</span> k,a,b;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,A+i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Add(i,A[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;k,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">if</span>(k) Add(a,b);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(b)-ask(a<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="数星星-Stars"><a href="#数星星-Stars" class="headerlink" title="数星星 Stars"></a>数星星 Stars</h4><p><strong>题意简述</strong><br>给定 n 个点，定义每个点的等级是在该点左下方（含正左、正下）的点的数目，试统计每个等级有多少个点。<br>(详细描述见原题面)</p><p><strong>解题思路</strong><br>由于y是升序的，我们只需要记录比当前x小的star有多少个即可得知其等级 x ，然后用num[x]表示等级为x的星星个数，最终答案就是num数组。<br>CDQ分治也可以写，都是先将一维给变的有序，再统计另一维度。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c[N],n;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//若x=0则死循环 </span></span><br><span class="line"><span class="keyword">for</span>(;x &lt; N;x += x&amp;-x) c[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x) res += c[x];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">ans[ask(x+<span class="number">1</span>)]++;<span class="comment">//要注意x = 0这种情况 </span></span><br><span class="line">Add(x+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="校门外的树"><a href="#校门外的树" class="headerlink" title="校门外的树*"></a>校门外的树*</h4><p><strong>题意简述</strong></p><p>原题来自：Vijos P1448<br>校门外有很多树，学校决定在某个时刻在某一段种上一种树，保证任一时刻不会出现两段相同种类的树，现有两种操作：</p><ul><li>K=1，读入 l,r 表示在 l 到 r 之间种上一种树，每次操作种的树的种类都不同；</li><li>K=2，读入 l,r 表示询问 l 到 r 之间有多少种树。</li></ul><p><strong>解题思路</strong><br>刚开始以为是区间修改的题，后来发现不是。这题利用了差分数组的思想。如果我们假设c0[ x ] 存放 [1, x] 的左端点数量，c1[]存放右端点数量；如果所求区间为[l , r]，那么一共只可能有 6 种不同的线段：</p><ul><li>第一种是全在r右侧；</li><li>第二种是左端点在 [l ,r] 内，右端点在r右侧；</li><li>第三种是左右端点都在[l ,r] 内；</li><li>第四种是右端点在[l ,r]内，左端点在 l 左侧；</li><li>第五种是左右端点全在 l 左侧；</li><li>第六种是左端点在 l 左侧，右端点在 r 右侧。</li></ul><p>那么我们用 l 右侧所有的右端点的数量，减去 r 右侧左端点的数量，可以画图理解，简单。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,m; </span><br><span class="line">ll A[N],c[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> ty,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">/*把第x位置上的数+y*/</span></span><br><span class="line"><span class="keyword">for</span>(;x &lt; N;x += x&amp;-x) c[ty][x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> ty,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回[1,x]元素和*/</span></span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x) res += c[ty][x];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">int</span> k,a,b;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;k,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">Add(<span class="number">0</span>,a,<span class="number">1</span>); Add(<span class="number">1</span>,b,<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">/*分类讨论,所有线段共6种情况 */</span> </span><br><span class="line"><span class="keyword">int</span> t1 = ask(<span class="number">1</span>,N<span class="number">-1</span>) - ask(<span class="number">1</span>,a<span class="number">-1</span>); </span><br><span class="line"><span class="keyword">int</span> t2 = ask(<span class="number">0</span>,N<span class="number">-1</span>) - ask(<span class="number">0</span>,b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,t1-t2);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="清点人数"><a href="#清点人数" class="headerlink" title="清点人数"></a>清点人数</h4><p><strong>题意简述</strong><br>NK 中学组织同学们去五云山寨参加社会实践活动，按惯例要乘坐火车去。由于 NK 中学的学生很多，在火车开之前必须清点好人数。<br>初始时，火车上没有学生。当同学们开始上火车时，年级主任从第一节车厢出发走到最后一节车厢，每节车厢随时都有可能有同学上下。年级主任走到第 m 节车厢时，他想知道前 m 节车厢上一共有多少学生，但是他没有调头往回走的习惯。也就是说每次当他提问时，m 总会比前一次大。<br><strong>解题思路</strong><br>也是模板题。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c[N] ,n,k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;x &lt; N;x += x&amp;-x) c[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x) res += c[x];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= k;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'A'</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x); <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'B'</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y); Add(x,y);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y); Add(x,-y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h4><p><strong>题意简述</strong><br>题目来源：CQOI 2006<br>有一个 n 个元素的数组，每个元素初始均为 0。有 m 条指令，要么让其中一段连续序列数字反转——0 变 1，1 变 0（操作 1），要么询问某个元素的值（操作 2）。</p><p><strong>解题思路</strong><br>一个位置如果反转偶数次，那么它还是0，否则是1，因此我们只需要统计每个位置被反转了几次即可，用到了树状数组区间修改单点查询。树状数组区间修改的推导就不写了，书上有。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">2</span>][N],n,m ,num[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> ty,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;x &lt;= n;x += x&amp;-x) c[ty][x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> ty,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x) res += c[ty][x];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin); </span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line">z = getInt();</span><br><span class="line"><span class="keyword">if</span>(z == <span class="number">1</span>)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">Add(<span class="number">0</span>,x,<span class="number">1</span>); Add(<span class="number">0</span>,y+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">Add(<span class="number">1</span>,x,x); Add(<span class="number">1</span>,y+<span class="number">1</span>,-y<span class="number">-1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">y = getInt(); x = y;</span><br><span class="line"><span class="keyword">int</span> res = (y+<span class="number">1</span>)*ask(<span class="number">0</span>,y) - ask(<span class="number">1</span>,y) - x*ask(<span class="number">0</span>,x<span class="number">-1</span>) + ask(<span class="number">1</span>,x<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res&amp;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="打鼹鼠"><a href="#打鼹鼠" class="headerlink" title="打鼹鼠*"></a>打鼹鼠*</h4><p><strong>题意简述</strong><br>这是一道模板题。<br>给出一个 n×m 的零矩阵 A，你需要完成如下操作：<br>1 x y k：表示元素 Ax,y自增 k；<br>2 a b c d：表示询问左上角为 (a,b)，右下角为 (c,d) 的子矩阵内所有数的和。</p><p><strong>解题思路</strong><br>是二维树状数组模板题，但是空间卡的很紧，开到N = 5000就险过，开到N = (1&lt;&lt;12)+10就好了一点。<br>和vijos那个原题不同，数据不一样，范围也不一样，这题不会出现下标为0的情况。就注意一下二维更新和查询时，每次的y需要恢复原值即可，因此需要用个变量存放一下y初值。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = (<span class="number">1</span>&lt;&lt;<span class="number">12</span>)+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll c[N][N]; </span><br><span class="line"><span class="keyword">int</span> n ,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line"><span class="comment">//printf("%d %d %d\n",x,y,z);</span></span><br><span class="line"><span class="keyword">for</span>(;x &lt;= n;x += x&amp;-x)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> ty = y;ty &lt;= m;ty += ty&amp;-ty) c[x][ty] += z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> ty = y;ty;ty -= ty&amp;-ty) res += c[x][ty];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d,x,y,k,op;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op) != EOF)&#123;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">x = getInt(); y = getInt(); k = getInt();</span><br><span class="line">Add(x,y,k);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">a = getInt(); b = getInt(); c = getInt();d = getInt();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(c,d)-ask(c,b<span class="number">-1</span>)-ask(a<span class="number">-1</span>,d)+ask(a<span class="number">-1</span>,b<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://ybt.ssoier.cn:8088/index.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;书本配套OJ&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.mfstem.org/contests&quot; targe
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树状数组" scheme="http://valenshi.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="二维树状数组" scheme="http://valenshi.top/tags/%E4%BA%8C%E7%BB%B4%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="树状数组区间修改" scheme="http://valenshi.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9/"/>
    
  </entry>
  
  <entry>
    <title>AC自动机题集</title>
    <link href="http://valenshi.top/2019/10/06/ac-problems/"/>
    <id>http://valenshi.top/2019/10/06/ac-problems/</id>
    <published>2019-10-06T03:21:35.000Z</published>
    <updated>2019-10-06T03:22:54.780Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Keywords-Search"><a href="#Keywords-Search" class="headerlink" title="Keywords Search"></a>Keywords Search</h4><p><strong>题意描述</strong><br>原题来自：HDU 2222<br>给定 n 个长度不超过 50 的由小写英文字母组成的单词准备查询，以及一篇长为 m 的文章，问：文中出现了多少个待查询的单词。多组数据。<br><strong>解题思路</strong><br>模板题<br><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;<span class="comment">//模式串个数 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">10</span>;<span class="comment">//文本串长度 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[N][<span class="number">50</span>],s[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">50</span>*N;<span class="comment">//trie节点数 </span></span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],End[SZ],tot ;</span><br><span class="line"><span class="keyword">int</span> fail[SZ];<span class="comment">//失配指针,类似于nex</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="keyword">sizeof</span> trie);</span><br><span class="line"><span class="built_in">memset</span>(End,<span class="number">0</span>,<span class="keyword">sizeof</span> End); tot = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 向trie树中插入字符串s */</span> </span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*利用bfs更新fail数组*/</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) trie[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop();</span><br><span class="line"><span class="comment">//printf("%d\n",q.size());</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.push(trie[p][i]);</span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 统计匹配成功的模式串个数并累加到ans上 */</span> </span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">int</span> k = trie[p][ch];</span><br><span class="line"><span class="keyword">while</span>(k &gt; <span class="number">1</span>)&#123;</span><br><span class="line">ans += End[k]; End[k] = <span class="number">0</span>;</span><br><span class="line">k = fail[k];</span><br><span class="line">&#125;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t,n;<span class="comment">//数组组数, 模式串个数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line">getFail(); ans = <span class="number">0</span>;</span><br><span class="line">ask(s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">init();<span class="comment">//多组数据不要忘了初始化！ </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[i]);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="玄武密码"><a href="#玄武密码" class="headerlink" title="玄武密码"></a>玄武密码</h4><p><strong>题意描述</strong></p><p>原题来自：JSOI 2012<br>在美丽的玄武湖畔，鸡鸣寺边，鸡笼山前，有一块富饶而秀美的土地，人们唤作进香河。相传一日，一缕紫气从天而至，只一瞬间便消失在了进香河中。老人们说，这是玄武神灵将天书藏匿在此。很多年后，人们终于在进香河地区发现了带有玄武密码的文字。更加神奇的是，这份带有玄武密码的文字，与玄武湖南岸台城的结构有微妙的关联。于是，漫长的破译工作开始了。<br>经过分析，我们可以用东南西北四个方向来描述台城城砖的摆放，不妨用一个长度为 N 的序列来描述，序列中的元素分别是 E，S，W，N，代表了东南西北四向，我们称之为母串。而神秘的玄武密码是由四象的图案描述而成的 M 段文字。<br>现在，考古工作者遇到了一个难题。对于每一段文字，其前缀在母串上的最大匹配长度是多少呢？</p><p><strong>解题思路</strong><br>求每个子串在母串上的最大匹配长度。如果挨个用子串来匹配母串，复杂度太高，所以要用AC自动机，以母串来匹配子串。<br>将母串在建立好的AC自动机上进行匹配，那么其所能到达的节点，就是可以和母串匹配的长度，所以我们每到一个节点，就对其进行标记，顺便也对其fail指针所指向的节点标记，那么最后一个被标记的节点，就是该子串所能匹配的最大长度。</p><p>那么我们如何找到最后一个被标记的节点呢？通过par数组，par[x]存放x的父亲节点的编号，如此就可以从后向前遍历了（下述代码中是nex数组）。</p><p>所以具体步骤有三步：</p><ul><li>根据所有子串建立AC自动机，同时更新par数组(代码中是nex数组)</li><li>利用母串对自动机上节点进行标记</li><li>利用par数组自底向上查找最后一个被标记的节点，该节点到根节点的路径长度就是与母串最大匹配，为此我们还需要记录每个字串结束时的节点编号End[id]，以及长度Len[id]</li></ul><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s[N],str[M][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = M*<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">5</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> fail[SZ],vis[SZ],End[SZ],nex[SZ];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIdx</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ch == <span class="string">'E'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">'S'</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">'W'</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = getIdx(s[i]);</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot,nex[tot] = p;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) trie[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">q.push(trie[p][i]);</span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mark</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = getIdx(s[i]);</span><br><span class="line"><span class="keyword">int</span> k = trie[p][ch];</span><br><span class="line"><span class="keyword">while</span>(k &gt; <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[k]) <span class="keyword">break</span>;</span><br><span class="line">vis[k] = <span class="number">1</span>; k = fail[k];</span><br><span class="line">&#125;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str[x]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = End[x];i &gt; <span class="number">1</span>;i = nex[i],len--) <span class="keyword">if</span>(vis[i]) <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) End[i] = Insert(str[i]);</span><br><span class="line">getFail();</span><br><span class="line">Mark(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) search(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[i]);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Censoring"><a href="#Censoring" class="headerlink" title="Censoring"></a>Censoring</h4><p><strong>题意简述</strong><br>原题来自：USACO 2015 Feb. Gold<br>有一个长度不超过 105 的字符串 S。Farmer John 希望在 S 中删掉 n 个屏蔽词（一个屏蔽词可能出现多次），这些词记为 t1∼tn。FJ 在 S 中从头开始寻找屏蔽词，一旦找到一个屏蔽词，FJ 就删除它，然后又从头开始寻找（而不是接着往下找）。<br>FJ 会重复这一过程，直到 S 中没有屏蔽词为止。注意删除一个单词后可能会导致 S 中出现另一个屏蔽词。<br>这 n 个屏蔽词不会出现一个单词是另一个单词子串的情况，这意味着每个屏蔽词在 S 中出现的开始位置是互不相同的，请帮助 FJ 完成这些操作并输出最后的 S。<br><strong>解题思路</strong><br>可以用KM+栈来解决，这里用AC自动机解决。<br>很容易想到的一个思路就是，建立好AC自动机后，从根节点开始匹配，如果匹配到叶子节点，即有End标记的节点，就说明当前字串是屏蔽词，删掉它，假设该子串长为 len ，那就将指针 p 回退到 len 步之前，继续匹配。<br>如此一来我们需要记录每个时刻的p指针，以及母串中保留的字符，用栈就可以很好的维护。如果屏蔽词匹配成功，长度为 len，那么母串中保留的字符从栈顶弹出 len 个，同时保存 p 的栈也弹出 len 个元素，栈顶元素就是 len 步之前的指针。</p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N], s[N];</span><br><span class="line"><span class="keyword">int</span> n, fail[SZ];</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],tot = <span class="number">1</span>,End[SZ];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p] = len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) trie[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.push(trie[p][i]); </span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> path[N];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>,Stack[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">getFail();<span class="comment">//为什么非要更新Fail数组呢 </span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,p = <span class="number">1</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = str[i]-<span class="string">'a'</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">Stack[++top] = p; path[top] = str[i];</span><br><span class="line"><span class="keyword">if</span>(End[p]) top -= End[p], p = Stack[top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= top;i++) <span class="built_in">putchar</span>(path[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s); Insert(s);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h4><p><strong>题意简述</strong><br>原题来自：TJOI 2013<br>某人读论文，一篇论文是由许多单词组成。但他发现一个单词会在论文中出现很多次，现在想知道每个单词分别在论文中出现多少次。<br><strong>解题思路</strong><br>这个文章是由这 n 个单词组成的，现在问每个单词出现多少次。直接用母串在fail树上匹配统计相同前缀个数是不对的，因为这样可能出现两个子串的重叠。根据AC自动机的特点啊，如果有个节点 x 的 fail 指针指向 y，那么说明 y 是 x 的前缀，即 y 是 x 的子串，那么自然有多少个 fail 指针指向 y，y就出现了多少次，而这个次数就是我们要求的单词出现的次数。</p><p>那么首先要记录AC自动机上每个节点出现的次数，因为单词可能出现重复。然后要记录结束时该子串对应的节点编号，End[id] = p；由于我们 fail 指针是从上到下更新的，而我们要统计次数需要从下到上转移，于是利用栈来存储 fail 指针转移时的节点编号，而后再更新 num 数组即可。<br><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">220</span>;</span><br><span class="line"><span class="built_in">string</span> str[N], s;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],End[SZ],tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> num[SZ];<span class="comment">// num[x] 为经过节点x的数量 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="keyword">const</span> <span class="keyword">int</span>&amp; id)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = s.length(), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">num[p]++;</span><br><span class="line">&#125;</span><br><span class="line">End[id] = p; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> fail[SZ];</span><br><span class="line"><span class="keyword">int</span> Stack[SZ], top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) trie[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop(); </span><br><span class="line">Stack[++top] = p;<span class="comment">//倒序记录编号 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.push(trie[p][i]);</span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i],i);</span><br><span class="line">getFail();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = top;i &gt; <span class="number">0</span>;--i)&#123;</span><br><span class="line">num[fail[Stack[i]]] += num[Stack[i]];</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cout</span> &lt;&lt; num[End[i]] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; str[i];</span><br><span class="line">solve(); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最短母串"><a href="#最短母串" class="headerlink" title="最短母串"></a>最短母串</h4><p><strong>题意描述</strong><br>原题来自：HNOI 2006<br>给定 n 个字符串 S1,S2,⋯,Sn，要求找到一个最短的字符串 T，使得这 n 个字符串都是 T 的子串。<br><strong>解题思路</strong><br>根据经验容易想到，母串要走完AC自动机上所有 有结束标记（End标记）的节点，而本题的答案就是找到最短的&amp;字典序最小的母串。<br>那提到结束标记 End，就应该想到 End 标记的转移，我们在求fail数组时顺便转移。如果每个结束标记都用不同id标识，那么母串只要能包含所有不同的结束标记即可。</p><p>既然只有最多12个子串，那么可以考虑用状态压缩节省空间。我们用 bfs 来求最短&amp;字典序最小母串。<br>由于母串最长600，而AC自动机上节点个数最多600，但是每个节点状态有1&lt;&lt;12种，因此 <code>vis[606][(1&lt;&lt;12)+1]</code> 用于表示该节点的对应状态是否被访问过； path[(1&lt;&lt;12)+1]用于存放由上一个状态转移而来需要添加的字符；s[606]自然就是存放最终母串。<br>当然还需要一些辅助数组，par[ ip ]记录 ip 的上一个状态的编号，用于查找路径；当然理论上讲path也算辅助数组。<br>接下来我们就可以通过bfs来实现不同状态间的转移了，实质上是bfs+状态压缩，实现起来还是有些难度的。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">60</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">600</span>+<span class="number">10</span>;<span class="comment">//一定要想好大小啊 </span></span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n, fail[SZ];</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>], End[<span class="number">30</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">605</span>][(<span class="number">1</span>&lt;&lt;<span class="number">12</span>)+<span class="number">1</span>]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch]; </span><br><span class="line">&#125;</span><br><span class="line">End[p] |= <span class="number">1</span>&lt;&lt;id;<span class="comment">//状压常用 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) trie[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.push(trie[p][i]);</span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">End[trie[p][i]] |= End[fail[trie[p][i]]];<span class="comment">//常用技巧 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*用来bfs计算最短母串*/</span></span><br><span class="line"><span class="keyword">char</span> path[<span class="number">606</span>*(<span class="number">1</span>&lt;&lt;<span class="number">12</span>)] ,s[<span class="number">606</span>];</span><br><span class="line"><span class="keyword">int</span> par[<span class="number">606</span>*(<span class="number">1</span>&lt;&lt;<span class="number">12</span>)],len = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="comment">/*分别是节点编号,当前状态,当前字符位置 */</span> </span><br><span class="line"><span class="keyword">int</span> p,now,ip;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;Node&gt; q2; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">q2.push(Node&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q2.empty())&#123;</span><br><span class="line">Node x = q2.front(); q2.pop();</span><br><span class="line"><span class="keyword">int</span> p = x.p,now = x.now,ip = x.ip;</span><br><span class="line"><span class="keyword">if</span>(now == (<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="comment">/*所有子串都包含了,可以输出答案了*/</span> </span><br><span class="line"><span class="keyword">for</span>(;ip;ip = par[ip]) s[len++] = path[ip];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,nex;i &lt; <span class="number">26</span>;i++)</span><br><span class="line"><span class="keyword">if</span>(!vis[trie[p][i]][nex = now|End[trie[p][i]]])&#123;</span><br><span class="line"><span class="comment">/*当前节点的第i个字符的 nex 状态未被访问过,访问并压入队列*/</span> </span><br><span class="line">vis[trie[p][i]][nex] = <span class="number">1</span>;</span><br><span class="line">path[++cnt] = i+<span class="string">'A'</span>, par[cnt] = ip;</span><br><span class="line"><span class="comment">/*压入下一个节点的编号,状态,字符结束位置*/</span> </span><br><span class="line">q2.push(Node&#123;trie[p][i],nex,cnt&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">getFail(); bfs();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--) <span class="built_in">putchar</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str); Insert(str,i<span class="number">-1</span>); </span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="POI-2000-病毒"><a href="#POI-2000-病毒" class="headerlink" title="POI 2000 病毒"></a>POI 2000 病毒</h4><p><strong>题意简述</strong></p><p>二进制病毒审查委员会最近发现了如下的规律：某些确定的二进制串是病毒的代码。如果某段代码中不存在任何一段病毒代码，那么我们就称这段代码是安全的。现在委员会已经找出了所有的病毒代码段，试问，是否存在一个无限长的安全的二进制代码。<br>示例：例如如果 {011,11,00000} 为病毒代码段，那么一个可能的无限长安全代码就是 010101⋯。如果 {01,11,000000} 为病毒代码段，那么就不存在一个无限长的安全代码。<br>请写一个程序，读入病毒代码，判断是否存在一个无限长的安全代码，将结果输出。</p><p><strong>解题思路</strong><br>本题要求找出一个无限长的安全的代码，无限长，当且仅当我们有一个安全的子串可以循环使用时才能构成。我们将AC自动机看作树，从根出发，那么叶子节点，即有End标记的节点是不能走的，因为该路径构成了病毒。同样的道理，如果当前节点fail指针所指向的节点有End标记，那么当前节点也不能走，因为它的子串是病毒串，所以我们在更新fail指针时顺便转移End标记（常用技巧）。<br>所以如果有一条路径，它上面的所有节点都没有End标记，且该路径构成环，那么它就可以构成一个无限长的安全字符串。</p><p>于是我们就只需要在AC自动机上通过dfs来找是否存在满足条件的环即可，而用拓扑排序不太好写。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> str[N];</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">3</span>],End[SZ],fail[SZ],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = s.length(), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">bool</span> f[SZ];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line">trie[<span class="number">0</span>][<span class="number">0</span>] = trie[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.push(trie[p][i]);</span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">End[trie[p][i]] |= End[trie[fail[p]][i]];<span class="comment">//转移标记</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> vis[SZ],ins[SZ];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">vis[p] = ins[p] = <span class="number">1</span>;    <span class="comment">//ins判断环,vis访问标记</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> k = trie[p][i];</span><br><span class="line"><span class="keyword">if</span>(ins[k]) flag = <span class="literal">true</span>;<span class="comment">//构成环了,这里也可以return</span></span><br><span class="line"><span class="keyword">if</span>(!End[k] &amp;&amp; !vis[k]) dfs(k);<span class="comment">//下一个满足条件的节点,递归访问它</span></span><br><span class="line">&#125;</span><br><span class="line">ins[p] = <span class="number">0</span>;<span class="comment">//释放p节点的标记</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line">getFail();</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="built_in">cout</span> &lt;&lt; <span class="string">"TAK"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NIE"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; str[i];</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="文本生成器"><a href="#文本生成器" class="headerlink" title="文本生成器"></a>文本生成器</h4><p><strong>题意简述</strong></p><p>原题来自：JSOI 2007JSOI<br>交给队员 ZYX 一个任务，编制一个称之为「文本生成器」的电脑软件：该软件的使用者是一些低幼人群，他们现在使用的是 GW 文本生成器 v6 版。该软件可以随机生成一些文章――总是生成一篇长度固定且完全随机的文章——也就是说，生成的文章中每个字节都是完全随机的。<br>如果一篇文章中至少包含使用者们了解的一个单词，那么我们说这篇文章是可读的（我们称文章 a 包含单词 b，当且仅当单词 b 是文章 a 的子串）。但是，即使按照这样的标准，使用者现在使用的 GW 文本生成器 v6 版所生成的文章也是几乎完全不可读的。<br>ZYX 需要指出 GW 文本生成器 v6 生成的所有文本中可读文本的数量，以便能够成功获得 v7 更新版。你能帮助他吗？</p><p><strong>解题思路</strong><br>首先易得所有不同的文本总数为$26^m$种，我们有两种容易想到的思路来求解，一个是利用容斥原理直接计算可读的文章总数，另一种是想办法计算不可读的文章数，再用不同的文章总数减去它。第一种思路很难实现，主要来看第二种思路如何实现。<br>类似上一题，如果一个文章是不可读的，那么从根出发，它不能经过有End标记的节点，也不能经过“fail指针指向的节点有End标记”的节点。所以不可读的文章总数就等于长度为m的<strong>合法路径</strong>数。所谓的合法路径就是上面提到的，路径上所有节点都没有End标记，且其fail指针指向的节点也没End标记。<br>我们通过动态规划来求<strong>方案总数</strong>，设f(i,j)表示从根节点出发，走了 i 步到达节点 j 时的合法方案总数，那么显然 f(0 , 1) = 1，因为节点 1 是AC自动机的根节点。<br>状态转移方程请结合代码理解。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">6000</span>*<span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">65</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> str[N][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],End[SZ],fail[SZ],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) trie[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.push(trie[p][i]);</span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">End[trie[p][i]] |= End[trie[fail[p]][i]];<span class="comment">//标记转移 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">110</span>][SZ] ,ans ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAns</span><span class="params">()</span></span>&#123;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= tot;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(End[j]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">26</span>;k++)&#123;</span><br><span class="line"><span class="comment">/*f[i][trie[j][k]]的方案总数显然等于它所有父亲的方案总数的和*/</span></span><br><span class="line">f[i][trie[j][k]] = (f[i][trie[j][k]]+f[i<span class="number">-1</span>][j])%P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>,tmp = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot;i++) </span><br><span class="line"><span class="keyword">if</span>(!End[i]) res = (res+f[m][i])%P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) tmp = tmp*<span class="number">26</span>%P;</span><br><span class="line">ans = (tmp-res+P)%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line">getFail();</span><br><span class="line">getAns();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[i]);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Keywords-Search&quot;&gt;&lt;a href=&quot;#Keywords-Search&quot; class=&quot;headerlink&quot; title=&quot;Keywords Search&quot;&gt;&lt;/a&gt;Keywords Search&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;题意描述&lt;/stro
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="AC自动机" scheme="http://valenshi.top/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="状态压缩" scheme="http://valenshi.top/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>AC自动机模板</title>
    <link href="http://valenshi.top/2019/10/02/acji/"/>
    <id>http://valenshi.top/2019/10/02/acji/</id>
    <published>2019-10-02T03:06:43.000Z</published>
    <updated>2019-10-02T03:07:41.832Z</updated>
    
    <content type="html"><![CDATA[<h4 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h4><p>AC自动机是用来处理字符串匹配问题。KMP是处理单模式串匹配问题，而AC自动机是用于处理多模式串匹配问题，例如：给出 n 个单词，再给出一段包含 m 个字符的文章，问有多少个单词在文章中出现过？以下模板就是根据该问题整理。</p><p><strong>使用说明</strong><br>其中的trie树编号是从 1 开始，每次使用前都要初始化 tot = 1，以及trie数组、End数组都要初始化。<br>SZ设计要合理，SZ表示字典树中的节点数目上限，太多或太少都会运行错误。<br>本文利用queue来实现bfs，嫌慢可以手写模拟，不会麻烦多少。</p><p><strong>代码示例</strong><br><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1479" target="_blank" rel="noopener">Keywords Search</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;<span class="comment">//模式串个数 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">10</span>;<span class="comment">//文本串长度 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[N][<span class="number">50</span>],s[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">50</span>*N;<span class="comment">//trie节点数 </span></span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],End[SZ],tot ;</span><br><span class="line"><span class="keyword">int</span> fail[SZ];<span class="comment">//失配指针,类似于nex</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="keyword">sizeof</span> trie);</span><br><span class="line"><span class="built_in">memset</span>(End,<span class="number">0</span>,<span class="keyword">sizeof</span> End); tot = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 向trie树中插入字符串s */</span> </span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*利用bfs更新fail数组*/</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) trie[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop();</span><br><span class="line"><span class="comment">//printf("%d\n",q.size());</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.push(trie[p][i]);</span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 统计匹配成功的模式串个数并累加到ans上 */</span> </span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">int</span> k = trie[p][ch];</span><br><span class="line"><span class="keyword">while</span>(k &gt; <span class="number">1</span>)&#123;</span><br><span class="line">ans += End[k]; End[k] = <span class="number">0</span>;</span><br><span class="line">k = fail[k];</span><br><span class="line">&#125;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t,n;<span class="comment">//数组组数, 模式串个数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line">getFail(); ans = <span class="number">0</span>;</span><br><span class="line">ask(s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">init();<span class="comment">//多组数据不要忘了初始化！ </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[i]);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="对getFail-函数的一些解释"><a href="#对getFail-函数的一些解释" class="headerlink" title="对getFail()函数的一些解释"></a>对getFail()函数的一些解释</h5><p>fail 数组就像是 kmp 算法中的 nex 数组一样，是在失配时转移指针用的，利用它可以使得时间控制在O(N)。<br>就上述代码而言，我们是如何更新fail数组的呢？</p><ul><li>首先根节点若失配，则无法匹配字符，即 fail[1] = 0。</li><li>若当前位置有字符，则它的失配指针指向“它父亲节点失配指针所指向节点 的 下一个节点”，即 <code>fail[ trie[p][i] ]  = fail[ fail[p] ][i]</code>，其思想类似kmp中nex转移。</li><li>若当前位置无字符，即<code>trie[p][i] = 0</code>，那么就让当前节点指向其失配指针的子节点，即<code>trie[p][i] = trie[ fail[p] ][i]</code>。</li></ul><p>第 3 步破坏了 trie 的结构，但这样可以优化时间。若不存在<code>trie[p][i]</code> 的转移边则指向 <code>trie[ fail[p] ][i]</code>，因为在具体问题中，若不存在<code>trie[p][i]</code> 则需要沿着 p 的前缀指针走到第一个满足存在 i 字符的转移边的点 v，得到<code>trie[v][i]</code>，那么我们直接令 <code>trie[p][i] = trie[v][i]</code> 即可使得该情况得到优化，类似记忆化 &amp; 路径压缩。<br>也正是这个原因，我们在构建 fail 数组时，没有处理 v 的转移边 i 不存在的情况，而是直接<code>fail[ trie[p][i] = trie[v][i]</code>（其中 <code>trie[v][i]</code> 在之前已经处理好了）。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>董永建，信息学竞赛一本通提高版，福州：福建教育出版社，2018.6，93-97</li><li><a href="https://bestsort.cn/2019/04/28/402/" target="_blank" rel="noopener">bestsort</a>的博客</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;AC自动机&quot;&gt;&lt;a href=&quot;#AC自动机&quot; class=&quot;headerlink&quot; title=&quot;AC自动机&quot;&gt;&lt;/a&gt;AC自动机&lt;/h4&gt;&lt;p&gt;AC自动机是用来处理字符串匹配问题。KMP是处理单模式串匹配问题，而AC自动机是用于处理多模式串匹配问题，例如：给出
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="AC自动机" scheme="http://valenshi.top/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Trie字典树练习题集</title>
    <link href="http://valenshi.top/2019/09/30/trie-problems/"/>
    <id>http://valenshi.top/2019/09/30/trie-problems/</id>
    <published>2019-09-30T10:37:26.000Z</published>
    <updated>2019-09-30T14:59:47.512Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/index.php" target="_blank" rel="noopener">测试地址</a></p><h4 id="Phone-List"><a href="#Phone-List" class="headerlink" title="Phone List"></a>Phone List</h4><p>原题来自：POJ 3630<br>给定 n 个长度不超过 10 的数字串，问其中是否存在两个数字串 S,T，使得 S 是 T 的前缀，多组数据。</p><p><strong>解题思路</strong><br>Trie的经典应用，可以作为模板题练手。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>], tot;</span><br><span class="line"><span class="keyword">int</span> End[SZ];</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 将字串s插入trie树 */</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s) ,p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][ch] == <span class="number">0</span>) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 字串s是否有前缀 */</span> </span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(End[p]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(search(str[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n); </span><br><span class="line"><span class="comment">/* 初始化trie相关变量 */</span></span><br><span class="line"><span class="built_in">memset</span>(End,<span class="number">0</span>,<span class="keyword">sizeof</span> End); tot = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="keyword">sizeof</span> trie);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[i]);</span><br><span class="line"><span class="keyword">if</span>(solve()) <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="The-XOR-Largest-Pair"><a href="#The-XOR-Largest-Pair" class="headerlink" title="The XOR Largest Pair"></a>The XOR Largest Pair</h4><p><strong>题意简述</strong><br>在给定的 N 个整数 A1,A2,…,AN 中选出两个进行异或运算，得到的结果最大是多少？</p><p><strong>解题思路</strong><br>就是将每个整数看作31位的01字符串，然后全部插入到Trie上，再分别对每个整数从高位到低位优先在Trie上走和该位相反的节点。01字典树。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">5e6</span>+<span class="number">10</span>;<span class="comment">//大小要合理！！！ </span></span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">3</span>], End[SZ], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][ch] == <span class="number">0</span>) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][!ch]) p = trie[p][!ch], res |= <span class="number">1</span>&lt;&lt;i;</span><br><span class="line"><span class="keyword">else</span> p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) calc(a[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Codechef-REBXOR"><a href="#Codechef-REBXOR" class="headerlink" title="Codechef REBXOR*"></a>Codechef REBXOR*</h4><p><strong>题意简述</strong><br><img src="/2019/09/30/trie-problems/1.png" alt="trie-problems/1.png"><br><strong>解题思路</strong><br>这题用的是 “Trie维护异或前缀和”，根据异或的特性，我们从左到右依次将元素插入后，再利用 x^y^x = y 这个特性在常数时间利用 Trie 找最大区间异或和。本题还是很有参考意义的，尤其是异或前缀和这一技巧。<br>当然由于OJ上给定的空间过小，本代码没过，待解决。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">20</span>*N;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">3</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],lmx[N],rmx[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">32</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">32</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][!ch]) p = trie[p][!ch],res |= <span class="number">1</span>&lt;&lt;i;</span><br><span class="line"><span class="keyword">else</span> p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;Insert(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/* x 用于累计异或前缀和,Trie用于求最大异或区间*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">x ^= a[i]; Insert(x);</span><br><span class="line">lmx[i] = max(search(x),lmx[i<span class="number">-1</span>]);</span><br><span class="line"><span class="comment">//包含x的最大区间异或和 与  不包含x的区间的最大异或和 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="keyword">sizeof</span> trie); tot = <span class="number">1</span>;</span><br><span class="line">Insert(<span class="number">0</span>); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">x ^= a[i]; Insert(x);</span><br><span class="line">rmx[i] = max(search(x),rmx[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) ans = max(ans,lmx[i]+rmx[i+<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Immediate-Decodability"><a href="#Immediate-Decodability" class="headerlink" title="Immediate Decodability"></a>Immediate Decodability</h4><p><strong>题意简述</strong><br>原题来自：ACM Pacific NW Region 1998<br>给出一些数字串，判断是否有一个数字串是另一个串的前缀。<br><strong>解题思路</strong><br>和第1题一样，模板题。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> End[SZ];</span><br><span class="line"><span class="keyword">int</span> n,t,cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 将字串s插入trie树 */</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s) ,p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][ch] == <span class="number">0</span>) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 字串s是否有前缀 */</span> </span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(End[p]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(search(str[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[++n]) != EOF)&#123;</span><br><span class="line"><span class="comment">/* 初始化trie相关变量 */</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(str[n]) == <span class="number">1</span> &amp;&amp; str[n][<span class="number">0</span>] == <span class="string">'9'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!solve()) <span class="built_in">printf</span>(<span class="string">"Set %d is immediately decodable\n"</span>,++cnt);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Set %d is not immediately decodable\n"</span>,++cnt);</span><br><span class="line"><span class="built_in">memset</span>(End,<span class="number">0</span>,<span class="keyword">sizeof</span> End); tot = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="keyword">sizeof</span> trie); n = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="L语言"><a href="#L语言" class="headerlink" title="L语言*"></a>L语言*</h4><p><strong>题意简述</strong></p><p>原题来自：HNOI 2004<br>标点符号的出现晚于文字的出现，所以以前的语言都是没有标点的。现在你要处理的就是一段没有标点的文章。<br>一段文章 T 是由若干小写字母构成。一个单词 W 也是由若干小写字母构成。一个字典 D 是若干个单词的集合。<br>我们称一段文章 T 在某个字典 D 下是可以被理解的，是指如果文章 T 可以被分成若干部分，且每一个部分都是字典 D 中的单词。例如字典 D 中包括单词 is , your , what , name ，则文章 whatisyourname 是在字典 D 下可以被理解的，因为它可以分成 4 个单词： what , is , your , name ，且每个单词都属于字典 D，而文章 whatisyouname 在字典 D 下不能被理解，但可以在字典 D′=D+you 下被理解。这段文章的一个前缀 whatis ，也可以在字典 D 下被理解 而且是在字典 D 下能够被理解的最长的前缀。<br>给定一个字典 D ，你的程序需要判断若干段文章在字典 D 下是否能够被理解。 并给出其在字典 D 下能够被理解的最长前缀的位置。<br><strong>解题思路</strong><br>这题有点难的地方是  文章中某个前缀可能由多个单词组合出来，于是我们需要对每个可能是单词末尾的位置再进行下一次匹配，检查其后是否有字典D中的单词。</p><p>我们首先将所有单词插入字典树，由于单词长度小于10，所以对于每个单词，我们最多比较10次就能知道该字串是否为字典D中的单词。每次匹配都要从字典树的根开始匹配。<br>我们设f[i]表示 “文章中第 i 位是否为可以被D理解的某个前缀的末尾”；如果 f[i] 为 1 ，那么说明[1, i]都可以被D理解，接下来只要再从 i+1 位开始尝试在字典树匹配单词即可。<br>这是存在性DP，状态转移很简单，在字典树查找单词时，若当前位置是某个单词的末尾，即End[ p ] = 1，那么f[ pos ] = 1（pos为当前字符位置），时间复杂度为O(10N)。</p><p><strong>优化</strong><br>在 查找/匹配 单词时，我习惯将其封装为一个函数search(char * s)，但是最差情况我们会调用1e6次该函数，虽然该函数内最多只比较10次，但是函数传参以及保护现场以及恢复等步骤还是会大大增加花费的时间。经过测试，写成函数调用形式在1e6数据下大概会比直接展开慢几十秒，当然还是可以通过一些步骤优化函数调用的。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],End[SZ], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> str[N],s[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">bool</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str)<span class="number">-1</span>, ans;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f); f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//printf("%d\n",len);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!f[i]) <span class="keyword">continue</span>;</span><br><span class="line">ans = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>,p = <span class="number">1</span>;j &lt;= len;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = str[j]-<span class="string">'a'</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line"><span class="keyword">if</span>(!p) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(End[p]) f[j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s); Insert(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'#'</span>; solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Secret-Message-秘密信息"><a href="#Secret-Message-秘密信息" class="headerlink" title="Secret Message 秘密信息"></a>Secret Message 秘密信息</h4><p><strong>题意描述</strong><br>原题来自：USACO 2008 Dec. Gold<br>贝茜正在领导奶牛们逃跑。为了联络，奶牛们互相发送秘密信息。信息是二进制的，共有 M 条。反间谍能力很强的约翰已经部分拦截了这些信息，知道了第 i 条二进制信息的前 bi 位。<br>他同时知道，奶牛使用 N 条密码。但是，他仅仅了解第 j 条密码的前 cj位。对于每条密码 j ，他想知道有多少截得的信息能够和它匹配。也就是说，有多少信息和这条密码有着相同的前缀。当然，这个前缀长度必须等于密码和那条信息长度的较小者。</p><p><strong>解题思路</strong><br>根据所给样例呢，可以更加明确题意。首先我们将M条信息看作01字符串，同理N条密码也看作01字符串，题意问的就是对于每个密码，有多少条信息可能和该密码匹配，如果一条信息 A 和密码 B 匹配，那么有 A 是 B 的前缀或 B 是 A 的前缀。<br>于是我们就只需要先把01数组转化为01字符串，再用trie统计即可，当然由于同一信息可能会重复出现，所以 End[p] 记录的是以 p 结尾的字串个数。<br>在本机与洛谷上都是可以AC的，复杂度大概O(5e5)，但是在一本通OJ就过不去，猜测可能是不支持关闭 scanf 同步流？待修改。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="built_in">string</span> str[N],s[N];</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">2</span>],End[SZ],tot = <span class="number">1</span>,tc[SZ];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = s.length(), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">tc[p]++;</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span></span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; s &lt;&lt; "-" &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">int</span> len = s.length(), p = <span class="number">1</span>,res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line"><span class="keyword">if</span>(!p) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(End[p] &amp;&amp; i != len<span class="number">-1</span>) res += End[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res + tc[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">cout</span> &lt;&lt; search(s[i]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("222.txt","w",stdout);</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,k;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>,x;j &lt;= k;j++) <span class="built_in">cin</span> &gt;&gt; x, str[i] += x+<span class="string">'0'</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; str[i] &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,k;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>,x;j &lt;= k;j++) <span class="built_in">cin</span> &gt;&gt; x, s[i] += x+<span class="string">'0'</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; s[i] &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="【SCOI2016】背单词"><a href="#【SCOI2016】背单词" class="headerlink" title="【SCOI2016】背单词*"></a>【SCOI2016】背单词*</h4><p><strong>题意简述</strong><br>Lweb 面对如山的英语单词，陷入了深深的沉思，「我怎么样才能快点学完，然后去玩三国杀呢？」。<br>这时候睿智的凤老师从远处飘来，他送给了 Lweb 一本计划册和一大缸泡椒，然后凤老师告诉 Lweb ，我知道你要学习的单词总共有 n 个，现在我们从上往下完成计划表，对于一个序号为 x 的单词（序号 1…x−1 都已经被填入）：</p><ul><li>如果存在一个单词是它的后缀，并且当前没有被填入表内，那他需要吃 n×n 颗泡椒才能学会；</li><li>当它的所有后缀都被填入表内的情况下，如果在 1…x−1 的位置上的单词都不是它的后缀，那么他吃 x 颗泡椒就能记住它；</li><li>当它的所有后缀都被填入表内的情况下，如果 1…x−1 的位置上存在是它后缀的单词，所有是它后缀的单词中，序号最大为 y，那么你只要吃 x−y 颗泡椒就能把它记住。</li></ul><p>Lweb 是一个吃到辣辣的东西会暴走的奇怪小朋友，所以请你帮助 Lweb，寻找一种最优的填写单词方案，使得他记住这  n 个单词的情况下，吃最少的泡椒。</p><p><strong>解题思路</strong><br>首先把所有字符串反转，那么后缀就变成前缀了，就可以用trie维护。<br>刚开始我是想记录每个字符串的前缀个数，然后根据个数从小到大分配编号，但显然不行。<br>正解是将所有字符串构成一棵树，一个节点的父亲就是它的前缀，而没有前缀的字符串父亲为 0 号节点。我们可以利用 trie中的 search 时填边建树。<br>这样我们就有一棵有向树了，假设我们给节点 x 分配的序号是 f[x] ，那么显然 ans += f[x] - f[par[x] ]，其中 par[x] 代表 x 的父亲节点。所以我们需要让每个节点和它父亲节点的编号相差尽量小，那么自然是优先给节点数少的子树分配编号咯，所以对于每个节点 x ，我们选择节点最小的一棵子树，为它们分配编号。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">6e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> tc[N];<span class="comment">//记录后缀个数</span></span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],End[SZ], tot = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> par[N], head[N], ver[N], nex[N],tot2 = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot2] = y, nex[tot2] = head[x], head[x] = tot2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">int</span> len = s.length(), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p] = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">int</span> len = s.length(), p = <span class="number">1</span> ,res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line"><span class="keyword">if</span>(End[p] &amp;&amp; i != len<span class="number">-1</span>) par[id] = End[p];</span><br><span class="line">&#125;</span><br><span class="line">addEdge(par[id],id);<span class="comment">//顺便建树啦 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> str[N];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> num[N];<span class="comment">//记录子树x的节点个数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i != <span class="number">-1</span>;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line">num[x] += dfs(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num[x]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">priority_queue&lt; pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="keyword">int</span> f[N]; <span class="comment">//记录x编号 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">ans += cnt - f[par[x]]; f[x] = cnt; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i != <span class="number">-1</span>;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line">q.push(make_pair(-num[y],y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> nnex[q.size()],tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> y = q.top().second;q.pop();</span><br><span class="line">nnex[tt++] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tt;i++) cnt++, calc(nnex[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i],i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) search(str[i],i);</span><br><span class="line">num[<span class="number">0</span>] = dfs(<span class="number">0</span>); calc(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; str[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) reverse(str[i].begin(),str[i].end());</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="The-xor-longest-Path"><a href="#The-xor-longest-Path" class="headerlink" title="The xor-longest Path*"></a>The xor-longest Path*</h4><p><strong>题意简述</strong><br>原题来自：POJ 3764<br>给定一棵 n 个点的带权树，求树上最长的异或和路径。</p><p><strong>解题思路</strong><br>设 d[x] 表示 x 到根节点的路径异或和，那么显然由于异或的特性，x^y^x = y，我们任选两个点 x 和 y ，那么d[x] ^ d[y]就是 x 和 y 之间的路径异或和，因为从LCA(x , y)到根节点的路径都被抵消了。<br>所以原问题就成了从 d[1,n] 中选两个数，使它们的异或和最大。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N],nex[N],edge[N],tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,d[N];<span class="comment">//d[x]:x到根节点的路径异或和 </span></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y, nex[tot] = head[x];</span><br><span class="line">edge[tot] = z, head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//printf("%d %d %d\n",x,y,z);</span></span><br><span class="line">d[y] = d[x]^z;</span><br><span class="line">dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">32</span>*N;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">2</span>], tot2 = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>,p = <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot2;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回x与集合中异或和最大的 结果*/</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>,p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][!ch]) p = trie[p][!ch],res |= <span class="number">1</span>&lt;&lt;i;</span><br><span class="line"><span class="keyword">else</span> p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/* 计算并输出答案 */</span></span><br><span class="line">dfs(<span class="number">1</span>); <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(d[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) ans = max(ans,search(d[i]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt; n;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt(); z = getInt();</span><br><span class="line">addEdge(x,y,z); addEdge(y,x,z);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://ybt.ssoier.cn:8088/index.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测试地址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;Phone-List&quot;&gt;&lt;a href=&quot;#Phone-List&quot; class
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Trie" scheme="http://valenshi.top/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法练习题集</title>
    <link href="http://valenshi.top/2019/09/29/kmp-problems/"/>
    <id>http://valenshi.top/2019/09/29/kmp-problems/</id>
    <published>2019-09-29T05:54:36.000Z</published>
    <updated>2019-09-29T06:02:06.919Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/index.php" target="_blank" rel="noopener">测试地址</a></p><h4 id="剪花布条"><a href="#剪花布条" class="headerlink" title="剪花布条"></a>剪花布条</h4><p><strong>题意简述</strong><br>原题来自：HDU 2087<br>一块花布条，里面有些图案，另有一块直接可用的小饰条，里面也有一些图案。对于给定的花布条和小饰条，计算一下能从花布条中尽可能剪出几块小饰条来呢？</p><p><strong>解题思路</strong><br>就是普通的kmp算法，只不过这里的两个模式串不能重叠，我们基于贪心策略遇到一个选一个即可。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> f[N],nex[N];</span><br><span class="line"><span class="keyword">char</span> S[N],T[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getF</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(s)<span class="number">-1</span>, m = <span class="built_in">strlen</span>(t)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; (j == m || s[i] != t[j+<span class="number">1</span>])) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == t[j+<span class="number">1</span>]) j++;</span><br><span class="line">f[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">getNex(T);</span><br><span class="line">getF(S,T);</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(S)<span class="number">-1</span>, m = <span class="built_in">strlen</span>(T)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt; r &amp;&amp; f[i] == m) ans++ ,r = i+m<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,S+<span class="number">1</span>) &amp;&amp; S[<span class="number">1</span>] != <span class="string">'#'</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,T+<span class="number">1</span>); S[<span class="number">0</span>] = T[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Power-Strings"><a href="#Power-Strings" class="headerlink" title="Power Strings"></a>Power Strings</h4><p>在之前的字符串与Hash题集中做过，而且刚过去不久，不整理了。</p><h4 id="Radio-Transmission"><a href="#Radio-Transmission" class="headerlink" title="Radio Transmission"></a>Radio Transmission</h4><p><strong>题意简述</strong><br>给你一个字符串，它是由某个字符串不断自我连接形成的。但是这个字符串是不确定的，现在只想知道它的最短长度是多少。</p><p><strong>解题思路</strong><br>求最短循环节，给定的字符串可能是由循环节循环构成的字串的一个子串，所以就直接用求最短循环节就可以了，省去用字符串hash判断该串是否满足了。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n,nex[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">getNex(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n - nex[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="OKR-Periods-of-Words"><a href="#OKR-Periods-of-Words" class="headerlink" title="OKR-Periods of Words"></a>OKR-Periods of Words</h4><p><strong>题意简述</strong></p><p>原题来自：POI 2006<br>串是有限个小写字符的序列，特别的，一个空序列也可以是一个串。一个串 P 是串 A 的前缀，当且仅当存在串 B，使得 A=PB。如果P≠A并且 P 不是一个空串，那么我们说 P 是 A 的一个 proper 前缀。<br>定义 Q 是 A 的周期，当且仅当 Q 是 A 的一个 proper 前缀并且 A 是 QQ 的前缀（不一定要是 proper 前缀）。比如串 abab 和 ababab 都是串 abababa 的周期。串 A 的最大周期就是它最长的一个周期或者是一个空串（当 A 没有周期的时候），比如说，ababab 的最大周期是 abab。串 abc 的最大周期是空串。<br>给出一个串，求出它所有前缀的最大周期长度之和。</p><p><strong>解题思路</strong><br>题意有一些绕，但是还好给的是中文题面，尚可理解。就是说P是A的一个真子串，且是A的前缀，那么P就是A的proper前缀。若Q是A的proper前缀，且A是QQ（两个Q拼接在一起）的前缀（前缀不必要是真子串），那么Q就是A的周期。<br>现在要求的是A的 所有前缀的 最长周期的长度之和。</p><p>如果要是求最短周期的长度，那么直接就是求最短循环节，跑一遍nex就解决了；现在要求最长周期的长度，相当于求最长的循环节（该循环节不能等于原串！否则就不是proper前缀了），那么就不断的令 j = nex[j]，找到非零的最小 nex[j] （将nex数组看作father数组，一棵father树），那么最长循环节就是 i - j 了。</p><p>这样会超时，因为我们每次令j = nex[j]相当于从叶子节点走到根节点，最坏情况是O(N)才能找到最小的非零 nex[j]，总时间复杂度就是O(N^2)。</p><p><strong>优化</strong><br>我们令 f[j] 表示根到 j 路径上最小非零的值。（我们把nex数组看作一棵树！！！）<br>那么对于任意的nex[p]，若nex[p] != 0，那么最长周期就是 p - f[nex[p] ]。<br>我们在求nex数组时顺便更新 f 数组，和记忆化类似，思路不难理解。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n,nex[N],f[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s)<span class="number">-1</span>; f[<span class="number">0</span>] = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line"><span class="keyword">if</span>(j) f[j] = min(j,f[nex[j]]);</span><br><span class="line"><span class="comment">//printf("%d %d\n",j,f[j]);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">getNex(str);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex[i]) ans += i - f[nex[i]];</span><br><span class="line"><span class="comment">//printf("%d %c\n",ans,str[i]);</span></span><br><span class="line"><span class="comment">//printf("%d %d\n",nex[i],f[i]);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="似乎在梦中见过的样子"><a href="#似乎在梦中见过的样子" class="headerlink" title="似乎在梦中见过的样子"></a>似乎在梦中见过的样子</h4><p><strong>题意简述</strong><br>原题来自：2014 年湖北省队互测 Week2<br>「Madoka，不要相信 QB！」伴随着 Homura 的失望地喊叫，Madoka 与 QB 签订了契约。<br>这是 Modoka 的一个噩梦，也同时是上个轮回中所发生的事。为了使这一次 Madoka 不再与 QB 签订契约，Homura 决定在刚到学校的第一天就解决 QB。然而，QB 也是有许多替身的（但在第八话中的剧情显示它也有可能是无限重生的），不过，意志坚定的 Homura 是不会放弃的——她决定消灭所有可能是 QB 的东西。现在，她已感受到附近的状态，并且把它转化为一个长度为 n 的字符串交给了学 OI 的你。<br>现在你从她的话中知道，所有形似于 A+B+A 的字串都是 QB 或它的替身，且 ∣A∣≥k,∣B∣≥1（位置不同其他性质相同的子串算不同子串，位置相同但拆分不同的子串算同一子串），然后你必须尽快告诉 Homura 这个答案——QB 以及它的替身的数量。<br>注：对于一个字符串 S，∣S∣ 表示 S 的长度。</p><p><strong>解题思路</strong><br>这题需要对照样例来理解题意，经过分析后，发现题意是如果有一个子串满足ABA形式，其中 |A|&gt;=k 且 B 不是空串，那么该子串就是QB大魔王。现在问有多少个这样的子串。</p><p>首先看思路，对于一个字符串(s[1,n])，我们通过求它的nex数组，如果nex[n] &gt;= k 并且 nex[n] 小于 n/2，那么该串就是QB；如果nex[n] &gt;= n/2，那么nex[ nex[n] ] ，一直到根节点的路径上，只要有一个nex大于k且小于n/2，该串就也是QB。</p><p>综上所述，我们对于一个下标为[1, p]的字符串，需要找到nex[p]到根节点（将nex数组看作一棵树）路径上大于等于 k 的最小 nex值（贪心思想）。我们用 f 数组来存放该值。之所以用 f 数组存放，是为了防止最坏情况O(N^2)遍历。</p><p>所以我们对原字符串 S 的每一个后缀都进行上述操作，时间复杂度共O(N^2)，勉强过。但是常数稍微大一些就过不了了，所以统计答案也要在求 nex 和更新 f 数组时顺便累加，如果觉得这样太怂了，还可以进行别的优化，不过我懒得改了。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">15000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> nex[N],k, f[N], ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//f[i]为nex[i]到根中,大于k的最小的一个 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s)<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex); f[<span class="number">0</span>] = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line"><span class="keyword">if</span>(j &lt; k) f[j] = INF; </span><br><span class="line"><span class="keyword">else</span> f[j] = min(j,f[nex[j]]);</span><br><span class="line"><span class="keyword">if</span>(f[j]&lt;&lt;<span class="number">1</span> &lt; i) ans++;</span><br><span class="line"><span class="comment">//printf("%d %d %d %d\n",i,j,f[j],nex[j]);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(str)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">getNex(str+i<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Censoring"><a href="#Censoring" class="headerlink" title="Censoring"></a>Censoring</h4><p>这个我一看就知道KMP很难写，应该用自动机，所以放在自动机专题整理，另外吐槽一下书上的翻译是谁写的，太敷衍了吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://ybt.ssoier.cn:8088/index.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测试地址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;剪花布条&quot;&gt;&lt;a href=&quot;#剪花布条&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="KMP" scheme="http://valenshi.top/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>哈希与哈希表</title>
    <link href="http://valenshi.top/2019/09/28/hash/"/>
    <id>http://valenshi.top/2019/09/28/hash/</id>
    <published>2019-09-28T10:40:00.000Z</published>
    <updated>2019-09-28T10:42:17.956Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>哈希算法是通过一个哈希函数 H，将一种数据（字符串、大数等）转化为能够用变量表示或者能直接作为数组下标的数，通过哈希函数转化得到的数值我们成为哈希值。通过哈希值可以实现快速查找和匹配。本文主要介绍两种哈希算法的应用：字符串 Hash 和哈希表。</p><h4 id="字符串Hash"><a href="#字符串Hash" class="headerlink" title="字符串Hash"></a>字符串Hash</h4><p>字符串Hash有几种不同的用途，但是基于同一个原理，就是通过hash值匹配。<br>首先就是模式串匹配问题，n = |S| , m = |T| ，可以通过维护原串中所有长度为 m 的子串的哈希值，实现在O(1)时间内转移，并在O(1)时间内与 T 串的 hash值判等，若相等则有可能匹配成功。<br>大部分模式串匹配问题是用KMP求解，但是如果要是从主串中每次选出两个子串判断是否匹配的问题，还是需要用字符串 Hash 求解。</p><p><strong>具体流程</strong><br>我们设计的哈希函数 H 应当能在O(1)时间内实现相邻子串间的转移，或在预处理后，对不同的子串应该能在O(1)时间内求出其哈希值；这里用到叫做 滚动哈希 的优化技巧。</p><p>我们选取两个合适的互质的常数 b 和 h(b &lt; h)，假设字符串 $C = c_1c_2…c_m$，那么我们定义函数：$H(C) = (c_1b^{m-1} + c_2b^{m-2} + … + c_mb^0)\:mod\:h$。</p><p>这里的b是基数，相当于把字符串看作是 b 进制数。<br>这一过程是递推计算的，设H(C , k+1)是前 k 个字符构成的字符串的哈希值，则（不考虑取模）：$H(C , k+1) = H(C, k) * b + c_{k+1}$。</p><p>如果我们要<strong>求 C 中从 k 出发长度为 m 的子串的哈希值</strong>，那么$hsh = H(C , k+m) - H(C, k) * b^m$，hsh即为所求。</p><p><strong>预处理</strong></p><p>我们通过预处理求出所有C[a1, k]（k &lt;= n）的哈希值并存储在hash数组中（hash[i] = H(C,i) ），并预处理 base 数组（base[i] = $b^i$），那么我们就可以在O(1)时间内求出任意一个子串的哈希值。</p><p>在实现算法时，我们通常利用32位或者64位无符号整数计算哈希值，并取 $h = 2^{32}$ 或 $h = 2^{64}$，通过自然溢出省去取模运算。通常 b 取131 或 13331时效果较好。</p><p><strong>代码实现</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bse[i] = b^i , hsh[i] = H(str, i) */</span></span><br><span class="line">bse[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//bse和hsh都是unsigned long long </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    hsh[i] = hsh[i<span class="number">-1</span>]*b + str[i]-<span class="string">'a'</span>;</span><br><span class="line">    bse[i] = bse[i<span class="number">-1</span>]*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正确性证明</strong><br>上述做法可以保证相同的字符串所产生的哈希值一定是相同的，但是不同的字符串所产生的哈希值一定是不同的吗？<br>并不一定，但是冲突的几率很小，我们通常认为算法竞赛不会出现不同字符串哈希值冲突的情况。实际上根据生日悖论，对于哈希值在[0 , n)内均匀分布的哈希函数，出现不同字符串哈希值相等的期望步数是 $O(\sqrt N)$，可以作为一个参考。<br>更进一步的，我们还可以使用 <strong>“双哈希”</strong> 降低冲突的概率，即取用不同的模数，把不同的模数算出的哈希值记下来，只有几个哈希值都一样，才判定字符串匹配。我们通常用双哈希就可以将冲突的概率降到很低，如果分别取 h = 1e9+7 和 h = 1e9+9，就几乎不可能发生冲突，因为它们是一对“孪生素数”。</p><h4 id="哈希表与哈希函数"><a href="#哈希表与哈希函数" class="headerlink" title="哈希表与哈希函数"></a>哈希表与哈希函数</h4><p>哈希表是一种高效的数据结构，查找时间效率是常数时间，同时也很容易实现，需要付出的代价是消耗内存，但在如今这点内存已不成问题。</p><p><strong>问题模型</strong><br>给定 n 个数，这些数可能很大，判断每个数在之前有无出现过，出现了几次？</p><p><strong>算法流程</strong><br>这里具体分为三步：构造哈希函数 H()；将元素映射到哈希表；解决冲突。<br>首先要解决存储问题，我们先用线性表，即一维数组来存放元素。对于每个元素val，key = H(val)（这里的 key 是小于 1e7 的，可以当作数组的下标），于是我们就将val存放在数组下标为 key 的位置上。</p><p>而不同的元素它们key值是不同的（理想情况），相同的元素key值一定是相同的（任何情况），于是我们就可以通过O(1)时间的H()转化，读取数组内对应位置上的元素。</p><p>为了减少冲突呢，我们必须构造一个好的哈希函数H，这在后面会单独介绍常用的构造方法。但是不管多么优秀的哈希函数，都不可避免存在冲突，因此我们还需要有解决冲突的对策。我们想到可以用链表来解决冲突，即该一维表的每一个位置都是一条链表，具有相同哈希值的元素都放在同一条链上，当查找时只需要遍历这条链即可。这就叫哈希（链）表。</p><h5 id="哈希函数的构造"><a href="#哈希函数的构造" class="headerlink" title="哈希函数的构造"></a>哈希函数的构造</h5><p>哈希函数是决定哈希表查找效率的关键，只有哈希值分配的足够均匀时，单词查找的复杂度才会尽量小。以下介绍几种效果好的、容易实现的哈希函数。<br><strong>（1）基数转换法</strong><br>基数转换法就是开头的字符串Hash所采用的转换方法：将 val 值看作另一种进制数，然后再把它转化成对应的十进制数，再用除余法对其取余。一般取大于10的数作为转换的基数，并且两个基数是互质的。一般来说，取 131 或 13331较好。</p><p>如 val = 236075 原本是十进制数，现在将它看作十三进制数$(236075) _ {13}$然后再将它转换为十进制数。<br>$(236075)_ {13} = 2 <em> 13^5 + 3 </em> 13^4 + 6 <em> 13^3 + 7 </em> 13 + 5 = (841547) _ {10}$</p><p><strong>（2）除余法</strong><br>选择一个适当的正整数 b，用其对 b 取模的余数作为哈希值，即：H(val) = val mod b，这个方法应用的最多，并且多数情况下性价比也是最高的。关键在于 b 的选取，一般选 b 是数组下标能存储得下并且尽量大的质数（一般根据空间取1e6左右的质数）。选质数是因为 通常b的约数越多，冲突的几率就越大。</p><p><strong>（3）乘积取整法</strong><br>我们用值 val 乘以一个在(0,1)中的实数 A（最好是无理数，$(\sqrt 5 - 1)/2$是一个实际效果很好的数），得到一个(0 , k)之间实数；取其小数部分，乘以哈希表的大小 M 再向下取整，即得 val 在Hash表中的位置。函数表达式可以写成：H(val) = { M( val * A mod 1 ) }。</p><h5 id="散列表模板"><a href="#散列表模板" class="headerlink" title="散列表模板"></a>散列表模板</h5><p>例题：门票(tickets)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">2181271</span>; </span><br><span class="line"><span class="keyword">int</span> nex[N],num[N],head[N],tot = <span class="number">1</span>;<span class="comment">// 用邻接表方式实现哈希表 </span></span><br><span class="line"><span class="keyword">int</span> top , stk[N];<span class="comment">//数组模拟堆栈,用于哈希表的初始化 </span></span><br><span class="line">ll a,b,c;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">tot = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span>(top) head[stk[top--]] = <span class="number">0</span>;<span class="comment">//只清空用了的表,节省时间 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将x插入哈希表*/</span></span><br><span class="line"><span class="keyword">int</span> h = x % P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[h] ;i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i] == x) <span class="keyword">return</span>; <span class="comment">//相同的值已经存放过了 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(!head[h]) stk[++top] = h; <span class="comment">//第一次出现的哈希值入栈</span></span><br><span class="line"><span class="comment">/* 邻接表添加元素基本套路 */</span></span><br><span class="line">nex[++tot] = head[h]; head[h] = tot; num[tot] = x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ask</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 返回 x 是否存在*/</span></span><br><span class="line"><span class="keyword">int</span> h = x%P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[h];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i] == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll x = <span class="number">1</span>; Insert(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">2e6</span>;i++)&#123;</span><br><span class="line">x = (x*a + x%b)%c;</span><br><span class="line"><span class="keyword">if</span>(ask(x)) <span class="keyword">return</span> i;</span><br><span class="line">Insert(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*多组样例要调用init()*/</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>董永建，信息学竞赛一本通提高版，福州：福建教育出版社，2018.6，63-69</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;哈希算法是通过一个哈希函数 H，将一种数据（字符串、大数等）转化为能够用变量表示或者能直接作为数组下标的数，通过哈希函数转化得到的数值我们成
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="hash" scheme="http://valenshi.top/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>字符串循环节问题</title>
    <link href="http://valenshi.top/2019/09/27/xhj/"/>
    <id>http://valenshi.top/2019/09/27/xhj/</id>
    <published>2019-09-27T05:22:29.000Z</published>
    <updated>2019-09-27T05:23:11.718Z</updated>
    
    <content type="html"><![CDATA[<p><strong>循环节与最短循环节：</strong><br>若某个字符串是由某个子串循环构成的，那么就称该子串为原串的循环节，长度最短的循环节就是最短循环节。<br>如abababab，abab和ab都是原串的循环节，而最短循环节是ab。</p><p><strong>结论：</strong><br>如果字符串 s 有个循环节 son，n = |s| , x = |son|，字符数组下标从1开始，那么：</p><ol><li>x 一定是 n 的约数。</li><li>那么s[1,n-x] = s[x, n] = son。</li></ol><p><strong>证明：</strong><br>结论1：如果 x 不是 n 的约数，那么自然 n 就不可能由 若干个 x 相加构成，即不满足 n = k * x ，其中 k 是正整数。<br>结论2：若想s[1 ,n-x] = s[x, n] ，必须s[1, x] = s[ x ,2x] = s[2x , 3x] = … = s[n-x , n]，刚好符合循环节定义，因此 结论2 成立。</p><h4 id="求单个字符串的最短循环节"><a href="#求单个字符串的最短循环节" class="headerlink" title="求单个字符串的最短循环节"></a>求单个字符串的最短循环节</h4><p><strong>例1：</strong> POJ 2406 Power Strings (KMP)<br><a href="http://poj.org/problem?id=2406" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong> 给定一个字符串 s ，求出它最多由某个子串 循环几次 构成。</p><p><strong>解题思路：</strong><br>首先 s 必须是由某个循环节循环若干次构成的，否则无解。题意让求最多循环几次构成，那么既然 s 的长度固定是 n，自然是循环节越短，那么循环次数越多了。<br>我们先求出KMP算法中的nex数组。<br><strong>结论3：</strong> 此时若 s 有解，那么最短循环节长度为 x = n - nex[n] 。</p><p><strong>证明：反证法</strong> </p><ol><li>首先根据结论2，因为 s[1,nex[n] ] = s[n - nex[n] , n]，所以必然存在长度为 x = n - nex[n]的循环节，问题就在于它是不是最短的。</li><li>假设存在循环节，长度为 y（y &lt; x） ，那么根据结论2，一定有： s[1, n-y] = s[y , n]；如此一来nex[n] = n-y &gt; n-x，这和nex数组定义矛盾，因此不存在y &lt; x。</li><li>综上所述，n - nex[n] 一定为最短循环节的长度。</li></ol><p>因此本题的答案就是 n/(n-nex[n])，若不能整除，则无解。</p><p><strong>代码示例：</strong> 见附录部分 code-1：Power Strings</p><h4 id="求任意子串的最短循环节"><a href="#求任意子串的最短循环节" class="headerlink" title="求任意子串的最短循环节"></a>求任意子串的最短循环节</h4><p><strong>例2：</strong> bzoj2795 Horrible Poem<br><a href="http://www.mfstem.org/contest/57/problem/F" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给出一个由小写英文字母组成的字符串 S，再给出 q 个询问，要求回答 S 某个子串的最短循环节长度。如果字符串 B 是字符串 A 的循环节，那么 A 可以由 B 重复若干次得到。</p><p><strong>解题思路：</strong><br>此题的 q 很大，我们不可能对每一个子串都O(n)求出 nex 数组再回答。我们利用 滚动哈希 ，在O(1)时间内利用 结论2 判断某个长度是否为循环节。<br>再根据结论1，可以得知循环节长度一定是子串长度 m 的约数，因此我们$O(\sqrt m)$分解约数，再用O(1)复杂度用hash判断，本题总复杂度就是 $O(q \sqrt m)$。</p><p>一般到这里就该结束了，我们利用了 结论1 和 结论2 大大减少了求循环节的时间。但是在本题还是不够，还需要优化。还能优化的地方就只有求约数的$O(\sqrt m)$复杂度了，我们可以通过质因数分解在$O(log_2^m)$时间内分解约数，于是最终复杂度就是 $O(q\:log_2^n)$，可以通过了。</p><p><strong>代码示例：</strong> 见附录部分code-2：Horrible Poem</p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p><strong>code-1：Power Strings</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> nex[N]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;str[i];i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; str[i] != str[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(str[i] == str[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算答案并输出*/</span></span><br><span class="line">getNex(str);</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(str)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(n%(n-nex[n])) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n/(n-nex[n]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>) &amp;&amp; str[<span class="number">1</span>] != <span class="string">'.'</span>)&#123;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'*'</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>code-2：Horrible Poem</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Q = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line">ull hsh[N],bse[N] , b = <span class="number">31</span>; <span class="comment">//采用无符号长整形,通过自然溢出省去取模 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*判断x是否为子串s[l,r]的最短循环节长度*/</span> </span><br><span class="line">ull h1 = hsh[r-x] - hsh[l<span class="number">-1</span>]*bse[r-x+<span class="number">1</span>-l];</span><br><span class="line">ull h2 = hsh[r] - hsh[l<span class="number">-1</span>+x]*bse[r-x+<span class="number">1</span>-l];</span><br><span class="line"><span class="keyword">return</span> h1 == h2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> v[N],primes[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPri</span><span class="params">()</span></span>&#123;<span class="comment">//线性筛 </span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i])&#123;</span><br><span class="line">primes[cnt++] = i;</span><br><span class="line">v[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cnt;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(primes[j] &gt; v[i] || primes[j]*i &gt; N)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">v[i*primes[j]] = primes[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*回答子串s[l,r]的最短循环节长度*/</span> </span><br><span class="line"><span class="keyword">int</span> len = r-l+<span class="number">1</span>, ans = len, d = len;</span><br><span class="line"><span class="keyword">while</span>(d != <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = v[d];</span><br><span class="line"><span class="keyword">while</span>(d%tmp == <span class="number">0</span> &amp;&amp; check(l,r,ans/tmp)) d /= tmp,ans /= tmp;</span><br><span class="line"><span class="keyword">while</span>(d%tmp == <span class="number">0</span>) d /= tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*预处理出hash数组,v数组*/</span></span><br><span class="line">getPri(); bse[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">hsh[i] = hsh[i<span class="number">-1</span>]*b + str[i]-<span class="string">'a'</span>;</span><br><span class="line">bse[i] = bse[i<span class="number">-1</span>]*b;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>) &#123; x=x*<span class="number">10</span>+c-<span class="string">'0'</span>; c=getchar(); &#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">n = read();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>); str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">q = read();</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,l,r;i &lt;= q;i++)&#123;</span><br><span class="line">l = read(); r = read();</span><br><span class="line">ask(l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;循环节与最短循环节：&lt;/strong&gt;&lt;br&gt;若某个字符串是由某个子串循环构成的，那么就称该子串为原串的循环节，长度最短的循环节就是最短循环节。&lt;br&gt;如abababab，abab和ab都是原串的循环节，而最短循环节是ab。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="KMP" scheme="http://valenshi.top/tags/KMP/"/>
    
      <category term="循环节" scheme="http://valenshi.top/tags/%E5%BE%AA%E7%8E%AF%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>字符串与哈希题集</title>
    <link href="http://valenshi.top/2019/09/26/hash-and-kmp/"/>
    <id>http://valenshi.top/2019/09/26/hash-and-kmp/</id>
    <published>2019-09-26T14:14:10.000Z</published>
    <updated>2019-09-28T10:07:02.709Z</updated>
    
    <content type="html"><![CDATA[<p>我校OJ：<a href="http://www.mfstem.org/contest/57/problems" target="_blank" rel="noopener">测试地址</a><br>图书配套OJ：<a href="http://ybt.ssoier.cn:8088/index.php" target="_blank" rel="noopener">测试地址</a></p><h4 id="A-Oulipo"><a href="#A-Oulipo" class="headerlink" title="A. Oulipo"></a>A. Oulipo</h4><p><strong>Description</strong><br>给出两个字符串s1,s2（只有大写字母），求s1在s2中出现多少次。例如：s1=”ABA”,s2=”ABAABA”,答案为2。</p><p><strong>解题思路：</strong><br>KMP算法的模板，也可以用拓展KMP解决。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> nex[N];<span class="comment">//nex[i] = T[i,n-1]与T[0,n-1]最长公共前缀 </span></span><br><span class="line"><span class="keyword">char</span> S[N],T[N]; <span class="comment">//S为目标串,T为模式串 </span></span><br><span class="line"><span class="keyword">int</span> extend[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算nex数组*/</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str) ,i = <span class="number">0</span>, j, p0 ;</span><br><span class="line">nex[<span class="number">0</span>] = len;</span><br><span class="line"><span class="keyword">while</span>(i+<span class="number">1</span> &lt; len &amp;&amp; str[i] == str[i+<span class="number">1</span>]) i++;</span><br><span class="line">nex[<span class="number">1</span>] = i; p0 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex[i-p0]+i &lt; nex[p0]+p0) nex[i] = nex[i-p0];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j = nex[p0]+p0-i;</span><br><span class="line"><span class="keyword">if</span>(j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i+j &lt; len &amp;&amp; str[j] == str[j+i]) j++;</span><br><span class="line">nex[i] = j; p0 = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exKMP</span><span class="params">(<span class="keyword">char</span>* str1,<span class="keyword">char</span> *str2)</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算str2与str1的所有后缀的最长公共前缀长度,存放在extend数组中*/</span> </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>,j,p0,l1 = <span class="built_in">strlen</span>(S), l2 = <span class="built_in">strlen</span>(T);</span><br><span class="line">getNex(str2);</span><br><span class="line"><span class="keyword">while</span>(i &lt; l1 &amp;&amp; i &lt; l2 &amp;&amp; str1[i] == str2[i]) i++;</span><br><span class="line">extend[<span class="number">0</span>] = i;p0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; l1;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex[i-p0]+i &lt; extend[p0]+p0) extend[i] = nex[i-p0];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">j = extend[p0]+p0-i;</span><br><span class="line"><span class="keyword">if</span>(j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i+j &lt; l1 &amp;&amp; j &lt; l2 &amp;&amp; str1[j+i] == str2[j]) j++;</span><br><span class="line">extend[i] = j; p0 = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算并输出答案*/</span></span><br><span class="line"><span class="keyword">int</span> l1 = <span class="built_in">strlen</span>(S), l2 = <span class="built_in">strlen</span>(T), ans = <span class="number">0</span>;</span><br><span class="line">exKMP(S,T); <span class="keyword">int</span> len = <span class="built_in">strlen</span>(T);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; l1;i++)</span><br><span class="line"><span class="keyword">if</span>(extend[i] == len) ans++;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,T,S);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="B-图书管理"><a href="#B-图书管理" class="headerlink" title="B. 图书管理"></a>B. 图书管理</h4><p><strong>Description</strong><br>图书管理是一件十分繁杂的工作，在一个图书馆中每天都会有许多新书加入。为了更方便的管理图书（以便于帮助想要借书的客人快速查找他们是否有他们所需要的书），我们需要设计一个图书查找系统。该系统需要支持 2 种操作：</p><ol><li>add(s) 表示新加入一本书名为 s 的图书。</li><li>find(s) 表示查询是否存在一本书名为 s 的图书。</li></ol><p><strong>解题思路：</strong><br>该题本意是用hash解决，但是我偷懒直接用map了。。。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span> ,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> tmp = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>;s[i];i++) tmp += s[i];</span><br><span class="line">mp[tmp] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> tmp = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>;s[i];i++) tmp += s[i];</span><br><span class="line"><span class="keyword">if</span>(mp.count(tmp)) <span class="built_in">cout</span> &lt;&lt; <span class="string">"yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"no"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">getline(<span class="built_in">cin</span>,str);</span><br><span class="line"><span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'a'</span>) add(str);</span><br><span class="line"><span class="keyword">else</span> Find(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="C-Power-Strings"><a href="#C-Power-Strings" class="headerlink" title="C. Power Strings"></a>C. Power Strings</h4><p><strong>Description</strong><br>给定若干个长度 ≤10^6的字符串，询问每个字符串最多是由多少个相同的子字符串重复连接而成的。如：ababab 则最多有 3 个 ab 连接而成。<br><strong>解题思路：</strong><br>本题是循环节问题，有个结论：若字符串 s 是由某个长度为 x 的子串循环构成，那么必定有s[1,n-x] = s[x, n]。而根据nex数组的定义，nex[n] 就是 s[x, n] 的长度n-x。<br>因此如果该题有解，则n % (n-nex[n])为0，答案就是n/(n-nex[n)。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> nex[N]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;str[i];i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; str[i] != str[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(str[i] == str[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算答案并输出*/</span></span><br><span class="line">getNex(str);</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(str)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(n%(n-nex[n])) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n/(n-nex[n]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>) &amp;&amp; str[<span class="number">1</span>] != <span class="string">'.'</span>)&#123;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'*'</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="D-Seek-the-Name-Seek-the-Fame"><a href="#D-Seek-the-Name-Seek-the-Fame" class="headerlink" title="D. Seek the Name, Seek the Fame"></a>D. Seek the Name, Seek the Fame</h4><p><strong>Description</strong><br>给定若干字符串（这些字符串总长 ≤4×10^5 ），在每个字符串中求出所有既是前缀又是后缀的子串长度。例如：ababcababababcabab，既是前缀又是后缀的：ab，abab，ababcabab，ababcababababcabab。</p><p><strong>解题思路：</strong><br>依然是利用KMP算法中的nex数组求解。首先该串本身是最长的“既是前缀又是后缀”的子串，下一个满足条件的子串是s[1,nex[n] ] ，下下个是s[1, nex[ nex[n] ] ]，… 。</p><p>道理很简单，就是想起来有点绕；如果存在一个长度为 x 的子串 son“既是前缀又是后缀”，那么有s[1,x] = s[n-x,n] = son，那么它的长度不还是不超过 nex[n] 吗？所以上述方法可以从大到小遍历所有可能的长度（不是所有子串！）。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> nex[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">getNex(str); <span class="keyword">int</span> n = <span class="built_in">strlen</span>(str)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>; ans[++cnt] = n;</span><br><span class="line"><span class="keyword">while</span>(nex[n])&#123;</span><br><span class="line">ans[++cnt] = nex[n];</span><br><span class="line">n = nex[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = cnt;i &gt; <span class="number">1</span>;i--) <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>))&#123;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="E-friends"><a href="#E-friends" class="headerlink" title="E. friends"></a>E. friends</h4><p><strong>Description</strong><br>有三个好朋友喜欢在一起玩游戏，A 君写下一个字符串 S，B 君将其复制一遍得到 T，C 君在 T 的任意位置（包括首尾）插入一个字符得到 U。现在你得到了 U，请你找出 S。</p><p><strong>解题思路：</strong><br>本题如果用nex或者hash求解，细节有点多，当然细心点应该是能写出来的。我的解题思路很简单，O(N)复杂度，主要基于如下基本推论：</p><ol><li>如果n为偶数，无解。</li><li>如果前n/2+1个字符通过删去一个，可以等同于后n/2个字符，则匹配成功。</li><li>如果后n/2+1个字符通过删去一个，可以等同于前n/2个字符，则匹配成功。</li><li>如果 2 和 3 都匹配成功，且两个得到的原串不同，则说明解不唯一。</li></ol><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N],tmp[N],s1[N],s2[N];</span><br><span class="line"><span class="keyword">int</span> n,nex[N],tot;</span><br><span class="line"><span class="keyword">char</span> ans1[N],ans2[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> *s1,<span class="keyword">char</span> *s2)</span></span>&#123;</span><br><span class="line">tot = <span class="number">0</span>; <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= n/<span class="number">2</span> &amp;&amp; j &lt;= n/<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(s1[i] != s2[j])&#123;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">flag = <span class="literal">true</span>; j++;</span><br><span class="line"><span class="keyword">if</span>(s1[i] != s2[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">tmp[tot++] = s1[i];</span><br><span class="line">i++ , j++;</span><br><span class="line">&#125;</span><br><span class="line">tmp[tot] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"NOT POSSIBLE"</span>); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n/<span class="number">2</span>;i++) s1[i] = str[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n/<span class="number">2</span>+<span class="number">1</span>;i++) s2[i] = str[i+n/<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> flag1,flag2;</span><br><span class="line">flag1 = check(s1,s2);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n/<span class="number">2</span>;i++) ans1[i] = tmp[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n/<span class="number">2</span>+<span class="number">1</span>;i++) s1[i] = str[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n/<span class="number">2</span>;i++) s2[i] = str[i+n/<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">flag2 = check(s2,s1);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n/<span class="number">2</span>;i++) ans2[i] = tmp[i];</span><br><span class="line"><span class="keyword">if</span>(flag1 &amp;&amp; flag2)&#123;</span><br><span class="line"><span class="keyword">bool</span> f = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n/<span class="number">2</span>;i++) </span><br><span class="line"><span class="keyword">if</span>(ans1[i] != ans2[i]) f = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!f)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"NOT UNIQUE"</span>); <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag1 || flag2)&#123;</span><br><span class="line"><span class="keyword">if</span>(flag1) <span class="built_in">puts</span>(ans1);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(ans2);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"NOT POSSIBLE"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%s"</span>,&amp;n,str+<span class="number">1</span>);</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'#'</span>; solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="F-A-Horrible-Poem"><a href="#F-A-Horrible-Poem" class="headerlink" title="F. A Horrible Poem"></a>F. A Horrible Poem</h4><p><strong>Description</strong><br>给出一个由小写英文字母组成的字符串 S，再给出 q 个询问，要求回答 S 某个子串的最短循环节。如果字符串 B 是字符串 A 的循环节，那么 A 可以由 B 重复若干次得到。</p><p><strong>解题思路：</strong><br>这个是最短循环节问题，另外本题卡常十分严格。为了快速求解，本题还用到了线性筛、滚动哈希优化等策略。</p><p>首先是基础的字符串循环节知识。如果字符串 s 是由某个子串循环得到，|s| = n，那么<br>循环节的长度一定是 len 的约数，包括最短循环节。因此一个策略就是对于 n 的所有约数，挨个判断是否为最短循环节的长度，而判断原理如下：</p><ul><li>如果字符串 s 的最短循环节长度为 x ，那么必然有 s[1, x] = s[n-x, n] 。</li></ul><p>我们可以通过滚动哈希技巧来在O(1)时间完成判断。那么现在主要花费的时间在于找寻 n 的约数上，一般做法$O(\sqrt n)$，于是这种做法总复杂度为$O(q \sqrt n)$。</p><p>但是这题卡常很严重，这样还是会超时。于是就要利用质因数分解定理在$O(log_2^n)$时间内完成约数分解，总时间复杂度为$O(q log_2^n)$。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Q = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line">ull hsh[N],bse[N] , b = <span class="number">31</span>; <span class="comment">//采用无符号长整形,通过自然溢出省去取模 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*判断x是否为子串s[l,r]的最短循环节长度*/</span> </span><br><span class="line">ull h1 = hsh[r-x] - hsh[l<span class="number">-1</span>]*bse[r-x+<span class="number">1</span>-l];</span><br><span class="line">ull h2 = hsh[r] - hsh[l<span class="number">-1</span>+x]*bse[r-x+<span class="number">1</span>-l];</span><br><span class="line"><span class="keyword">return</span> h1 == h2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> v[N],primes[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPri</span><span class="params">()</span></span>&#123;<span class="comment">//线性筛 </span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i])&#123;</span><br><span class="line">primes[cnt++] = i;</span><br><span class="line">v[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cnt;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(primes[j] &gt; v[i] || primes[j]*i &gt; N)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">v[i*primes[j]] = primes[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*回答子串s[l,r]的最短循环节长度*/</span> </span><br><span class="line"><span class="keyword">int</span> len = r-l+<span class="number">1</span>, ans = len, d = len;</span><br><span class="line"><span class="keyword">while</span>(d != <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = v[d];</span><br><span class="line"><span class="keyword">while</span>(d%tmp == <span class="number">0</span> &amp;&amp; check(l,r,ans/tmp)) d /= tmp,ans /= tmp;</span><br><span class="line"><span class="keyword">while</span>(d%tmp == <span class="number">0</span>) d /= tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*预处理出hash数组,v数组*/</span></span><br><span class="line">getPri(); bse[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">hsh[i] = hsh[i<span class="number">-1</span>]*b + str[i]-<span class="string">'a'</span>;</span><br><span class="line">bse[i] = bse[i<span class="number">-1</span>]*b;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>) &#123; x=x*<span class="number">10</span>+c-<span class="string">'0'</span>; c=getchar(); &#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">n = read();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>); str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">q = read();</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,l,r;i &lt;= q;i++)&#123;</span><br><span class="line">l = read(); r = read();</span><br><span class="line">ask(l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="G-Beads"><a href="#G-Beads" class="headerlink" title="G. Beads"></a>G. Beads</h4><p><strong>Description</strong><br>Zxl有一次决定制造一条项链，她以非常便宜的价格买了一长条鲜艳的珊瑚珠子，她现在也有一个机器，能把这条珠子切成很多块（子串），每块有k（k&gt;0）个珠子，如果这条珠子的长度不是k的倍数，最后一块小于k的就不要拉（nc真浪费），保证珠子的长度为正整数。 Zxl喜欢多样的项链，为她应该怎样选择数字k来尽可能得到更多的不同的子串感到好奇，子串都是可以反转的，换句话说，子串（1，2，3）和（3,2,1）是一样的。写一个程序，为Zxl决定最适合的k从而获得最多不同的子串。例如：这一串珠子是： (1,1,1,2,2,2,3,3,3,1,2,3,3,1,2,2,1,3,3,2,1)。<br>k=1的时候，我们得到3个不同的子串：(1),(2),(3)<br>k=2的时候，我们得到6个不同的子串： (1,1),(1,2),(2,2),(3,3),(3,1),(2,3)<br>k=3的时候，我们得到5个不同的子串：  (1,1,1),(2,2,2),(3,3,3),(1,2,3),(3,1,2)<br>k=4的时候，我们得到5个不同的子串： (1,1,1,2),(2,2,3,3),(3,1,2,3),(3,1,2,2),(1,3,3,2)</p><p><strong>解题思路：</strong><br>刚开始时间复杂度算错了，n + n/2 + n/3 + n/4 + … + 1是调和级数，时间复杂度并不高，因此两层循环加上 滚动哈希 O(1)的判断是可以很快通过的。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> col[N] , n;</span><br><span class="line">ull hsh[N],hsh2[N],bse[N] , B = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;ull,<span class="keyword">int</span>&gt; vis;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">int</span> tc , mx , k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">bse[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">hsh[i] = hsh[i<span class="number">-1</span>]*B+col[i], bse[i] = bse[i<span class="number">-1</span>]*B;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--) </span><br><span class="line">hsh2[i] = hsh2[i+<span class="number">1</span>]*B+col[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">vis.clear(); cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt;= n;j += i)&#123;</span><br><span class="line">ull h1 = hsh[j] - hsh[j-i]*bse[i];</span><br><span class="line">ull h2 = hsh2[j-i+<span class="number">1</span>] - hsh2[j+<span class="number">1</span>]*bse[i];</span><br><span class="line"><span class="keyword">if</span>(vis.count(h1*h2) == <span class="number">0</span>)&#123;</span><br><span class="line">vis[h1*h2] = <span class="number">1</span>; cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf("%llu %llu\n",h1,h2);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf("%d %d\n",cnt,mx);</span></span><br><span class="line"><span class="keyword">if</span>(cnt == mx) ans.push_back(i);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cnt &gt; mx) &#123;</span><br><span class="line">ans.clear(); ans.push_back(i); mx = cnt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,mx,ans.size());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ans.size();i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,col+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="H-Antisymmetry"><a href="#H-Antisymmetry" class="headerlink" title="H. Antisymmetry"></a>H. Antisymmetry</h4><p><strong>Description</strong><br>对于一个01字符串，如果将这个字符串0和1取反后，再将整个串反过来和原串一样，就称作“反对称”字符串。比如00001111和010101就是反对称的，1001就不是。<br>现在给出一个长度为N的01字符串，求它有多少个子串是反对称的。</p><p><strong>解题思路：</strong><br>01串的题目真是变化多端啊。要想解决本题首先要得出几个推论：</p><ol><li>“反对称”的串长度一定是偶数。</li><li>如果一个子串是“反对称”的，那么它一定关于中轴线，左右01对应（如0101）。</li><li>如果一个串是“反对称”的，那么和它共中轴线的子串也是“反对称”的。</li></ol><p>然后就发现和回文串的性质有些相似，仅有 2 点不同，就是回文串长度可以为奇，以及回文串是关于中轴对称而不是相反。</p><p>那么我们依然可以利用Manacher算法，只不过将判等 改为判“反”即可。当然也要用通配符“#”来填充，因为所有“反对称” 的串长度必须为偶，所以我们在“#”上进行计算，以此来保证长度为偶数。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N],s2[<span class="number">2</span>*N];</span><br><span class="line"><span class="keyword">int</span> n,len[<span class="number">2</span>*N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="string">'#'</span> &amp;&amp; b == <span class="string">'#'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="string">'1'</span> &amp;&amp; b == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="string">'0'</span> &amp;&amp; b == <span class="string">'1'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">s2[<span class="number">0</span>] = <span class="string">'$'</span>,s2[<span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">s2[i&lt;&lt;<span class="number">1</span>] = str[i<span class="number">-1</span>];</span><br><span class="line">s2[(i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">&#125;</span><br><span class="line">s2[n*<span class="number">2</span>+<span class="number">2</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span>, mid;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">2</span>*n+<span class="number">2</span>;i += <span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt; mx) len[i] = min(len[<span class="number">2</span>*mid-i],mx-i);</span><br><span class="line"><span class="keyword">else</span> len[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( check(s2[i-len[i]], s2[i+len[i]]) ) len[i]++;</span><br><span class="line"><span class="keyword">if</span>(len[i]+i &gt; mx)&#123;</span><br><span class="line">mx = len[i] + i;</span><br><span class="line">mid = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">2</span>*n+<span class="number">2</span>;i++) ans += len[i]&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str); </span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="I-门票-tickets"><a href="#I-门票-tickets" class="headerlink" title="I. 门票(tickets)"></a>I. 门票(tickets)</h4><p><strong>Description</strong><br>已知数列$a_n, a_0 = 1$, $a_{i+1} = (a_i * A + a_i \:mod \:B ) \:mod \:C$，请问给定A，B和C，该数列在第几项第一次出现重复？</p><p><strong>解题思路：</strong><br>map太慢了啊，我测试了读入输出，测试了乘法和取模，就是没有怀疑map，浪费很多时间。<br>手写hash函数，利用邻接表来消除冲突，如此一来快了很多。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">2181271</span>; </span><br><span class="line"><span class="keyword">int</span> nex[N],num[N],head[N],tot = <span class="number">1</span>;<span class="comment">// 用邻接表方式实现哈希表 </span></span><br><span class="line"><span class="keyword">int</span> top , stk[N];<span class="comment">//数组模拟堆栈,用于哈希表的初始化 </span></span><br><span class="line">ll a,b,c;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">tot = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span>(top) head[stk[top--]] = <span class="number">0</span>;<span class="comment">//只清空用了的表,节省时间 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将x插入哈希表*/</span></span><br><span class="line"><span class="keyword">int</span> h = x % P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[h] ;i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i] == x) <span class="keyword">return</span>; <span class="comment">//相同的值已经存放过了 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(!head[h]) stk[++top] = h; <span class="comment">//第一次出现的哈希值入栈</span></span><br><span class="line"><span class="comment">/* 邻接表添加元素基本套路 */</span></span><br><span class="line">nex[++tot] = head[h]; head[h] = tot; num[tot] = x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ask</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 返回 x 是否存在*/</span></span><br><span class="line"><span class="keyword">int</span> h = x%P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[h];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i] == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll x = <span class="number">1</span>; Insert(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">2e6</span>;i++)&#123;</span><br><span class="line">x = (x*a + x%b)%c;</span><br><span class="line"><span class="keyword">if</span>(ask(x)) <span class="keyword">return</span> i;</span><br><span class="line">Insert(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*多组样例要调用init()*/</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="J-收集雪花-snowflakes"><a href="#J-收集雪花-snowflakes" class="headerlink" title="J. 收集雪花(snowflakes)"></a>J. 收集雪花(snowflakes)</h4><p><strong>Description</strong><br>不同的雪花往往有不同的形状。在北方的同学想将雪花收集起来，作为礼物送给在南方的同学们。一共有 n 个时刻，给出每个时刻下落雪花的形状，用不同的整数表示不同的形状。在收集的过程中，同学们不希望有重复的雪花。你可以从任意  a 时刻开始，在 b 时刻停止。a 到 b 时刻中间的雪花也都将被收集。他们希望收集的雪花最多。</p><p><strong>解题思路：</strong><br>这个用hash有点难写，难在重置哈希表。我用的是离散化+双指针，只需要维护左边界即可。如果当前雪花第二次出现，那么知道它上一次出现位置是v[p] ，所以先用当前区间长度更新答案，再将左边界更新为 v[p] + 1。<br>正确性证明就不写了，很显然。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], n, v[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i),b[i] = a[i];</span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">int</span> tot = unique(a+<span class="number">1</span>,a+<span class="number">1</span>+n)-a<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,l = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> p = lower_bound(a+<span class="number">1</span>,a+tot+<span class="number">1</span>,b[i])-a;</span><br><span class="line"><span class="keyword">if</span>(v[p] &gt;= l)&#123;</span><br><span class="line">ans = max(ans,i-l);</span><br><span class="line">l = v[p]+<span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line">v[p] = i;</span><br><span class="line"><span class="keyword">if</span>(i == n) ans = max(ans,i-l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我校OJ：&lt;a href=&quot;http://www.mfstem.org/contest/57/problems&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测试地址&lt;/a&gt;&lt;br&gt;图书配套OJ：&lt;a href=&quot;http://ybt.ssoier.cn:
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="拓展KMP" scheme="http://valenshi.top/tags/%E6%8B%93%E5%B1%95KMP/"/>
    
      <category term="哈希" scheme="http://valenshi.top/tags/%E5%93%88%E5%B8%8C/"/>
    
      <category term="KMP" scheme="http://valenshi.top/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="http://valenshi.top/2019/09/26/kmp/"/>
    <id>http://valenshi.top/2019/09/26/kmp/</id>
    <published>2019-09-26T04:12:11.000Z</published>
    <updated>2019-09-26T04:14:09.394Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>KMP算法，又称模式匹配算法，能够在线性时间内判定字符串 T 是否为 S 的子串，并求出字符串 T 在 S 中各次出现的位置。<br>KMP算法比较晦涩难懂。本文对于思想介绍略简，侧重于实现。</p><h4 id="问题模型与算法思路"><a href="#问题模型与算法思路" class="headerlink" title="问题模型与算法思路"></a>问题模型与算法思路</h4><p><strong>问题模型：</strong> 给定两个字符串 S 和 T ，试求出 T 在 S 中第一次出现的位置。</p><p>上述问题模型是模式串匹配最基础的模型，即单模式串匹配问题，这类问题是KMP算法以及字符串Hash大展身手的题型。</p><p><strong>算法思路1：Hash</strong><br>设|S| = n , |T| = m。如果不考虑冲突，那么我们可以将 S 的所有长度为 m 的子串hash值都求出来，复杂度为O(N)。将这 n-m+1 个子串与T的hash值在O(1)的时间内一一比对，即可通过hash值是否相同来判断是否匹配成功。<br>但实际上如果n和m很大(1e6)，那么散列值冲突是不可避免的，此时需要二次判断或者通过其他方法（构造更好的散列函数）来在保证速度的情况下提升正确性。</p><p><strong>算法思路2：KMP</strong><br>设|S| = n , |T| = m。首先考虑一个朴素算法，那就是将字符串 S 中的每一个长度为m的子串都与 T 进行一次匹配，失配后再匹配下一个，复杂度O(NM)。<br>手动模拟一下可以发现，上述做法中指向字符串 S 的指针和 T 的指针都有回退$^{[1]}$，但实际上我们并不需要发生回退，KMP算法就是通过防止指针回退来提升朴素算法效率的。</p><p>假设我们 S[i] 和 T[j+1] 发生了失配，如果我们知道 “T 中以 j 为末尾的真子串” 和 T[1, j] 的最长公共前缀的长度（假设为len，len一定小于 j ），那么显然 T[1, len] = S[i-len+1, i]；于是此时的 j = len，接着匹配即可。我们用nex数组（见下文）来存放 T 对应位置的“len”。</p><p>详细的讲，<strong>KMP算法分为两步：</strong></p><ol><li>对字符串 T 进行自我“匹配”，求出一个数组 nex，其中 nex[i] 表示“ T 中以 i 结尾的非前缀子串”与“ T 的前缀”能够匹配的最大长度，即：<br>&emsp;&emsp;nex[i] = max{j}，其中j &lt; i 并且 T[i-j+1, i] = T[1 ,j]。</li><li>对字符串 T 与 S 进行匹配，求出一个数组 f ，其中 f[i] 表示“S 中以 i 结尾的子串”与“ T 的前缀”能够匹配的最长长度。即：<br>&emsp;&emsp;f[i] = max{j}，其中j &lt;= i并且 S[i-j+1, i] = T[1, j]</li></ol><p><em>[1] 指针回退：在朴素做法中，如果发生失配，则要将指向 S 串的指针回退到当前子串起始位置，并右移至下一个子串起始位置，同理指向 T 的指针也要回到起始位置。</em></p><h4 id="Next数组"><a href="#Next数组" class="headerlink" title="Next数组"></a>Next数组</h4><p>首先要明白什么是Next数组（以下简称nex数组）。<br>nex[i]表示“T 中以 i 结尾的非前缀子串”与“T 的前缀”能够匹配的最长长度，即：nex[i] = max{j}，其中j &lt; i 并且 T[i-j+1, i] = T[i, j]。</p><blockquote><p>跳过：nex数组起到什么辅助作用，为什么要用nex数组？</p></blockquote><p><strong>nex 数组的求法</strong></p><ol><li>初始化 nex[1] = j = 0，假设nex[1, i-1] 已求出，下面求nex[i]。</li><li>不断尝试拓展匹配长度 j，如果拓展失败（下一个字符不相等），令 j 变为nex[j]，直至 j 为0（应该从头开始匹配）。</li><li>如果能够拓展成功，匹配长度 j 就增加1。nex[i] 的值就是 j 。</li></ol><p><strong>代码块</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/*更新模式串s的nex数组*/</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="f-数组"><a href="#f-数组" class="headerlink" title="f 数组"></a>f 数组</h4><p>按照前面的定义， f[i] 表示“S 中以 i 结尾的子串”与“ T 的前缀”能够匹配的最长长度。可以发现 f 数组和 nex 数组定义是一致的，因此他们的求解过程也基本一致。</p><p><strong>代码块</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getF</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">const</span> <span class="keyword">char</span> *T)</span></span>&#123;</span><br><span class="line"><span class="comment">/*求解 f 数组,S是目标串,T是模式串*/</span> </span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(S),len2 = <span class="built_in">strlen</span>(T);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;i &lt; len1;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; (j == len2 || S[i] != T[j+<span class="number">1</span>])) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(S[i] == T[j+<span class="number">1</span>]) j++;</span><br><span class="line">f[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题讲解"><a href="#例题讲解" class="headerlink" title="例题讲解"></a>例题讲解</h4><p><a href="https://www.luogu.org/problem/P3375" target="_blank" rel="noopener">测试地址</a><br><strong>代码模板</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">KMP算法模板-ValenShi</span></span><br><span class="line"><span class="comment">最后修改：2019/9/26</span></span><br><span class="line"><span class="comment">使用说明：</span></span><br><span class="line"><span class="comment">1.字符串起始位置是1而不是0,修改可能会出错.</span></span><br><span class="line"><span class="comment">2.记得初始化nex与f数组</span></span><br><span class="line"><span class="comment">3.原串长度与模式串长度都在函数中用strlen更新,无需修改全局变量 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s1[N],s2[N];</span><br><span class="line"><span class="keyword">int</span> nex[N],f[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/*更新模式串s的nex数组*/</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getF</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">const</span> <span class="keyword">char</span> *T)</span></span>&#123;</span><br><span class="line"><span class="comment">/*求解 f 数组,S是目标串,T是模式串*/</span> </span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(S),len2 = <span class="built_in">strlen</span>(T);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;i &lt; len1;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; (j == len2 || S[i] != T[j+<span class="number">1</span>])) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(S[i] == T[j+<span class="number">1</span>]) j++;</span><br><span class="line">f[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*求解nex数组与f数组,并 按要求 输出答案*/</span></span><br><span class="line">getNex(s2);</span><br><span class="line">getF(s1,s2);</span><br><span class="line"><span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(s1)<span class="number">-1</span>,len2 = <span class="built_in">strlen</span>(s2)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len1;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(f[i] == len2) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i-len2+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len2;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,nex[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,s1+<span class="number">1</span>,s2+<span class="number">1</span>);</span><br><span class="line">s1[<span class="number">0</span>] = s2[<span class="number">0</span>] = <span class="string">'#'</span>;<span class="comment">//不然strlen函数无法使用 </span></span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>董永建，信息学竞赛一本通提高版，福州：福建教育出版社，2018.6，74-81</li><li>李煜东，算法竞赛进阶指南，郑州：河南电子音像出版社，2017.10，65-67</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;KMP算法，又称模式匹配算法，能够在线性时间内判定字符串 T 是否为 S 的子串，并求出字符串 T 在 S 中各次出现的位置。&lt;br&gt;KMP
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Fish eating fruits</title>
    <link href="http://valenshi.top/2019/09/22/fish-eating-fruit/"/>
    <id>http://valenshi.top/2019/09/22/fish-eating-fruit/</id>
    <published>2019-09-22T06:57:11.000Z</published>
    <updated>2019-09-22T07:00:18.062Z</updated>
    
    <content type="html"><![CDATA[<p><a href>测试地址</a><br><strong>题意简述：</strong><br>树上任意两点之间的路径按照模 3 为 012 分类，将两点间距离加和，乘 2 即为答案。 </p><p><strong>解题思路：</strong><br>可以采用树上dp解决，也可以点分治，这里先给出一种树上dp做法：<br><code>dp[i][k]</code> 表示距 i 模 3 为 k 的节点距离和。<br><code>tc[i][k]</code> 表示距 i 模 3 为 k 的节点数目。<br><code>ans[k]</code>  表示所有路径中模 3 为 k 的路径的总长度。<br>目标答案是<code>ans[k]</code> 。<br>初始状态 <code>tc[i][0] = 1</code> 。</p><p>如果每次只考虑所有经过根 x 的路径，并且路径上的一个端点在x的一个子树上，另一个端点在另一个子树上（其他所有情况都可以在x的祖先或者子节点被考虑到，所以这样可以包含所有情况）。<br>假设当前枚举到x的子节点y，之前遍历的子节点已经使得dp和tc数组更新完成，那么我们要计算的路径起点在y，终点在之前遍历过的所有子节点中。<br><strong>分类讨论答案贡献：</strong></p><ol><li>边 x-y 对答案的贡献：设 j，k属于{0,1,2}，x 到 y 的边权为 z ，那么z对答案的贡献为<code>tc[x][j] * tc[y][k] * z</code>。</li><li>终点是 y 的所有路径长度的贡献：<code>dp[y][k] * tc[x][j] * z</code>。</li><li>起点是 x 的所有路径长度的贡献：<code>dp[x][j] * tc[y][k] * z</code>。</li></ol><p><strong>于是状态转移方程：</strong><br><code>dp[x][(j+z)%3] += dp[y][j] + z * tc[y][j]</code><br><code>tc[x][(j+z)%3] += tc[y][j]</code></p><p>当然，在状态转移前也要更新ans数组。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N],ver[N],edge[N],nex[N];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll tc[N][<span class="number">4</span>], dp[N][<span class="number">4</span>], ans[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 利用dfs进行状态转移,x为当前子树根节点 */</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i != <span class="number">-1</span>;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;<span class="comment">//y是父节点则跳过 </span></span><br><span class="line">dfs(y,x);</span><br><span class="line"><span class="comment">/* 这里统计答案 */</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">3</span>;k++)&#123;</span><br><span class="line">ans[(j+k+z)%<span class="number">3</span>] += (dp[x][j]*tc[y][k]%P+dp[y][k]*tc[x][j]%P)%P;</span><br><span class="line">ans[(j+k+z)%<span class="number">3</span>] += z*tc[x][j]%P*tc[y][k]%P;</span><br><span class="line">ans[(j+k+z)%<span class="number">3</span>] %= P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在这里转移状态 */</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)&#123;</span><br><span class="line">dp[x][(j+z)%<span class="number">3</span>] = (dp[x][(j+z)%<span class="number">3</span>] + dp[y][j] + z*tc[y][j])%P;</span><br><span class="line">tc[x][(j+z)%<span class="number">3</span>] = (tc[x][(j+z)%<span class="number">3</span>] + tc[y][j])%P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line"><span class="built_in">memset</span>(tc,<span class="number">0</span>,<span class="keyword">sizeof</span> tc);</span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span> ans);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) tc[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 统计答案并输出 */</span> </span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,ans[i]*<span class="number">2</span>%P);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[<span class="number">2</span>]*<span class="number">2</span>%P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head); tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addEdge(x+<span class="number">1</span>,y+<span class="number">1</span>,z); addEdge(y+<span class="number">1</span>,x+<span class="number">1</span>,z);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href&gt;测试地址&lt;/a&gt;&lt;br&gt;&lt;strong&gt;题意简述：&lt;/strong&gt;&lt;br&gt;树上任意两点之间的路径按照模 3 为 012 分类，将两点间距离加和，乘 2 即为答案。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解题思路：&lt;/strong&gt;&lt;br&gt;可以采用树上dp解决，也
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树上DP" scheme="http://valenshi.top/tags/%E6%A0%91%E4%B8%8ADP/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces Round 586(Div1+Div2)</title>
    <link href="http://valenshi.top/2019/09/21/cf-586/"/>
    <id>http://valenshi.top/2019/09/21/cf-586/</id>
    <published>2019-09-21T07:11:48.000Z</published>
    <updated>2019-09-25T02:50:15.189Z</updated>
    
    <content type="html"><![CDATA[<h4 id="A-Cards"><a href="#A-Cards" class="headerlink" title="A. Cards"></a>A. Cards</h4><p><a href="https://codeforces.com/contest/1220/problem/A" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定一个长度为 n 的字符串，该字符串可以组合出来几个one和几个zero，每个字符只能用一次。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> nn;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,z,e,r,o;</span><br><span class="line">n = z = e = r = o = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= nn;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i] == <span class="string">'o'</span>) o++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'z'</span>) z++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'r'</span>) r++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'e'</span>) e++;</span><br><span class="line"><span class="keyword">else</span> n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> one,zero;</span><br><span class="line">one = min(n,min(o,e));</span><br><span class="line">n -= one, o -= one, e -= one;</span><br><span class="line">zero = min(o,min(e,min(z,r)));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= one;i++) <span class="built_in">printf</span>(<span class="string">"1 "</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= zero;i++) <span class="built_in">printf</span>(<span class="string">"0 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;nn);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="B-Multiplication-Table"><a href="#B-Multiplication-Table" class="headerlink" title="B. Multiplication Table"></a>B. Multiplication Table</h4><p><a href="https://codeforces.com/contest/1220/problem/B" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定一个n <em> n表格，其中$M_{i,j} = a_i </em> a_j$，现在有个坏蛋把序列a给扔了，同时把M_{i,i}都给扣走了，现在请你利用剩下的信息求出a序列。</p><p><strong>解题思路：</strong><br>不是高斯消元题，其实是个找规律题。如果我们能求出来$a_1$，那么我们就可以根据第一列求出所有答案。而我们又可以根据$a_1a_2 = x$ , $a_1a_3 = y$ , $a_2a_3 = z$来求出$a_1$，于是就可以在求出其他所有结果了。<br><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line">ll mat[N][N],ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">ans[<span class="number">1</span>] = mat[<span class="number">1</span>][<span class="number">2</span>]*mat[<span class="number">1</span>][<span class="number">3</span>]/mat[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">ans[<span class="number">1</span>] = (ll)<span class="built_in">sqrt</span>(ans[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">ans[i] = mat[<span class="number">1</span>][i]/ans[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">printf</span>(<span class="string">"%I64d "</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>,&amp;mat[i][j]);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-Substring-Game-in-the-Lesson"><a href="#C-Substring-Game-in-the-Lesson" class="headerlink" title="C. Substring Game in the Lesson"></a>C. Substring Game in the Lesson</h4><p><a href="https://codeforces.com/contest/1220/problem/C" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>Ann和Mike在玩游戏，有一个字符串s，初始时有l  = r = k ，每个人轮流操作：</p><ul><li>选择l’ &lt; l , r’ &lt; r，且s[l’,r’] 字典序小于 s[l,r]，然后令l = l’, r = r’。</li><li>若不能做任何操作，则失败。</li></ul><p>Ann先手，对于每个位置k，输出谁必胜。</p><p><strong>题意简述：</strong><br>简单的博弈论，首先必败态是“在 l 之前不存在l’ &lt; l ， 且s[l’ , r] 字典序小于 s[l ,r] ”，而若当前不是必败态，则一定可以使得下一个状态一定是必败态，于是只需要判断每个位置前面是否有字典序比其小的字符即可。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mi = (<span class="keyword">int</span>)str[<span class="number">0</span>],n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mi &lt; (<span class="keyword">int</span>)str[i]) vis[i] = <span class="number">1</span>;</span><br><span class="line">mi = min(mi,(<span class="keyword">int</span>)str[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line"><span class="keyword">if</span>(vis[i]) <span class="built_in">printf</span>(<span class="string">"Ann\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Mike"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="D-Alex-and-Julian"><a href="#D-Alex-and-Julian" class="headerlink" title="D. Alex and Julian"></a>D. Alex and Julian</h4><p><a href="https://codeforces.com/contest/1220/problem/D" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定一个正整数集合B，令全集Z(所有整数)内的元素作为无向图的顶点，对于图中内任意两点i 和 j，若abs(i - j)属于集合B，则 i 和 j 之间有一条无向边。现在请问最少删除B中几个顶点可以使得剩下的图是二分图。</p><p><strong>解题思路：</strong><br>不是二分图问题，只用到了“一张图是二分图，当且仅当图中不存在奇环”这一二分图判定定理。<br>至于为啥不能用二分图算法来解决呢，从问题规模就可以猜到，因为要构造图需要$O((1e18)^2)$，显然n的规模不允许这样做。</p><p>那么从数学角度考虑（找规律），若有节点0和节点a，那么0 到 a有边，若还存在节点2 <em> a ，那么a 和2 </em> a也有边，且2 <em> a与 0也有边，这就是奇环了（哪怕还有3 </em> a，也还是奇环+一个偶环），因此不能有2 <em> a，同理也不能有4 </em> a，因此若想保留a，那么2 <em> a，4 </em> a， 8 * a， … 都要删去。<br>但是这样做法复杂度过高，因为顶点集合是[1, 1e18]，挨个计算显然不现实，因此我们可以对集合B中每个元素b，B中有哪些元素可以和b一起被保留。</p><p>若a中有x个因数2，b中有y个因数2（x != y），那么a和b一定不能同时存在；假设c = lcm(a ,b)那么0 -&gt; a -&gt; 2 <em> a -&gt; … -&gt; c -&gt; … -&gt; 2 </em> b -&gt; b -&gt; 0一定可以构成一个奇环 ，因此a和b不能同时存在。所以若是x != y，则a和b不能同时存在（a和b都是集合B内元素）。</p><p>若是x = y，那么a和b可以同时存在，因为它们不存在a是b的倍数，或者b是a的倍数这种情况，也就不能删去0，因此若有环则一定是偶环。</p><p>综上所述，我们通过统计B集合中每个元素有多少个因子2即可判断最多同时存在多少个元素，即最少删去多少个元素。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="keyword">int</span> tc[N],num[N],n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ll tmp = a[i];</span><br><span class="line"><span class="keyword">while</span>(tmp &amp;&amp; tmp%<span class="number">2</span> == <span class="number">0</span>) tc[i]++,tmp/=<span class="number">2</span>;</span><br><span class="line">num[tc[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">64</span>;i++)</span><br><span class="line"><span class="keyword">if</span>(num[p] &lt; num[i]) p = i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n-num[p]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line"><span class="keyword">if</span>(tc[i] != p) <span class="built_in">printf</span>(<span class="string">"%I64d "</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="E-Tourism"><a href="#E-Tourism" class="headerlink" title="E. Tourism"></a>E. Tourism</h4><p><a href="https://codeforces.com/contest/1220/problem/E" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>一共有n个点和m条无向边，每个点有权值，同一条边不能<strong>连续经过</strong>两次；每个点的权值最多只能加一次；给出每个点的权值以及无向图的边，给出起点编号s，求出怎样才能走才能使得权值和最大。</p><p><strong>解题思路：</strong><br>很容易发现如果经过一个环，那么该环上所有点的权值都可以拿到，且可以从环上任意一点出环，于是我们就可以将一个环缩为一个点，将图中所有环都缩为点后，无向图就成了无根树。题目就成了求无根树上从s出发的最远路径。于是该方法需要Tarjan缩点+树上dp，同时需要注意叶子节点不能缩（一定不是环）。</p><p>另一种方法就是利用拓扑排序。我们可以通过画图等模拟发现，最终答案一定是一些环与从环上出发的一条最长链。<br>于是我们可以考虑如下算法：</p><ol><li>利用拓扑排序，每次都从叶子节点出发，将路径上的权值累加到环上的对应节点（另开数组存放）并终止，并标记路径上的所有点。</li><li>由于环上所有点可互相到达，因此将所有未被标记的点的权值累加（有可能好几个环，但是环与环之间的路径未被标记，并且可达），即为可获得的环上最大权值和。</li><li>找从环上某点出发的最长链，与上述结果相加即为最终答案。</li></ol><p>很显然上述算法是正确的，我们将答案分为了两部分：可互达的“连通环”以及“从环上出发的最长链”。又由于我们是从s出发的，上述算法我们是累加未被标记的节点，因此如果标记的时候遇到了s，那么就将结果累加到s的附加域并终止；最终累加时候因为从 s 出发的链未被标记，因此依然会被累加。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[M],ver[M],nex[M];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> deg[N];<span class="comment">//入度,初始值为0 </span></span><br><span class="line">ll w[N],cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; </span><br><span class="line">head[x] = tot; deg[y]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> n,m,s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line"><span class="keyword">if</span>(deg[i] == <span class="number">1</span> &amp;&amp; i != s) q.push(i);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">deg[x] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(deg[y] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">deg[y]--;</span><br><span class="line">cnt[y] = max(cnt[y],cnt[x]+w[x]);</span><br><span class="line"><span class="keyword">if</span>(deg[y] == <span class="number">1</span> &amp;&amp; y != s) q.push(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll s1 = <span class="number">0</span>,s2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(deg[i] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">s1 += w[i];</span><br><span class="line">s2 = max(s2,cnt[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,s1+s2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,w+i); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;A-Cards&quot;&gt;&lt;a href=&quot;#A-Cards&quot; class=&quot;headerlink&quot; title=&quot;A. Cards&quot;&gt;&lt;/a&gt;A. Cards&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1220/pro
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="博弈论" scheme="http://valenshi.top/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
      <category term="数论" scheme="http://valenshi.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="拓扑排序" scheme="http://valenshi.top/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="图论" scheme="http://valenshi.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>5 连续内存分配</title>
    <link href="http://valenshi.top/2019/09/20/os5/"/>
    <id>http://valenshi.top/2019/09/20/os5/</id>
    <published>2019-09-20T14:52:54.000Z</published>
    <updated>2019-09-23T12:16:26.853Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机体系结构和内存层次"><a href="#计算机体系结构和内存层次" class="headerlink" title="计算机体系结构和内存层次"></a>计算机体系结构和内存层次</h3><ul><li>计算机体系结构</li><li>内存层次</li><li>操作系统的内存管理方式</li></ul><h4 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h4><p>基本的分配和释放的管理要求。cpu高速缓存，存储管理单元（MMU），内存最小访问单位8bit；32位的意思是一次可以读写32位；高速缓存用来存放会重复使用的数据，用来提高效率；</p><h4 id="内存层次"><a href="#内存层次" class="headerlink" title="内存层次"></a>内存层次</h4><p>缓存速度最快，首先去缓存找数据，若未命中则去内存中找，若仍未命中则去外存（虚拟内存）中找，这三者速度差别很大。</p><h4 id="操作系统的内存管理"><a href="#操作系统的内存管理" class="headerlink" title="操作系统的内存管理"></a>操作系统的内存管理</h4><p>知识点：我们希望的理想状态。逻辑存储单元。<br><strong>存储管理要达到的效果：</strong></p><ul><li>抽象：逻辑地址空间</li><li>保护：独立地址空间</li><li>共享：访问相同内存</li><li>虚拟化：更大的地址空间</li></ul><h4 id="操作系统中采用的内存管理方式："><a href="#操作系统中采用的内存管理方式：" class="headerlink" title="操作系统中采用的内存管理方式："></a>操作系统中采用的内存管理方式：</h4><ul><li>重定位（relocation）</li><li>分段（segmentation）</li><li>分页（paging）</li><li>虚拟存储（目前多数系统，如Linux，采用按需页式虚拟存储）</li></ul><p><strong>实现高度依赖硬件：</strong></p><ul><li>与计算机存储架构紧耦合</li><li>MMU（内存管理单元）：处理CPU存储访问请求的硬件</li></ul><h3 id="地址空间和地址生成"><a href="#地址空间和地址生成" class="headerlink" title="地址空间和地址生成"></a>地址空间和地址生成</h3><h4 id="地址空间的定义"><a href="#地址空间的定义" class="headerlink" title="地址空间的定义"></a>地址空间的定义</h4><p>物理地址空间-硬件支持的地址空间（地址总线条数）。</p><ul><li>起始地址为0，知道$MAX_{sys}$</li></ul><p>逻辑地址空间-在CPU运行的进程看到的地址</p><ul><li>起始地址为0，直到$MAX_{prog}$</li></ul><p>地址是从哪里来的？</p><h4 id="逻辑地址生成"><a href="#逻辑地址生成" class="headerlink" title="逻辑地址生成"></a>逻辑地址生成</h4><p><img src="/2019/09/20/os5/1.png" alt="1"></p><p><center>图1：逻辑地址生成图示</center></p><h4 id="地址生成时机和限制"><a href="#地址生成时机和限制" class="headerlink" title="地址生成时机和限制"></a>地址生成时机和限制</h4><p>编译时：</p><ul><li>假设起始地址已知</li><li>如果起始地址改变，必须重新编译</li></ul><p>加载时：</p><ul><li>如编译时起始位置位置，编译器需生成可重定位的代码</li><li>加载时，生成绝对地址</li></ul><p>执行时：</p><ul><li>执行时代码可移动</li><li>需地址转换（映射）硬件支持</li></ul><h4 id="地址生成过程"><a href="#地址生成过程" class="headerlink" title="地址生成过程"></a>地址生成过程</h4><p>CPU：</p><ul><li>ALU：需要逻辑地址的内存内容</li><li>MMU：进行逻辑地址和物理地址的转换</li></ul><p>内存：</p><ul><li>发送物理地址的内容给CPU</li><li>或接受CPU数据到物理地址</li></ul><p>操作系统：</p><ul><li>建立逻辑地址LA和物理地址PA的映射</li></ul><h4 id="地址检查"><a href="#地址检查" class="headerlink" title="地址检查"></a>地址检查</h4><p>检查段的长度和偏移量是否为有效范围。</p><h3 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h3><h4 id="连续内存分配和内存碎片"><a href="#连续内存分配和内存碎片" class="headerlink" title="连续内存分配和内存碎片"></a>连续内存分配和内存碎片</h4><p><strong>连续内存分配：</strong> 给进程分配一块不小于指定大小的连续的物理内存。<br><strong>内存碎片：</strong> 空闲内存不能被利用。<br><strong>外部碎片：</strong> 分配单元之间的未被使用的内存。<br><strong>内部碎片：</strong> 分配单元内部的未被使用的内存，取决于分配单元大小是否要调整。</p><h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p><strong>动态内存分配：</strong></p><ul><li>当程序被加载可执行时，分配一个进程指定大小可变的分区（块，内存块）</li><li>分区的地址是连续的</li></ul><p><strong>操作系统需要维护的数据结构：</strong></p><ul><li>所有进程的已分配分区</li><li>空闲分区（Empty-blocks）</li></ul><p><strong>动态分区分配策略：</strong></p><ul><li>最先匹配</li><li>最优匹配</li><li>最差匹配</li></ul><h4 id="最先匹配（First-Fit-Allocation）策略"><a href="#最先匹配（First-Fit-Allocation）策略" class="headerlink" title="最先匹配（First Fit Allocation）策略"></a>最先匹配（First Fit Allocation）策略</h4><p>思路：分配n个字节时，使用第一个可用的空间比n大的空闲块。<br>原理&amp;实现：</p><ul><li>空闲分区列表按照地址顺序排序</li><li>分配过程中，搜索一个合适的分区</li><li>释放分区时，检查是否可与临近的空闲分区合并</li></ul><p>优点：</p><ul><li>简单</li><li>在高地址上有大块的空闲分区</li></ul><p>缺点：</p><ul><li>外部碎片多</li><li>分配大块时较慢</li></ul><h4 id="最佳匹配（Best-Fit-Allocation）策略"><a href="#最佳匹配（Best-Fit-Allocation）策略" class="headerlink" title="最佳匹配（Best Fit Allocation）策略"></a>最佳匹配（Best Fit Allocation）策略</h4><p>思路：分配n个字节时，查找并使用不小于n的最小空闲分区<br>原理&amp;实现：</p><ul><li>空闲分区列表按照大小排序</li><li>分配时，查找一个合适的分区</li><li>释放时，查找并合并临近的空闲分区（如果找到）</li></ul><p>优点： 大部分分配的尺寸较小时，效果很好</p><ul><li>可避免大的空闲分区被拆分</li><li>可减小外部碎片的大小</li><li>相对简单</li></ul><p>缺点：</p><ul><li>外部碎片</li><li>释放分区慢</li><li>容易产生很多无用的小碎片</li></ul><h4 id="最差匹配（Worst-Fit-Allocation）策略"><a href="#最差匹配（Worst-Fit-Allocation）策略" class="headerlink" title="最差匹配（Worst Fit Allocation）策略"></a>最差匹配（Worst Fit Allocation）策略</h4><p>思路：分配n字节，使用尺寸不小于n的最大空闲分区。<br>原理&amp;实现：</p><ul><li>空闲分区按从大到小排序</li><li>分配时，选最大的分区</li><li>释放时，检查是否可与临近的空闲分区合并，进行可能的合并，并调整空闲分区列表的顺序</li></ul><p>优点：</p><ul><li>中等大小的分配较多时，效果最好</li><li>避免出现太多的小碎片</li></ul><p>缺点：</p><ul><li>释放分区较慢</li><li>外部碎片</li><li>容易破坏大的空闲分区，因此后续难以分配大的分区</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;计算机体系结构和内存层次&quot;&gt;&lt;a href=&quot;#计算机体系结构和内存层次&quot; class=&quot;headerlink&quot; title=&quot;计算机体系结构和内存层次&quot;&gt;&lt;/a&gt;计算机体系结构和内存层次&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;计算机体系结构&lt;/li&gt;
&lt;li&gt;内存层次&lt;/l
      
    
    </summary>
    
      <category term="计算机操作系统" scheme="http://valenshi.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="内存分配" scheme="http://valenshi.top/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Dudu&#39;s maze 解题报告</title>
    <link href="http://valenshi.top/2019/09/15/dudu-maze/"/>
    <id>http://valenshi.top/2019/09/15/dudu-maze/</id>
    <published>2019-09-15T05:29:21.000Z</published>
    <updated>2019-09-15T05:30:57.412Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://nanti.jisuanke.com/t/41402" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>在一个无向图中，有 k 个怪物点，n-k个糖果点，每个糖果点有1个糖果，且可以移动到相邻的点，但是每个点的糖果只能拿一次（但是可以经过多次）。而每个怪物点没糖果，但是可以随机传送到相邻的点，只能传送一次（即只能进一次怪物房），请问最终拿到糖果的最优期望是多少？<br><strong>解题思路：</strong><br>dfs求连通块+染色，我现在还是不明白我单独染色为什么一直超时，无语了，就按照下面的代码写吧，用标记数组单独存放被染色的连通块糖果数，相当于记忆化。当然节点1所在的连通块糖果都能拿到，然后再选择走和1相连的且期望最大的怪物点即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[<span class="number">2</span>*N],nex[<span class="number">2</span>*N],tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,t,k;</span><br><span class="line"><span class="keyword">int</span> vis[N],mst[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y;nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> vm[N],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"><span class="keyword">int</span> tc[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="number">1</span>; ans++; tc[x]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i != <span class="number">-1</span>;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(mst[y])&#123;</span><br><span class="line">vm[++cnt] = y;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">dfs1(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num[col]) <span class="keyword">return</span> num[col];</span><br><span class="line"><span class="keyword">if</span>(vis[x] || mst[x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> res = <span class="number">1</span>; vis[x] = col;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i != <span class="number">-1</span>;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y] || mst[y]) <span class="keyword">continue</span>;</span><br><span class="line">res += dfs2(y,col);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">ans = <span class="number">0</span>; cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span> num);</span><br><span class="line">dfs1(<span class="number">1</span>); <span class="keyword">double</span> mx = <span class="number">0</span>; <span class="keyword">int</span> col = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++)&#123;</span><br><span class="line"><span class="keyword">double</span> pp = <span class="number">0</span>,ecnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = head[vm[i]] ;j != <span class="number">-1</span>;j = nex[j]) ecnt++;</span><br><span class="line"><span class="comment">//printf("ecnt: %f\n",ecnt);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = head[vm[i]] ;j != <span class="number">-1</span>;j = nex[j])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[j]; <span class="keyword">double</span> tmp;</span><br><span class="line"><span class="keyword">if</span>(vis[y]) tmp = num[vis[y]];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">tmp = dfs2(y,++col);</span><br><span class="line">num[col] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">pp += tmp;</span><br><span class="line"><span class="comment">//printf("%d %f\n",ver[j] ,tmp);</span></span><br><span class="line">&#125;</span><br><span class="line">pp /= ecnt;</span><br><span class="line"><span class="keyword">if</span>(mx - pp &lt; <span class="number">0</span>) mx = pp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.7f\n"</span>,mx+ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">t = getInt();</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">tot = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(mst,<span class="number">0</span>,<span class="keyword">sizeof</span> mst);</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">n = getInt(), m = getInt(),k = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">addEdge(x,y);addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= k;i++) x = getInt() , mst[x] = <span class="number">1</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://nanti.jisuanke.com/t/41402&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测试地址&lt;/a&gt;&lt;br&gt;&lt;strong&gt;题意简述：&lt;/strong&gt;&lt;br&gt;在一个无向图中，有 k 个怪物点，n-k个糖果
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="dfs连通块" scheme="http://valenshi.top/tags/dfs%E8%BF%9E%E9%80%9A%E5%9D%97/"/>
    
      <category term="染色" scheme="http://valenshi.top/tags/%E6%9F%93%E8%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>Educational Codeforces Round 72 解题报告</title>
    <link href="http://valenshi.top/2019/09/10/cf-r72/"/>
    <id>http://valenshi.top/2019/09/10/cf-r72/</id>
    <published>2019-09-10T13:36:28.000Z</published>
    <updated>2019-09-10T13:40:39.340Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1217" target="_blank" rel="noopener">题集链接</a></p><h4 id="A-Creating-a-Character"><a href="#A-Creating-a-Character" class="headerlink" title="A.Creating a Character"></a>A.Creating a Character</h4><p><strong>题意简述：</strong><br>有三个数a，b，c，将c分配在a和b上，使得a&gt;b，请问有多少种分配方案？两个方案不同，当且仅当它们对应的a或b不相等。</p><p><strong>解题思路：</strong><br>假设将c分配给a和b后使得a = b = res，那么显然若原始的a &gt; res，就说明b+c &lt; a，那么答案就是c+1（当然特判b+c&lt;a也行）；否则a &lt;= res，此时分配给a的值一定要大于res - a，所以共c - (res-a) = c-res + a 种不同方案。 </p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a,b,c,t,d;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a+c &lt;= b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = a+b+c&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a &gt; res) <span class="keyword">return</span> c+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> c-res+a; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="B-Zmei-Gorynich"><a href="#B-Zmei-Gorynich" class="headerlink" title="B.Zmei Gorynich"></a>B.Zmei Gorynich</h4><p><strong>题意简述：</strong><br>一条恶龙共 x 滴血，勇士有n件武器，每件武器有伤害值 d 和 副作用 h，表示着将会给恶龙造成 d 点伤害，之后会给恶龙回 h 点血。当某一时刻恶龙血量低于0时则会死亡，请问勇者最少砍多少次才能杀死恶龙？如果杀不死输出-1，一个武器可以重复使用。<br><strong>解题思路：</strong><br>如果当前有一个武器能杀死恶龙（d &gt;= x），那么就可以忽略他的副作用 h ，直接秒杀恶龙；否则我们就要选择一个d-h最大的来砍恶龙，所以我们最多用两把武器，一把用来消耗，一把用来终结恶龙。当无法秒杀恶龙，也无法消耗恶龙时，说明无法杀死恶龙。否则就可以通过计算最少需要消耗多少次来O(1)计算答案。</p><p>特别注意是否能一刀秒杀恶龙等特殊情况。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> t1,t2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//恶龙本来就死了</span></span><br><span class="line"><span class="keyword">if</span>(t1 &gt;= x) <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//秒杀恶龙</span></span><br><span class="line"><span class="keyword">if</span>(t2 &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//无法杀死恶龙</span></span><br><span class="line">x -= t1;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x%t2) res++;</span><br><span class="line">res += x/t2;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;x); t1 = t2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,ta,tb;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;ta,&amp;tb);</span><br><span class="line">t1 = max(t1,ta);</span><br><span class="line">t2 = max(t2,ta-tb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="C-The-Number-Of-Good-Substrings"><a href="#C-The-Number-Of-Good-Substrings" class="headerlink" title="C.The Number Of Good Substrings"></a>C.The Number Of Good Substrings</h4><p><strong>题意简述：</strong><br>给定一个01串 s ，假设 sub 是 s 的子串，定义f(sub) = “sub十进制的值”。若f(sub) = len(sub)，f(sub) = 子串sub的长度，那么称sub为“优秀的子串”。<br>现在给定字符串s，试求出s的“优秀的子串”的数量。</p><p><strong>解题思路：</strong><br>刚开始想用KMP算法：对于每一可能的长度（共2e5种可能的情况）转化为二进制的01串，再用KMP计算该串在 s 中出现的次数，将所有情况累加即为答案。<br>但是KMP超时了，还是对KMP不太熟悉，上述算法复杂度应该是$O(N^2)$，是不行的。</p><p>再考虑由于$2^{20} &gt; 2e5$ 所以我们其实可以通过将 s 所有长度为 [1 , 20] 的子串挨个判断是否为“优秀的子串”，如此O(20N)时间内求出结果。具体做法是从左向右，将上一个 1 作为子串左端点，然后依次向右延申，长度+1，并将其转化为十进制，如果该十进制要大于区间长度，则后续肯定也不可能是“优秀子串”，故退出。能这样做是因为左边的0不影响十进制数的大小，而右边的0影响。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> last = <span class="number">0</span>,x,l,len = <span class="built_in">strlen</span>(str); ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;str[i];i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i] == <span class="string">'0'</span>) <span class="keyword">continue</span>; x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; len &amp;&amp; j &lt;= i+<span class="number">25</span>;j++)&#123;</span><br><span class="line">x = x*<span class="number">2</span>+str[j]-<span class="string">'0'</span>;</span><br><span class="line">l = j-x+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= last) <span class="keyword">break</span>;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">last = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="D-Coloring-Edges"><a href="#D-Coloring-Edges" class="headerlink" title="D.Coloring Edges"></a>D.Coloring Edges</h4><p><strong>题意简述：</strong><br>给定一个有 n 个点 m 条边的有向图，该有向图无自环无重边。我们对该有向图进行染色，一个好的染色方案当且仅当图中没有一个环是同一个颜色。请问要想使得该染色方案是好的，最少需要多少种不同的颜色？并输出每条边的颜色。<br><strong>解题思路：</strong><br>首先通过手画几种样例可以得出，我们最多只需要2种不同的颜色就可以完成图的着色。因此若图中有环，则k = 2，否则k = 1。而当k = 2时，即图中有环，需要2种不同颜色染色时，我们知道有向图中，若存在环，则必然有从编号小的点指向编号大的点，也有编号大的点指向编号小的点。因此，若边u-&gt;v，若u &lt; v则染颜色1，否则染颜色2，这样可以保证该环被拆分成两种颜色。</p><p><em>注：若有向图中不存在环，则不一定有 “从编号小的点指向编号大的点，同时也有从编号大的点指向编号小的点。”</em></p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[N],ver[N],nex[N];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x];</span><br><span class="line">head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,xx[N],yy[N];</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span>;</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y] == <span class="number">1</span>)&#123;</span><br><span class="line">flag = <span class="literal">true</span>; <span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!vis[y]) dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">vis[x] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!vis[i]) dfs(i);</span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(xx[i] &gt; yy[i]) <span class="built_in">printf</span>(<span class="string">"2 "</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"1 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">printf</span>(<span class="string">"1 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;xx[i],&amp;yy[i]);</span><br><span class="line">addEdge(xx[i],yy[i]);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/1217&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题集链接&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;A-Creating-a-Character&quot;&gt;&lt;a href=&quot;#A-Crea
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="图论" scheme="http://valenshi.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>hdu6629 string matching（拓展KMP）</title>
    <link href="http://valenshi.top/2019/09/06/hdu6629-String-Match/"/>
    <id>http://valenshi.top/2019/09/06/hdu6629-String-Match/</id>
    <published>2019-09-06T08:22:55.000Z</published>
    <updated>2019-09-06T08:25:42.812Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6629" target="_blank" rel="noopener">hdu6629string matching</a><br><strong>Description:</strong><br>给出一个字符串S，我们执行“求出S所有后缀与S的最长公共前缀长度”这个操作，我们采取暴力算法(算法流程见题面)，请问我们在该算法中共执行了多少次比较操作？<br><strong>Input:</strong><br>第一行一个整数t，接下来共t组测试用例，每个测试用例输入一个长度小于1e6的字符串S。<br><strong>解题思路：</strong><br>可以用拓展KMP做，其中S是原串，T也是原串。暴力算法的比较次数就等同于所有后缀的最长公共前缀长度和，若没有比到字符串末尾，则还要加上一次失配的操作比较。由于本题T也是S，故可以在计算nex数组的同时便统计答案。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> nex[N];<span class="comment">//nex[i] = T[i,n-1]与T[0,n-1]最长公共前缀 </span></span><br><span class="line"><span class="keyword">char</span> S[N];<span class="comment">//S为目标串,T为模式串 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str) ,i = <span class="number">0</span>,j,p0 ;</span><br><span class="line">nex[<span class="number">0</span>] = len;</span><br><span class="line"><span class="keyword">while</span>(i+<span class="number">1</span> &lt; len &amp;&amp; str[i] == str[i+<span class="number">1</span>]) i++;</span><br><span class="line">nex[<span class="number">1</span>] = i; p0 = <span class="number">1</span>; ans += nex[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(nex[<span class="number">1</span>] != len<span class="number">-1</span>) ans++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex[i-p0]+i &lt; nex[p0]+p0) nex[i] = nex[i-p0];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j = nex[p0]+p0-i;</span><br><span class="line"><span class="keyword">if</span>(j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i+j &lt; len &amp;&amp; str[j] == str[j+i]) j++;</span><br><span class="line">nex[i] = j; p0 = i;</span><br><span class="line">&#125;</span><br><span class="line">ans += nex[i];</span><br><span class="line"><span class="keyword">if</span>(nex[i] != len-i) ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算并返回答案*/</span></span><br><span class="line">ans = <span class="number">0</span>; getNex(S);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,S);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6629&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hdu6629string matching&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="拓展KMP" scheme="http://valenshi.top/tags/%E6%8B%93%E5%B1%95KMP/"/>
    
  </entry>
  
  <entry>
    <title>拓展KMP算法</title>
    <link href="http://valenshi.top/2019/09/06/exkmp/"/>
    <id>http://valenshi.top/2019/09/06/exkmp/</id>
    <published>2019-09-06T08:22:41.000Z</published>
    <updated>2019-09-06T08:24:34.010Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题模型：</strong><br>给定字符串S和子串T，S的长度为n，T的长度为m；求字符串T与字符串S的每一个后缀d的最长公共前缀。</p><h4 id="拓展KMP算法"><a href="#拓展KMP算法" class="headerlink" title="拓展KMP算法"></a>拓展KMP算法</h4><p>假设 extend[] 数组： extend[i] 表示 T 与 S[i, n] 的最长公共前缀，目的是求出所有的 extend[0~n-1]。<br>（注意到，如果存在extend[i] = m，则说明 T 在 S 中完全出现过，那么问题就变成标准KMP算法了。）<br>我们下面的目标就是如何在较短的时间内更新extend数组；与KMP算法类似，我们通过利用next数组来阻止指针的回退。</p><p><strong>下面先通过一般的例子来看我们是如何更新extend数组的：</strong></p><p>S = “aaaabaa” , T = “aaaaa”。</p><p>显然extend[0] = 4，显然当匹配到第5个时失配，共匹配了5次。<br>我们考虑利用已知的信息来计算extend[1]，已知S[1 , 3] = T[1 , 3]，现在要用S[1 , n-1]和T[0 , n-1]进行匹配，如果我们设 nex[1] 存放 T[1 , n-1] 与 T[0 , n-1] 的最长公共前缀，nex[1] = 4，这就说明<strong>对于S[1, n-1]，T[1 , n-1]能匹配上的字符，T[0,n-1]的前nex[1]个也能匹配的上</strong>，由于T[1,n-1]只能匹配S[1 , 3]共3个字符，那么显然前 3 个字符都可以成功匹配，我们直接匹配下一位即可；于是extend[1] = 3。</p><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><p><strong>定义extend[]数组：</strong> extend[i] 表示字符串 T 与字符串 S[i , n] 的最长公共前缀长度。<br><strong>定义nex[]数组：</strong> nex[i] 表示 T[i , n] 与 T[1 , n] 的最长公共前缀的长度。</p><p>首先我们从左到右计算extend数组，假设在某一时刻 extend[0 , k] 已经计算完毕，并且之前匹配过程中所达到的最远距离为p，所谓最远距离即 p = MAX{ i+extend[i]  (0 &lt;= i &lt;= k) } 的最大值，p’ 为达到最远距离时的 i 。</p><p><strong>现在来利用已知的信息求extend[k+1]：</strong><br>已知S[p’ , p] = T[0, p-p’]，即S[k+1 , p] = T[k+1 - p’ , p-p’]。<br>设 len = nex[k+1 - p’] ，即 len 为 T[k+1 - p’ , n-1] 与 T[0 , n-1]的最长公共前缀。</p><ul><li>如果k+len &lt; p，则extend[k+1] = len：<br>此时由于已知条件 以及 nex数组性质，可以知道前 len 个字符一定是匹配的。若S[k+ len+1] = T[len]，则说明 nex 是len+1而非len，于是与nex数组矛盾，故不成立；因此若k+len &lt; p，则extend[k+1] = len。</li></ul><p><img src="/2019/09/06/exkmp/1.png" alt="1"><br>(图1：当k+len&lt;p时情形，其中po = p’，图片来自 <em>dyx心心</em> 的博客)</p><ul><li>若k+len &gt;= p：<br>此时已知的是S[k+1 , p] = T[0 , p-k-1]，但是 S[p+1] 是否等同于 T[p-k] 尚且未知，因此需要向后遍历判断，同时更新p与p’。</li></ul><p><img src="/2019/09/06/exkmp/2.png" alt="2"><br>(图2：当k+len &gt;= p时情形，其中po = p’，图片来自 <em>dyx心心</em> 的博客)</p><p>对于nex数组，其求法和extend数组类似，详情参考代码中getNex()函数实现方法。</p><h4 id="例题模板"><a href="#例题模板" class="headerlink" title="例题模板"></a>例题模板</h4><p><a href="https://www.luogu.org/problem/P5410" target="_blank" rel="noopener">洛谷P5410拓展KMP模板</a><br><strong>题意简述：</strong><br>给定字符串S和T，输出next数组以及extend数组。</p><p><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> nex[N];<span class="comment">//nex[i] = T[i,n-1]与T[0,n-1]最长公共前缀 </span></span><br><span class="line"><span class="keyword">char</span> S[N],T[N]; <span class="comment">//S为目标串,T为模式串 </span></span><br><span class="line"><span class="keyword">int</span> extend[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算nex数组*/</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str) ,i = <span class="number">0</span>, j, p0 ;</span><br><span class="line">nex[<span class="number">0</span>] = len;</span><br><span class="line"><span class="keyword">while</span>(i+<span class="number">1</span> &lt; len &amp;&amp; str[i] == str[i+<span class="number">1</span>]) i++;</span><br><span class="line">nex[<span class="number">1</span>] = i; p0 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex[i-p0]+i &lt; nex[p0]+p0) nex[i] = nex[i-p0];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j = nex[p0]+p0-i;</span><br><span class="line"><span class="keyword">if</span>(j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i+j &lt; len &amp;&amp; str[j] == str[j+i]) j++;</span><br><span class="line">nex[i] = j; p0 = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exKMP</span><span class="params">(<span class="keyword">char</span>* str1,<span class="keyword">char</span> *str2)</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算str2与str1的所有后缀的最长公共前缀长度,存放在extend数组中*/</span> </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>,j,p0,l1 = <span class="built_in">strlen</span>(S), l2 = <span class="built_in">strlen</span>(T);</span><br><span class="line">getNex(str2);</span><br><span class="line"><span class="keyword">while</span>(i &lt; l1 &amp;&amp; i &lt; l2 &amp;&amp; str1[i] == str2[i]) i++;</span><br><span class="line">extend[<span class="number">0</span>] = i;p0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; l1;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex[i-p0]+i &lt; extend[p0]+p0) extend[i] = nex[i-p0];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">j = extend[p0]+p0-i;</span><br><span class="line"><span class="keyword">if</span>(j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i+j &lt; l1 &amp;&amp; j &lt; l2 &amp;&amp; str1[j+i] == str2[j]) j++;</span><br><span class="line">extend[i] = j; p0 = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算并输出答案*/</span></span><br><span class="line"><span class="keyword">int</span> l1 = <span class="built_in">strlen</span>(S), l2 = <span class="built_in">strlen</span>(T);</span><br><span class="line">exKMP(S,T);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; l2;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,nex[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; l1;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,extend[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,S,T);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://blog.csdn.net/dyx404514/article/details/41831947#commentBox" target="_blank" rel="noopener">dyx心心的博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;问题模型：&lt;/strong&gt;&lt;br&gt;给定字符串S和子串T，S的长度为n，T的长度为m；求字符串T与字符串S的每一个后缀d的最长公共前缀。&lt;/p&gt;
&lt;h4 id=&quot;拓展KMP算法&quot;&gt;&lt;a href=&quot;#拓展KMP算法&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="拓展KMP" scheme="http://valenshi.top/tags/%E6%8B%93%E5%B1%95KMP/"/>
    
  </entry>
  
  <entry>
    <title>hdu6638 Snowy Smile-线段树维护最大子矩阵</title>
    <link href="http://valenshi.top/2019/09/03/hdu6638-Snowy-Smile/"/>
    <id>http://valenshi.top/2019/09/03/hdu6638-Snowy-Smile/</id>
    <published>2019-09-03T12:53:13.000Z</published>
    <updated>2019-09-03T12:54:05.891Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6638" target="_blank" rel="noopener">题目链接</a></p><h4 id="Snowy-Smile"><a href="#Snowy-Smile" class="headerlink" title="Snowy Smile"></a>Snowy Smile</h4><p><strong>题意简述：</strong><br>给出平面上n(n &lt;= 2000)个点，点的坐标在-1e9~1e9之间，试求出最大子矩阵的和是多少。</p><p><strong>解题思路：</strong><br>考虑数据范围，2e3个点离散化后可能会有2e3个，本题中各个点是离散的，所以用普通的动态规划比较麻烦，因此本题采用$O(N^2log_2N)$的线段树+枚举。<br>我们对x，枚举所有可能的x[i]和x[j]其中x[i]为上界，x[j]为下界，这个枚举花费时间为$O(N^2)$，而对于每一种可能的组合，再利用线段树$O(log_2N)$求出最大连续子段和，因此总时间$O(N^2log_2N)$。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3010</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">int</span> tmp[N];<span class="comment">//离散化用</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Chest</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,val;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Chest &amp; B) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt; B.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;cs[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="comment">/*分别为区间和,区间最大子段和,</span></span><br><span class="line"><span class="comment">从左侧开始的最大子段和,从右侧开始的最大子段和*/</span></span><br><span class="line">ll sum,mx,lx,rx; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mx(x) tr[x].mx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lx(x) tr[x].lx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rx(x) tr[x].rx </span></span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*在区间[l,r]上建立一棵线段树*/</span></span><br><span class="line">sum(rt) = mx(rt) = lx(rt) = rx(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid);</span><br><span class="line">BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="comment">/*用于根据rt的子节点更新rt的4个数据*/</span></span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>)+sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">mx(rt) = max(rx(rt*<span class="number">2</span>)+lx(rt*<span class="number">2</span>+<span class="number">1</span>),max(mx(rt*<span class="number">2</span>),mx(rt*<span class="number">2</span>+<span class="number">1</span>)));</span><br><span class="line">lx(rt) = max(lx(rt*<span class="number">2</span>),sum(rt*<span class="number">2</span>)+lx(rt*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">rx(rt) = max(rx(rt*<span class="number">2</span>+<span class="number">1</span>),sum(rt*<span class="number">2</span>+<span class="number">1</span>)+rx(rt*<span class="number">2</span>));</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p,<span class="keyword">int</span> val,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将线段树p位置的值设为val;l,r是辅助作用哦*/</span></span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum(rt) += val;</span><br><span class="line">lx(rt) = rx(rt) = mx(rt) = sum(rt); </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= mid) Insert(rt*<span class="number">2</span>,p,val,l,mid);</span><br><span class="line"><span class="keyword">else</span> Insert(rt*<span class="number">2</span>+<span class="number">1</span>,p,val,mid+<span class="number">1</span>,r);</span><br><span class="line">spread(rt);<span class="comment">//在回溯时更新节点的值 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回当前最大连续子段和*/</span></span><br><span class="line"><span class="keyword">return</span>  tr[<span class="number">1</span>].mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">sort(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">int</span> cnt = unique(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+n)-tmp<span class="number">-1</span>;</span><br><span class="line">sort(cs+<span class="number">1</span>,cs+<span class="number">1</span>+n);</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*我们对每一个x[i]上限,枚举所有可能x[j]的下限,</span></span><br><span class="line"><span class="comment">并利用线段树求出x[i]~x[j]最大字段和*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(cs[i].x == cs[i<span class="number">-1</span>].x &amp;&amp; i != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,cnt);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(cs[j].x != cs[j<span class="number">-1</span>].x &amp;&amp; i != j) ans = max(ans,ask());</span><br><span class="line"><span class="keyword">int</span> y = lower_bound(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+cnt,cs[j].y)-tmp;</span><br><span class="line">Insert(<span class="number">1</span>,y,cs[j].val,<span class="number">1</span>,cnt);</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans,ask());<span class="comment">//如果全部相等,在此处特判 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;cs[i].x,&amp;cs[i].y,&amp;cs[i].val);</span><br><span class="line">tmp[i] = cs[i].y;</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6638&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;Snowy-Smile&quot;&gt;&lt;a href=&quot;#Snowy
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="线段树" scheme="http://valenshi.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="最大子矩阵" scheme="http://valenshi.top/tags/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
</feed>
