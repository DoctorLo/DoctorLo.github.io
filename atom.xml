<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ValenShi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://valenshi.top/"/>
  <updated>2019-08-22T06:02:19.831Z</updated>
  <id>http://valenshi.top/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rikka with Coin 解题报告</title>
    <link href="http://valenshi.top/2019/08/22/hdu6685/"/>
    <id>http://valenshi.top/2019/08/22/hdu6685/</id>
    <published>2019-08-22T06:01:46.000Z</published>
    <updated>2019-08-22T06:02:19.831Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6685" target="_blank" rel="noopener">测试地址</a><br>本题为2019航电icpc暑期多校训练第9场的第6题。</p><h5 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h5><p>有10分，20分，50分，100分的硬币若干（反正够用），商店有n件商品（n&lt;101），每件商品的价格给出；请问要想可以买下任意一件商品，最少带多少个硬币？</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>我一开始思路是背包，然后觉得w（商品的价值）太大了，可能用大背包，就放弃了。原来这题需要转化一下思维，并不是用背包而是简单的遍历。首先我们需要明白，就是如若我们买一件物品需要用2个10分的硬币，那么我们换成一个10分一个20分的肯定是可以的，而且反而能买的价格更多了（从10,20变为10,20,30），同理：</p><ul><li>如果有4个20分的，就可以用1个10分，2个20分，1个50分的硬币代替。因为原来可以表示20,40,60,80,现在可以表示10,20,30,40,50,60,70,80,90,100。</li><li>如果有2个50分的，同理，可以用1个50，1个100替代。</li></ul><p>于是我们知道了10分，20分，50分的硬币最多需要1个，3个，1个，所以三层循环遍历所有可能的情况，对于每种情况，判断是否可以表出所有物品（当然不足的用100分的硬币替代）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= a;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= b;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= c;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>((x-i*<span class="number">10</span>-j*<span class="number">20</span>-k*<span class="number">50</span>)%<span class="number">100</span> == <span class="number">0</span>) </span><br><span class="line">res = min((x-i*<span class="number">10</span>-j*<span class="number">20</span>-k*<span class="number">50</span>)/<span class="number">100</span>,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = check2(w[i],a,b,c);</span><br><span class="line"><span class="keyword">if</span>(tmp == INF) <span class="keyword">return</span> INF; </span><br><span class="line"><span class="keyword">else</span> res = max(res,tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf("%d %d %d %d\n",res,a,b,c);</span></span><br><span class="line"><span class="keyword">return</span> res+a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(w[i]%<span class="number">10</span>)&#123;<span class="built_in">puts</span>(<span class="string">"-1"</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">3</span>;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= <span class="number">1</span>;k++)</span><br><span class="line">ans = min(ans,check(i,j,k));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,w+i);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6685&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测试地址&lt;/a&gt;&lt;br&gt;本题为2019航电icpc暑期多校训练第9场的第6题。&lt;/p&gt;
&lt;h5 i
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="思维" scheme="http://valenshi.top/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>2018徐州icpc网络赛A、B题解</title>
    <link href="http://valenshi.top/2019/08/21/2018xuzhou-icpc/"/>
    <id>http://valenshi.top/2019/08/21/2018xuzhou-icpc/</id>
    <published>2019-08-21T03:26:15.000Z</published>
    <updated>2019-08-21T03:48:15.352Z</updated>
    
    <content type="html"><![CDATA[<h4 id="A-Hard-to-prepare"><a href="#A-Hard-to-prepare" class="headerlink" title="A. Hard to prepare"></a>A. Hard to prepare</h4><p><a href="https://nanti.jisuanke.com/t/A2000" target="_blank" rel="noopener">测试地址</a><br>抱怨一下，这题目真的是长，题意理解起来有点费劲，当然费劲的只是因为题面长而不是表述不清。<br><strong>题意简述：</strong><br>从$[1,2^k-1]$中选出n个数，将n个数围成一圈，要求相邻的两个数NXOR大于0，即异或后按位取反的值大于0。问共有多少种不同的方案。</p><p><strong>解题思路：</strong><br>通过简单证明，我们会发现只有1按位取反的值才是0，所以两个数 异或 != 1 就可以相邻；而与x异或 = 1 的数，有且仅有一个。</p><p>首先如果不是环形，而是一条直线，那么一共 $2 ^ k  *  (2 ^ k - 1) ^ {n-1}$​ 种不同的方案，这里设A = ​2^k​。环形和直线不同之处在于，直线首尾的值异或可能 = 1，即我们之前的答案多算了首尾异或=1的情况。那么我们接下来就需要设法减去这些值。</p><p>我们通过动态规划思想来计算这些多加上的值。假设当前位置为 i ，直线首元素是a，尾元素是b，且a^b = 1；设x是位置 i 元素 = a时的方案数，y是位置 i 元素 = b时的方案数，z是位置 i 不等于a和b时的方案数。</p><p>那么我们初始状态（第2个位置时）x = 1 , y = 0 , z = A - 2；目标是求第n-1 位时的 y + z（首位是a，末位是b时，中间2~n-1位的不同排列情况数）。<br>那么易得：<br>x = x + z;<br>y = y + z;<br>z = z<em>(A-3)+(x+y) </em> (A-2).<br>于是我们从第3位递推到第n-1位即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,k;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = res*a%P;</span><br><span class="line">        a = a*a%P;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll A = qpow(<span class="number">2</span>,k);</span><br><span class="line">    ll ans = A*qpow(A<span class="number">-1</span>,n<span class="number">-1</span>)%P;</span><br><span class="line">    ll x = <span class="number">1</span>,y = <span class="number">0</span>,z = A<span class="number">-2</span>;</span><br><span class="line">    <span class="comment">/*x:当前位置数和A相同方案数,</span></span><br><span class="line"><span class="comment">y:当前位置数和B相同方案数,</span></span><br><span class="line"><span class="comment">z:当前位置的数和AB都不同的方案数。 </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; n;i++)&#123;</span><br><span class="line">        ll t1 = x+z,t2 = y+z;</span><br><span class="line">        z = z*(A<span class="number">-3</span>)%P+(x+y)*(A<span class="number">-2</span>)%P;</span><br><span class="line">        z = z%P;</span><br><span class="line">        x = t1%P, y = t2%P;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//  printf("%lld %lld %lld\n",ans,y,z);</span></span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">2</span>) ans = (ans - A*(y+z)%P+P)%P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="B-BE-GE-or-NE"><a href="#B-BE-GE-or-NE" class="headerlink" title="B. BE,GE or NE"></a>B. BE,GE or NE</h4><p><a href="https://nanti.jisuanke.com/t/A2001" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>这是一个博弈论题。有两个人，小K和小S在玩游戏，该游戏一共有n次操作，俩人轮流进行。初始给定一个数值m，每次操作有三种选择：加上a；减去b；若c为1，则m = -1。每次三选一，其中小K想使得最终值&gt;= k，而小S想使得最终值&lt;= l，否则两人平局。给定这n次操作的a,b,c值，请问两人都采取最优策略，最终结果是谁胜出或是平局？</p><p><strong>解题思路：</strong><br>首先每个决策的选举会影响之后的决策，即不满足无后效，因此我们不能单纯的从后向前推（从动态规划角度）。而从博弈论来看，如果当前局面可以转移到必胜态，则当前选手必胜，换到这题，就是使得当前选手得分最大或最小。由于得分只有200种可能，于是可能的状态只有1000 * 200 = 200,000种，记忆化搜索即可。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">250</span>];</span><br><span class="line"><span class="keyword">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="keyword">int</span> n,m,k,l;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; n) <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">if</span>(f[pos][sum+<span class="number">100</span>] != INF) <span class="keyword">return</span> f[pos][sum+<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">if</span>(pos&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = -INF;</span><br><span class="line">        <span class="keyword">if</span>(a[pos]) x = max(x,dfs(pos+<span class="number">1</span>,min(<span class="number">100</span>,sum+a[pos])));</span><br><span class="line">        <span class="keyword">if</span>(b[pos]) x = max(x,dfs(pos+<span class="number">1</span>,max(<span class="number">-100</span>,sum-b[pos])));</span><br><span class="line">        <span class="keyword">if</span>(c[pos]) x = max(x,dfs(pos+<span class="number">1</span>,-sum));</span><br><span class="line">        f[pos][sum+<span class="number">100</span>] = x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = INF;</span><br><span class="line">        <span class="keyword">if</span>(a[pos]) x = min(x,dfs(pos+<span class="number">1</span>,min(sum+a[pos],<span class="number">100</span>)));</span><br><span class="line">        <span class="keyword">if</span>(b[pos]) x = min(x,dfs(pos+<span class="number">1</span>,max(<span class="number">-100</span>,sum-b[pos])));</span><br><span class="line">        <span class="keyword">if</span>(c[pos]) x = min(x,dfs(pos+<span class="number">1</span>,-sum));</span><br><span class="line">        f[pos][sum+<span class="number">100</span>] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[pos][sum+<span class="number">100</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;k,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,a+i,b+i,c+i);</span><br><span class="line">    <span class="keyword">int</span> ans = dfs(<span class="number">1</span>,m);</span><br><span class="line">    <span class="keyword">if</span>(ans &gt;= k) <span class="built_in">puts</span>(<span class="string">"Good Ending"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ans &lt;= l) <span class="built_in">puts</span>(<span class="string">"Bad Ending"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Normal Ending"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;A-Hard-to-prepare&quot;&gt;&lt;a href=&quot;#A-Hard-to-prepare&quot; class=&quot;headerlink&quot; title=&quot;A. Hard to prepare&quot;&gt;&lt;/a&gt;A. Hard to prepare&lt;/h4&gt;&lt;p&gt;&lt;a href=
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="博弈论" scheme="http://valenshi.top/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
      <category term="动态规划" scheme="http://valenshi.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>第一章 基础数据结构模板</title>
    <link href="http://valenshi.top/2019/08/20/chapter1/"/>
    <id>http://valenshi.top/2019/08/20/chapter1/</id>
    <published>2019-08-20T15:37:44.000Z</published>
    <updated>2019-08-20T15:42:45.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-基础数据结构"><a href="#1-基础数据结构" class="headerlink" title="1 基础数据结构"></a>1 基础数据结构</h2><h3 id="1-1-并查集"><a href="#1-1-并查集" class="headerlink" title="1.1 并查集"></a>1.1 并查集</h3><h4 id="1-1-1-并查集“拓展域”"><a href="#1-1-1-并查集“拓展域”" class="headerlink" title="1.1.1 并查集“拓展域”"></a>1.1.1 并查集“拓展域”</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关押罪犯</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> par[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;B) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt; B.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; nodes[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == par[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> par[x] = Find(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    par[Find(x)] = Find(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;nodes[i].a,&amp;nodes[i].b,&amp;nodes[i].c);</span><br><span class="line">        par[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(nodes+<span class="number">1</span>,nodes+<span class="number">1</span>+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = nodes[i].a,y = nodes[i].b,d = nodes[i].c;</span><br><span class="line">        <span class="keyword">int</span> x_en = x+n, y_en = y+n;</span><br><span class="line">        <span class="keyword">if</span>(Find(x) == Find(y))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Merge(x,y_en);Merge(x_en,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-2-并查集“边带权”"><a href="#1-1-2-并查集“边带权”" class="headerlink" title="1.1.2 并查集“边带权”"></a>1.1.2 并查集“边带权”</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POJ1773</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">21000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,ans;</span><br><span class="line">&#125; q[MAXN];</span><br><span class="line"><span class="keyword">int</span> a[MAXN],par[MAXN],d[MAXN],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    a数组用来离散化，par[x]代表x的父节点编号，d[x]代表</span></span><br><span class="line"><span class="comment">    从x到根节点路径和，cnt也是用于离散化。</span></span><br><span class="line"><span class="comment">    这里根节点即集合的代表节点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x] == x) <span class="keyword">return</span> x;   <span class="comment">//找到根节点，返回</span></span><br><span class="line">    <span class="keyword">int</span> root = Find(par[x]);    <span class="comment">//临时存根节点</span></span><br><span class="line">    d[x] ^= d[par[x]];          <span class="comment">//路径压缩，距离数组d也应该更新</span></span><br><span class="line">    <span class="keyword">return</span> par[x] = root;       <span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">char</span> rs[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;q[i].l,&amp;q[i].r,rs);</span><br><span class="line">        <span class="keyword">if</span>(rs[<span class="number">0</span>] == <span class="string">'o'</span>) q[i].ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> q[i].ans = <span class="number">0</span>;</span><br><span class="line">        a[cnt++] = q[i].l<span class="number">-1</span>;    <span class="comment">//这里需要存l-1，为了使l也包含在内</span></span><br><span class="line">        a[cnt++] = q[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下两行代码离散化用</span></span><br><span class="line">    sort(a,a+cnt);</span><br><span class="line">    <span class="keyword">int</span> len = unique(a,a+cnt)-a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) par[i] = i; <span class="comment">//初始化爸爸数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;      </span><br><span class="line">        <span class="comment">//左右边界在离散化数组中的编号：</span></span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(a,a+len,q[i].l<span class="number">-1</span>)-a;</span><br><span class="line">        <span class="keyword">int</span> y = lower_bound(a,a+len,q[i].r)-a;  </span><br><span class="line">        <span class="comment">//左右边界的祖先分别为ta和tb</span></span><br><span class="line">        <span class="keyword">int</span> ta = Find(x),tb = Find(y);</span><br><span class="line">        <span class="keyword">if</span>(ta == tb)&#123;   <span class="comment">//如果已经在同一个集合内，则判断是否矛盾</span></span><br><span class="line">            <span class="keyword">if</span>((d[x]^d[y]) != q[i].ans)&#123;<span class="comment">//矛盾的条件就是事实和结果不同</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            par[ta] = tb;d[ta] = d[x]^d[y]^q[i].ans;</span><br><span class="line">            <span class="comment">//这里d[ta]的值需要推导一下。</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            我们将x所在的集合和y所在的集合合并，那么就需要更新d数组</span></span><br><span class="line"><span class="comment">            这里d[x]存放的是x到par[x]的距离，所以合并两个集合对于</span></span><br><span class="line"><span class="comment">            非根节点来说并无影响，关键是对于两个根d[ta]和d[tb]如何处理</span></span><br><span class="line"><span class="comment">            如果我们将ta代表的集合归于tb下，那么就需要更新d[ta],而已知</span></span><br><span class="line"><span class="comment">            ans = d[x]^d[y]^d[ta]，即x到y的总路径等于x到ta XOR y到tb XOR </span></span><br><span class="line"><span class="comment">            ta到tb；对上式变形，得：d[ta] = ans^d[x]^d[y],而后三者是已知，</span></span><br><span class="line"><span class="comment">            故可以求出d[ta]。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-倍增求LCA（最近公共祖先）"><a href="#1-2-倍增求LCA（最近公共祖先）" class="headerlink" title="1.2 倍增求LCA（最近公共祖先）"></a>1.2 倍增求LCA（最近公共祖先）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HDU2586求树上任意两个节点的路径的边权和  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2</span>*<span class="number">41000</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N],nex[N],edge[N],tot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;x ^= y;y^=x;x^=y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y,edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x],head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    deep[x]表示x的深度,anc[x][i]为x向上走2^i步的祖先 </span></span><br><span class="line"><span class="comment">    dis[x]为节点到根节点的距离,即边权或点权和 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="keyword">int</span> deep[N],anc[N][<span class="number">25</span>],dis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.初始化anc数组，</span></span><br><span class="line"><span class="comment">        2.初始化deep数组</span></span><br><span class="line"><span class="comment">        3.初始化dis数组</span></span><br><span class="line"><span class="comment">        以上三个都可以通过dfs来实现</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++)</span><br><span class="line">        anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(dis[y] || y == <span class="number">1</span>) <span class="keyword">continue</span>;<span class="comment">//防止重复访问</span></span><br><span class="line">        deep[y] = deep[x]+<span class="number">1</span>;</span><br><span class="line">        dis[y] = dis[x] + z;</span><br><span class="line">        anc[y][<span class="number">0</span>] = x;</span><br><span class="line">        dfs(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        先把深度调到一致，再按照二进制拆分思想找寻最近公共祖先</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(deep[u] &lt; deep[v]) swap(u,v);    <span class="comment">//u是较深的节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[anc[u][i]] &gt;= deep[v]) u = anc[u][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(anc[u][i] != anc[v][i])&#123;</span><br><span class="line">            u = anc[u][i];</span><br><span class="line">            v = anc[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> anc[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dis[u] + dis[v] <span class="number">-2</span>*dis[Lca(u,v)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">        <span class="built_in">memset</span>(deep,<span class="number">0</span>,<span class="keyword">sizeof</span> deep);</span><br><span class="line">        <span class="built_in">memset</span>(anc,<span class="number">0</span>,<span class="keyword">sizeof</span> anc);</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head);<span class="comment">//head也要初始化</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            addEdge(x,y,z);</span><br><span class="line">            addEdge(y,x,z);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x,y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-后缀数组"><a href="#1-3-后缀数组" class="headerlink" title="1.3 后缀数组"></a>1.3 后缀数组</h3><h4 id="1-3-1-求后缀数组"><a href="#1-3-1-求后缀数组" class="headerlink" title="1.3.1 求后缀数组"></a>1.3.1 求后缀数组</h4><p>$O(Nlog_2^N)$复杂度求后缀数组模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> sa[N],rank[N],tmp[N];</span><br><span class="line"><span class="comment">//比较(rank[i],rank[i+k])和(rank[j],rank[j+k]) </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rank[i] != rank[j]) <span class="keyword">return</span> rank[i] &lt; rank[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n ? rank[i+k] : <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n ? rank[j+k] : <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算字符串S的后缀数组 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line">n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="comment">//初始长度为1，rank直接取字符的编码</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rank[i] = i &lt; n ? S[i] : <span class="number">-1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//利用对长度为k的排序结果对长度为2k的排序</span></span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+n+<span class="number">1</span>,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + (compare_sa(sa[i<span class="number">-1</span>],sa[i])?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rank[i] = tmp[i];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str) != EOF)&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,sa[i]+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-求高度数组lcp"><a href="#1-3-2-求高度数组lcp" class="headerlink" title="1.3.2 求高度数组lcp"></a>1.3.2 求高度数组lcp</h4><p>时间复杂度为O(N)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sa[i]表示排名为i的后缀起始位置是多少</span></span><br><span class="line"><span class="comment">rank[i]表示起始位置是i的串排名是多少</span></span><br><span class="line"><span class="comment">rank[sa[i] ] = i , sa[rank[i] ] = i,rank与sa互逆 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">int</span> sa[N],rank[N],tmp[N],lcp[N];</span><br><span class="line"><span class="comment">//比较(rank[i],rank[i+k])和(rank[j],rank[j+k]) </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rank[i] != rank[j]) <span class="keyword">return</span> rank[i] &lt; rank[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n ? rank[i+k] : <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n ? rank[j+k] : <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算字符串S的后缀数组 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line">n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="comment">//初始长度为1，rank直接取字符的编码</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rank[i] = i &lt; n ? S[i] : <span class="number">-1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//利用对长度为k的排序结果对长度为2k的排序</span></span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+n+<span class="number">1</span>,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + (compare_sa(sa[i<span class="number">-1</span>],sa[i])?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rank[i] = tmp[i];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最长公共前缀模板,其中sa为后缀数组,求得结果存放在lcp </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(S);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rank[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>;lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*lcp[i] 表示起始位置为sa[i]与</span></span><br><span class="line"><span class="comment">起始位置为sa[i+1]的串的最长公共前缀长度*/</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rank[i]<span class="number">-1</span>];</span><br><span class="line"><span class="comment">/*此处j表示排在"以i开始的后缀"前面一名的子串的起始位置*/</span> </span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j + h &lt; n &amp;&amp; i+h &lt; n;h++)&#123;</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*h为以i开头的后缀与以j开头的后缀的"最长公共前缀"的长度*/</span> </span><br><span class="line">lcp[rank[i]<span class="number">-1</span>] = h;</span><br><span class="line"><span class="comment">/*于是以j开头的后缀 与以i开头的后缀 的 最长公共前缀的长度</span></span><br><span class="line"><span class="comment">被存放在lcp[rank[i]-1]中,因为lcp定义的就是: </span></span><br><span class="line"><span class="comment">lcp[k] 为排名为i的后缀与排名为i+1的后缀的最长公共前缀的长度*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str) != EOF)&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line">construct_lcp(str,sa,lcp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,lcp[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-基于平方分割的RMQ算法"><a href="#1-4-基于平方分割的RMQ算法" class="headerlink" title="1.4 基于平方分割的RMQ算法"></a>1.4 基于平方分割的RMQ算法</h3><p><strong>问题模型：</strong></p><blockquote><p>给定一个数列$a_1,a_2,…,a_n$，目标是在O（&radic;n）复杂度内实现以下两个功能：</p><ul><li>给定s，t，求$a_s,a_{s+1},…a_t$的最小值</li><li>给定i，x，把$a_i$的值变为x。</li></ul></blockquote><p><strong>基于平方分割的RMQ的复杂度：</strong><br>在更新值时，由于每个桶内有b个元素，所以复杂度是O(b) = O(&radic;n)<br>而查询为：O(n/b+b) = O(&radic;n+&radic;n) = O(&radic;n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> mi[MAXN/B];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">a[pos] = y;</span><br><span class="line">mi[pos/B] = min(mi[pos/B],y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = INF;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r &amp;&amp; l%B) ans = min(ans,a[l++]);</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r &amp;&amp; r%B) ans = min(ans,a[--r]);</span><br><span class="line"><span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line"><span class="keyword">int</span> b = l/B;</span><br><span class="line">ans = min(ans,mi[b]);</span><br><span class="line">l += B;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; MAXN/B;i++) mi[i] = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">mi[i/B] = min(mi[i/B],a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="keyword">int</span> op,x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;op,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>) updata(x,y);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; query(x,y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-ST表"><a href="#1-5-ST表" class="headerlink" title="1.5 ST表"></a>1.5 ST表</h3><h4 id="1-5-1一维st表"><a href="#1-5-1一维st表" class="headerlink" title="1.5.1一维st表"></a>1.5.1一维st表</h4><p><strong>问题模型：</strong></p><p>给定一个长度为n的序列，有m次询问，每次给定区间[L , R]，求区间内最大值。</p><p>我们设 <code>st[i][j]</code> 为从 i 开始的 $2^j$ 个数中的最大值。假设这n个数存放的序列a中，根据定义 <code>st[i][j]</code> = max{a[k] | $i &lt;= k &lt;= i+2^j - 1$}。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],st[N][<span class="number">25</span>],Log[N];<span class="comment">//2^20就过一百万了，完全够用 </span></span><br><span class="line"><span class="comment">//初始化st表 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">Log[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//预处理log函数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;<span class="comment">//涉及到位运算多加括号! </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)) &lt;= n;i++)&#123;</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> mx = max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"><span class="comment">//printf("%d %d\n",k,mx);</span></span><br><span class="line"><span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,l,r;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(l,r));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-2-二维st表"><a href="#1-5-2-二维st表" class="headerlink" title="1.5.2 二维st表"></a>1.5.2 二维st表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">令t1 = st[a][b][c];</span><br><span class="line">令t2 = st[a][b+c-(1&lt;&lt;k)+1][c];</span><br><span class="line">令t3 = st[a+c-(1&lt;&lt;k)+1][b][c];</span><br><span class="line">令t4 = st[a+c-(1&lt;&lt;k)+1][b+c-(1&lt;&lt;k)+1][c];</span><br><span class="line">ans = max&#123;t1 , t2 , t3 , t4&#125;；</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N],n,m,len,Log[N];</span><br><span class="line"><span class="keyword">int</span> st[<span class="number">3</span>][N][N][<span class="number">15</span>];<span class="comment">//0最小，1最大值 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mx = a;<span class="keyword">if</span>(mx &lt; b) mx = b;<span class="keyword">if</span>(mx &lt; c) mx = c;<span class="keyword">if</span>(mx &lt; d) mx = d;</span><br><span class="line"><span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mi = a;<span class="keyword">if</span>(mi &gt; b) mi = b;<span class="keyword">if</span>(mi &gt; c) mi = c;<span class="keyword">if</span>(mi &gt; d) mi = d;</span><br><span class="line"><span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++) </span><br><span class="line">st[<span class="number">0</span>][i][j][<span class="number">0</span>] = st[<span class="number">1</span>][i][j][<span class="number">0</span>] = a[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= <span class="number">12</span>;k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span> &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j + (<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span> &lt;= m;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> t1 = st[<span class="number">0</span>][i][j][k<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> t2 = st[<span class="number">0</span>][i+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][j][k<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> t3 = st[<span class="number">0</span>][i][j+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][k<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> t4 = st[<span class="number">0</span>][i+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][j+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][k<span class="number">-1</span>];</span><br><span class="line">st[<span class="number">0</span>][i][j][k] = min(t1,t2,t3,t4);</span><br><span class="line">t1 = st[<span class="number">1</span>][i][j][k<span class="number">-1</span>];</span><br><span class="line">t2 = st[<span class="number">1</span>][i+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][j][k<span class="number">-1</span>];</span><br><span class="line">t3 = st[<span class="number">1</span>][i][j+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][k<span class="number">-1</span>];</span><br><span class="line">t4 = st[<span class="number">1</span>][i+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][j+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][k<span class="number">-1</span>];</span><br><span class="line">st[<span class="number">1</span>][i][j][k] = max(t1,t2,t3,t4);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[len];</span><br><span class="line"><span class="keyword">int</span> t1 = st[<span class="number">0</span>][r][c][k];</span><br><span class="line"><span class="keyword">int</span> t2 = st[<span class="number">0</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c][k];</span><br><span class="line"><span class="keyword">int</span> t3 = st[<span class="number">0</span>][r][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line"><span class="keyword">int</span> t4 = st[<span class="number">0</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line"><span class="keyword">int</span> mi = min(t1,t2,t3,t4);</span><br><span class="line">t1 = st[<span class="number">1</span>][r][c][k];</span><br><span class="line">t2 = st[<span class="number">1</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c][k];</span><br><span class="line">t3 = st[<span class="number">1</span>][r][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line">t4 = st[<span class="number">1</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line"><span class="keyword">int</span> mx = max(t1,t2,t3,t4);</span><br><span class="line"><span class="comment">//printf("%d %d\n",mx,mi);</span></span><br><span class="line"><span class="keyword">return</span> mx - mi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n-len+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m-len+<span class="number">1</span>;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = ask(i,j,len);</span><br><span class="line">ans = ans &lt; tmp?ans:tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-莫队算法"><a href="#1-6-莫队算法" class="headerlink" title="1.6 莫队算法"></a>1.6 莫队算法</h3><p><strong>SPOJ D-query：</strong> 给定一个数组，每次询问一个区间内有多少个不同的元素。</p><p><strong>复杂度分析：</strong> 莫队算法是离线算法，可以解决一类离线的区间问题，对于序列上的区间询问问题，如果从 [l,r] 的答案能够 O(1) 扩展到 [l−1,r],[l+1,r],[l,r+1],[l,r−1] 的答案，那么可以在 $O(n\sqrt n)$ 的复杂度内求出所有询问的答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">31000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Q = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],m;</span><br><span class="line"><span class="keyword">int</span> ans,sum[<span class="number">1010000</span>];<span class="comment">//一个全局答案ans和标记数组sum是必要的 </span></span><br><span class="line"><span class="comment">//当然也可以离散化 </span></span><br><span class="line"><span class="keyword">int</span> len;<span class="comment">//块大小，在读入询问前需要先赋值 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,block,id;</span><br><span class="line">Query()&#123;&#125;</span><br><span class="line">Query(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> id):l(l),r(r),id(id)&#123;</span><br><span class="line">block = l/len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Query &amp;B) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(block == B.block) <span class="keyword">return</span> block&amp;<span class="number">1</span>? r &lt; B.r : r &gt; B.r;</span><br><span class="line"><span class="comment">//小优化，使得r呈波浪形 </span></span><br><span class="line"><span class="keyword">return</span> block &lt; B.block;</span><br><span class="line">&#125;</span><br><span class="line">&#125;query[Q];</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//增加或减少一个x位置上的数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">x = a[x]; </span><br><span class="line">sum[x] += v;</span><br><span class="line"><span class="keyword">if</span>(v &gt; <span class="number">0</span>) ans += sum[x] == <span class="number">1</span>;<span class="comment">//判等是为了防止重复计数 </span></span><br><span class="line"><span class="keyword">else</span> ans -= sum[x] == <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">len = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">query[i] = Query(x,y,i);</span><br><span class="line">&#125;</span><br><span class="line">sort(query+<span class="number">1</span>,query+<span class="number">1</span>+m);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>,r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l &lt; query[i].l) Move(l,<span class="number">-1</span>),l++;</span><br><span class="line"><span class="keyword">while</span>(l &gt; query[i].l) Move(l<span class="number">-1</span>,<span class="number">1</span>),l--;</span><br><span class="line"><span class="keyword">while</span>(r &gt; query[i].r) Move(r,<span class="number">-1</span>),r--;</span><br><span class="line"><span class="keyword">while</span>(r &lt; query[i].r) Move(r+<span class="number">1</span>,<span class="number">1</span>),r++;</span><br><span class="line">q.push(make_pair(-query[i].id,ans));<span class="comment">//大根堆变为小根堆 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.top().second;q.pop();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-二叉堆"><a href="#1-7-二叉堆" class="headerlink" title="1.7 二叉堆"></a>1.7 二叉堆</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左儿子：2*rt+1, 右儿子: 2*rt+2,时间复杂度O(N)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> heap[MAXN];</span><br><span class="line"><span class="keyword">int</span> sz = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//i是自己节点的编号 </span></span><br><span class="line"><span class="keyword">int</span> i = sz++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//p是父亲节点的编号</span></span><br><span class="line"><span class="keyword">int</span> p = (i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(heap[p] &lt;= x) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">heap[i] = heap[p];</span><br><span class="line">i = p; </span><br><span class="line">&#125;</span><br><span class="line">heap[i] = x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = heap[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//要提到根的数值x</span></span><br><span class="line"><span class="keyword">int</span> x = heap[--sz];</span><br><span class="line"><span class="comment">//从根开始向下交换 </span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i*<span class="number">2</span> + <span class="number">1</span> &lt; sz)&#123;</span><br><span class="line"><span class="comment">//左右儿子 </span></span><br><span class="line"><span class="keyword">int</span> a = i*<span class="number">2</span>+<span class="number">1</span>,b = i*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(b &lt; sz &amp;&amp; heap[b] &lt; heap[a]) a = b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(heap[a]  &gt;= x) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">heap[i] = heap[a];</span><br><span class="line">i = a;</span><br><span class="line">&#125;</span><br><span class="line">heap[i] = x;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-基础数据结构&quot;&gt;&lt;a href=&quot;#1-基础数据结构&quot; class=&quot;headerlink&quot; title=&quot;1 基础数据结构&quot;&gt;&lt;/a&gt;1 基础数据结构&lt;/h2&gt;&lt;h3 id=&quot;1-1-并查集&quot;&gt;&lt;a href=&quot;#1-1-并查集&quot; class=&quot;header
      
    
    </summary>
    
      <category term="ValenShi的ACM模板" scheme="http://valenshi.top/categories/ValenShi%E7%9A%84ACM%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>hdu6681 Rikka with Cake</title>
    <link href="http://valenshi.top/2019/08/19/hdu6681/"/>
    <id>http://valenshi.top/2019/08/19/hdu6681/</id>
    <published>2019-08-19T14:41:32.000Z</published>
    <updated>2019-08-20T12:47:48.178Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6681" target="_blank" rel="noopener">测试地址</a></p><h5 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h5><p>直接看样例其实就明白了，看图说话，就是给出一个左下角坐标为(0,0)，右上角为(n,m)的矩形；然后有k条线段，这些线段不重叠，都是从矩形内某一点出发到矩形某一边为止，这些线段共四种，都与坐标轴平行。<br><img src="/2019/08/19/hdu6681/1.png" alt="1"><br>请问这些线段将矩形分为了几个不连通的面？（图一是3个，图二是5个）</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>首先考虑到任意两条直线的x，y坐标都是不同的，所以不会出现重叠现象。观察得，肯定是相交的线段才能分割出新的面（一条横的线与几条竖线相交就会增加几个面）。<br>所以我们只需考虑，假设先将所有与y轴平行的线加入，然后对于每一条与x轴平行的线，有几条与其相交，最终答案就是这些交点个数再+1。</p><p>现在的问题就是对于每个与x轴平行的线，有多少与y轴平行的线与其相交。如果挨个计算并累加，计算完所有线段需要O(N^2)时间。其实我们会发现，找与(x , y)至左边界（L）的横线相交的线段，只需要找出 x’ &lt;= x &amp;&amp; y’ &lt;= y的向上方(U) 的线段以及 x’ &lt;= x &amp;&amp; y’ &gt;= y的向下 (D) 的线段的数量即可。这是二维偏序问题，是4个二维偏序问题。而二维偏序问题可以在$O(Nlog_2^N)$时间内用CDQ分治解决，写起来也不是很麻烦（还好不是三维）。</p><p>PS：呜呜呜正解是欧拉定理呜呜呜呜呜</p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,t;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">    Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y):x(x),y(y)&#123;t = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; B)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; B.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node U[N],D[N],R[N],L[N],tmp[N];</span><br><span class="line">Node TU[N];</span><br><span class="line"><span class="keyword">int</span> cu,cd,cr,cl,cnt;</span><br><span class="line"><span class="keyword">int</span> n,m,t,k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq1</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    cdq1(l,mid); cdq1(mid,r);</span><br><span class="line">    <span class="keyword">int</span> p = l,q = mid,tk = <span class="number">0</span>,tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; mid &amp;&amp; q &lt; r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(TU[p].y &lt;= TU[q].y)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!TU[p].t) tt++;</span><br><span class="line">            tmp[tk++] = TU[p++];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(TU[q].t) cnt += tt;</span><br><span class="line">            tmp[tk++] = TU[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; mid) tmp[tk++] = TU[p++];</span><br><span class="line">    <span class="keyword">while</span>(q &lt; r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(TU[q].t) cnt += tt;</span><br><span class="line">        tmp[tk++] = TU[q++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tk;i++) TU[i+l] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(Node a,Node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    对于L[i],有多少U中x &lt; L[i].x &amp;&amp; y &lt; L[i].y,</span></span><br><span class="line"><span class="comment">            有多少D中x &lt; L[i].x &amp;&amp; y &gt; L[i].y;</span></span><br><span class="line"><span class="comment">    对于R[i]有多少U中x &gt; R[i].x &amp;&amp; y &lt; R[i].y,</span></span><br><span class="line"><span class="comment">            有多少D中x &gt; R[i].x &amp;&amp; y &gt; R[i].y;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cu;i++) TU[i] = U[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cl;i++) TU[i+cu] = L[i],TU[i+cu].t = <span class="number">1</span>;</span><br><span class="line">    stable_sort(TU,TU+cu+cl);</span><br><span class="line">    cdq1(<span class="number">0</span>,cl+cu);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cd;i++) TU[i] = D[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cl;i++) TU[i+cd] = L[i],TU[i+cd].t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cl+cd;i++) TU[i].y *= <span class="number">-1</span>;</span><br><span class="line">    stable_sort(TU,TU+cd+cl);</span><br><span class="line">    cdq1(<span class="number">0</span>,cl+cd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cu;i++) TU[i] = U[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cr;i++) TU[i+cu] = R[i],TU[i+cu].t = <span class="number">1</span>;</span><br><span class="line">    stable_sort(TU,TU+cr+cu,cmp2);</span><br><span class="line">    <span class="comment">//for(int i = 0;i &lt; cr+cu;i++) printf("%d %d\n",TU[i].x,TU[i].y);</span></span><br><span class="line">    cdq1(<span class="number">0</span>,cr+cu);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cd;i++) TU[i] = D[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cr;i++) TU[i+cd] = R[i],TU[i+cd].t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cd+cr;i++) TU[i].y *= <span class="number">-1</span>;</span><br><span class="line">    stable_sort(TU,TU+cr+cd,cmp2);</span><br><span class="line">    cdq1(<span class="number">0</span>,cr+cd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        cu = cd = cr = cl = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;<span class="keyword">char</span> dir[<span class="number">5</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;x,&amp;y,dir);</span><br><span class="line">            <span class="keyword">if</span>(dir[<span class="number">0</span>] == <span class="string">'U'</span>) U[cu++] = Node(x,y);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dir[<span class="number">0</span>] == <span class="string">'D'</span>) D[cd++] = Node(x,y);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dir[<span class="number">0</span>] == <span class="string">'L'</span>) L[cl++] = Node(x,y);</span><br><span class="line">            <span class="keyword">else</span> R[cr++] = Node(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6681&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测试地址&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;题意简述&quot;&gt;&lt;a href=&quot;#题意简述&quot; class=
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="CDQ分治" scheme="http://valenshi.top/tags/CDQ%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>bzoj1093最大半连通子图</title>
    <link href="http://valenshi.top/2019/08/18/bzoj1093/"/>
    <id>http://valenshi.top/2019/08/18/bzoj1093/</id>
    <published>2019-08-18T12:51:15.000Z</published>
    <updated>2019-08-20T12:46:31.989Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.mfstem.org/contest/17/problem/B" target="_blank" rel="noopener">测试地址</a></p><h5 id="问题简述"><a href="#问题简述" class="headerlink" title="问题简述"></a>问题简述</h5><p>给出一个有向图，求其最大半连通子图的节点个数，以及不同的最大半连通子图的数目。<br>（子图、半连通图、最大半连通子图等定义请参照原题）</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>本题是《信息学奥赛一本通·提高篇》中，强连通分量章节的一道例题。本题思路其实很清晰也很明确，就是求最大半连通子图的节点数，以及有多少个这样的子图。可以得知，如果一个子图是强连通的，那么他一定是半连通的，所以对于所有的强连通分量，我们都缩为一个点，这样就得到了一个有向无环图（DAG）。<br>我们对得到的DAG进行建图得到G’，每个节点的“权值”就等于该强连通分量的顶点数；于是原问题就成了在 G’ 上找到权值最大的<strong>链</strong>（因为我们可以保证对于链上任意两点u和v，都单向或双向可达）。<br>找到了“最长链”之后，下一步是找<strong>不同的最长链的个数</strong> ，这一步用到类似DP的思想，即设f[i]为到节点 i 时，达到局部最长链时不同方案数，我们只需要在进行<strong>拓扑排序求最长链</strong> 的同时<strong>递推更新f[]</strong> 即可。</p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><p>虽然写代码时的思路很清晰，但是代码还是写的很乱，可读性很差；因为涉及变量太多、太乱，所以每个变量或数组的作用是什么并不是一目了然，但我也懒得写注释了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y;nex[tot] = head[x];head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head2[N],ver2[M],nex2[M],tot2 = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    ver2[++tot2] = y; nex2[tot2] = head2[x];head2[x] = tot2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Stack[N],top;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],num,co[N],col;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++num;</span><br><span class="line">Stack[++top] = u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> v = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">Tarjan(v);</span><br><span class="line">low[u] = min(low[u],low[v]);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!co[v]) low[u] = min(low[u],dfn[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[u] == dfn[u])&#123;</span><br><span class="line">co[u] = ++col;</span><br><span class="line"><span class="keyword">while</span>(Stack[top] != u)&#123;</span><br><span class="line">co[Stack[top]] = col;</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,P;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; e[M];</span><br><span class="line"><span class="keyword">int</span> du[N],dis[N],si[N];<span class="comment">//si[col]记录强连通分量col节点个数</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> mxnum,mxcol;</span><br><span class="line"><span class="keyword">int</span> f[N];<span class="comment">//到i距离为最长的方案数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(si,<span class="number">0</span>,<span class="keyword">sizeof</span> si);</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) si[co[i]]++,f[co[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++) <span class="keyword">if</span>(!du[i]) q.push(i),dis[i] = si[i];</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head2[x];i ;i = nex2[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> y = ver2[i];du[y]--;</span><br><span class="line">            <span class="keyword">if</span>(!du[y]) q.push(y);</span><br><span class="line">            <span class="keyword">if</span>(dis[y] &lt; dis[x]+si[y])&#123;</span><br><span class="line">                dis[y] = dis[x] + si[y];</span><br><span class="line">                f[y] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(dis[mxcol] &lt; dis[y]) mxcol = y;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dis[y] == dis[x]+si[y])</span><br><span class="line">                f[y] = (f[y]+f[x])%P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++)</span><br><span class="line">        <span class="keyword">if</span>(dis[i] == dis[mxcol]) mxnum = (mxnum+f[i])%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    num = col = top = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="keyword">sizeof</span> dfn);</span><br><span class="line">    <span class="built_in">memset</span>(co,<span class="number">0</span>,<span class="keyword">sizeof</span> co);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = head[i];j ;j = nex[j])&#123;</span><br><span class="line">            <span class="keyword">int</span> y = ver[j];</span><br><span class="line">            e[++cnt] = make_pair(co[i],co[y]);</span><br><span class="line">            <span class="comment">//printf("%d %d %d %d\n",co[i],co[y],i,y);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf("cnt %d\n",cnt);</span></span><br><span class="line">    sort(e+<span class="number">1</span>,e+<span class="number">1</span>+cnt);tot2 = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(du,<span class="number">0</span>,<span class="keyword">sizeof</span> du);</span><br><span class="line">    <span class="built_in">memset</span>(head2,<span class="number">0</span>,<span class="keyword">sizeof</span> head2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i].first != e[i].second &amp;&amp;</span><br><span class="line">         (e[i].first != e[i<span class="number">-1</span>].first || e[i].second != e[i<span class="number">-1</span>].second))</span><br><span class="line">            addEdge2(e[i].first,e[i].second), du[e[i].second]++;</span><br><span class="line">        <span class="comment">//printf("%d %d\n",e[i].first,e[i].second);</span></span><br><span class="line">    &#125;</span><br><span class="line">    topo();<span class="comment">//拓扑排序找出最长链</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>,dis[mxcol],mxnum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;P);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,a,b;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        addEdge(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.mfstem.org/contest/17/problem/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测试地址&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;问题简述&quot;&gt;&lt;a href=&quot;#问题简述&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="强连通分量" scheme="http://valenshi.top/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>大整数开方根模板</title>
    <link href="http://valenshi.top/2019/08/18/bigsqrt/"/>
    <id>http://valenshi.top/2019/08/18/bigsqrt/</id>
    <published>2019-08-18T12:50:54.000Z</published>
    <updated>2019-08-20T12:46:50.130Z</updated>
    
    <content type="html"><![CDATA[<p><strong>例1：</strong> 试判断n是否为完全平方数(Perfect square)，$n &lt;=10^{200}$。</p><p>本来想写一篇关于牛顿迭代法+高精度运算的C++版本的模板，但是涉及到高精度加减乘除，动辄300行代码以上，还是在网上找个JAVA的大整数开方根的模板凑合用吧。</p><p>用JAVA书写代码，需要注意的是时间和空间，内存超限很常见。</p><h4 id="大数开平方根模板"><a href="#大数开平方根模板" class="headerlink" title="大数开平方根模板"></a>大数开平方根模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static BigInteger sqrt(String x) &#123;</span><br><span class="line">        int mlen = x.length();    //被开方数的长度</span><br><span class="line">        int len;    //开方后的长度</span><br><span class="line">        BigInteger beSqrtNum = new BigInteger(x);//被开方数</span><br><span class="line">        BigInteger sqrtOfNum;    //存储开方后的数</span><br><span class="line">        BigInteger sqrtOfNumMul;    //开方数的平方</span><br><span class="line">        String sString;//存储sArray转化后的字符串</span><br><span class="line">        if(mlen%2 == 0)    len = mlen/2;</span><br><span class="line">        else    len = mlen/2+1;</span><br><span class="line">        char[] sArray = new char[len];</span><br><span class="line">        Arrays.fill(sArray, &apos;0&apos;);//开方数初始化为0</span><br><span class="line">        for(int pos=0; pos&lt;len; pos++)&#123;</span><br><span class="line">         //从最高开始遍历数组，每一位都转化为开方数平方后刚好不大于被开方数的程度</span><br><span class="line">            for(char num=&apos;1&apos;; num&lt;=&apos;9&apos;; num++)&#123;</span><br><span class="line">                sArray[pos] = num;</span><br><span class="line">                sString = String.valueOf(sArray);</span><br><span class="line">                sqrtOfNum = new BigInteger(sString);</span><br><span class="line">                sqrtOfNumMul = sqrtOfNum.multiply(sqrtOfNum);</span><br><span class="line">                if(sqrtOfNumMul.compareTo(beSqrtNum) == 1)&#123;</span><br><span class="line">                    sArray[pos]-=1;</span><br><span class="line">                    break;    </span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new BigInteger(String.valueOf(sArray));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断n是否为Perfect-square"><a href="#判断n是否为Perfect-square" class="headerlink" title="判断n是否为Perfect square"></a>判断n是否为Perfect square</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> T = cin.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cas = <span class="number">1</span>; cas &lt;= T; ++cas) &#123;</span><br><span class="line">            String str = cin.next();</span><br><span class="line">            BigInteger n = <span class="keyword">new</span> BigInteger(str);</span><br><span class="line">            BigInteger m = n.multiply(n.subtract(BigInteger.ONE)).shiftRight(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//System.out.println(n);</span></span><br><span class="line">            <span class="comment">//System.out.println(m);</span></span><br><span class="line">            <span class="keyword">boolean</span> nIsSquare = isSquare(n);</span><br><span class="line">            <span class="keyword">boolean</span> mIsSquare = isSquare(m);</span><br><span class="line">            <span class="keyword">if</span> (nIsSquare &amp;&amp; mIsSquare) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Arena of Valor"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nIsSquare &amp;&amp; !mIsSquare) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Hearth Stone"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!nIsSquare &amp;&amp; mIsSquare) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Clash Royale"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"League of Legends"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSquare</span><span class="params">(BigInteger n)</span> </span>&#123;</span><br><span class="line">        BigInteger low = BigInteger.ZERO;</span><br><span class="line">        BigInteger high = n;</span><br><span class="line">        <span class="keyword">while</span> (low.compareTo(high) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            BigInteger mid = low.add(high).shiftRight(<span class="number">1</span>);</span><br><span class="line">            BigInteger square = mid.multiply(mid);</span><br><span class="line">            <span class="keyword">int</span> result = square.compareTo(n);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                high = mid.subtract(BigInteger.ONE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid.add(BigInteger.ONE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>Molex的<a href="https://www.cnblogs.com/yzm10/p/9651696.html" target="_blank" rel="noopener">博客</a></li><li>2019焦作网络赛 J 题<a href="https://nanti.jisuanke.com/t/A2020" target="_blank" rel="noopener">Participate in E-sports</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;例1：&lt;/strong&gt; 试判断n是否为完全平方数(Perfect square)，$n &amp;lt;=10^{200}$。&lt;/p&gt;
&lt;p&gt;本来想写一篇关于牛顿迭代法+高精度运算的C++版本的模板，但是涉及到高精度加减乘除，动辄300行代码以上，还是在网上找个J
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>中国剩余定理（拓展）</title>
    <link href="http://valenshi.top/2019/08/18/realchina/"/>
    <id>http://valenshi.top/2019/08/18/realchina/</id>
    <published>2019-08-18T12:50:28.000Z</published>
    <updated>2019-08-20T12:47:04.538Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>在《孙子算经》中有这样一个问题：“今有物不知其数，三三数之剩二（除以3余2），五五数之剩三（除以5余3），七七数之剩二（除以7余2），问物几何？”这个问题称为“孙子问题”，该问题的一般解法国际上称为“中国剩余定理”。</p><p>中国剩余定理是数论四大定理之一，其重要性不容置疑，本文主要介绍中国剩余定理问题的经典模型，然后再对更一般的情况进行拓展，得到拓展中国剩余定理，当然最重要的是给出模板并附上模板使用说明书。</p><h4 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h4><p>若$m_1,m_2,…,m_n$是两两互质的正整数，M = $\prod_{i = 1}^{n} m_i$, $M_i = M/m_i$，$t_i$是线性同余方程$M_it_i \equiv1(mod\: m_i)$的一个解。对于任意的n个整数$a_1,a_2,…,a_n$，则同余方程组</p><p><img src="/2019/08/18/realchina/1.png" alt="1"></p><p>有整数解，方程组的解为$x = a_1M_1t_1 + a_2M_2t_2 + … + a_nM_nt_n$。并且在模M意义下有唯一解。</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>因为$M_i = M/m_i$是除$m_i$之外所有模数的倍数，所以$\forall k \neq i, a_iM_it_i \equiv 0(mod\:m_k)$。又因为$a_iM_it_i \equiv a_i(mod\: m_i)$，所以带入$x = \sum_{i = 1}^n a_iM_it_i$，原方程组成立。<br>证毕。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>中国剩余定理给出了模数两两互质的线性同余方程组的一个特殊解。方程组的通解可以表示为$x + kM(k \in Z)$。有些题目要求我们求出最小的非负整数解，只需把 x 对M取模，并让 x 落在0~M-1的范围内即可。</p><p>另外，即使模数不满足两两互质，我们也有办法判断线性同余方程组是否有解，并求出方程组的解。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 代码出自:洛谷用户sumijie 2019/8/18</span></span><br><span class="line"><span class="comment"> * 使用说明:</span></span><br><span class="line"><span class="comment"> *    1.ll为自定义类型,视题目数据而定,并不一定是__int128</span></span><br><span class="line"><span class="comment"> *    2.N为方程组中方程个数,视数据而定</span></span><br><span class="line"><span class="comment"> * 输入：</span></span><br><span class="line"><span class="comment"> *    输入第一行包含整数 n.</span></span><br><span class="line"><span class="comment"> *    接下来 n 行,每行两个非负整数 ai,bi</span></span><br><span class="line"><span class="comment"> * 输出:</span></span><br><span class="line"><span class="comment"> *    输出一行,为满足条件的最小非负整数x.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> __int128 ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;g,ll &amp;x,ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        g = a; x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b,a%b,g,y,x);</span><br><span class="line">    y-=(a/b)*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">ll a1,a2,n1,n2;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">abs</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;<span class="number">0</span>?x:-x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">china</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll d = a2 - a1;</span><br><span class="line">    ll g,x,y;</span><br><span class="line">    exgcd(n1,n2,g,x,y);</span><br><span class="line">    <span class="keyword">if</span> (d % g == <span class="number">0</span>) &#123;</span><br><span class="line">        x = ((x*d/g)%(n2/g)+(n2/g))%(n2/g);</span><br><span class="line">        a1 = x*n1 + a1;</span><br><span class="line">        n1 = (n1*n2)/g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;          <span class="comment">//方程个数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> as[N];<span class="comment">//余数</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ns[N];<span class="comment">//模数</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">realchina</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*返回线性同余方程组的最小非负整数解*/</span></span><br><span class="line">    a1 = as[<span class="number">0</span>];</span><br><span class="line">    n1 = ns[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        a2 = as[i];</span><br><span class="line">        n2 = ns[i];</span><br><span class="line">        china();</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;ns[i]&gt;&gt;as[i];<span class="comment">//输入模数和余数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">long</span> <span class="keyword">long</span>)realchina()&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>董永建，信息学竞赛一本通提高篇，福州：福建教育出版社，2018.6，401-403</li><li>洛谷网用户sumijie的<a href="https://www.luogu.org/blog/sumijie/solution-p4777" target="_blank" rel="noopener">博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;在《孙子算经》中有这样一个问题：“今有物不知其数，三三数之剩二（除以3余2），五五数之剩三（除以5余3），七七数之剩二（除以7余2），问物几
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数论" scheme="http://valenshi.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>矩阵快速幂模板</title>
    <link href="http://valenshi.top/2019/08/17/Matrix/"/>
    <id>http://valenshi.top/2019/08/17/Matrix/</id>
    <published>2019-08-17T02:28:50.000Z</published>
    <updated>2019-08-20T12:46:20.756Z</updated>
    
    <content type="html"><![CDATA[<p>矩阵快速幂常用于动态规划中的“矩阵加速链乘”里，可以将线性的递归式优化为$O(log_2N)$，是一种很常用的技巧。由于矩阵快速幂不像普通的整数快速幂一样方便记忆，因此整理模板以便需要时参考。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************</span></span><br><span class="line"><span class="comment"> 最后修改：2019/8/17 ValenShi</span></span><br><span class="line"><span class="comment"> 使用说明：</span></span><br><span class="line"><span class="comment">    1.注意矩阵是在Mod P下相乘</span></span><br><span class="line"><span class="comment">    2.矩阵为nn*nn的方阵,使用前需对nn赋值</span></span><br><span class="line"><span class="comment">    3.矩阵有效行列下标是1~nn</span></span><br><span class="line"><span class="comment">    4.注意memset头文件以及 long long</span></span><br><span class="line"><span class="comment"> *********************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> nn; <span class="comment">//nn 为矩阵大小 nn*nn</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mat</span>&#123;</span></span><br><span class="line">    ll v[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line">    Mat()&#123;<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span> v);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">Mul</span><span class="params">(<span class="keyword">const</span> Mat&amp; a,<span class="keyword">const</span> Mat&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 返回矩阵a*矩阵b的结果 */</span></span><br><span class="line">    Mat c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= nn;i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= nn;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= nn;k++)</span><br><span class="line">          c.v[i][j] = (c.v[i][j]+a.v[i][k]*b.v[k][j]%P)%P;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">qpow</span><span class="params">(Mat A,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 返回矩阵A^b后的结果(矩阵) */</span></span><br><span class="line">    Mat c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= nn;i++) c.v[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) c = Mul(c,A);</span><br><span class="line">        A = Mul(A,A);</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;矩阵快速幂常用于动态规划中的“矩阵加速链乘”里，可以将线性的递归式优化为$O(log_2N)$，是一种很常用的技巧。由于矩阵快速幂不像普通的整数快速幂一样方便记忆，因此整理模板以便需要时参考。&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>伸展树笔记</title>
    <link href="http://valenshi.top/2019/08/16/splay/"/>
    <id>http://valenshi.top/2019/08/16/splay/</id>
    <published>2019-08-16T14:08:15.000Z</published>
    <updated>2019-08-16T14:16:03.528Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><strong>前置知识：</strong></p><ul><li>树-&gt;二叉搜索树-&gt;平衡树-&gt;AVL树-&gt;Treap-&gt;伸展树</li><li>左单(双)旋、右单(双)旋、左右双旋</li></ul><p><strong>伸展树(Splay Tree)</strong> 是平衡二叉查找树的一种，具有二叉查找树的所有性质；伸展树又称Self-Adjusting Search Trees，即<strong>自调整的二叉搜索树</strong> 。与普通的二叉查找树相比，其维护更少的节点额外信息，空间性能更优且编程复杂度更低。它由Daniel Sleator 和 Robert Tarjan创造。在伸展树上的一般操作都基于<strong>伸展操作</strong>。</p><h4 id="需要伸展树的原因："><a href="#需要伸展树的原因：" class="headerlink" title="需要伸展树的原因："></a>需要伸展树的原因：</h4><p>各种查找树都有各自的优缺点以及适用范围。例如，对于一棵具有n个节点的平衡树，虽然其查找的时间复杂度不超过O(log n)，但是如果访问模式不均匀（询问点不随机），平衡树的效率就会受影响，此时我们需要额外的空间记录平衡信息，同时也加大了编程复杂度。<br>这些查找树的设计目标都是减少最坏情况下单次操作时间，但是如果我们的目标是使一系列查找操作的总时间最少，那我们更好的目标就是降低操作的摊平时间。此处的摊平时间指的是在一系列最坏情况下的操作序列中单次操作的平均时间。而伸展树就是为实现这一目标而设计的。</p><h4 id="和其他平衡树或具有明确限制的数据结构相比，伸展树的优点："><a href="#和其他平衡树或具有明确限制的数据结构相比，伸展树的优点：" class="headerlink" title="和其他平衡树或具有明确限制的数据结构相比，伸展树的优点："></a>和其他平衡树或具有明确限制的数据结构相比，伸展树的优点：</h4><ul><li>从摊平角度讲，它们忽略常量因子，因此绝对不会比有明确限制的数据结构差。而且它们可以依据适用情况进行调整，于是在<strong>使用模式不均匀</strong>的情况下更加有效。</li><li>由于无需存储限制信息，它们所需空间更小，实现起来也更加简洁。</li><li>它们的查找和更新算法概念简单，易于实现。</li></ul><h4 id="潜在的两个缺点："><a href="#潜在的两个缺点：" class="headerlink" title="潜在的两个缺点："></a>潜在的两个缺点：</h4><ul><li>它们需要更多的局部调整，尤其是在查找期间。（而其他有明确限制的查找树仅需要在更新期间进行调整，查找期间则不用）</li><li>一系列查找操作中的某一个可能会耗时较长。这在实际应用中需要作为是否选用的参考依据。</li></ul><h4 id="什么是伸展树："><a href="#什么是伸展树：" class="headerlink" title="什么是伸展树："></a>什么是伸展树：</h4><p>假设要对一个二叉搜索树执行一系列查找操作，为了使得总时间最小，那么被查找频率高的节点自然就要放在靠近根的位置。于是想到一个简单的设计方案，<strong>在每次查找之后对树进行重构，把被查找的条目搬到离树根近一点的位置。</strong> 顺着这个思路，splay诞生了。<br>splay是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列旋转把该节点搬移到树根，同时使得该条路径上的点尽量靠近树根。</p><h4 id="构建方法"><a href="#构建方法" class="headerlink" title="构建方法"></a>构建方法</h4><p><strong>两种可能的重构方法：</strong></p><ul><li>单旋：在查找完位于节点x中的条目之后，旋转链接x和其父节点的边。（除非x是根）</li><li>搬移至树根：在查找完位于节点x中的条目后，旋转链接x和其父节点的边，然后重复这个操作直至x成为树根。</li></ul><p><strong>注：</strong><br>上述两个方法是不一样的，一种是查找x后仅交换一次，另一个是将被查询的节点x旋转至树根。<br><strong>旋转示意图：</strong><br>其中三角形代表子树，而图示的树也可能是一棵更大的树的子树。<br><img src="/2019/08/16/splay/1.png" alt="1"></p><p><strong>上述两种重构方法的示意图：</strong><br>其中被查询节点是a。<br><img src="/2019/08/16/splay/2.png" alt="2"></p><p><strong>注：</strong></p><ul><li>若x为p(x)的左孩子，交换x和p(x)的位置，称为右旋。</li><li>若x为p(x)的右孩子，交换x和p(x)的位置，称为左旋。</li></ul><p><strong>不幸的是，上述两个重构方法在摊分效率方面表现的都不太好。</strong> 如果有很长的随机查询序列，那么上述两种重构方法的查询时间复杂度是O(N)。显然我们需要一种性能更强大的重构方法。</p><h4 id="伸展操作"><a href="#伸展操作" class="headerlink" title="伸展操作"></a>伸展操作</h4><p>我们采取的重构方法叫做splaying，即伸展，它和上述“搬移至树根”相似。它们都是沿着<strong>查询路径</strong> 做旋转倒置，将被查询的节点通过此方法移动到根节点。不同的是，伸展操作是按照该结构上的查找顺序<strong>成对旋转</strong> 。对于伸展树中的一个节点x，我们重复如下操作<strong>直到</strong> x 成为树的根节点。</p><p><strong><em>Splaying Step</em></strong><br><em>Case 1(zig)：</em> 如果p(x)是x的父节点，并且p(x)是树的根，那么旋转x和p(x)间的边。（此为最终步骤）<br><em>Case 2(zig-zig)：</em> 如果p(x)不是根节点，并且x和p(x)都是左儿子或者右儿子，那么旋转链接p(x)和g(x)的边，然后旋转链接x和p(x)的边。<br><em>Case 3(zig-zag)：</em> 如果p(x)不是根，并且x是左儿子 p(x)是右儿子，或者相反，那么旋转链接x和p(x)的边，然后旋转链接x和p(x)的新边。</p><p><strong>注：</strong><br>其中我们假设p(x)为x的父节点，g(x)为p(x)的父节点。下图三个操作a、b、c分别对应上述的zig、zig-zig、zig-zag。</p><p><img src="/2019/08/16/splay/3.png" alt="3"></p><p><strong>分析：</strong><br>对于深度为d的节点x做伸展操作，需要花费的时间和d成比例，即和查找x的时间成比例。伸展操作并不仅仅是将x移动到根节点，而是<strong>将查找路径上的节点的深度都粗略减少了一半。</strong> 如此一来使得伸展树的效率非同凡响。效率证明略，不过我们依然可以根据如下1种常规情况(Figures 4)及2种极端情况(Figures 5)下进行splaying操作后 树的构造来略窥一二。</p><p><img src="/2019/08/16/splay/4.png" alt="4"></p><p><img src="/2019/08/16/splay/5.png" alt="5"></p><h4 id="伸展树上的更新操作"><a href="#伸展树上的更新操作" class="headerlink" title="伸展树上的更新操作"></a>伸展树上的更新操作</h4><p>使用伸展树，我们可以继承标准的二叉搜索树的操作。考虑如下几个操作：<br><em>access(i,t):</em> &emsp;如果i在树t中，返回一个指向i位置的指针；否则，返回一个指向空节点的指针。<br><em>insert(i,t):</em> &emsp;向树t中插入一个元素i，假设此前i不存在。<br><em>delete(i,t):</em> &emsp;从树t中删除元素i，假设i存在。<br><em>join(t1,t2):</em> &emsp;将树t1和t2合并成一棵新的树并返回新树的树根。该操作假设t1中所有元素都小于t2中的元素。合并后删除t1和t2。<br><em>split(i,t):</em> &emsp;将t分成两棵子树t1和t2，所有小于等于i的元素在t1，所有大于i的元素在t2。然后删除树t。</p><p><strong>access(i,t)实现方法：</strong><br>我们从树t的根开始，按照二叉搜索树的查找方式向下查找；如果当前节点x包含待查目标i，则算法完成，我们对x进行splaying操作并返回指向x的指针。如果搜索到达了空节点（即待查目标不存在），那么我们对搜索路径的最后一个节点进行splaying操作，并返回一个空指针。如果树为空，则取消splaying操作。（Figures 6）</p><p><strong>join(t1,t2)实现方法：</strong><br>我们首先在t1中执行一次access(i,t1)，其中i是t1中最大的元素。于是在access后，t1的根包含i，并且它没有右儿子。于是我们可以将t2作为t1的右儿子连接，并返回处理后的树，join操作完成。(Figures 7)</p><p><strong>split(i,t)实现方法：</strong><br>我们首先执行一次access(i,t)，然后断开t和左右儿子的链接，左子树作为t1，右子树作为t2，并且考虑根是否包含等于i的元素。返回t1或t2，split操作完成。(Figures 7)</p><p><strong>insert(i,t)实现方法</strong><br>我们先对t进行一次split(i,t)，得到了两个子树t1和t2，这时我们把i作为一个新的根节点，t1作为i的左子树，t2作为其右子树。(Figures 8)</p><p><strong>delete(i,t)实现方法</strong><br>我们先执行一次access(i,t)，此时得到根节点t，这个时候对t的两个子树t1和t2执行join(t1,t2)，就完成了删除i节点。(Figures 8)</p><p><strong>小结：</strong><br>通过上述操作的实现方法，我们可以发现，实现join和split时用到了access，实现insert和delete时我们又用到了split和join，由此可见我们可以通过已实现的操作来搭建未实现的操作，这样更加简洁且降低了编程难度。</p><p><img src="/2019/08/16/splay/6.png" alt="6"></p><p><img src="/2019/08/16/splay/7.png" alt="7"></p><p>另外，对于insert和delete操作还有另一种稍加优化的方法，这里省略，复杂度分析同样省略，具体可以参照原文[1]。</p><p><strong>参考文献：</strong></p><p>[1]  Daniel D.Sleator , Robert Endre Tarjan, <em>A data structure for dynamic trees</em>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;前置知识：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树-&amp;gt;二叉搜索树-&amp;gt;平衡树-&amp;gt;AVL树-&amp;gt;T
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线段树区间修改-延迟标记</title>
    <link href="http://valenshi.top/2019/08/16/interval-tree/"/>
    <id>http://valenshi.top/2019/08/16/interval-tree/</id>
    <published>2019-08-16T14:04:57.000Z</published>
    <updated>2019-08-20T12:45:46.357Z</updated>
    
    <content type="html"><![CDATA[<h4 id="延迟标记"><a href="#延迟标记" class="headerlink" title="延迟标记"></a>延迟标记</h4><p>在线段树中，单点修改时，我们是将信息从叶节点向上依次更新它的父节点，直到根节点。如果在区间修改仍然按照这个策略，那么修改的时间复杂度为O(N)。<br>为了降低时间复杂度，我们可以在更新时只更新大区间，不向下更新到叶子节点，等查询时再更新。举个例子：我们将1-5的位置上每个数+100，重复10000次上述操作。<strong>我们加10000次100和直接+1000000是相等的效果，但是一个执行了10000次，而另一个只执行1次。</strong> 我们又知道计算机的计算效率和计算次数是相关的，所以我们可以利用该原理，当区间修改时不向下更新，直至查询时再更新。</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>以POJ3468为例，我们使用线段树+延迟标记技巧 来实现快速区间修改与区间查询。<br>具体做法是，我们为每个节点增加一个延迟标记add，如果add为0，则说明该点的所有子区间都已更新完成，否则说明其子区间仍需要+add。请注意，如果一个节点被打上“延迟标记”，说明该节点曾经被修改过，但其子节点尚未被更新，即延迟标记说明的是子节点的待更新情况。<br>具体实现时，我们可以使用一个函数spread来实现延迟标记向下传递。<br><strong>代码示例：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll sum,add;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(x) t[x].add</span></span><br><span class="line">&#125;t[MAXN*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN],n,m;</span><br><span class="line"><span class="comment">//将延迟标记向下更新一层 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(add(p))&#123;</span><br><span class="line">sum(p*<span class="number">2</span>) += (r(p*<span class="number">2</span>) - l(p*<span class="number">2</span>) + <span class="number">1</span>)*add(p);</span><br><span class="line">sum(p*<span class="number">2</span>+<span class="number">1</span>) += (r(p*<span class="number">2</span>+<span class="number">1</span>) - l(p*<span class="number">2</span>+<span class="number">1</span>) + <span class="number">1</span>)*add(p);</span><br><span class="line">add(p*<span class="number">2</span>) += add(p);</span><br><span class="line">add(p*<span class="number">2</span>+<span class="number">1</span>) += add(p);</span><br><span class="line">add(p) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建树  l和r是当前节点所代表的区间的左右端点 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">l(p) = l,r(p) = r,add(p) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">t[p].sum = a[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">build(p*<span class="number">2</span>,l,mid);</span><br><span class="line">build(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">t[p].sum = t[p*<span class="number">2</span>].sum + t[p*<span class="number">2</span>+<span class="number">1</span>].sum; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间更新 如果当前区间被包含 则延迟标记 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(p) &amp;&amp; r(p) &lt;= r)&#123;</span><br><span class="line">sum(p) += (r(p)-l(p)+<span class="number">1</span>)*d;</span><br><span class="line">add(p) += d;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">int</span> mid = (l(p)+r(p))/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) change(p*<span class="number">2</span>,l,r,d);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) change(p*<span class="number">2</span>+<span class="number">1</span>,l,r,d);</span><br><span class="line">sum(p) = sum(p*<span class="number">2</span>) + sum(p*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间查询 当查询到该区间时顺便更新 </span></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">//printf("%d %d\n",l(p),r(p));</span></span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(p) &amp;&amp; r(p) &lt;= r)&#123;</span><br><span class="line"><span class="keyword">return</span> sum(p);</span><br><span class="line">&#125;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">int</span> mid = (l(p) + r(p))/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) ans += ask(p*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) ans += ask(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'C'</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> l,r,d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;d);</span><br><span class="line">change(<span class="number">1</span>,l,r,d);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(<span class="number">1</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>参考书目：</strong><br>《算法竞赛进阶指南》李煜东.P209</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;延迟标记&quot;&gt;&lt;a href=&quot;#延迟标记&quot; class=&quot;headerlink&quot; title=&quot;延迟标记&quot;&gt;&lt;/a&gt;延迟标记&lt;/h4&gt;&lt;p&gt;在线段树中，单点修改时，我们是将信息从叶节点向上依次更新它的父节点，直到根节点。如果在区间修改仍然按照这个策略，那么修改的时
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Trie-字典树笔记</title>
    <link href="http://valenshi.top/2019/08/16/trie/"/>
    <id>http://valenshi.top/2019/08/16/trie/</id>
    <published>2019-08-16T14:03:30.000Z</published>
    <updated>2019-08-20T12:46:11.279Z</updated>
    
    <content type="html"><![CDATA[<p>Trie，又称字典树，是一种用于实现字符串快速检索的<strong>多叉树</strong>结构。Trie的每个节点都拥有若干个字符指针，若在插入或检索字符串时扫描到一个字符c，就沿着当前节点的c这个字符指针，走向该指针指向的节点。</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>一颗空Trie仅包含一个根节点，该节点的字符指针均指向空。</p><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p>若需要插入一个字符串S时，我们令一个指针P起初指向根节点。然后，依次扫描S中的每个字符c：</p><ul><li>若P的c字符指针指向一个已经存在的节点Q，则令 P = Q。</li><li>若P的c字符指针指向空，则新建一个节点Q，令P的c字符指针指向Q，然后令P = Q。</li></ul><p>当S的字符扫描完毕时，在当前节点P上标记它是一个字符串的末尾。</p><h5 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h5><p>当需要检索一个字符串S在Trie中是否存在时，我们令一个指针P起初指向根节点，然后依次扫描S中的每个字符c：</p><ul><li>若p的c字符指针指向空，则说明S没有被插入过Trie，结束检索。</li><li>若P的c字符指针指向一个已经存在的节点Q，则令P = Q</li></ul><p>若S中的字符扫描完毕时，当前节点P被标记为一个字符串的末尾，则说明S在Trie中存在，否则说明S没有被插入过。</p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><p>我们以一个简单的经典问题为例：有m次询问，每次询问给出一个操作符op和字符串S，若op = 1，则将S放入集合T，若op = 2，则回答T集合中是否有S字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">bool</span> End[SIZE];</span><br><span class="line"><span class="keyword">int</span> trie[SIZE][<span class="number">30</span>],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; len;k++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ch = str[k]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(trie[p][ch] == <span class="number">0</span>) trie[p][ch] = ++tot;</span><br><span class="line">        p = trie[p][ch];</span><br><span class="line">    &#125;</span><br><span class="line">    End[p] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str),p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; len;k++)&#123;</span><br><span class="line">        p = trie[p][str[k]-<span class="string">'0'</span>];</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> End[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> m,op;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>,&amp;op,s);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) insert(s);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(search(s)) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考书目：</strong></p><ul><li>《算法竞赛进阶指南》李煜东.P71</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Trie，又称字典树，是一种用于实现字符串快速检索的&lt;strong&gt;多叉树&lt;/strong&gt;结构。Trie的每个节点都拥有若干个字符指针，若在插入或检索字符串时扫描到一个字符c，就沿着当前节点的c这个字符指针，走向该指针指向的节点。&lt;/p&gt;
&lt;h5 id=&quot;初始化&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最短路径算法</title>
    <link href="http://valenshi.top/2019/08/16/dijkstra/"/>
    <id>http://valenshi.top/2019/08/16/dijkstra/</id>
    <published>2019-08-16T14:01:36.000Z</published>
    <updated>2019-08-20T12:45:27.305Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前置知识：</strong> 图的相关定义、图的存储</p><p><strong>摘要：</strong><br>最短路径算法中常用的有4个：Floyed-Warshall、Dijkstra、Bellman-Ford、SPFA。这几种算法区别在于适用范围，以及对于不同构造的图效率不同。由于边的权值可以为负，在边权为负的情况下Dijkstra算法无法使用。而Bellman-Ford算法虽然可以处理负边权图，但却不能处理负权回路的情况（文中有介绍）。<br>进一步的，我们可以将最短路径问题分为单源最短路径和多源最短路径问题。在学会处理这两个问题后，我们还将探讨如何记录并输出最短路径而不仅仅是求值；在走最短路径的基础上，我们还应能对等效路径（即最终结果相同的两条路径，这里表现为权值相同）做约束选择（即有第二权值）。</p><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>我们假设图中顶点个数为N，编号依次为1~N，边的个数为M。</p><p><strong>最短路问题：</strong> 在图中，给定两个顶点，在以这两个点为起点和终点的路径中，边的权值和最小的路径。<br><strong>稀疏图：</strong> 符合|E| = O(V)的图称为稀疏图。<br><strong>稠密图：</strong> 符合|E| = O(V^2)的图称为稠密图。在算法竞赛中，若|E|比|V|大一个数量级以上则可认为是稠密图。</p><h4 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h4><p>源，即起点的意思。单源最短路径问题就是求从一个起点出发到其它顶点的最短路径。这里我们假设起点为1（图中顶点编号为1~N），dist[ i ] 为从起点1到顶点i的最短路径。<br>求单源最短路径有3个算法：Dijkstra、Bellman-Ford和SPFA。其中SPFA是Bellman-Ford的优化版本，于是我们通常依据情况挑选适合的算法使用。</p><h5 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h5><p><strong>适用范围与效率：</strong><br>Dijkstra算法适用于所有边权值非负情况，其运行效率为O(N^2)，优化后效率为O(M* LogN)，适用于稠密图。</p><p><strong>算法流程：</strong> </p><ol><li>初始化dist[1] = 0，其余节点的dist值设为无穷大。</li><li>找出一个未被标记的、dist[x]最小的节点x，然后标记节点x。</li><li>扫描节点x的所有出边（x,y,z），若dist[y] &gt; dist[x]+z，则适用dist[x]+z更新dist[y]。</li></ol><p><strong>算法思想：</strong><br>Dijkstra算法基于贪心的思想。我们的做法就是不断通过已求出的最短路径dist[x]来更新和其相连的点y（假设(x,y,z)分别为起点、终点、边权）。在这种情况下，每个点y有可能被多个点x更新，于是我们取dist[x]+z值最小的作为dist[y]。<br><strong>正确性证明：</strong><br>在上述算法流程步骤2中，我们找出未被标记的、dist[x]最小的节点x来更新和x相连的点，这里所指的dist[x]即<strong>全局最小值</strong>。为什么使用全局最小值来更新和其相连的点可以达到目的呢？<br>首先，由于除了节点1外所有点的dist初始值都为无穷大，因此dist不是无穷大的点一定是被更新过了的；另外，dist为全局最小值的点，其dist一定不会再被更新，因为<strong>没有比其dist更小的点</strong>可以用来更新它。至此，我们已经证明了dist为全局最小值的点x一定是被更新过了的，且一定是不能再被更新了的，因此dist[x]即为节点1到x的最短路径，所以我们可以用x来更新其它点。</p><p><strong>优化：</strong><br>上述算法，在找全局最小值时采取遍历的方法，其查找与删除的效率为O(N)，加之使用邻接矩阵存储，遍历边也是O(N)，所以时间复杂度为O(N^2)。但是我们可以采用堆+邻接表的方式来优化。我们可以在O(log N)的复杂度下获取和删除全局最小值，最终可在O(M log N)时间内完成算法。</p><p><strong>代码示例：</strong><br>见附录部分code-1：二叉堆优化的Dijkstra算法模板</p><h5 id="Bellman-Ford算法与SPFA算法"><a href="#Bellman-Ford算法与SPFA算法" class="headerlink" title="Bellman-Ford算法与SPFA算法"></a>Bellman-Ford算法与SPFA算法</h5><p><strong>适用范围与效率：</strong><br>能处理带负权边的情况，不能处理存在负权回路的情况。其中Bellman-Ford效率为O(NM)，SPFA效率为O(KE)，其中K为常数，平均值为2。适用于稀疏图。<br><strong>算法介绍：</strong><br>可以注意到我们将Bellman-Ford算法和SPFA算法放在了一起整理，因为实际上SPFA是“队列优化的Bellman-Ford算法”，因此本质上思想相同。<br><strong>算法流程：</strong> </p><ol><li>扫描所有边(x,y,z)，若dist[y] &gt; dist[x] + z，则用dist[x] + z更新dist[y]。</li><li>重复上述步骤，直到没有更新操作为止。</li></ol><p><strong>算法思想：</strong><br>Bellman-Ford算法是基于迭代思想的。我们每一次都对所有的边进行一次更新操作，直至没有更新操作发生为止。每一次的更新操作都使得我们更接近答案，这种通过若干次重复操作不断逼近答案的思想就是迭代思想。算法的正确性很显然，不予证明。</p><p><strong>SPFA：</strong></p><ol><li>建立一个队列，最初队列中只包含起点。</li><li>取出队头节点x，扫描它所有出边（x,y,z)，若dist[y] &gt; dist[x] + z，则使用dist[x] + z更新dist[y]。同时，若y不在队列中，则把y入队。</li><li>重复上述步骤，直到队列为空。</li></ol><p>在这个优化中，我们采用队列保存了待扩展节点。每次入队相当于完成一次对dist数组的更新操作，一个节点可能会入队、出队多次。这个队列避免了Bellman-Ford算法中对不需要扩展节点的冗余扫描。在稀疏图上SPFA效率较高，为O(KM)级别，其中k是一个较小的常数。但是在稠密图或者特殊的网格图上，仍有可能退化为O(NM)。</p><p><strong>代码示例：</strong><br>见附录部分code-2：SPFA模板</p><h4 id="多源最短路径问题"><a href="#多源最短路径问题" class="headerlink" title="多源最短路径问题"></a>多源最短路径问题</h4><p>与单源最短路径问题对应，多源最短路径问题不局限于某一固定起点，而是可能在一次算法中询问任意两个点之间的最短路径，于是之前的3个算法就捉襟见肘了，显然，我们需要一种新的算法来解决这类问题，这个算法就是Floyd算法。</p><h5 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h5><p><strong>适用范围：</strong> 适用于求多源最短路径问题，适用于稠密图，时间复杂度为O(N^3)。<br><strong>算法思想：</strong><br>Floyd算法基于动态规划。设D[k,i,j]表示“经过若干个编号不超过k的节点”从i到j的最短路径长度。该问题可以划分为两个子问题，经过编号不超过k-1的节点从i到j，或者从i先到k再到j。于是有状态转移方程：<br>&emsp;&emsp;D[k,i,j] = min( D[k-1,i,j] , D[k-1,i,k] + D[k-1,k,j] )<br>初值为D[0,i,j] = A[i,j]其中A[i,j]为自定义的邻接矩阵。<br>上述算法中，k是阶段，所以必须置于最外层循环。i和j是附加状态，因此可以置于内层循环。算法的正确等价于动态规划的正确性证明，此处不予证明。<br><strong>优化：</strong><br>Floyd算法可进行空间优化，我们可以注意到第一维完全可以向背包问题中一样省略。最初，我们可以直接用D保存邻接矩阵。在最外层循环到k层时，内层有状态转移：<br>&emsp;&emsp;D[i,j] = min(D[i,j] , D[i,k] + D[k,j])<br>最终D[i,j]就保存了i到j的最短路径。<br><strong>代码示例：</strong><br>见附录部分code-3：Floyd算法模板。</p><h4 id="未解决的问题"><a href="#未解决的问题" class="headerlink" title="未解决的问题"></a>未解决的问题</h4><p>以下问题将在另一篇笔记中整理：</p><ul><li>如何保存并输出最短路径。</li><li>最短路径的变形，如：求连通性、求传递闭包、求路径最大权值最小。</li><li>节点有约束的最短路径问题。</li><li>如何判断负环。</li></ul><h4 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h4><ul><li>《算法竞赛进阶指南》,李煜东,P322-331.</li><li>《信息学奥赛一本通》,董永建,科学技术文献出版社,P471-485.</li><li>《挑战程序设计竞赛(第二版)》,人民邮电出版社,秋叶拓哉,P99.</li></ul><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p>code-1：二叉堆优化的Dijkstra算法模板<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    《算法竞赛进阶指南》P324</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],Next[M],d[N];</span><br><span class="line"><span class="keyword">int</span> n,m,tot;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">priority_queue&lt; pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//pair 第一维是dist的相反数，利用相反数使得大根堆变成小根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y,edge[tot] = z;</span><br><span class="line">    Next[tot] = head[x],head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);    <span class="comment">//初始化dist数组</span></span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);   <span class="comment">//初始化标记数组</span></span><br><span class="line">    d[s] = <span class="number">0</span>;   </span><br><span class="line">    q.push(make_pair(<span class="number">0</span>,s));</span><br><span class="line">    <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.top().second;q.pop();<span class="comment">//x为全最最小值节点编号</span></span><br><span class="line">        <span class="keyword">if</span>(vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//遍历所有边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i;i = Next[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line">            <span class="keyword">if</span>(d[y] &gt; d[x] + z)&#123;</span><br><span class="line">                d[y] = d[x]+z;</span><br><span class="line">                q.push(make_pair(-d[y],y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>code-2：SPFA算法模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//《算法竞赛进阶指南》P326</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[M],ver[M],Next[M],d[N];</span><br><span class="line"><span class="keyword">int</span> n,m,tot;</span><br><span class="line"><span class="keyword">bool</span> vis[N];    <span class="comment">//用来标记节点x是否在队列中</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;   <span class="comment">//辅助队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y,edge[tot] = z;</span><br><span class="line">    Next[tot] = head[x],head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();q.pop();</span><br><span class="line">        vis[x] = <span class="literal">false</span>;     <span class="comment">//表示x不在队列中了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i;i = Next[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">            <span class="keyword">if</span>(d[y] &gt; d[x]+z)&#123;</span><br><span class="line">                d[y] = d[x]+z;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y]) q.push(y),vis[y] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,z,s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        add(x,y,z);</span><br><span class="line">    &#125;</span><br><span class="line">    SPFA(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,d[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>code-3：Floyd算法模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> a&gt;b?b:a;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) d[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        d[x][y] = min(d[x][y],z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">                d[i][j] = min(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,d[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;前置知识：&lt;/strong&gt; 图的相关定义、图的存储&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;最短路径算法中常用的有4个：Floyed-Warshall、Dijkstra、Bellman-Ford、SPFA。这几种算法区别在于适用范围，
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最长上升子序列模板</title>
    <link href="http://valenshi.top/2019/08/16/lis/"/>
    <id>http://valenshi.top/2019/08/16/lis/</id>
    <published>2019-08-16T14:00:15.000Z</published>
    <updated>2019-08-20T12:45:04.094Z</updated>
    
    <content type="html"><![CDATA[<p>按照数据结构来划分的话，最长上升子序列(LIS)是属于线性DP，其作为动态规划经典入门模型，重要性也是不言而喻的。而LIS问题也有很多种变型，对于这些问题有的超过了动态规划的适用范围，有的需要对转移方程进行更改，需要具体问题具体分析。</p><p><strong>前置知识：</strong></p><ul><li>子序列的概念</li><li>动态规划一般步骤</li><li>二分查找</li></ul><blockquote><p>问题模型：给定一个长度为N的数列A，求数值单调递增的子序列长度最长是多少。</p></blockquote><p><strong>解题思路：</strong><br>状态表示：我们设F[i]表示以A[i]为结尾的“最长上升子序列”的长度。<br>阶段划分：子序列的结尾位置（数列A中的位置，从前到后）。<br>转移方程：F[i] = max{ f[j] + 1} (0 &lt;= j &lt; i 且 A[j] &lt; A[i])。<br>边界：F[0] = 0。<br>目标：max{F[i]} ( 0 &lt;= i &lt; = N)。</p><p>如此设计目标函数与转移方程，很显然可以得到正确结果，其效率是O(N^2)，代码实现也很简单。</p><p><strong>优化：</strong><br>首先考虑一下上述算法最耗时的地方在哪，显然我们每次都要用O(N)的时间遍历前i-1个位置上的元素来更新F[i]，而能更新F[i]的元素A[j]需要满足两个条件：A[j] &lt; A[i]且F[j] &gt;= F[i]，那么F[i]就可以被更新为F[j]+1。在这个过程中，A[j]也可以描述为“小于A[i]的所有元素中F的值最大的那个”，通过这个描述来找A[j]的效率是O(N)。<br>考虑另一种方式，我们新增一个辅助数组d，d[i] 表示“长度为i的最长上升子序列的最小结尾是多少”，那么很显然，d数组中的元素是严格递增的。且每当我们读取到A序列中的一个元素A[i]时，都有两种情况：</p><ol><li>A[i] &gt; d[len]，此时 d[++len] = A[i]。 </li><li>A[i] &lt;= d[len]，此时说明d数组中某个元素可以被A[i]更新，我们采用二分查找的方式更新d数组即可。</li></ol><p>其中len代表当前最长上升子序列的长度。<br>上述方法中，如果遇到情况1，那么效率是O(1)，情况2，效率就是O(log N)，总体来讲，对于大量数据，该优化效果还是很喜人的。</p><p><strong>优化的正确性说明：</strong><br>上述优化可以用堆栈思想来解释，也可以将其看作一个小技巧。借助于d数组，对于序列A中的每个元素A[i]，我们都可以快速找到“小于A[i]的所有元素中F的值最大的那个”，<strong>因为d[len]存放的就是最长上升子序列长度为len时的最小元素</strong> 。如果A[i] &lt;= d[len]，那么很显然当前的最长上升子序列长度len不能再增加了（因为A[i] 不能添加在A的子序列d[1] ~d[len] 的后面），且d数组可以被更新(再不济也可以将d[len] 更新为 A[i]，因为 A[i] &lt; d[len])。于是借助于d数组的特性，完成了优化，当然也有所牺牲。</p><p><strong>代码示例：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">b_search</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> s,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(s &lt; e)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = s+(e-s)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(d[mid] &gt;= x) e = mid;</span><br><span class="line">        <span class="keyword">else</span> s = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    d[<span class="number">1</span>] = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt;= d[len])  d[++len] = A[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> p = b_search(A[i],<span class="number">1</span>,len);</span><br><span class="line">            d[p] = A[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  for(int i = 0;i &lt; len;i++)  cout &lt;&lt; d[i+1]&lt;&lt;" ";</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ul><li>《算法竞赛进阶指南》,李煜东,P237.</li><li><a href="https://www.cnblogs.com/wxjor/p/5524447.html" target="_blank" rel="noopener">博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;按照数据结构来划分的话，最长上升子序列(LIS)是属于线性DP，其作为动态规划经典入门模型，重要性也是不言而喻的。而LIS问题也有很多种变型，对于这些问题有的超过了动态规划的适用范围，有的需要对转移方程进行更改，需要具体问题具体分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前置知识
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>“拓展域”与“边带权”并查集</title>
    <link href="http://valenshi.top/2019/08/16/bingchaji/"/>
    <id>http://valenshi.top/2019/08/16/bingchaji/</id>
    <published>2019-08-16T13:57:56.000Z</published>
    <updated>2019-08-20T12:44:45.408Z</updated>
    
    <content type="html"><![CDATA[<h5 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h5><ul><li>并查集</li><li>路径压缩与按秩合并</li></ul><h5 id="“边带权”并查集"><a href="#“边带权”并查集" class="headerlink" title="“边带权”并查集"></a>“边带权”并查集</h5><p>并查集实际上是由若干棵树构成的森林，我们可以在树中的每条边上记录一个权值，即维护一个数组d，用d[x]保存节点x到父节点fa[x]之前的边权。在每次路径压缩后，每个访问过的节点都会直接指向树根，如果我们同时更新这些节点的d值，就可以利用路径压缩的过程来统计每个节点到树根之间的路径上的一些信息。这就是所谓“边带权” 的并查集。</p><h5 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h5><blockquote><p>POJ1773<br>题目描述：见《算法竞赛进阶指南》P190</p></blockquote><p><strong>解题思路1：边带权</strong><br>本题可作为“边带权”和“扩展域”模板题整理。与一般的并查集不同的是，本题传递关系不止一种：</p><ul><li>若x1和x2奇偶性相同，x2与x3奇偶性也相同，则x1与x3奇偶性相同。</li><li>若x1和x2奇偶性相同，x2与x3奇偶性不同，则x1与x3奇偶性不同。</li><li>若x1和x2奇偶性不同，x2与x3奇偶性不同，则x1与x3奇偶性相同。</li></ul><p>另外，本题的N太大，而M却很小，可以使用离散化方法，所以顺便复习一下离散化。<br>为了处理本题的多种传递关系，我们可以采用一种“边带权”的并查集。具体操作是用边权d[x] = 0 表示 x 与 par[x] 奇偶性相同；为1表示 x 与 par[x] 奇偶性不同。于是在路径压缩时，就可以通过对路径上边权做异或运算，即可得到 x 与树根的奇偶性关系。<br>于是对于每一个询问的(l , r , ans)，我们假设回答”odd”时，ans = 1，“even”时ans = 0，我们令 x 、 y 分别代表l-1和r离散化后的序号，如果x和y在同一个集合，则判断d[x] ^ d[y] 是否等于 ans，若不等则冲突；如果x和y不在同一个集合内，则合并 x 和 y ，此时需要注意如何更新d数组。（代码 code - 1 详解）</p><p><strong>解题思路2：扩展域</strong><br>本题还可以使用“扩展域”的并查集。<br>我们把每个变量x拆分成两个节点x_odd和x_even。其中用 x_odd 表示1~x有奇数个1，x_even表示有偶数个。我们把这两个节点称为x的“奇数域”与“偶数域”。<br>对于每个问题，假设在离散化后的 l-1 与 r 的值分别是x和y，设ans表示该问题的回答（0代表回答偶数个，1代表回答奇数个）。</p><ul><li>若ans = 0，x_odd 与 y_even在同一个集合，则与答案矛盾；否则合并x_odd与y_odd，x_even与y_even，这表示[l , r]中有偶数个1。</li><li>若ans = 1，x_odd与y_odd在同一个集合，则与答案矛盾；否则合并x_odd与y_even，x_even与y_odd。</li></ul><p>代码见code - 2.</p><h5 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h5><ul><li>《算法竞赛进阶指南》,李煜东,P190.</li></ul><p><strong>代码示例：code - 1</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">21000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,ans;</span><br><span class="line">&#125; q[MAXN];</span><br><span class="line"><span class="keyword">int</span> a[MAXN],par[MAXN],d[MAXN],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    a数组用来离散化，par[x]代表x的父节点编号，d[x]代表</span></span><br><span class="line"><span class="comment">    从x到根节点路径和，cnt也是用于离散化。</span></span><br><span class="line"><span class="comment">    这里根节点即集合的代表节点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x] == x) <span class="keyword">return</span> x;   <span class="comment">//找到根节点，返回</span></span><br><span class="line">    <span class="keyword">int</span> root = Find(par[x]);    <span class="comment">//临时存根节点</span></span><br><span class="line">    d[x] ^= d[par[x]];          <span class="comment">//路径压缩，距离数组d也应该更新</span></span><br><span class="line">    <span class="keyword">return</span> par[x] = root;       <span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">char</span> rs[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;q[i].l,&amp;q[i].r,rs);</span><br><span class="line">        <span class="keyword">if</span>(rs[<span class="number">0</span>] == <span class="string">'o'</span>) q[i].ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> q[i].ans = <span class="number">0</span>;</span><br><span class="line">        a[cnt++] = q[i].l<span class="number">-1</span>;    <span class="comment">//这里需要存l-1，为了使l也包含在内</span></span><br><span class="line">        a[cnt++] = q[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下两行代码离散化用</span></span><br><span class="line">    sort(a,a+cnt);</span><br><span class="line">    <span class="keyword">int</span> len = unique(a,a+cnt)-a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) par[i] = i; <span class="comment">//初始化爸爸数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;      </span><br><span class="line">        <span class="comment">//左右边界在离散化数组中的编号：</span></span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(a,a+len,q[i].l<span class="number">-1</span>)-a;</span><br><span class="line">        <span class="keyword">int</span> y = lower_bound(a,a+len,q[i].r)-a;  </span><br><span class="line">        <span class="comment">//左右边界的祖先分别为ta和tb</span></span><br><span class="line">        <span class="keyword">int</span> ta = Find(x),tb = Find(y);</span><br><span class="line">        <span class="keyword">if</span>(ta == tb)&#123;   <span class="comment">//如果已经在同一个集合内，则判断是否矛盾</span></span><br><span class="line">            <span class="keyword">if</span>((d[x]^d[y]) != q[i].ans)&#123;<span class="comment">//矛盾的条件就是事实和结果不同</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            par[ta] = tb;d[ta] = d[x]^d[y]^q[i].ans;</span><br><span class="line">            <span class="comment">//这里d[ta]的值需要推导一下。</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            我们将x所在的集合和y所在的集合合并，那么就需要更新d数组</span></span><br><span class="line"><span class="comment">            这里d[x]存放的是x到par[x]的距离，所以合并两个集合对于</span></span><br><span class="line"><span class="comment">            非根节点来说并无影响，关键是对于两个根d[ta]和d[tb]如何处理</span></span><br><span class="line"><span class="comment">            如果我们将ta代表的集合归于tb下，那么就需要更新d[ta],而已知</span></span><br><span class="line"><span class="comment">            ans = d[x]^d[y]^d[ta]，即x到y的总路径等于x到ta XOR y到tb XOR </span></span><br><span class="line"><span class="comment">            ta到tb；对上式变形，得：d[ta] = ans^d[x]^d[y],而后三者是已知，</span></span><br><span class="line"><span class="comment">            故可以求出d[ta]。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>代码示例：code - 2</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2</span>*<span class="number">21000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,ans;</span><br><span class="line">&#125;Q[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],par[N];    <span class="comment">//a用于离散化，par是爸爸数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> par[x] = Find(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;Q[i].l,&amp;Q[i].r,str);</span><br><span class="line">        Q[i].ans = str[<span class="number">0</span>] == <span class="string">'o'</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        a[++t] = Q[i].l<span class="number">-1</span>;</span><br><span class="line">        a[++t] = Q[i].r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+t);</span><br><span class="line">    n = unique(a+<span class="number">1</span>,a+<span class="number">1</span>+t) - a- <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span>*n;i++) par[i] = i;</span><br><span class="line">    <span class="comment">//因为每个节点有两个扩展域，所以n需要*2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(a+<span class="number">1</span>,a+<span class="number">1</span>+n,Q[i].l<span class="number">-1</span>)-a;</span><br><span class="line">        <span class="keyword">int</span> y = lower_bound(a+<span class="number">1</span>,a+<span class="number">1</span>+n,Q[i].r)-a;</span><br><span class="line">        <span class="keyword">int</span> x_odd = x,x_even = x+n;</span><br><span class="line">        <span class="keyword">int</span> y_odd = y,y_even = y+n;</span><br><span class="line">        <span class="keyword">if</span>(Q[i].ans == <span class="number">0</span>)&#123;      </span><br><span class="line">            <span class="keyword">if</span>(Find(x_odd) == Find(y_even))&#123;    <span class="comment">//答案与事实不符</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            par[Find(x_odd)] = Find(y_odd);</span><br><span class="line">            par[Find(x_even)] = Find(y_even);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(Find(x_odd) == Find(y_odd))&#123;     <span class="comment">//答案与事实不符</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i<span class="number">-1</span>); </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            par[Find(x_odd)] = Find(y_even);    <span class="comment">//合并x为奇，y为偶</span></span><br><span class="line">            par[Find(x_even)] = Find(y_odd);    <span class="comment">//合并x为偶和y为奇</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;并查集&lt;/li&gt;
&lt;li&gt;路径压缩与按秩合并&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;“边带权”并查集&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>莫队算法</title>
    <link href="http://valenshi.top/2019/08/16/modui/"/>
    <id>http://valenshi.top/2019/08/16/modui/</id>
    <published>2019-08-16T13:55:49.000Z</published>
    <updated>2019-08-20T12:44:28.318Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>莫队算法大概有基础莫队、树形莫队、带修（带修改的）莫队等类型，本文仅介绍基础莫队。可以看作莫队算法的入门。<br>莫队算法据说是2010年国家集训队的莫涛发明的一个优化类的算法，由于莫涛经常打比赛做队长，大家都叫他莫队，该算法也被称为莫队算法。它使用指针移动以及分块的思想对朴素算法进行优化。<br>莫队算法是离线算法，可以解决一类离线的区间问题，对于序列上的区间询问问题，如果从 [l,r] 的答案能够 O(1) 扩展到 [l−1,r],[l+1,r],[l,r+1],[l,r−1] 的答案，那么可以在 O(n√n) 的复杂度内求出所有询问的答案。</p><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p><strong>SPOJ D-query：</strong> 给定一个数组，每次询问一个区间内有多少个不同的元素。<br><strong>解题思路：</strong> </p><ol><li>朴素思想<br>注意到询问没有强制在线，因此我们可以使用离线的方法。首先我们考虑此类问题，如果我们已经计算出[L , R]的答案以及中间结果，那么我们显然可以在常数时间内计算出[L-1,R] , [L+1 , R] , [L , R-1] , [L , R+1]的答案，即便所给的询问并不一定是这样相差为1的区间，但这也启发了我们要尽可能将区间范围相近的放在一起计算。</li><li>为什么将询问区间相近的放在一起计算可以节省时间呢？<br>因为我们通过两个指针（p和q）的左右移动来统计区间信息，显然对于程序的每次运行，这两个指针的移动次数越少越好，要想移动的尽量少，显然区间相近的放在一起最好。</li><li>如何排序？<br>按照以上思路，我们要做的就是对区间进行排序，使得范围相近的询问区间尽量放在一起；但是区间有两个关键字（左端点和右端点），如果我们按照左端点严格升序，再按照右端点严格升序，那么很容易就想到一些反例来证明这种方法不是最优的，例如：(1, 100), (2, 2), (3, 99), (4, 4), (5, 102), (6, 7)。显然严格升序是不好的，很容易被出题人针对，如果能适当的减少右端点的移动次数，那么即使左端点的移动次数增加些许也是可以接受的。因此我们就要设计一种均衡的算法，使得左右端点并不一定严格有序，但总体复杂度（指针移动次数）尽量小。<br>利用分块思想，我们可以实现上述目标。我们将长度为n的序列分为长度为$\sqrt{n}$的若干块，将区间<strong>按照左端点所在的块的序号进行排序，如果块号相同则按照右端点排序。</strong> 当然我们只是概念上分块，并不一定需要严格存储块。之后我们只需要按照排序好是顺序挨个计算即可。</li></ol><p>总结起来一共三步：分块、排序、计算。算法复杂度为$O(N \sqrt{N})$</p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>可以发现本文是应用型的，对于算法的正确性证明以及复杂度证明都没有涉及，这方面的原因之一是由于这是入门文章，写太多证明反而令初学者害怕，如果学有余力自然可以找相关证明；然后就是拓展，掌握了基本思想再去拓展就轻松很多了，拓展方向可以向树形莫队、带修莫队等常见类型拓展，同时注意比较莫队和其他数据结构的异同以及优劣。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">31000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Q = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],m;</span><br><span class="line"><span class="keyword">int</span> ans,sum[<span class="number">1010000</span>];<span class="comment">//一个全局答案ans和标记数组sum是必要的 </span></span><br><span class="line"><span class="comment">//当然也可以离散化 </span></span><br><span class="line"><span class="keyword">int</span> len;<span class="comment">//块大小，在读入询问前需要先赋值 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,block,id;</span><br><span class="line">Query()&#123;&#125;</span><br><span class="line">Query(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> id):l(l),r(r),id(id)&#123;</span><br><span class="line">block = l/len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Query &amp;B) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(block == B.block) <span class="keyword">return</span> block&amp;<span class="number">1</span>? r &lt; B.r : r &gt; B.r;</span><br><span class="line"><span class="comment">//小优化，使得r呈波浪形 </span></span><br><span class="line"><span class="keyword">return</span> block &lt; B.block;</span><br><span class="line">&#125;</span><br><span class="line">&#125;query[Q];</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//增加或减少一个x位置上的数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">x = a[x]; </span><br><span class="line">sum[x] += v;</span><br><span class="line"><span class="keyword">if</span>(v &gt; <span class="number">0</span>) ans += sum[x] == <span class="number">1</span>;<span class="comment">//判等是为了防止重复计数 </span></span><br><span class="line"><span class="keyword">else</span> ans -= sum[x] == <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">len = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">query[i] = Query(x,y,i);</span><br><span class="line">&#125;</span><br><span class="line">sort(query+<span class="number">1</span>,query+<span class="number">1</span>+m);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>,r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l &lt; query[i].l) Move(l,<span class="number">-1</span>),l++;</span><br><span class="line"><span class="keyword">while</span>(l &gt; query[i].l) Move(l<span class="number">-1</span>,<span class="number">1</span>),l--;</span><br><span class="line"><span class="keyword">while</span>(r &gt; query[i].r) Move(r,<span class="number">-1</span>),r--;</span><br><span class="line"><span class="keyword">while</span>(r &lt; query[i].r) Move(r+<span class="number">1</span>,<span class="number">1</span>),r++;</span><br><span class="line">q.push(make_pair(-query[i].id,ans));<span class="comment">//大根堆变为小根堆 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.top().second;q.pop();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] 张瑯小强的<a href="https://www.cnblogs.com/CsOH/p/5904430.html" target="_blank" rel="noopener">博客</a>，2019.7.4<br>[2] 例题测试地址<a href="https://vjudge.net/problem/SPOJ-DQUERY" target="_blank" rel="noopener">SPOJ-DQUERY</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;莫队算法大概有基础莫队、树形莫队、带修（带修改的）莫队等类型，本文仅介绍基础莫队。可以看作莫队算法的入门。&lt;br&gt;莫队算法据说是2010年国
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>逆元模板</title>
    <link href="http://valenshi.top/2019/08/16/inv/"/>
    <id>http://valenshi.top/2019/08/16/inv/</id>
    <published>2019-08-16T13:54:10.000Z</published>
    <updated>2019-08-20T12:47:13.449Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>本文主要介绍了几种求逆元的方法，但是对于证明并未给出，所以本文是偏于应用型的，其后附录部分的代码模板可以参考使用。其中最容易理解也最容易写的是费马小定理求逆元，然后更加常用的就是求阶乘的逆元了，通过O(N)的预处理，我们可以在常数时间内求出组合数C(n,m)在 mod P下的值。</p><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p><strong>1.1 定义：</strong> 逆元素是指一个可以取消另一给定元素运算的元素，在数学里，逆元素广义化了加法中的加法逆元和乘法中的倒数。</p><p><strong>1.2 数论中定义：</strong> 如果满足公式，a*b = 1（mod P），则a是b的逆元，同时b也是a的逆元。</p><p><strong>1.3 另一种定义：</strong> a*x  = 1 (mod P)，其中a与P互质，则称x的最小整数为a关于P的逆元。</p><h4 id="2-逆元的应用"><a href="#2-逆元的应用" class="headerlink" title="2.逆元的应用"></a>2.逆元的应用</h4><p><strong>2.1 除法模运算：</strong> 设c为b在对P取模状态下的逆元，在求(a/b)modP时，很可能会因为b过大而超过精度范围，这时候可以将除法转换成乘法来做，（a/b）mod P = (a <em> Invb) mod P = (a mod P)</em> (Invb mod P) mod P。</p><h4 id="3-求逆元的常用方法"><a href="#3-求逆元的常用方法" class="headerlink" title="3.求逆元的常用方法"></a>3.求逆元的常用方法</h4><h5 id="3-1-费马小定理"><a href="#3-1-费马小定理" class="headerlink" title="3.1 费马小定理"></a>3.1 费马小定理</h5><blockquote><p>费马小定理：若p为素数，则有$a^{P-1} \equiv 1(mod P)$<br>推论：$a * a^{P-2} \equiv 1(mod P)$<br>故$a^{P-2}$就是a关于P的一个逆元</p></blockquote><p><strong>3.1.1 代码实例：</strong> 见附录部分code-1。</p><p><strong>3.1.2 复杂度分析：</strong> 求单个逆元的时间复杂度是lg(Mod)。</p><h5 id="3-2-拓展欧几里得算法"><a href="#3-2-拓展欧几里得算法" class="headerlink" title="3.2 拓展欧几里得算法"></a>3.2 拓展欧几里得算法</h5><h5 id="3-3-逆元线性筛"><a href="#3-3-逆元线性筛" class="headerlink" title="3.3 逆元线性筛"></a>3.3 逆元线性筛</h5><blockquote><p>递推式：inv[i] = (Mod-Mod / i) <em> inv[Mod% i]%Mod<br>如果要保证结果为正： inv[i] = (Mod-Mod / i) </em> inv[Mod% i]%Mod<br>证明：</p></blockquote><p><strong>3.3.1 代码示例：</strong> 见附录部分code-2。<br><strong>3.3.2 复杂度分析：</strong> O(N)。</p><h5 id="3-4求阶乘的逆元"><a href="#3-4求阶乘的逆元" class="headerlink" title="3.4求阶乘的逆元"></a>3.4求阶乘的逆元</h5><blockquote><p>递推式：inv[i] = inv[i+1] * (i + 1) % Mod<br>证明：</p></blockquote><p><strong>3.4.1代码示例：</strong> 见附录部分code-3.。</p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p><strong>code-1：费马小定理求逆元</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 100010;</span><br><span class="line">const int P = 1e5+7;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll Finv[N];</span><br><span class="line">ll qpow(ll x,ll p,ll m)&#123;//快速幂算法 </span><br><span class="line">ll res = 1;</span><br><span class="line">while(p)&#123;</span><br><span class="line">if(p&amp;1)res =res*x%m;</span><br><span class="line">x = x*x%m;</span><br><span class="line">p &gt;&gt;= 1;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">void Init()&#123;//用来求逆元 </span><br><span class="line">Finv[1] = 1;</span><br><span class="line">for(int i = 2;i &lt; N;i++)</span><br><span class="line">Finv[i] = qpow(i,P-2,P);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Init();</span><br><span class="line">for(int i = 1;i &lt; N;i++)</span><br><span class="line">cout &lt;&lt; Finv[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>code-2：逆元线性筛</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int N = 100010;</span><br><span class="line">const int P = 1e5+7;</span><br><span class="line">ll inv[N];</span><br><span class="line">void Inv()&#123;</span><br><span class="line">inv[0] = inv[1] = 1;</span><br><span class="line">for(ll i = 2;i &lt; N;i++)&#123;</span><br><span class="line">inv[i] = (P - P/i)*inv[P%i]%P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Inv();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>code-3求阶乘的逆元</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll Finv[N],F[N];<span class="comment">//F存阶乘，Finv存对应逆元 </span></span><br><span class="line"><span class="function">ll <span class="title">Qpow</span><span class="params">(ll x,ll p,ll m)</span></span>&#123; </span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line"><span class="keyword">if</span>(p&amp;<span class="number">1</span>)res =res*x%m;</span><br><span class="line">x = x*x%m;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">F[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt; N;i++)</span><br><span class="line">F[i] = F[i<span class="number">-1</span>]*i%P; </span><br><span class="line">Finv[N<span class="number">-1</span>] = Qpow(F[N<span class="number">-1</span>],P<span class="number">-2</span>,P);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = N<span class="number">-1</span>;i &gt; <span class="number">0</span>;i--)</span><br><span class="line">Finv[i<span class="number">-1</span>] = Finv[i]*i%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; N;i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Finv[i]*F[i]%P &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;本文主要介绍了几种求逆元的方法，但是对于证明并未给出，所以本文是偏于应用型的，其后附录部分的代码模板可以参考使用。其中最容易理解也最容易写的
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数论" scheme="http://valenshi.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://valenshi.top/2019/08/16/bit-cal/"/>
    <id>http://valenshi.top/2019/08/16/bit-cal/</id>
    <published>2019-08-16T13:53:04.000Z</published>
    <updated>2019-08-16T13:53:55.632Z</updated>
    
    <content type="html"><![CDATA[<p><strong>需要掌握的知识：</strong></p><ul><li>原码、反码、补码</li><li>按位或</li><li>按位与</li><li>异或</li><li>非</li><li>移位运算</li><li>lowbit的实现</li><li>运算符优先级<h5 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h5><strong>原码：</strong> 是最简单的机器数表示法。用最高位表示符号位，‘1’表示负号，‘0’表示正号。其他位存放该数的二进制的绝对值。<blockquote><p>1010  ： 最高位为‘1’,表示这是一个负数，其他三位为‘010’，<br>即（0<em> 2^2）+（1</em> 2^1）+（0* 2^0）=2（‘^’表示幂运算符）<br>所以1010表示十进制数（-2）。</p></blockquote></li></ul><p><strong>面临问题：</strong> 原码下，正数相加所得结果正确，但是正数和负数相加出错。</p><hr><p><strong>反码：</strong> 正数的反码还是等于原码，负数的反码就是他的原码除符号位外，按位取反。</p><blockquote><p>3是正数，反码与原码相同，则可以表示为0011<br>-3的原码是1011，符号位保持不变，低三位（011）按位取反得（100）<br>所以-3的反码为1100</p></blockquote><p><strong>面临问题：</strong> 正数相加所得结果正确，正负相加所得结果正确，负负相加结果出错。</p><hr><p><strong>补码：</strong> 正数的补码等于他的原码，负数的补码等于反码+1。</p><p>上述给出的是补码的求法，补码的真正定义是什么？为什么要这样定义？</p><p>采用补码的表示方式的<strong>好处</strong>，一是可以将减法转化为加法运算，简化运算复杂度；二是可以让符号位作为数值直接参与运算，所得结果仍然是正确的，即符号位无需单独处理。</p><h5 id="按位或、与、异或、非"><a href="#按位或、与、异或、非" class="headerlink" title="按位或、与、异或、非"></a>按位或、与、异或、非</h5><p>在c语言中，是将一个十进制整数（一般情况下）转化为二进制位，然后再对二进制数的每一位对应进行或、与、异或、非操作。</p><h5 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h5><p>位移运算分为左移和算数右移，其中<strong>左移</strong>是指在二进制表示下把所有位数字同时向左移动一位，高位越界后舍弃，低位以0补充。其中越界是指，int型变量一般仅有32位，如果左移后超过了32位则舍弃超过的部分。<br><strong>算数右移</strong>是指在二进制补码表示下把数字同时向右移动，高位以符号位填充，低位越界后舍弃。算数右移等于除以2向下取整，（-5）&gt;&gt;1 = -3 , 3 &gt;&gt; 1 = 2。<br>可以发现算数右移并不等同于c语言中的整数/2，值得一提的是c语言中的整数/2是“除以2向0取整”。<br><strong>逻辑右移</strong>是在补码表示下把所有数字同时右移，高位以0补充，低位越界后舍弃，但是C++没有规定实现方式，一般编译器都会实现算数右移。</p><h5 id="lowbit的实现"><a href="#lowbit的实现" class="headerlink" title="lowbit的实现"></a>lowbit的实现</h5><p><strong>定义：</strong> lowbit( n )是取出非负整数 n 在二进制表示下最低位的 1 以及它后面的0所构成的十进制数值。<br><strong>实现：</strong><br>若 n &gt; 0，且第 k 位是1，第 0 ~ k-1 位都是0。<br>先将n按位取反，那么第 k 位变成了0，第 0 ~k 位变成了1。<br>再令n = n+1，那么显然通过一系列进位，第 0~k-1 位都变成了0，而第 k 位又变成了1。<br>我们注意到，最初的 n ，与最终的n只有第 0~k 位相同，更高的位都恰好相反（举个例子推导试试），于是将它们按位与就得到了 0~k 位的数值，这个值就是我们所求的答案。</p><h5 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h5><p>不确定就加括号！！位移运算最好加括号！<br><a href="https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/4752611?fr=aladdin" target="_blank" rel="noopener">百度百科，运算符优先级表</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;需要掌握的知识：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原码、反码、补码&lt;/li&gt;
&lt;li&gt;按位或&lt;/li&gt;
&lt;li&gt;按位与&lt;/li&gt;
&lt;li&gt;异或&lt;/li&gt;
&lt;li&gt;非&lt;/li&gt;
&lt;li&gt;移位运算&lt;/li&gt;
&lt;li&gt;lowbit的实现&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二维st表</title>
    <link href="http://valenshi.top/2019/08/16/st2/"/>
    <id>http://valenshi.top/2019/08/16/st2/</id>
    <published>2019-08-16T13:30:10.000Z</published>
    <updated>2019-08-20T12:43:05.972Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>我们知道一维的st表在经过预处理后可以在O(1)时间内查询任意区间的极值，虽然其是离线算法，但胜在代码短小易写。而在二维RMQ（区间最值查询）问题中，我们依然可以采用st算法解决问题，只不过我们需要从一维拓展到二维，当然适用范围依然是离线。二维st表仍然是用倍增思想，如果理解了一维的st表，那么对于二维的也不难理解。</p><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个n* n的矩阵以及一个整数b和k，共有k次询问，每次询问给出边长为b的子矩阵的左上角的行和列(r,c)，请回答该子矩阵内的最大值和最小值的差是多少。</p><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><p><strong>变量定义：</strong><br><code>st[r][c][k]</code> 存放以(r , c)为左上角的边长为$2^k$个元素的矩阵的最大值。<br><code>a[n][n]</code> 用来存放矩阵中的元素。</p><p><strong>查询操作：</strong><br>假设我们的st表已经更新完毕，此时<code>st[r][c][k]</code> 中存放的是以(r , c)为左上角的边长为$2^k$ 的矩阵内的最大值，那么对于一个查询(a , b , c) 即查询以(a , b)为左上角，边长为 c 的矩阵内的最大值该如何处理呢？<br>显然和一维一样，由于我们的st表中存放的区间长度是2的次方项，因此如果边长并不恰好是2的次方项，那么就无法通过一次访问st表求得，需要通过几个重叠区间得出结果。在二维RMQ中，就体现为将一个大矩阵查询分为4个小矩阵查询。<br>下面我们具体来讲一下如何划分查询区间。假设我们要查询的是以（a，b）为左上角，边长为 c 的矩阵内的最大值，那么假设 $k = log_2^c$ 向下取整，那么显然<code>st[a][b][k]</code>是一个如下图(a)中显示的一个小矩阵。</p><p><img src="/2019/08/16/st2/1.png" alt="1"></p><p>那么显而易见，<code>st[a][b+c-(1&lt;&lt;k)+1][k]</code>正如（b）中的蓝色矩形一样覆盖了以右上角为顶点的矩阵。同理，我们共需要四个矩形来覆盖整个大矩形，如（c）所示。因此对于任意边长的正方形，我们都可以计算出其覆盖面积的最大值。因为求极值操作是允许区间重叠的( [1 , 10] 的最大值可以由[1 , 6] 的最大值和[2 , 10]的最大值得出 )，因此上述划分方法虽有区间重叠，但对最终答案没有影响（求和则不行）。<br>总结起来，若设最终要求的答案为ans，则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">令t1 = st[a][b][c];</span><br><span class="line">令t2 = st[a][b+c-(1&lt;&lt;k)+1][c];</span><br><span class="line">令t3 = st[a+c-(1&lt;&lt;k)+1][b][c];</span><br><span class="line">令t4 = st[a+c-(1&lt;&lt;k)+1][b+c-(1&lt;&lt;k)+1][c];</span><br><span class="line">ans = max&#123;t1 , t2 , t3 , t4&#125;；</span><br></pre></td></tr></table></figure></p><p>因此我们得证了，利用上述定义的st表，确实可以在常数时间内求出目标矩阵的最大值。</p><p><strong>更新st表（预处理）</strong><br>我们在一开始就提到过，st表是离线算法， 即不支持修改操作，因此以此预处理之后便只能进行查询。预处理时间复杂度为$O(N^2log_2N)$。预处理用到了动态规划的思想。<br>更新也是同样的道理，更新一个大矩形，需要用到4个小矩形。状态转移方程如下：</p><p><code>st[i][j][k] = Max( st[i][j][k-1] , st[i+(1&lt;&lt;k-1)][j][k-1] , st[i][j+(1&lt;&lt;k-1)][k-1] , st[i+(1&lt;&lt;k-1)][j+(1&lt;&lt;k-1)][k-1]);</code></p><p>为什么这个式子成立呢？如果从式子上看，$2^{k-1} + 2^{k-1} = 2^k$，因此俩个小区间可以更新一个大区间，拓展到二维上呢，就是4个小矩阵更新一个大矩阵。如果用图来描述，就如（d）所示，四个小矩形构成一个大矩形，而大矩形的边长是小矩形的2倍。于是我们就可以通过四个小矩阵的值来更新大矩阵的值。<br><img src="/2019/08/16/st2/2.png" alt="2"></p><h4 id="例题-HAOI2007理想的正方形"><a href="#例题-HAOI2007理想的正方形" class="headerlink" title="例题 HAOI2007理想的正方形"></a>例题 <a href="https://www.luogu.org/problem/P2216" target="_blank" rel="noopener">HAOI2007理想的正方形</a></h4><p><strong>解题思路：</strong><br>本题就是一个二维RMQ问题的裸题，和上述模型不同的是，其是一个长a宽b的矩形，而非正方形。不管是矩形还是正方形，我们的更新和查询都是划分为4个子矩阵来更新或查询，因此只需对代码稍作改变即可，基本没太大变化，预处理都是$O(N^2logN)$，查询也都是O(1)。</p><p><strong>代码示例：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N],n,m,len,Log[N];</span><br><span class="line"><span class="keyword">int</span> st[<span class="number">3</span>][N][N][<span class="number">15</span>];<span class="comment">//0最小，1最大值 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mx = a;<span class="keyword">if</span>(mx &lt; b) mx = b;<span class="keyword">if</span>(mx &lt; c) mx = c;<span class="keyword">if</span>(mx &lt; d) mx = d;</span><br><span class="line"><span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mi = a;<span class="keyword">if</span>(mi &gt; b) mi = b;<span class="keyword">if</span>(mi &gt; c) mi = c;<span class="keyword">if</span>(mi &gt; d) mi = d;</span><br><span class="line"><span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++) </span><br><span class="line">st[<span class="number">0</span>][i][j][<span class="number">0</span>] = st[<span class="number">1</span>][i][j][<span class="number">0</span>] = a[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= <span class="number">12</span>;k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span> &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j + (<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span> &lt;= m;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> t1 = st[<span class="number">0</span>][i][j][k<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> t2 = st[<span class="number">0</span>][i+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][j][k<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> t3 = st[<span class="number">0</span>][i][j+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][k<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> t4 = st[<span class="number">0</span>][i+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][j+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][k<span class="number">-1</span>];</span><br><span class="line">st[<span class="number">0</span>][i][j][k] = min(t1,t2,t3,t4);</span><br><span class="line">t1 = st[<span class="number">1</span>][i][j][k<span class="number">-1</span>];</span><br><span class="line">t2 = st[<span class="number">1</span>][i+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][j][k<span class="number">-1</span>];</span><br><span class="line">t3 = st[<span class="number">1</span>][i][j+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][k<span class="number">-1</span>];</span><br><span class="line">t4 = st[<span class="number">1</span>][i+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][j+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][k<span class="number">-1</span>];</span><br><span class="line">st[<span class="number">1</span>][i][j][k] = max(t1,t2,t3,t4);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[len];</span><br><span class="line"><span class="keyword">int</span> t1 = st[<span class="number">0</span>][r][c][k];</span><br><span class="line"><span class="keyword">int</span> t2 = st[<span class="number">0</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c][k];</span><br><span class="line"><span class="keyword">int</span> t3 = st[<span class="number">0</span>][r][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line"><span class="keyword">int</span> t4 = st[<span class="number">0</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line"><span class="keyword">int</span> mi = min(t1,t2,t3,t4);</span><br><span class="line">t1 = st[<span class="number">1</span>][r][c][k];</span><br><span class="line">t2 = st[<span class="number">1</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c][k];</span><br><span class="line">t3 = st[<span class="number">1</span>][r][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line">t4 = st[<span class="number">1</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line"><span class="keyword">int</span> mx = max(t1,t2,t3,t4);</span><br><span class="line"><span class="comment">//printf("%d %d\n",mx,mi);</span></span><br><span class="line"><span class="keyword">return</span> mx - mi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n-len+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m-len+<span class="number">1</span>;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = ask(i,j,len);</span><br><span class="line">ans = ans &lt; tmp?ans:tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>大家可以发现我们的二维st表建立在正方形矩阵查询的基础上的，因此st表仅三个维度，即<code>st[r][c][k]</code> 代表以(r , c) 为左上角的边长为$2^k$的矩阵的极值；但如果所给矩阵以及所求矩阵并不是正方形而是普通矩形，那就要增加一个维度，即<code>st[r][c][k1][k2]</code> 表示以（r，c）为左上角，长为$2^{k1}$高为$2^{k2}$的矩阵的极值，其更新方法与本文所介绍的类似，都是通过4个子矩阵来更新，查询也是通过4个子矩阵来查询最终答案。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;我们知道一维的st表在经过预处理后可以在O(1)时间内查询任意区间的极值，虽然其是离线算法，但胜在代码短小易写。而在二维RMQ（区间最值查询
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>求a的大幂对P取模</title>
    <link href="http://valenshi.top/2019/08/16/bigpow/"/>
    <id>http://valenshi.top/2019/08/16/bigpow/</id>
    <published>2019-08-16T05:08:42.000Z</published>
    <updated>2019-08-20T12:42:54.271Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有如下问题：<br>求2^n mod (1e9+7)，其中1&lt; n &lt; 10^100000。</p></blockquote><p>首先明确一下此类问题的几种算法，首先朴素算法，即暴力循环求解，是O(N)复杂度，适用范围应该是n小于1000000；然后是快速幂算法，效率是O(log N)，适用于n小于2^100000级别的；然后就是上面的例题了，由于范围是10^100000，即使是快速幂也不可能在期望时间内解决，这时候需要另辟蹊径。</p><p><strong>费马小定理：</strong> 对于质数P，任意的整数a，若满足GCD(a,P) = 1，则有：$a^p \equiv a (mod \,p)$</p><p><strong>主要思路：</strong><br>回到上述例题，可知 P 即1e9+7，这是个素数。而 a 是 2 ，很明显 2 也是素数，所以GCD(a , P ) = 1，满足费马小定理的条件。那么我们想提高2^n计算的效率，就绕不开减小n的大小，我们接下来就利用费马小定理来减少幂n的大小。</p><p>首先费马小定理的一个小变形：$a^{(P-1)} \equiv 1 (mod \,P)$</p><p>接下来对2^n进行变形：<script type="math/tex">2^n = 2^{ x *  (P-1)}  * 2^k</script> ，而根据费马小定理，显然 $2^{x *  (P-1)} mod\,P = 1 mod \,P$ ，于是 $2^n mod\,P= 2^k$ ，其中k = n%(P-1)。此时k小于P，即小于1e9+7，可以使用快速幂解决。</p><p><strong>注意：</strong> 值得注意的是，10^100000 最大是1后面有100000个0，需要用字符串存，在转化为整数时利用模运算规则，边转化边取模。</p><p><strong>代码示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = res*a%M;</span><br><span class="line">a = a*a%M;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="built_in">string</span> x)</span></span>&#123;</span><br><span class="line">ll M1 = M<span class="number">-1</span>;</span><br><span class="line">ll k = x[<span class="number">0</span>]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;x[i];i++) k = (k*<span class="number">10</span>+x[i]-<span class="string">'0'</span>)%M1;</span><br><span class="line">ll ans = qpow(<span class="number">2</span>,k); </span><br><span class="line"><span class="keyword">return</span> ans%M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n != <span class="string">"0"</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,solve(n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;有如下问题：&lt;br&gt;求2^n mod (1e9+7)，其中1&amp;lt; n &amp;lt; 10^100000。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先明确一下此类问题的几种算法，首先朴素算法，即暴力循环求解，是O(N)复杂度，适用范围应该是n小于
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>强连通分量</title>
    <link href="http://valenshi.top/2019/08/16/tarjan/"/>
    <id>http://valenshi.top/2019/08/16/tarjan/</id>
    <published>2019-08-16T03:56:44.000Z</published>
    <updated>2019-08-20T12:42:42.224Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>强连通分量常用于<strong>缩点</strong>，是图论中一个重要的知识点。本文首先介绍了强连通分量的相关定义以及其应用范围，然后将着重介绍两种求强连通分量的算法：Kosaraju算法以及Tarjan算法，它们的时间复杂度都是O(n+m)（n：顶点数，m：边数）。<br>其中Kosaraju算法思想简单，操作方便，易于理解与代码实现，但是性能以及拓展性上比Tarjan略逊一筹；本文将会逐一介绍这两种算法的思想以及实现步骤，最后会以例题的形式给出代码模板。</p><h4 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h4><p>在有向图G中，如果两个顶点u，v间存在一条 u 到 v 的路径且也存在一条 v 到 u 的路径，则称这两个顶点u，v 是强连通的（strongly connected）。如果有向图G的任意两个顶点都强连通，则称G是一个强连通图。有向非强连通图的极大强连通子图，称为强连通分量（strongly connected components）。</p><p><strong>极大强连通子图：</strong> G是一个极大强连通子图，当且仅当G是一个强连通子图且不存在另一个强连通子图G’，使得 G 是 G’ 的真子集。</p><h4 id="强连通分量的应用"><a href="#强连通分量的应用" class="headerlink" title="强连通分量的应用"></a>强连通分量的应用</h4><p>若将有向图中的强连通分量都缩为一个点，则原图会形成一个DAG（有向无环图），如图1所示:<br><img src="/2019/08/16/tarjan/1.png" alt="图1"><br><em>图1：虚线部分构成一个强连通分量（图片来自<a href="https://blog.csdn.net/sinat_40872274/article/details/99344104#commentBox" target="_blank" rel="noopener">ccf的博客</a>）</em></p><p>强连通分量的<strong>常见用途</strong>有两个：</p><ul><li>有向图的缩点。</li><li>解决2-SAT问题。</li></ul><h4 id="Kosaraju-算法"><a href="#Kosaraju-算法" class="headerlink" title="Kosaraju 算法"></a>Kosaraju 算法</h4><p>Kosaraju算法的时间复杂度是O(n+m)，基于两次DFS的有向图强连通子图算法。<br>该算法共分为三步：</p><blockquote><p>第一步，对原有向图G进行DFS，记录节点访问完的顺序d[i] , d[i] 表示第 i 个访问完的节点是d[i]；<br>第二步，选择具有最晚访问完的顶点，对反向图GT 进行DFS，删除能够遍历到的顶点，这些顶点构成的一个强连通分量。<br>第三步，如果还有顶点没有删除，继续第二部，否则算法结束。</p></blockquote><h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><p>见附录部分 code-1：Kosaraju算法模板（POJ2186）</p><h4 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h4><p>Tarjan算法是 Robert Tarjan 发明的一个算法，其时间复杂度也是O(n+m)，但我们之所以在掌握了Kosaraju算法后仍要学习Tarjan算法的主要原因有以下三点：</p><ul><li>Tarjan算法效率比Kosaraju算法高大概30%，所以Kosaraju可能会被卡常。</li><li>Kosaraju算法利用递归实现，可能会爆栈；而Tarjan则不会（因为根本没递归）。</li><li>Tarjan算法还可以通过拓展解决求割点、割桥以及2-SAT等问题。</li></ul><p>实际上如果出题人有这个想法，那么就不是可能会超时，是一定会超时；不是可能会爆栈，是一定会爆栈，所以还是要掌握该算法的。</p><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>Tarjan算法是基于对图深度优先搜索（DFS）的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个栈，回溯时可以判断栈顶到栈中的节点是否构成一个强连通分量。<br>我们定义DFS过程中遇到的<strong>四种边</strong>：</p><ul><li>树枝边：DFS时经过的边，即DFS搜索树上的边。</li><li>前向边：与DFS方向一致，从某个节点指向其某个子孙的边。</li><li>后向边：与DFS方向相反，从某个节点指向其某个祖先的边。</li><li>横向边：从某个节点指向搜索树中另一子树中的某节点的边。</li></ul><p><strong>定义DFN(u)</strong> 为节点 u 的搜索次序编号（时间戳），Low(u) 为u 或者u 的子树能够回溯到的最早的栈中节点的DFN值。</p><p>根据定义我们可以得出：</p><ul><li>如果(u , v)为树枝边，u 为 v 的父节点，则 Low(u) = min{ Low(u) , Low(v) }。</li><li>如果(u , v)为后向边或指向栈中节点的横叉边，则Low(u) = min{ Low(u) , DFN(v) }。</li></ul><p>当节点u的搜索过程结束后，若DFN(u) = Low(u)，则以u为根的搜索子树上所有还在栈中的节点（即u和栈中在u之后的所有节点）是一个强连通分量，可退栈。通俗的说，若u为强连通分量的根，那么它的子孙中的最高最先应该就是它本身。</p><h5 id="算法的主要过程"><a href="#算法的主要过程" class="headerlink" title="算法的主要过程"></a>算法的主要过程</h5><p><strong>数组的初始化：</strong> 当首次搜索到点 u 时，DFN(u)为节点u的搜索次序编号（时间戳）。<br><strong>堆栈：</strong> 将u压入堆栈。<br><strong>更新Low(u)：</strong> </p><ol><li>如果（u，v）为树枝边（v不在栈中），u为v的父节点，则Low(u) = min{Low(u) , Low(v)}。</li><li>如果（u，v）为后向边或者指向栈中节点的横叉边（v在栈中），则Low(u) = min{ Low(u) DFN(v)}。</li><li>如果u的子树已经全部遍历后Low(u) = DFS(u)，则将u和<strong>栈中在u之后的所有节点</strong> 弹出栈。这些出栈的元素组成一个强连通分量。</li><li>继续搜索（或许会更换搜索的起点，因为整个有向图可能分为多个不连通的部分），直到所有点被遍历。</li></ol><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>见附录部分code-2：POJ2182（Tarjan算法）</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>董永建，信息学竞赛一本通提高版，福州：福建教育出版社，2018.6，155-178</li><li>秋叶拓哉，挑战程序设计竞赛第2版，北京：人民邮电出版社，2013.6，320-324</li></ul><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p><strong>code-1：Kosaraju算法模板（POJ2182）</strong><br>求所有“红牛”总数。（红牛即所有牛的偶像）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************</span></span><br><span class="line"><span class="comment">    最后修改：2019/8/15 Valenshi</span></span><br><span class="line"><span class="comment">    使用说明：</span></span><br><span class="line"><span class="comment">        用数组表示邻接表,分别建立了正图和反图;</span></span><br><span class="line"><span class="comment">        只适用于节点从1~n的题型,切记若干节点编号是0~n-1会死循环!</span></span><br><span class="line"><span class="comment">        主函数：scc(),用于求所有强连通分量,O(N+M),答案存放在kos数组。</span></span><br><span class="line"><span class="comment"> *******************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot;  <span class="comment">//邻接表存放有向图</span></span><br><span class="line"><span class="keyword">int</span> rhead[N],rver[M],rnex[M],rtot;<span class="comment">//存放反图</span></span><br><span class="line"><span class="keyword">int</span> vis[N],kos[N];<span class="comment">//访问标记;节点所属联通分量标号</span></span><br><span class="line"><span class="keyword">int</span> ts[N],tc;  <span class="comment">//时间戳, dfs访问时的顺序;tc为当前"时间"</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 建立一条从x-&gt;y的有向边 , 同时在反图添加一条从y-&gt;x的有向边*/</span></span><br><span class="line">    ver[++tot] = y,nex[tot] = head[x], head[x] = tot;</span><br><span class="line">    rver[++rtot] = x,rnex[rtot] = rhead[y],rhead[y] = rtot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*给节点x以及它的子孙打上时间戳*/</span></span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x] ;i ;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i];</span><br><span class="line">        <span class="keyword">if</span>(!vis[y]) dfs(y);</span><br><span class="line">    &#125;</span><br><span class="line">    ts[++tc] = x;     <span class="comment">//第tc个回溯的是点x</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rdfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 找出属于第k个强连通分量的所有点 */</span></span><br><span class="line">    vis[x] = <span class="literal">true</span>;kos[x] = k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = rhead[x];i ;i = rnex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = rver[i];</span><br><span class="line">        <span class="keyword">if</span>(!vis[y]) rdfs(y,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;      <span class="comment">//点的个数,编号为1~n;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 将原图分为若干强连通分量,并返回个数 */</span></span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);tc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) dfs(i);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = tc;i &gt; <span class="number">0</span>;i--) <span class="keyword">if</span>(!vis[ts[i]]) rdfs(ts[i],++k);</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************</span></span><br><span class="line"><span class="comment">以下为POJ2186解题代码 </span></span><br><span class="line"><span class="comment"> ***********************************/</span></span><br><span class="line"><span class="keyword">int</span> A[N],B[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = scc();<span class="comment">//备选答案总数 </span></span><br><span class="line"><span class="keyword">int</span> y = <span class="number">0</span>,sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(kos[i] == k)&#123;</span><br><span class="line">y = i;sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查是否从所有点可达</span></span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">rdfs(y,<span class="number">0</span>);<span class="comment">//代码重用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">sum = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>code-2：POJ2182（Tarjan算法模板）</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************************************************************</span></span><br><span class="line"><span class="comment">最后更新：2019/8/16 ValenShi</span></span><br><span class="line"><span class="comment">使用说明：</span></span><br><span class="line"><span class="comment">1.记得初始化辅助数组dfn[],co[],head[],</span></span><br><span class="line"><span class="comment">以及"数组指针" ,top,tot,num,col ;</span></span><br><span class="line"><span class="comment">2.每个辅助数组具体作用见注释;</span></span><br><span class="line"><span class="comment">3.节点范围是1~n,若是0~n-1会死循环,可更改head[]初始值解决。 </span></span><br><span class="line"><span class="comment">***************************************************************/</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="comment">/* 邻接表存有向图 */</span></span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y,nex[tot] = head[x],head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***************************************** </span></span><br><span class="line"><span class="comment">Tarjan算法及其辅助数组：</span></span><br><span class="line"><span class="comment">Stack[]为栈,top为栈顶指针;</span></span><br><span class="line"><span class="comment">dfn[]为节点的时间戳,num为对应的"时间";</span></span><br><span class="line"><span class="comment">co[]为节点所在的强连通分量的编号,col对应编号; </span></span><br><span class="line"><span class="comment">******************************************/</span> </span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> Stack[N],top;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],num,co[N],col;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++num;</span><br><span class="line">Stack[++top] = u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> v = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">Tarjan(v);</span><br><span class="line">low[u] = min(low[u],low[v]);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!co[v]) low[u] = min(low[u],dfn[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[u] == dfn[u])&#123;</span><br><span class="line">co[u] = ++col;</span><br><span class="line"><span class="keyword">while</span>(Stack[top] != u)&#123;</span><br><span class="line">co[Stack[top]] = col;</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> chudu[N];<span class="comment">/*用来记录每个强连通分量的出度 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">num = col = top = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//memset(dfn,0,sizeof dfn);</span></span><br><span class="line"><span class="comment">//memset(co,0,sizeof co);</span></span><br><span class="line"><span class="comment">//memset(chudu,0,sizeof chudu); </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,tcnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*ans存放答案,tcnt表示出度为0的强连通分量的个数*/</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = head[i];j ;j = nex[j])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[j];</span><br><span class="line"><span class="keyword">if</span>(co[i] != co[y]) chudu[co[i]]++;</span><br><span class="line"><span class="comment">/*i所在的强连通分量的出度+1 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tcol = <span class="number">1</span>;<span class="comment">/*tcol为出度为0的强连通分量的编号*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++) <span class="keyword">if</span>(!chudu[i]) tcnt++,tcol = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(co[i] == tcol) ans++;</span><br><span class="line"><span class="keyword">if</span>(tcnt &gt; <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,u,v;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">addEdge(u,v);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;强连通分量常用于&lt;strong&gt;缩点&lt;/strong&gt;，是图论中一个重要的知识点。本文首先介绍了强连通分量的相关定义以及其应用范围，然后将着
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
