<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ValenShi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://valenshi.top/"/>
  <updated>2019-09-30T14:57:51.770Z</updated>
  <id>http://valenshi.top/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Trie字典树练习题集</title>
    <link href="http://valenshi.top/2019/09/30/trie-problems/"/>
    <id>http://valenshi.top/2019/09/30/trie-problems/</id>
    <published>2019-09-30T10:37:26.000Z</published>
    <updated>2019-09-30T14:57:51.770Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/index.php" target="_blank" rel="noopener">测试地址</a></p><h4 id="Phone-List"><a href="#Phone-List" class="headerlink" title="Phone List"></a>Phone List</h4><p>原题来自：POJ 3630<br>给定 n 个长度不超过 10 的数字串，问其中是否存在两个数字串 S,T，使得 S 是 T 的前缀，多组数据。</p><p><strong>解题思路</strong><br>Trie的经典应用，可以作为模板题练手。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>], tot;</span><br><span class="line"><span class="keyword">int</span> End[SZ];</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 将字串s插入trie树 */</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s) ,p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][ch] == <span class="number">0</span>) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 字串s是否有前缀 */</span> </span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(End[p]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(search(str[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n); </span><br><span class="line"><span class="comment">/* 初始化trie相关变量 */</span></span><br><span class="line"><span class="built_in">memset</span>(End,<span class="number">0</span>,<span class="keyword">sizeof</span> End); tot = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="keyword">sizeof</span> trie);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[i]);</span><br><span class="line"><span class="keyword">if</span>(solve()) <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="The-XOR-Largest-Pair"><a href="#The-XOR-Largest-Pair" class="headerlink" title="The XOR Largest Pair"></a>The XOR Largest Pair</h4><p><strong>题意简述</strong><br>在给定的 N 个整数 A1,A2,…,AN 中选出两个进行异或运算，得到的结果最大是多少？</p><p><strong>解题思路</strong><br>就是将每个整数看作31位的01字符串，然后全部插入到Trie上，再分别对每个整数从高位到低位优先在Trie上走和该位相反的节点。01字典树。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">5e6</span>+<span class="number">10</span>;<span class="comment">//大小要合理！！！ </span></span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">3</span>], End[SZ], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][ch] == <span class="number">0</span>) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][!ch]) p = trie[p][!ch], res |= <span class="number">1</span>&lt;&lt;i;</span><br><span class="line"><span class="keyword">else</span> p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) calc(a[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Codechef-REBXOR"><a href="#Codechef-REBXOR" class="headerlink" title="Codechef REBXOR*"></a>Codechef REBXOR*</h4><p><strong>题意简述</strong><br><img src="/2019/09/30/trie-problems/1.png" alt="trie-problems/1.png"><br><strong>解题思路</strong><br>这题用的是 “Trie维护异或前缀和”，根据异或的特性，我们从左到右依次将元素插入后，再利用 x^y^x = y 这个特性在常数时间利用 Trie 找最大区间异或和。本题还是很有参考意义的，尤其是异或前缀和这一技巧。<br>当然由于OJ上给定的空间过小，本代码没过，待解决。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">20</span>*N;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">3</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],lmx[N],rmx[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">32</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">32</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][!ch]) p = trie[p][!ch],res |= <span class="number">1</span>&lt;&lt;i;</span><br><span class="line"><span class="keyword">else</span> p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;Insert(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/* x 用于累计异或前缀和,Trie用于求最大异或区间*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">x ^= a[i]; Insert(x);</span><br><span class="line">lmx[i] = max(search(x),lmx[i<span class="number">-1</span>]);</span><br><span class="line"><span class="comment">//包含x的最大区间异或和 与  不包含x的区间的最大异或和 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="keyword">sizeof</span> trie); tot = <span class="number">1</span>;</span><br><span class="line">Insert(<span class="number">0</span>); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">x ^= a[i]; Insert(x);</span><br><span class="line">rmx[i] = max(search(x),rmx[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) ans = max(ans,lmx[i]+rmx[i+<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Immediate-Decodability"><a href="#Immediate-Decodability" class="headerlink" title="Immediate Decodability"></a>Immediate Decodability</h4><p><strong>题意简述</strong><br>原题来自：ACM Pacific NW Region 1998<br>给出一些数字串，判断是否有一个数字串是另一个串的前缀。<br><strong>解题思路</strong><br>和第1题一样，模板题。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> End[SZ];</span><br><span class="line"><span class="keyword">int</span> n,t,cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 将字串s插入trie树 */</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s) ,p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][ch] == <span class="number">0</span>) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 字串s是否有前缀 */</span> </span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(End[p]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(search(str[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[++n]) != EOF)&#123;</span><br><span class="line"><span class="comment">/* 初始化trie相关变量 */</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(str[n]) == <span class="number">1</span> &amp;&amp; str[n][<span class="number">0</span>] == <span class="string">'9'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!solve()) <span class="built_in">printf</span>(<span class="string">"Set %d is immediately decodable\n"</span>,++cnt);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Set %d is not immediately decodable\n"</span>,++cnt);</span><br><span class="line"><span class="built_in">memset</span>(End,<span class="number">0</span>,<span class="keyword">sizeof</span> End); tot = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="keyword">sizeof</span> trie); n = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="L语言"><a href="#L语言" class="headerlink" title="L语言*"></a>L语言*</h4><p><strong>题意简述</strong></p><p>原题来自：HNOI 2004<br>标点符号的出现晚于文字的出现，所以以前的语言都是没有标点的。现在你要处理的就是一段没有标点的文章。<br>一段文章 T 是由若干小写字母构成。一个单词 W 也是由若干小写字母构成。一个字典 D 是若干个单词的集合。<br>我们称一段文章 T 在某个字典 D 下是可以被理解的，是指如果文章 T 可以被分成若干部分，且每一个部分都是字典 D 中的单词。例如字典 D 中包括单词 is , your , what , name ，则文章 whatisyourname 是在字典 D 下可以被理解的，因为它可以分成 4 个单词： what , is , your , name ，且每个单词都属于字典 D，而文章 whatisyouname 在字典 D 下不能被理解，但可以在字典 D′=D+you 下被理解。这段文章的一个前缀 whatis ，也可以在字典 D 下被理解 而且是在字典 D 下能够被理解的最长的前缀。<br>给定一个字典 D ，你的程序需要判断若干段文章在字典 D 下是否能够被理解。 并给出其在字典 D 下能够被理解的最长前缀的位置。<br><strong>解题思路</strong><br>这题有点难的地方是  文章中某个前缀可能由多个单词组合出来，于是我们需要对每个可能是单词末尾的位置再进行下一次匹配，检查其后是否有字典D中的单词。</p><p>我们首先将所有单词插入字典树，由于单词长度小于10，所以对于每个单词，我们最多比较10次就能知道该字串是否为字典D中的单词。每次匹配都要从字典树的根开始匹配。<br>我们设f[i]表示 “文章中第 i 位是否为可以被D理解的某个前缀的末尾”；如果 f[i] 为 1 ，那么说明[1, i]都可以被D理解，接下来只要再从 i+1 位开始尝试在字典树匹配单词即可。<br>这是存在性DP，状态转移很简单，在字典树查找单词时，若当前位置是某个单词的末尾，即End[ p ] = 1，那么f[ pos ] = 1（pos为当前字符位置），时间复杂度为O(10N)。</p><p><strong>优化</strong><br>在 查找/匹配 单词时，我习惯将其封装为一个函数search(char * s)，但是最差情况我们会调用1e6次该函数，虽然该函数内最多只比较10次，但是函数传参以及保护现场以及恢复等步骤还是会大大增加花费的时间。经过测试，写成函数调用形式在1e6数据下大概会比直接展开慢几十秒，当然还是可以通过一些步骤优化函数调用的。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],End[SZ], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> str[N],s[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">bool</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str)<span class="number">-1</span>, ans;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f); f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//printf("%d\n",len);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!f[i]) <span class="keyword">continue</span>;</span><br><span class="line">ans = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>,p = <span class="number">1</span>;j &lt;= len;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = str[j]-<span class="string">'a'</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line"><span class="keyword">if</span>(!p) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(End[p]) f[j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s); Insert(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'#'</span>; solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Secret-Message-秘密信息"><a href="#Secret-Message-秘密信息" class="headerlink" title="Secret Message 秘密信息"></a>Secret Message 秘密信息</h4><p><strong>题意描述</strong><br>原题来自：USACO 2008 Dec. Gold<br>贝茜正在领导奶牛们逃跑。为了联络，奶牛们互相发送秘密信息。信息是二进制的，共有 M 条。反间谍能力很强的约翰已经部分拦截了这些信息，知道了第 i 条二进制信息的前 bi 位。<br>他同时知道，奶牛使用 N 条密码。但是，他仅仅了解第 j 条密码的前 cj位。对于每条密码 j ，他想知道有多少截得的信息能够和它匹配。也就是说，有多少信息和这条密码有着相同的前缀。当然，这个前缀长度必须等于密码和那条信息长度的较小者。</p><p><strong>解题思路</strong><br>根据所给样例呢，可以更加明确题意。首先我们将M条信息看作01字符串，同理N条密码也看作01字符串，题意问的就是对于每个密码，有多少条信息可能和该密码匹配，如果一条信息 A 和密码 B 匹配，那么有 A 是 B 的前缀或 B 是 A 的前缀。<br>于是我们就只需要先把01数组转化为01字符串，再用trie统计即可，当然由于同一信息可能会重复出现，所以 End[p] 记录的是以 p 结尾的字串个数。<br>在本机与洛谷上都是可以AC的，复杂度大概O(5e5)，但是在一本通OJ就过不去，猜测可能是不支持关闭 scanf 同步流？待修改。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="built_in">string</span> str[N],s[N];</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">2</span>],End[SZ],tot = <span class="number">1</span>,tc[SZ];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = s.length(), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">tc[p]++;</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span></span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; s &lt;&lt; "-" &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">int</span> len = s.length(), p = <span class="number">1</span>,res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line"><span class="keyword">if</span>(!p) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(End[p] &amp;&amp; i != len<span class="number">-1</span>) res += End[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res + tc[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">cout</span> &lt;&lt; search(s[i]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("222.txt","w",stdout);</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,k;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>,x;j &lt;= k;j++) <span class="built_in">cin</span> &gt;&gt; x, str[i] += x+<span class="string">'0'</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; str[i] &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,k;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>,x;j &lt;= k;j++) <span class="built_in">cin</span> &gt;&gt; x, s[i] += x+<span class="string">'0'</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; s[i] &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="【SCOI2016】背单词"><a href="#【SCOI2016】背单词" class="headerlink" title="【SCOI2016】背单词*"></a>【SCOI2016】背单词*</h4><p><strong>题意简述</strong><br>Lweb 面对如山的英语单词，陷入了深深的沉思，「我怎么样才能快点学完，然后去玩三国杀呢？」。<br>这时候睿智的凤老师从远处飘来，他送给了 Lweb 一本计划册和一大缸泡椒，然后凤老师告诉 Lweb ，我知道你要学习的单词总共有 n 个，现在我们从上往下完成计划表，对于一个序号为 x 的单词（序号 1…x−1 都已经被填入）：</p><ul><li>如果存在一个单词是它的后缀，并且当前没有被填入表内，那他需要吃 n×n 颗泡椒才能学会；</li><li>当它的所有后缀都被填入表内的情况下，如果在 1…x−1 的位置上的单词都不是它的后缀，那么他吃 x 颗泡椒就能记住它；</li><li>当它的所有后缀都被填入表内的情况下，如果 1…x−1 的位置上存在是它后缀的单词，所有是它后缀的单词中，序号最大为 y，那么你只要吃 x−y 颗泡椒就能把它记住。</li></ul><p>Lweb 是一个吃到辣辣的东西会暴走的奇怪小朋友，所以请你帮助 Lweb，寻找一种最优的填写单词方案，使得他记住这  n 个单词的情况下，吃最少的泡椒。</p><p><strong>解题思路</strong><br>首先把所有字符串反转，那么后缀就变成前缀了，就可以用trie维护。<br>刚开始我是想记录每个字符串的前缀个数，然后根据个数从小到大分配编号，但显然不行。<br>正解是将所有字符串构成一棵树，一个节点的父亲就是它的前缀，而没有前缀的字符串父亲为 0 号节点。我们可以利用 trie中的 search 时填边建树。<br>这样我们就有一棵有向树了，假设我们给节点 x 分配的序号是 f[x] ，那么显然 ans += f[x] - f[par[x] ]，其中 par[x] 代表 x 的父亲节点。所以我们需要让每个节点和它父亲节点的编号相差尽量小，那么自然是优先给节点数少的子树分配编号咯，所以对于每个节点 x ，我们选择节点最小的一棵子树，为它们分配编号。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">6e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> tc[N];<span class="comment">//记录后缀个数</span></span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],End[SZ], tot = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> par[N], head[N], ver[N], nex[N],tot2 = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot2] = y, nex[tot2] = head[x], head[x] = tot2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">int</span> len = s.length(), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p] = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">int</span> len = s.length(), p = <span class="number">1</span> ,res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line"><span class="keyword">if</span>(End[p] &amp;&amp; i != len<span class="number">-1</span>) par[id] = End[p];</span><br><span class="line">&#125;</span><br><span class="line">addEdge(par[id],id);<span class="comment">//顺便建树啦 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> str[N];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> num[N];<span class="comment">//记录子树x的节点个数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i != <span class="number">-1</span>;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line">num[x] += dfs(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num[x]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">priority_queue&lt; pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="keyword">int</span> f[N]; <span class="comment">//记录x编号 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">ans += cnt - f[par[x]]; f[x] = cnt; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i != <span class="number">-1</span>;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line">q.push(make_pair(-num[y],y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> nnex[q.size()],tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> y = q.top().second;q.pop();</span><br><span class="line">nnex[tt++] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tt;i++) cnt++, calc(nnex[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i],i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) search(str[i],i);</span><br><span class="line">num[<span class="number">0</span>] = dfs(<span class="number">0</span>); calc(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; str[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) reverse(str[i].begin(),str[i].end());</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="The-xor-longest-Path"><a href="#The-xor-longest-Path" class="headerlink" title="The xor-longest Path*"></a>The xor-longest Path*</h4><p><strong>题意简述</strong><br>原题来自：POJ 3764<br>给定一棵 n 个点的带权树，求树上最长的异或和路径。</p><p><strong>解题思路</strong><br>设 d[x] 表示 x 到根节点的路径异或和，那么显然由于异或的特性，x^y^x = y，我们任选两个点 x 和 y ，那么d[x] ^ d[y]就是 x 和 y 之间的路径异或和，因为从LCA(x , y)到根节点的路径都被抵消了。<br>所以原问题就成了从 d[1,n] 中选两个数，使它们的异或和最大。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N],nex[N],edge[N],tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,d[N];<span class="comment">//d[x]:x到根节点的路径异或和 </span></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y, nex[tot] = head[x];</span><br><span class="line">edge[tot] = z, head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//printf("%d %d %d\n",x,y,z);</span></span><br><span class="line">d[y] = d[x]^z;</span><br><span class="line">dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">32</span>*N;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">2</span>], tot2 = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>,p = <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot2;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回x与集合中异或和最大的 结果*/</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>,p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][!ch]) p = trie[p][!ch],res |= <span class="number">1</span>&lt;&lt;i;</span><br><span class="line"><span class="keyword">else</span> p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/* 计算并输出答案 */</span></span><br><span class="line">dfs(<span class="number">1</span>); <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(d[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) ans = max(ans,search(d[i]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt; n;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt(); z = getInt();</span><br><span class="line">addEdge(x,y,z); addEdge(y,x,z);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://ybt.ssoier.cn:8088/index.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测试地址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;Phone-List&quot;&gt;&lt;a href=&quot;#Phone-List&quot; class
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Trie" scheme="http://valenshi.top/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法练习题集</title>
    <link href="http://valenshi.top/2019/09/29/kmp-problems/"/>
    <id>http://valenshi.top/2019/09/29/kmp-problems/</id>
    <published>2019-09-29T05:54:36.000Z</published>
    <updated>2019-09-29T06:02:06.919Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/index.php" target="_blank" rel="noopener">测试地址</a></p><h4 id="剪花布条"><a href="#剪花布条" class="headerlink" title="剪花布条"></a>剪花布条</h4><p><strong>题意简述</strong><br>原题来自：HDU 2087<br>一块花布条，里面有些图案，另有一块直接可用的小饰条，里面也有一些图案。对于给定的花布条和小饰条，计算一下能从花布条中尽可能剪出几块小饰条来呢？</p><p><strong>解题思路</strong><br>就是普通的kmp算法，只不过这里的两个模式串不能重叠，我们基于贪心策略遇到一个选一个即可。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> f[N],nex[N];</span><br><span class="line"><span class="keyword">char</span> S[N],T[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getF</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(s)<span class="number">-1</span>, m = <span class="built_in">strlen</span>(t)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; (j == m || s[i] != t[j+<span class="number">1</span>])) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == t[j+<span class="number">1</span>]) j++;</span><br><span class="line">f[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">getNex(T);</span><br><span class="line">getF(S,T);</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(S)<span class="number">-1</span>, m = <span class="built_in">strlen</span>(T)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt; r &amp;&amp; f[i] == m) ans++ ,r = i+m<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,S+<span class="number">1</span>) &amp;&amp; S[<span class="number">1</span>] != <span class="string">'#'</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,T+<span class="number">1</span>); S[<span class="number">0</span>] = T[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Power-Strings"><a href="#Power-Strings" class="headerlink" title="Power Strings"></a>Power Strings</h4><p>在之前的字符串与Hash题集中做过，而且刚过去不久，不整理了。</p><h4 id="Radio-Transmission"><a href="#Radio-Transmission" class="headerlink" title="Radio Transmission"></a>Radio Transmission</h4><p><strong>题意简述</strong><br>给你一个字符串，它是由某个字符串不断自我连接形成的。但是这个字符串是不确定的，现在只想知道它的最短长度是多少。</p><p><strong>解题思路</strong><br>求最短循环节，给定的字符串可能是由循环节循环构成的字串的一个子串，所以就直接用求最短循环节就可以了，省去用字符串hash判断该串是否满足了。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n,nex[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">getNex(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n - nex[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="OKR-Periods-of-Words"><a href="#OKR-Periods-of-Words" class="headerlink" title="OKR-Periods of Words"></a>OKR-Periods of Words</h4><p><strong>题意简述</strong></p><p>原题来自：POI 2006<br>串是有限个小写字符的序列，特别的，一个空序列也可以是一个串。一个串 P 是串 A 的前缀，当且仅当存在串 B，使得 A=PB。如果P≠A并且 P 不是一个空串，那么我们说 P 是 A 的一个 proper 前缀。<br>定义 Q 是 A 的周期，当且仅当 Q 是 A 的一个 proper 前缀并且 A 是 QQ 的前缀（不一定要是 proper 前缀）。比如串 abab 和 ababab 都是串 abababa 的周期。串 A 的最大周期就是它最长的一个周期或者是一个空串（当 A 没有周期的时候），比如说，ababab 的最大周期是 abab。串 abc 的最大周期是空串。<br>给出一个串，求出它所有前缀的最大周期长度之和。</p><p><strong>解题思路</strong><br>题意有一些绕，但是还好给的是中文题面，尚可理解。就是说P是A的一个真子串，且是A的前缀，那么P就是A的proper前缀。若Q是A的proper前缀，且A是QQ（两个Q拼接在一起）的前缀（前缀不必要是真子串），那么Q就是A的周期。<br>现在要求的是A的 所有前缀的 最长周期的长度之和。</p><p>如果要是求最短周期的长度，那么直接就是求最短循环节，跑一遍nex就解决了；现在要求最长周期的长度，相当于求最长的循环节（该循环节不能等于原串！否则就不是proper前缀了），那么就不断的令 j = nex[j]，找到非零的最小 nex[j] （将nex数组看作father数组，一棵father树），那么最长循环节就是 i - j 了。</p><p>这样会超时，因为我们每次令j = nex[j]相当于从叶子节点走到根节点，最坏情况是O(N)才能找到最小的非零 nex[j]，总时间复杂度就是O(N^2)。</p><p><strong>优化</strong><br>我们令 f[j] 表示根到 j 路径上最小非零的值。（我们把nex数组看作一棵树！！！）<br>那么对于任意的nex[p]，若nex[p] != 0，那么最长周期就是 p - f[nex[p] ]。<br>我们在求nex数组时顺便更新 f 数组，和记忆化类似，思路不难理解。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n,nex[N],f[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s)<span class="number">-1</span>; f[<span class="number">0</span>] = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line"><span class="keyword">if</span>(j) f[j] = min(j,f[nex[j]]);</span><br><span class="line"><span class="comment">//printf("%d %d\n",j,f[j]);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">getNex(str);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex[i]) ans += i - f[nex[i]];</span><br><span class="line"><span class="comment">//printf("%d %c\n",ans,str[i]);</span></span><br><span class="line"><span class="comment">//printf("%d %d\n",nex[i],f[i]);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="似乎在梦中见过的样子"><a href="#似乎在梦中见过的样子" class="headerlink" title="似乎在梦中见过的样子"></a>似乎在梦中见过的样子</h4><p><strong>题意简述</strong><br>原题来自：2014 年湖北省队互测 Week2<br>「Madoka，不要相信 QB！」伴随着 Homura 的失望地喊叫，Madoka 与 QB 签订了契约。<br>这是 Modoka 的一个噩梦，也同时是上个轮回中所发生的事。为了使这一次 Madoka 不再与 QB 签订契约，Homura 决定在刚到学校的第一天就解决 QB。然而，QB 也是有许多替身的（但在第八话中的剧情显示它也有可能是无限重生的），不过，意志坚定的 Homura 是不会放弃的——她决定消灭所有可能是 QB 的东西。现在，她已感受到附近的状态，并且把它转化为一个长度为 n 的字符串交给了学 OI 的你。<br>现在你从她的话中知道，所有形似于 A+B+A 的字串都是 QB 或它的替身，且 ∣A∣≥k,∣B∣≥1（位置不同其他性质相同的子串算不同子串，位置相同但拆分不同的子串算同一子串），然后你必须尽快告诉 Homura 这个答案——QB 以及它的替身的数量。<br>注：对于一个字符串 S，∣S∣ 表示 S 的长度。</p><p><strong>解题思路</strong><br>这题需要对照样例来理解题意，经过分析后，发现题意是如果有一个子串满足ABA形式，其中 |A|&gt;=k 且 B 不是空串，那么该子串就是QB大魔王。现在问有多少个这样的子串。</p><p>首先看思路，对于一个字符串(s[1,n])，我们通过求它的nex数组，如果nex[n] &gt;= k 并且 nex[n] 小于 n/2，那么该串就是QB；如果nex[n] &gt;= n/2，那么nex[ nex[n] ] ，一直到根节点的路径上，只要有一个nex大于k且小于n/2，该串就也是QB。</p><p>综上所述，我们对于一个下标为[1, p]的字符串，需要找到nex[p]到根节点（将nex数组看作一棵树）路径上大于等于 k 的最小 nex值（贪心思想）。我们用 f 数组来存放该值。之所以用 f 数组存放，是为了防止最坏情况O(N^2)遍历。</p><p>所以我们对原字符串 S 的每一个后缀都进行上述操作，时间复杂度共O(N^2)，勉强过。但是常数稍微大一些就过不了了，所以统计答案也要在求 nex 和更新 f 数组时顺便累加，如果觉得这样太怂了，还可以进行别的优化，不过我懒得改了。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">15000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> nex[N],k, f[N], ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//f[i]为nex[i]到根中,大于k的最小的一个 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s)<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex); f[<span class="number">0</span>] = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line"><span class="keyword">if</span>(j &lt; k) f[j] = INF; </span><br><span class="line"><span class="keyword">else</span> f[j] = min(j,f[nex[j]]);</span><br><span class="line"><span class="keyword">if</span>(f[j]&lt;&lt;<span class="number">1</span> &lt; i) ans++;</span><br><span class="line"><span class="comment">//printf("%d %d %d %d\n",i,j,f[j],nex[j]);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(str)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">getNex(str+i<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Censoring"><a href="#Censoring" class="headerlink" title="Censoring"></a>Censoring</h4><p>这个我一看就知道KMP很难写，应该用自动机，所以放在自动机专题整理，另外吐槽一下书上的翻译是谁写的，太敷衍了吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://ybt.ssoier.cn:8088/index.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测试地址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;剪花布条&quot;&gt;&lt;a href=&quot;#剪花布条&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="KMP" scheme="http://valenshi.top/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>哈希与哈希表</title>
    <link href="http://valenshi.top/2019/09/28/hash/"/>
    <id>http://valenshi.top/2019/09/28/hash/</id>
    <published>2019-09-28T10:40:00.000Z</published>
    <updated>2019-09-28T10:42:17.956Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>哈希算法是通过一个哈希函数 H，将一种数据（字符串、大数等）转化为能够用变量表示或者能直接作为数组下标的数，通过哈希函数转化得到的数值我们成为哈希值。通过哈希值可以实现快速查找和匹配。本文主要介绍两种哈希算法的应用：字符串 Hash 和哈希表。</p><h4 id="字符串Hash"><a href="#字符串Hash" class="headerlink" title="字符串Hash"></a>字符串Hash</h4><p>字符串Hash有几种不同的用途，但是基于同一个原理，就是通过hash值匹配。<br>首先就是模式串匹配问题，n = |S| , m = |T| ，可以通过维护原串中所有长度为 m 的子串的哈希值，实现在O(1)时间内转移，并在O(1)时间内与 T 串的 hash值判等，若相等则有可能匹配成功。<br>大部分模式串匹配问题是用KMP求解，但是如果要是从主串中每次选出两个子串判断是否匹配的问题，还是需要用字符串 Hash 求解。</p><p><strong>具体流程</strong><br>我们设计的哈希函数 H 应当能在O(1)时间内实现相邻子串间的转移，或在预处理后，对不同的子串应该能在O(1)时间内求出其哈希值；这里用到叫做 滚动哈希 的优化技巧。</p><p>我们选取两个合适的互质的常数 b 和 h(b &lt; h)，假设字符串 $C = c_1c_2…c_m$，那么我们定义函数：$H(C) = (c_1b^{m-1} + c_2b^{m-2} + … + c_mb^0)\:mod\:h$。</p><p>这里的b是基数，相当于把字符串看作是 b 进制数。<br>这一过程是递推计算的，设H(C , k+1)是前 k 个字符构成的字符串的哈希值，则（不考虑取模）：$H(C , k+1) = H(C, k) * b + c_{k+1}$。</p><p>如果我们要<strong>求 C 中从 k 出发长度为 m 的子串的哈希值</strong>，那么$hsh = H(C , k+m) - H(C, k) * b^m$，hsh即为所求。</p><p><strong>预处理</strong></p><p>我们通过预处理求出所有C[a1, k]（k &lt;= n）的哈希值并存储在hash数组中（hash[i] = H(C,i) ），并预处理 base 数组（base[i] = $b^i$），那么我们就可以在O(1)时间内求出任意一个子串的哈希值。</p><p>在实现算法时，我们通常利用32位或者64位无符号整数计算哈希值，并取 $h = 2^{32}$ 或 $h = 2^{64}$，通过自然溢出省去取模运算。通常 b 取131 或 13331时效果较好。</p><p><strong>代码实现</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bse[i] = b^i , hsh[i] = H(str, i) */</span></span><br><span class="line">bse[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//bse和hsh都是unsigned long long </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    hsh[i] = hsh[i<span class="number">-1</span>]*b + str[i]-<span class="string">'a'</span>;</span><br><span class="line">    bse[i] = bse[i<span class="number">-1</span>]*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正确性证明</strong><br>上述做法可以保证相同的字符串所产生的哈希值一定是相同的，但是不同的字符串所产生的哈希值一定是不同的吗？<br>并不一定，但是冲突的几率很小，我们通常认为算法竞赛不会出现不同字符串哈希值冲突的情况。实际上根据生日悖论，对于哈希值在[0 , n)内均匀分布的哈希函数，出现不同字符串哈希值相等的期望步数是 $O(\sqrt N)$，可以作为一个参考。<br>更进一步的，我们还可以使用 <strong>“双哈希”</strong> 降低冲突的概率，即取用不同的模数，把不同的模数算出的哈希值记下来，只有几个哈希值都一样，才判定字符串匹配。我们通常用双哈希就可以将冲突的概率降到很低，如果分别取 h = 1e9+7 和 h = 1e9+9，就几乎不可能发生冲突，因为它们是一对“孪生素数”。</p><h4 id="哈希表与哈希函数"><a href="#哈希表与哈希函数" class="headerlink" title="哈希表与哈希函数"></a>哈希表与哈希函数</h4><p>哈希表是一种高效的数据结构，查找时间效率是常数时间，同时也很容易实现，需要付出的代价是消耗内存，但在如今这点内存已不成问题。</p><p><strong>问题模型</strong><br>给定 n 个数，这些数可能很大，判断每个数在之前有无出现过，出现了几次？</p><p><strong>算法流程</strong><br>这里具体分为三步：构造哈希函数 H()；将元素映射到哈希表；解决冲突。<br>首先要解决存储问题，我们先用线性表，即一维数组来存放元素。对于每个元素val，key = H(val)（这里的 key 是小于 1e7 的，可以当作数组的下标），于是我们就将val存放在数组下标为 key 的位置上。</p><p>而不同的元素它们key值是不同的（理想情况），相同的元素key值一定是相同的（任何情况），于是我们就可以通过O(1)时间的H()转化，读取数组内对应位置上的元素。</p><p>为了减少冲突呢，我们必须构造一个好的哈希函数H，这在后面会单独介绍常用的构造方法。但是不管多么优秀的哈希函数，都不可避免存在冲突，因此我们还需要有解决冲突的对策。我们想到可以用链表来解决冲突，即该一维表的每一个位置都是一条链表，具有相同哈希值的元素都放在同一条链上，当查找时只需要遍历这条链即可。这就叫哈希（链）表。</p><h5 id="哈希函数的构造"><a href="#哈希函数的构造" class="headerlink" title="哈希函数的构造"></a>哈希函数的构造</h5><p>哈希函数是决定哈希表查找效率的关键，只有哈希值分配的足够均匀时，单词查找的复杂度才会尽量小。以下介绍几种效果好的、容易实现的哈希函数。<br><strong>（1）基数转换法</strong><br>基数转换法就是开头的字符串Hash所采用的转换方法：将 val 值看作另一种进制数，然后再把它转化成对应的十进制数，再用除余法对其取余。一般取大于10的数作为转换的基数，并且两个基数是互质的。一般来说，取 131 或 13331较好。</p><p>如 val = 236075 原本是十进制数，现在将它看作十三进制数$(236075) _ {13}$然后再将它转换为十进制数。<br>$(236075)_ {13} = 2 <em> 13^5 + 3 </em> 13^4 + 6 <em> 13^3 + 7 </em> 13 + 5 = (841547) _ {10}$</p><p><strong>（2）除余法</strong><br>选择一个适当的正整数 b，用其对 b 取模的余数作为哈希值，即：H(val) = val mod b，这个方法应用的最多，并且多数情况下性价比也是最高的。关键在于 b 的选取，一般选 b 是数组下标能存储得下并且尽量大的质数（一般根据空间取1e6左右的质数）。选质数是因为 通常b的约数越多，冲突的几率就越大。</p><p><strong>（3）乘积取整法</strong><br>我们用值 val 乘以一个在(0,1)中的实数 A（最好是无理数，$(\sqrt 5 - 1)/2$是一个实际效果很好的数），得到一个(0 , k)之间实数；取其小数部分，乘以哈希表的大小 M 再向下取整，即得 val 在Hash表中的位置。函数表达式可以写成：H(val) = { M( val * A mod 1 ) }。</p><h5 id="散列表模板"><a href="#散列表模板" class="headerlink" title="散列表模板"></a>散列表模板</h5><p>例题：门票(tickets)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">2181271</span>; </span><br><span class="line"><span class="keyword">int</span> nex[N],num[N],head[N],tot = <span class="number">1</span>;<span class="comment">// 用邻接表方式实现哈希表 </span></span><br><span class="line"><span class="keyword">int</span> top , stk[N];<span class="comment">//数组模拟堆栈,用于哈希表的初始化 </span></span><br><span class="line">ll a,b,c;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">tot = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span>(top) head[stk[top--]] = <span class="number">0</span>;<span class="comment">//只清空用了的表,节省时间 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将x插入哈希表*/</span></span><br><span class="line"><span class="keyword">int</span> h = x % P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[h] ;i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i] == x) <span class="keyword">return</span>; <span class="comment">//相同的值已经存放过了 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(!head[h]) stk[++top] = h; <span class="comment">//第一次出现的哈希值入栈</span></span><br><span class="line"><span class="comment">/* 邻接表添加元素基本套路 */</span></span><br><span class="line">nex[++tot] = head[h]; head[h] = tot; num[tot] = x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ask</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 返回 x 是否存在*/</span></span><br><span class="line"><span class="keyword">int</span> h = x%P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[h];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i] == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll x = <span class="number">1</span>; Insert(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">2e6</span>;i++)&#123;</span><br><span class="line">x = (x*a + x%b)%c;</span><br><span class="line"><span class="keyword">if</span>(ask(x)) <span class="keyword">return</span> i;</span><br><span class="line">Insert(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*多组样例要调用init()*/</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>董永建，信息学竞赛一本通提高版，福州：福建教育出版社，2018.6，63-69</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;哈希算法是通过一个哈希函数 H，将一种数据（字符串、大数等）转化为能够用变量表示或者能直接作为数组下标的数，通过哈希函数转化得到的数值我们成
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="hash" scheme="http://valenshi.top/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>字符串循环节问题</title>
    <link href="http://valenshi.top/2019/09/27/xhj/"/>
    <id>http://valenshi.top/2019/09/27/xhj/</id>
    <published>2019-09-27T05:22:29.000Z</published>
    <updated>2019-09-27T05:23:11.718Z</updated>
    
    <content type="html"><![CDATA[<p><strong>循环节与最短循环节：</strong><br>若某个字符串是由某个子串循环构成的，那么就称该子串为原串的循环节，长度最短的循环节就是最短循环节。<br>如abababab，abab和ab都是原串的循环节，而最短循环节是ab。</p><p><strong>结论：</strong><br>如果字符串 s 有个循环节 son，n = |s| , x = |son|，字符数组下标从1开始，那么：</p><ol><li>x 一定是 n 的约数。</li><li>那么s[1,n-x] = s[x, n] = son。</li></ol><p><strong>证明：</strong><br>结论1：如果 x 不是 n 的约数，那么自然 n 就不可能由 若干个 x 相加构成，即不满足 n = k * x ，其中 k 是正整数。<br>结论2：若想s[1 ,n-x] = s[x, n] ，必须s[1, x] = s[ x ,2x] = s[2x , 3x] = … = s[n-x , n]，刚好符合循环节定义，因此 结论2 成立。</p><h4 id="求单个字符串的最短循环节"><a href="#求单个字符串的最短循环节" class="headerlink" title="求单个字符串的最短循环节"></a>求单个字符串的最短循环节</h4><p><strong>例1：</strong> POJ 2406 Power Strings (KMP)<br><a href="http://poj.org/problem?id=2406" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong> 给定一个字符串 s ，求出它最多由某个子串 循环几次 构成。</p><p><strong>解题思路：</strong><br>首先 s 必须是由某个循环节循环若干次构成的，否则无解。题意让求最多循环几次构成，那么既然 s 的长度固定是 n，自然是循环节越短，那么循环次数越多了。<br>我们先求出KMP算法中的nex数组。<br><strong>结论3：</strong> 此时若 s 有解，那么最短循环节长度为 x = n - nex[n] 。</p><p><strong>证明：反证法</strong> </p><ol><li>首先根据结论2，因为 s[1,nex[n] ] = s[n - nex[n] , n]，所以必然存在长度为 x = n - nex[n]的循环节，问题就在于它是不是最短的。</li><li>假设存在循环节，长度为 y（y &lt; x） ，那么根据结论2，一定有： s[1, n-y] = s[y , n]；如此一来nex[n] = n-y &gt; n-x，这和nex数组定义矛盾，因此不存在y &lt; x。</li><li>综上所述，n - nex[n] 一定为最短循环节的长度。</li></ol><p>因此本题的答案就是 n/(n-nex[n])，若不能整除，则无解。</p><p><strong>代码示例：</strong> 见附录部分 code-1：Power Strings</p><h4 id="求任意子串的最短循环节"><a href="#求任意子串的最短循环节" class="headerlink" title="求任意子串的最短循环节"></a>求任意子串的最短循环节</h4><p><strong>例2：</strong> bzoj2795 Horrible Poem<br><a href="http://www.mfstem.org/contest/57/problem/F" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给出一个由小写英文字母组成的字符串 S，再给出 q 个询问，要求回答 S 某个子串的最短循环节长度。如果字符串 B 是字符串 A 的循环节，那么 A 可以由 B 重复若干次得到。</p><p><strong>解题思路：</strong><br>此题的 q 很大，我们不可能对每一个子串都O(n)求出 nex 数组再回答。我们利用 滚动哈希 ，在O(1)时间内利用 结论2 判断某个长度是否为循环节。<br>再根据结论1，可以得知循环节长度一定是子串长度 m 的约数，因此我们$O(\sqrt m)$分解约数，再用O(1)复杂度用hash判断，本题总复杂度就是 $O(q \sqrt m)$。</p><p>一般到这里就该结束了，我们利用了 结论1 和 结论2 大大减少了求循环节的时间。但是在本题还是不够，还需要优化。还能优化的地方就只有求约数的$O(\sqrt m)$复杂度了，我们可以通过质因数分解在$O(log_2^m)$时间内分解约数，于是最终复杂度就是 $O(q\:log_2^n)$，可以通过了。</p><p><strong>代码示例：</strong> 见附录部分code-2：Horrible Poem</p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p><strong>code-1：Power Strings</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> nex[N]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;str[i];i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; str[i] != str[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(str[i] == str[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算答案并输出*/</span></span><br><span class="line">getNex(str);</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(str)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(n%(n-nex[n])) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n/(n-nex[n]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>) &amp;&amp; str[<span class="number">1</span>] != <span class="string">'.'</span>)&#123;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'*'</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>code-2：Horrible Poem</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Q = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line">ull hsh[N],bse[N] , b = <span class="number">31</span>; <span class="comment">//采用无符号长整形,通过自然溢出省去取模 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*判断x是否为子串s[l,r]的最短循环节长度*/</span> </span><br><span class="line">ull h1 = hsh[r-x] - hsh[l<span class="number">-1</span>]*bse[r-x+<span class="number">1</span>-l];</span><br><span class="line">ull h2 = hsh[r] - hsh[l<span class="number">-1</span>+x]*bse[r-x+<span class="number">1</span>-l];</span><br><span class="line"><span class="keyword">return</span> h1 == h2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> v[N],primes[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPri</span><span class="params">()</span></span>&#123;<span class="comment">//线性筛 </span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i])&#123;</span><br><span class="line">primes[cnt++] = i;</span><br><span class="line">v[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cnt;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(primes[j] &gt; v[i] || primes[j]*i &gt; N)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">v[i*primes[j]] = primes[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*回答子串s[l,r]的最短循环节长度*/</span> </span><br><span class="line"><span class="keyword">int</span> len = r-l+<span class="number">1</span>, ans = len, d = len;</span><br><span class="line"><span class="keyword">while</span>(d != <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = v[d];</span><br><span class="line"><span class="keyword">while</span>(d%tmp == <span class="number">0</span> &amp;&amp; check(l,r,ans/tmp)) d /= tmp,ans /= tmp;</span><br><span class="line"><span class="keyword">while</span>(d%tmp == <span class="number">0</span>) d /= tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*预处理出hash数组,v数组*/</span></span><br><span class="line">getPri(); bse[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">hsh[i] = hsh[i<span class="number">-1</span>]*b + str[i]-<span class="string">'a'</span>;</span><br><span class="line">bse[i] = bse[i<span class="number">-1</span>]*b;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>) &#123; x=x*<span class="number">10</span>+c-<span class="string">'0'</span>; c=getchar(); &#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">n = read();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>); str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">q = read();</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,l,r;i &lt;= q;i++)&#123;</span><br><span class="line">l = read(); r = read();</span><br><span class="line">ask(l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;循环节与最短循环节：&lt;/strong&gt;&lt;br&gt;若某个字符串是由某个子串循环构成的，那么就称该子串为原串的循环节，长度最短的循环节就是最短循环节。&lt;br&gt;如abababab，abab和ab都是原串的循环节，而最短循环节是ab。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="KMP" scheme="http://valenshi.top/tags/KMP/"/>
    
      <category term="循环节" scheme="http://valenshi.top/tags/%E5%BE%AA%E7%8E%AF%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>字符串与哈希题集</title>
    <link href="http://valenshi.top/2019/09/26/hash-and-kmp/"/>
    <id>http://valenshi.top/2019/09/26/hash-and-kmp/</id>
    <published>2019-09-26T14:14:10.000Z</published>
    <updated>2019-09-28T10:07:02.709Z</updated>
    
    <content type="html"><![CDATA[<p>我校OJ：<a href="http://www.mfstem.org/contest/57/problems" target="_blank" rel="noopener">测试地址</a><br>图书配套OJ：<a href="http://ybt.ssoier.cn:8088/index.php" target="_blank" rel="noopener">测试地址</a></p><h4 id="A-Oulipo"><a href="#A-Oulipo" class="headerlink" title="A. Oulipo"></a>A. Oulipo</h4><p><strong>Description</strong><br>给出两个字符串s1,s2（只有大写字母），求s1在s2中出现多少次。例如：s1=”ABA”,s2=”ABAABA”,答案为2。</p><p><strong>解题思路：</strong><br>KMP算法的模板，也可以用拓展KMP解决。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> nex[N];<span class="comment">//nex[i] = T[i,n-1]与T[0,n-1]最长公共前缀 </span></span><br><span class="line"><span class="keyword">char</span> S[N],T[N]; <span class="comment">//S为目标串,T为模式串 </span></span><br><span class="line"><span class="keyword">int</span> extend[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算nex数组*/</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str) ,i = <span class="number">0</span>, j, p0 ;</span><br><span class="line">nex[<span class="number">0</span>] = len;</span><br><span class="line"><span class="keyword">while</span>(i+<span class="number">1</span> &lt; len &amp;&amp; str[i] == str[i+<span class="number">1</span>]) i++;</span><br><span class="line">nex[<span class="number">1</span>] = i; p0 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex[i-p0]+i &lt; nex[p0]+p0) nex[i] = nex[i-p0];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j = nex[p0]+p0-i;</span><br><span class="line"><span class="keyword">if</span>(j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i+j &lt; len &amp;&amp; str[j] == str[j+i]) j++;</span><br><span class="line">nex[i] = j; p0 = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exKMP</span><span class="params">(<span class="keyword">char</span>* str1,<span class="keyword">char</span> *str2)</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算str2与str1的所有后缀的最长公共前缀长度,存放在extend数组中*/</span> </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>,j,p0,l1 = <span class="built_in">strlen</span>(S), l2 = <span class="built_in">strlen</span>(T);</span><br><span class="line">getNex(str2);</span><br><span class="line"><span class="keyword">while</span>(i &lt; l1 &amp;&amp; i &lt; l2 &amp;&amp; str1[i] == str2[i]) i++;</span><br><span class="line">extend[<span class="number">0</span>] = i;p0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; l1;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex[i-p0]+i &lt; extend[p0]+p0) extend[i] = nex[i-p0];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">j = extend[p0]+p0-i;</span><br><span class="line"><span class="keyword">if</span>(j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i+j &lt; l1 &amp;&amp; j &lt; l2 &amp;&amp; str1[j+i] == str2[j]) j++;</span><br><span class="line">extend[i] = j; p0 = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算并输出答案*/</span></span><br><span class="line"><span class="keyword">int</span> l1 = <span class="built_in">strlen</span>(S), l2 = <span class="built_in">strlen</span>(T), ans = <span class="number">0</span>;</span><br><span class="line">exKMP(S,T); <span class="keyword">int</span> len = <span class="built_in">strlen</span>(T);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; l1;i++)</span><br><span class="line"><span class="keyword">if</span>(extend[i] == len) ans++;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,T,S);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="B-图书管理"><a href="#B-图书管理" class="headerlink" title="B. 图书管理"></a>B. 图书管理</h4><p><strong>Description</strong><br>图书管理是一件十分繁杂的工作，在一个图书馆中每天都会有许多新书加入。为了更方便的管理图书（以便于帮助想要借书的客人快速查找他们是否有他们所需要的书），我们需要设计一个图书查找系统。该系统需要支持 2 种操作：</p><ol><li>add(s) 表示新加入一本书名为 s 的图书。</li><li>find(s) 表示查询是否存在一本书名为 s 的图书。</li></ol><p><strong>解题思路：</strong><br>该题本意是用hash解决，但是我偷懒直接用map了。。。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span> ,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> tmp = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>;s[i];i++) tmp += s[i];</span><br><span class="line">mp[tmp] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> tmp = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>;s[i];i++) tmp += s[i];</span><br><span class="line"><span class="keyword">if</span>(mp.count(tmp)) <span class="built_in">cout</span> &lt;&lt; <span class="string">"yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"no"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">getline(<span class="built_in">cin</span>,str);</span><br><span class="line"><span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'a'</span>) add(str);</span><br><span class="line"><span class="keyword">else</span> Find(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="C-Power-Strings"><a href="#C-Power-Strings" class="headerlink" title="C. Power Strings"></a>C. Power Strings</h4><p><strong>Description</strong><br>给定若干个长度 ≤10^6的字符串，询问每个字符串最多是由多少个相同的子字符串重复连接而成的。如：ababab 则最多有 3 个 ab 连接而成。<br><strong>解题思路：</strong><br>本题是循环节问题，有个结论：若字符串 s 是由某个长度为 x 的子串循环构成，那么必定有s[1,n-x] = s[x, n]。而根据nex数组的定义，nex[n] 就是 s[x, n] 的长度n-x。<br>因此如果该题有解，则n % (n-nex[n])为0，答案就是n/(n-nex[n)。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> nex[N]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;str[i];i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; str[i] != str[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(str[i] == str[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算答案并输出*/</span></span><br><span class="line">getNex(str);</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(str)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(n%(n-nex[n])) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n/(n-nex[n]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>) &amp;&amp; str[<span class="number">1</span>] != <span class="string">'.'</span>)&#123;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'*'</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="D-Seek-the-Name-Seek-the-Fame"><a href="#D-Seek-the-Name-Seek-the-Fame" class="headerlink" title="D. Seek the Name, Seek the Fame"></a>D. Seek the Name, Seek the Fame</h4><p><strong>Description</strong><br>给定若干字符串（这些字符串总长 ≤4×10^5 ），在每个字符串中求出所有既是前缀又是后缀的子串长度。例如：ababcababababcabab，既是前缀又是后缀的：ab，abab，ababcabab，ababcababababcabab。</p><p><strong>解题思路：</strong><br>依然是利用KMP算法中的nex数组求解。首先该串本身是最长的“既是前缀又是后缀”的子串，下一个满足条件的子串是s[1,nex[n] ] ，下下个是s[1, nex[ nex[n] ] ]，… 。</p><p>道理很简单，就是想起来有点绕；如果存在一个长度为 x 的子串 son“既是前缀又是后缀”，那么有s[1,x] = s[n-x,n] = son，那么它的长度不还是不超过 nex[n] 吗？所以上述方法可以从大到小遍历所有可能的长度（不是所有子串！）。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> nex[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">getNex(str); <span class="keyword">int</span> n = <span class="built_in">strlen</span>(str)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>; ans[++cnt] = n;</span><br><span class="line"><span class="keyword">while</span>(nex[n])&#123;</span><br><span class="line">ans[++cnt] = nex[n];</span><br><span class="line">n = nex[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = cnt;i &gt; <span class="number">1</span>;i--) <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>))&#123;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="E-friends"><a href="#E-friends" class="headerlink" title="E. friends"></a>E. friends</h4><p><strong>Description</strong><br>有三个好朋友喜欢在一起玩游戏，A 君写下一个字符串 S，B 君将其复制一遍得到 T，C 君在 T 的任意位置（包括首尾）插入一个字符得到 U。现在你得到了 U，请你找出 S。</p><p><strong>解题思路：</strong><br>本题如果用nex或者hash求解，细节有点多，当然细心点应该是能写出来的。我的解题思路很简单，O(N)复杂度，主要基于如下基本推论：</p><ol><li>如果n为偶数，无解。</li><li>如果前n/2+1个字符通过删去一个，可以等同于后n/2个字符，则匹配成功。</li><li>如果后n/2+1个字符通过删去一个，可以等同于前n/2个字符，则匹配成功。</li><li>如果 2 和 3 都匹配成功，且两个得到的原串不同，则说明解不唯一。</li></ol><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N],tmp[N],s1[N],s2[N];</span><br><span class="line"><span class="keyword">int</span> n,nex[N],tot;</span><br><span class="line"><span class="keyword">char</span> ans1[N],ans2[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> *s1,<span class="keyword">char</span> *s2)</span></span>&#123;</span><br><span class="line">tot = <span class="number">0</span>; <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= n/<span class="number">2</span> &amp;&amp; j &lt;= n/<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(s1[i] != s2[j])&#123;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">flag = <span class="literal">true</span>; j++;</span><br><span class="line"><span class="keyword">if</span>(s1[i] != s2[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">tmp[tot++] = s1[i];</span><br><span class="line">i++ , j++;</span><br><span class="line">&#125;</span><br><span class="line">tmp[tot] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"NOT POSSIBLE"</span>); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n/<span class="number">2</span>;i++) s1[i] = str[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n/<span class="number">2</span>+<span class="number">1</span>;i++) s2[i] = str[i+n/<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> flag1,flag2;</span><br><span class="line">flag1 = check(s1,s2);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n/<span class="number">2</span>;i++) ans1[i] = tmp[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n/<span class="number">2</span>+<span class="number">1</span>;i++) s1[i] = str[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n/<span class="number">2</span>;i++) s2[i] = str[i+n/<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">flag2 = check(s2,s1);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n/<span class="number">2</span>;i++) ans2[i] = tmp[i];</span><br><span class="line"><span class="keyword">if</span>(flag1 &amp;&amp; flag2)&#123;</span><br><span class="line"><span class="keyword">bool</span> f = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n/<span class="number">2</span>;i++) </span><br><span class="line"><span class="keyword">if</span>(ans1[i] != ans2[i]) f = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!f)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"NOT UNIQUE"</span>); <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag1 || flag2)&#123;</span><br><span class="line"><span class="keyword">if</span>(flag1) <span class="built_in">puts</span>(ans1);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(ans2);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"NOT POSSIBLE"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%s"</span>,&amp;n,str+<span class="number">1</span>);</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'#'</span>; solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="F-A-Horrible-Poem"><a href="#F-A-Horrible-Poem" class="headerlink" title="F. A Horrible Poem"></a>F. A Horrible Poem</h4><p><strong>Description</strong><br>给出一个由小写英文字母组成的字符串 S，再给出 q 个询问，要求回答 S 某个子串的最短循环节。如果字符串 B 是字符串 A 的循环节，那么 A 可以由 B 重复若干次得到。</p><p><strong>解题思路：</strong><br>这个是最短循环节问题，另外本题卡常十分严格。为了快速求解，本题还用到了线性筛、滚动哈希优化等策略。</p><p>首先是基础的字符串循环节知识。如果字符串 s 是由某个子串循环得到，|s| = n，那么<br>循环节的长度一定是 len 的约数，包括最短循环节。因此一个策略就是对于 n 的所有约数，挨个判断是否为最短循环节的长度，而判断原理如下：</p><ul><li>如果字符串 s 的最短循环节长度为 x ，那么必然有 s[1, x] = s[n-x, n] 。</li></ul><p>我们可以通过滚动哈希技巧来在O(1)时间完成判断。那么现在主要花费的时间在于找寻 n 的约数上，一般做法$O(\sqrt n)$，于是这种做法总复杂度为$O(q \sqrt n)$。</p><p>但是这题卡常很严重，这样还是会超时。于是就要利用质因数分解定理在$O(log_2^n)$时间内完成约数分解，总时间复杂度为$O(q log_2^n)$。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Q = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line">ull hsh[N],bse[N] , b = <span class="number">31</span>; <span class="comment">//采用无符号长整形,通过自然溢出省去取模 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*判断x是否为子串s[l,r]的最短循环节长度*/</span> </span><br><span class="line">ull h1 = hsh[r-x] - hsh[l<span class="number">-1</span>]*bse[r-x+<span class="number">1</span>-l];</span><br><span class="line">ull h2 = hsh[r] - hsh[l<span class="number">-1</span>+x]*bse[r-x+<span class="number">1</span>-l];</span><br><span class="line"><span class="keyword">return</span> h1 == h2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> v[N],primes[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPri</span><span class="params">()</span></span>&#123;<span class="comment">//线性筛 </span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i])&#123;</span><br><span class="line">primes[cnt++] = i;</span><br><span class="line">v[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cnt;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(primes[j] &gt; v[i] || primes[j]*i &gt; N)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">v[i*primes[j]] = primes[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*回答子串s[l,r]的最短循环节长度*/</span> </span><br><span class="line"><span class="keyword">int</span> len = r-l+<span class="number">1</span>, ans = len, d = len;</span><br><span class="line"><span class="keyword">while</span>(d != <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = v[d];</span><br><span class="line"><span class="keyword">while</span>(d%tmp == <span class="number">0</span> &amp;&amp; check(l,r,ans/tmp)) d /= tmp,ans /= tmp;</span><br><span class="line"><span class="keyword">while</span>(d%tmp == <span class="number">0</span>) d /= tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*预处理出hash数组,v数组*/</span></span><br><span class="line">getPri(); bse[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">hsh[i] = hsh[i<span class="number">-1</span>]*b + str[i]-<span class="string">'a'</span>;</span><br><span class="line">bse[i] = bse[i<span class="number">-1</span>]*b;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>) &#123; x=x*<span class="number">10</span>+c-<span class="string">'0'</span>; c=getchar(); &#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">n = read();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>); str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">q = read();</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,l,r;i &lt;= q;i++)&#123;</span><br><span class="line">l = read(); r = read();</span><br><span class="line">ask(l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="G-Beads"><a href="#G-Beads" class="headerlink" title="G. Beads"></a>G. Beads</h4><p><strong>Description</strong><br>Zxl有一次决定制造一条项链，她以非常便宜的价格买了一长条鲜艳的珊瑚珠子，她现在也有一个机器，能把这条珠子切成很多块（子串），每块有k（k&gt;0）个珠子，如果这条珠子的长度不是k的倍数，最后一块小于k的就不要拉（nc真浪费），保证珠子的长度为正整数。 Zxl喜欢多样的项链，为她应该怎样选择数字k来尽可能得到更多的不同的子串感到好奇，子串都是可以反转的，换句话说，子串（1，2，3）和（3,2,1）是一样的。写一个程序，为Zxl决定最适合的k从而获得最多不同的子串。例如：这一串珠子是： (1,1,1,2,2,2,3,3,3,1,2,3,3,1,2,2,1,3,3,2,1)。<br>k=1的时候，我们得到3个不同的子串：(1),(2),(3)<br>k=2的时候，我们得到6个不同的子串： (1,1),(1,2),(2,2),(3,3),(3,1),(2,3)<br>k=3的时候，我们得到5个不同的子串：  (1,1,1),(2,2,2),(3,3,3),(1,2,3),(3,1,2)<br>k=4的时候，我们得到5个不同的子串： (1,1,1,2),(2,2,3,3),(3,1,2,3),(3,1,2,2),(1,3,3,2)</p><p><strong>解题思路：</strong><br>刚开始时间复杂度算错了，n + n/2 + n/3 + n/4 + … + 1是调和级数，时间复杂度并不高，因此两层循环加上 滚动哈希 O(1)的判断是可以很快通过的。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> col[N] , n;</span><br><span class="line">ull hsh[N],hsh2[N],bse[N] , B = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;ull,<span class="keyword">int</span>&gt; vis;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">int</span> tc , mx , k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">bse[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">hsh[i] = hsh[i<span class="number">-1</span>]*B+col[i], bse[i] = bse[i<span class="number">-1</span>]*B;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--) </span><br><span class="line">hsh2[i] = hsh2[i+<span class="number">1</span>]*B+col[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">vis.clear(); cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt;= n;j += i)&#123;</span><br><span class="line">ull h1 = hsh[j] - hsh[j-i]*bse[i];</span><br><span class="line">ull h2 = hsh2[j-i+<span class="number">1</span>] - hsh2[j+<span class="number">1</span>]*bse[i];</span><br><span class="line"><span class="keyword">if</span>(vis.count(h1*h2) == <span class="number">0</span>)&#123;</span><br><span class="line">vis[h1*h2] = <span class="number">1</span>; cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf("%llu %llu\n",h1,h2);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf("%d %d\n",cnt,mx);</span></span><br><span class="line"><span class="keyword">if</span>(cnt == mx) ans.push_back(i);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cnt &gt; mx) &#123;</span><br><span class="line">ans.clear(); ans.push_back(i); mx = cnt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,mx,ans.size());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ans.size();i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,col+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="H-Antisymmetry"><a href="#H-Antisymmetry" class="headerlink" title="H. Antisymmetry"></a>H. Antisymmetry</h4><p><strong>Description</strong><br>对于一个01字符串，如果将这个字符串0和1取反后，再将整个串反过来和原串一样，就称作“反对称”字符串。比如00001111和010101就是反对称的，1001就不是。<br>现在给出一个长度为N的01字符串，求它有多少个子串是反对称的。</p><p><strong>解题思路：</strong><br>01串的题目真是变化多端啊。要想解决本题首先要得出几个推论：</p><ol><li>“反对称”的串长度一定是偶数。</li><li>如果一个子串是“反对称”的，那么它一定关于中轴线，左右01对应（如0101）。</li><li>如果一个串是“反对称”的，那么和它共中轴线的子串也是“反对称”的。</li></ol><p>然后就发现和回文串的性质有些相似，仅有 2 点不同，就是回文串长度可以为奇，以及回文串是关于中轴对称而不是相反。</p><p>那么我们依然可以利用Manacher算法，只不过将判等 改为判“反”即可。当然也要用通配符“#”来填充，因为所有“反对称” 的串长度必须为偶，所以我们在“#”上进行计算，以此来保证长度为偶数。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N],s2[<span class="number">2</span>*N];</span><br><span class="line"><span class="keyword">int</span> n,len[<span class="number">2</span>*N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="string">'#'</span> &amp;&amp; b == <span class="string">'#'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="string">'1'</span> &amp;&amp; b == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="string">'0'</span> &amp;&amp; b == <span class="string">'1'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">s2[<span class="number">0</span>] = <span class="string">'$'</span>,s2[<span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">s2[i&lt;&lt;<span class="number">1</span>] = str[i<span class="number">-1</span>];</span><br><span class="line">s2[(i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">&#125;</span><br><span class="line">s2[n*<span class="number">2</span>+<span class="number">2</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span>, mid;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">2</span>*n+<span class="number">2</span>;i += <span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt; mx) len[i] = min(len[<span class="number">2</span>*mid-i],mx-i);</span><br><span class="line"><span class="keyword">else</span> len[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( check(s2[i-len[i]], s2[i+len[i]]) ) len[i]++;</span><br><span class="line"><span class="keyword">if</span>(len[i]+i &gt; mx)&#123;</span><br><span class="line">mx = len[i] + i;</span><br><span class="line">mid = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">2</span>*n+<span class="number">2</span>;i++) ans += len[i]&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str); </span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="I-门票-tickets"><a href="#I-门票-tickets" class="headerlink" title="I. 门票(tickets)"></a>I. 门票(tickets)</h4><p><strong>Description</strong><br>已知数列$a_n, a_0 = 1$, $a_{i+1} = (a_i * A + a_i \:mod \:B ) \:mod \:C$，请问给定A，B和C，该数列在第几项第一次出现重复？</p><p><strong>解题思路：</strong><br>map太慢了啊，我测试了读入输出，测试了乘法和取模，就是没有怀疑map，浪费很多时间。<br>手写hash函数，利用邻接表来消除冲突，如此一来快了很多。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">2181271</span>; </span><br><span class="line"><span class="keyword">int</span> nex[N],num[N],head[N],tot = <span class="number">1</span>;<span class="comment">// 用邻接表方式实现哈希表 </span></span><br><span class="line"><span class="keyword">int</span> top , stk[N];<span class="comment">//数组模拟堆栈,用于哈希表的初始化 </span></span><br><span class="line">ll a,b,c;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">tot = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span>(top) head[stk[top--]] = <span class="number">0</span>;<span class="comment">//只清空用了的表,节省时间 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将x插入哈希表*/</span></span><br><span class="line"><span class="keyword">int</span> h = x % P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[h] ;i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i] == x) <span class="keyword">return</span>; <span class="comment">//相同的值已经存放过了 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(!head[h]) stk[++top] = h; <span class="comment">//第一次出现的哈希值入栈</span></span><br><span class="line"><span class="comment">/* 邻接表添加元素基本套路 */</span></span><br><span class="line">nex[++tot] = head[h]; head[h] = tot; num[tot] = x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ask</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 返回 x 是否存在*/</span></span><br><span class="line"><span class="keyword">int</span> h = x%P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[h];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i] == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll x = <span class="number">1</span>; Insert(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">2e6</span>;i++)&#123;</span><br><span class="line">x = (x*a + x%b)%c;</span><br><span class="line"><span class="keyword">if</span>(ask(x)) <span class="keyword">return</span> i;</span><br><span class="line">Insert(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*多组样例要调用init()*/</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="J-收集雪花-snowflakes"><a href="#J-收集雪花-snowflakes" class="headerlink" title="J. 收集雪花(snowflakes)"></a>J. 收集雪花(snowflakes)</h4><p><strong>Description</strong><br>不同的雪花往往有不同的形状。在北方的同学想将雪花收集起来，作为礼物送给在南方的同学们。一共有 n 个时刻，给出每个时刻下落雪花的形状，用不同的整数表示不同的形状。在收集的过程中，同学们不希望有重复的雪花。你可以从任意  a 时刻开始，在 b 时刻停止。a 到 b 时刻中间的雪花也都将被收集。他们希望收集的雪花最多。</p><p><strong>解题思路：</strong><br>这个用hash有点难写，难在重置哈希表。我用的是离散化+双指针，只需要维护左边界即可。如果当前雪花第二次出现，那么知道它上一次出现位置是v[p] ，所以先用当前区间长度更新答案，再将左边界更新为 v[p] + 1。<br>正确性证明就不写了，很显然。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], n, v[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i),b[i] = a[i];</span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">int</span> tot = unique(a+<span class="number">1</span>,a+<span class="number">1</span>+n)-a<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,l = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> p = lower_bound(a+<span class="number">1</span>,a+tot+<span class="number">1</span>,b[i])-a;</span><br><span class="line"><span class="keyword">if</span>(v[p] &gt;= l)&#123;</span><br><span class="line">ans = max(ans,i-l);</span><br><span class="line">l = v[p]+<span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line">v[p] = i;</span><br><span class="line"><span class="keyword">if</span>(i == n) ans = max(ans,i-l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我校OJ：&lt;a href=&quot;http://www.mfstem.org/contest/57/problems&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测试地址&lt;/a&gt;&lt;br&gt;图书配套OJ：&lt;a href=&quot;http://ybt.ssoier.cn:
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="拓展KMP" scheme="http://valenshi.top/tags/%E6%8B%93%E5%B1%95KMP/"/>
    
      <category term="哈希" scheme="http://valenshi.top/tags/%E5%93%88%E5%B8%8C/"/>
    
      <category term="KMP" scheme="http://valenshi.top/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="http://valenshi.top/2019/09/26/kmp/"/>
    <id>http://valenshi.top/2019/09/26/kmp/</id>
    <published>2019-09-26T04:12:11.000Z</published>
    <updated>2019-09-26T04:14:09.394Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>KMP算法，又称模式匹配算法，能够在线性时间内判定字符串 T 是否为 S 的子串，并求出字符串 T 在 S 中各次出现的位置。<br>KMP算法比较晦涩难懂。本文对于思想介绍略简，侧重于实现。</p><h4 id="问题模型与算法思路"><a href="#问题模型与算法思路" class="headerlink" title="问题模型与算法思路"></a>问题模型与算法思路</h4><p><strong>问题模型：</strong> 给定两个字符串 S 和 T ，试求出 T 在 S 中第一次出现的位置。</p><p>上述问题模型是模式串匹配最基础的模型，即单模式串匹配问题，这类问题是KMP算法以及字符串Hash大展身手的题型。</p><p><strong>算法思路1：Hash</strong><br>设|S| = n , |T| = m。如果不考虑冲突，那么我们可以将 S 的所有长度为 m 的子串hash值都求出来，复杂度为O(N)。将这 n-m+1 个子串与T的hash值在O(1)的时间内一一比对，即可通过hash值是否相同来判断是否匹配成功。<br>但实际上如果n和m很大(1e6)，那么散列值冲突是不可避免的，此时需要二次判断或者通过其他方法（构造更好的散列函数）来在保证速度的情况下提升正确性。</p><p><strong>算法思路2：KMP</strong><br>设|S| = n , |T| = m。首先考虑一个朴素算法，那就是将字符串 S 中的每一个长度为m的子串都与 T 进行一次匹配，失配后再匹配下一个，复杂度O(NM)。<br>手动模拟一下可以发现，上述做法中指向字符串 S 的指针和 T 的指针都有回退$^{[1]}$，但实际上我们并不需要发生回退，KMP算法就是通过防止指针回退来提升朴素算法效率的。</p><p>假设我们 S[i] 和 T[j+1] 发生了失配，如果我们知道 “T 中以 j 为末尾的真子串” 和 T[1, j] 的最长公共前缀的长度（假设为len，len一定小于 j ），那么显然 T[1, len] = S[i-len+1, i]；于是此时的 j = len，接着匹配即可。我们用nex数组（见下文）来存放 T 对应位置的“len”。</p><p>详细的讲，<strong>KMP算法分为两步：</strong></p><ol><li>对字符串 T 进行自我“匹配”，求出一个数组 nex，其中 nex[i] 表示“ T 中以 i 结尾的非前缀子串”与“ T 的前缀”能够匹配的最大长度，即：<br>&emsp;&emsp;nex[i] = max{j}，其中j &lt; i 并且 T[i-j+1, i] = T[1 ,j]。</li><li>对字符串 T 与 S 进行匹配，求出一个数组 f ，其中 f[i] 表示“S 中以 i 结尾的子串”与“ T 的前缀”能够匹配的最长长度。即：<br>&emsp;&emsp;f[i] = max{j}，其中j &lt;= i并且 S[i-j+1, i] = T[1, j]</li></ol><p><em>[1] 指针回退：在朴素做法中，如果发生失配，则要将指向 S 串的指针回退到当前子串起始位置，并右移至下一个子串起始位置，同理指向 T 的指针也要回到起始位置。</em></p><h4 id="Next数组"><a href="#Next数组" class="headerlink" title="Next数组"></a>Next数组</h4><p>首先要明白什么是Next数组（以下简称nex数组）。<br>nex[i]表示“T 中以 i 结尾的非前缀子串”与“T 的前缀”能够匹配的最长长度，即：nex[i] = max{j}，其中j &lt; i 并且 T[i-j+1, i] = T[i, j]。</p><blockquote><p>跳过：nex数组起到什么辅助作用，为什么要用nex数组？</p></blockquote><p><strong>nex 数组的求法</strong></p><ol><li>初始化 nex[1] = j = 0，假设nex[1, i-1] 已求出，下面求nex[i]。</li><li>不断尝试拓展匹配长度 j，如果拓展失败（下一个字符不相等），令 j 变为nex[j]，直至 j 为0（应该从头开始匹配）。</li><li>如果能够拓展成功，匹配长度 j 就增加1。nex[i] 的值就是 j 。</li></ol><p><strong>代码块</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/*更新模式串s的nex数组*/</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="f-数组"><a href="#f-数组" class="headerlink" title="f 数组"></a>f 数组</h4><p>按照前面的定义， f[i] 表示“S 中以 i 结尾的子串”与“ T 的前缀”能够匹配的最长长度。可以发现 f 数组和 nex 数组定义是一致的，因此他们的求解过程也基本一致。</p><p><strong>代码块</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getF</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">const</span> <span class="keyword">char</span> *T)</span></span>&#123;</span><br><span class="line"><span class="comment">/*求解 f 数组,S是目标串,T是模式串*/</span> </span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(S),len2 = <span class="built_in">strlen</span>(T);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;i &lt; len1;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; (j == len2 || S[i] != T[j+<span class="number">1</span>])) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(S[i] == T[j+<span class="number">1</span>]) j++;</span><br><span class="line">f[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题讲解"><a href="#例题讲解" class="headerlink" title="例题讲解"></a>例题讲解</h4><p><a href="https://www.luogu.org/problem/P3375" target="_blank" rel="noopener">测试地址</a><br><strong>代码模板</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">KMP算法模板-ValenShi</span></span><br><span class="line"><span class="comment">最后修改：2019/9/26</span></span><br><span class="line"><span class="comment">使用说明：</span></span><br><span class="line"><span class="comment">1.字符串起始位置是1而不是0,修改可能会出错.</span></span><br><span class="line"><span class="comment">2.记得初始化nex与f数组</span></span><br><span class="line"><span class="comment">3.原串长度与模式串长度都在函数中用strlen更新,无需修改全局变量 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s1[N],s2[N];</span><br><span class="line"><span class="keyword">int</span> nex[N],f[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/*更新模式串s的nex数组*/</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getF</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">const</span> <span class="keyword">char</span> *T)</span></span>&#123;</span><br><span class="line"><span class="comment">/*求解 f 数组,S是目标串,T是模式串*/</span> </span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(S),len2 = <span class="built_in">strlen</span>(T);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;i &lt; len1;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; (j == len2 || S[i] != T[j+<span class="number">1</span>])) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(S[i] == T[j+<span class="number">1</span>]) j++;</span><br><span class="line">f[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*求解nex数组与f数组,并 按要求 输出答案*/</span></span><br><span class="line">getNex(s2);</span><br><span class="line">getF(s1,s2);</span><br><span class="line"><span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(s1)<span class="number">-1</span>,len2 = <span class="built_in">strlen</span>(s2)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len1;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(f[i] == len2) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i-len2+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len2;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,nex[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,s1+<span class="number">1</span>,s2+<span class="number">1</span>);</span><br><span class="line">s1[<span class="number">0</span>] = s2[<span class="number">0</span>] = <span class="string">'#'</span>;<span class="comment">//不然strlen函数无法使用 </span></span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>董永建，信息学竞赛一本通提高版，福州：福建教育出版社，2018.6，74-81</li><li>李煜东，算法竞赛进阶指南，郑州：河南电子音像出版社，2017.10，65-67</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;KMP算法，又称模式匹配算法，能够在线性时间内判定字符串 T 是否为 S 的子串，并求出字符串 T 在 S 中各次出现的位置。&lt;br&gt;KMP
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Fish eating fruits</title>
    <link href="http://valenshi.top/2019/09/22/fish-eating-fruit/"/>
    <id>http://valenshi.top/2019/09/22/fish-eating-fruit/</id>
    <published>2019-09-22T06:57:11.000Z</published>
    <updated>2019-09-22T07:00:18.062Z</updated>
    
    <content type="html"><![CDATA[<p><a href>测试地址</a><br><strong>题意简述：</strong><br>树上任意两点之间的路径按照模 3 为 012 分类，将两点间距离加和，乘 2 即为答案。 </p><p><strong>解题思路：</strong><br>可以采用树上dp解决，也可以点分治，这里先给出一种树上dp做法：<br><code>dp[i][k]</code> 表示距 i 模 3 为 k 的节点距离和。<br><code>tc[i][k]</code> 表示距 i 模 3 为 k 的节点数目。<br><code>ans[k]</code>  表示所有路径中模 3 为 k 的路径的总长度。<br>目标答案是<code>ans[k]</code> 。<br>初始状态 <code>tc[i][0] = 1</code> 。</p><p>如果每次只考虑所有经过根 x 的路径，并且路径上的一个端点在x的一个子树上，另一个端点在另一个子树上（其他所有情况都可以在x的祖先或者子节点被考虑到，所以这样可以包含所有情况）。<br>假设当前枚举到x的子节点y，之前遍历的子节点已经使得dp和tc数组更新完成，那么我们要计算的路径起点在y，终点在之前遍历过的所有子节点中。<br><strong>分类讨论答案贡献：</strong></p><ol><li>边 x-y 对答案的贡献：设 j，k属于{0,1,2}，x 到 y 的边权为 z ，那么z对答案的贡献为<code>tc[x][j] * tc[y][k] * z</code>。</li><li>终点是 y 的所有路径长度的贡献：<code>dp[y][k] * tc[x][j] * z</code>。</li><li>起点是 x 的所有路径长度的贡献：<code>dp[x][j] * tc[y][k] * z</code>。</li></ol><p><strong>于是状态转移方程：</strong><br><code>dp[x][(j+z)%3] += dp[y][j] + z * tc[y][j]</code><br><code>tc[x][(j+z)%3] += tc[y][j]</code></p><p>当然，在状态转移前也要更新ans数组。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N],ver[N],edge[N],nex[N];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll tc[N][<span class="number">4</span>], dp[N][<span class="number">4</span>], ans[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 利用dfs进行状态转移,x为当前子树根节点 */</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i != <span class="number">-1</span>;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;<span class="comment">//y是父节点则跳过 </span></span><br><span class="line">dfs(y,x);</span><br><span class="line"><span class="comment">/* 这里统计答案 */</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">3</span>;k++)&#123;</span><br><span class="line">ans[(j+k+z)%<span class="number">3</span>] += (dp[x][j]*tc[y][k]%P+dp[y][k]*tc[x][j]%P)%P;</span><br><span class="line">ans[(j+k+z)%<span class="number">3</span>] += z*tc[x][j]%P*tc[y][k]%P;</span><br><span class="line">ans[(j+k+z)%<span class="number">3</span>] %= P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在这里转移状态 */</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)&#123;</span><br><span class="line">dp[x][(j+z)%<span class="number">3</span>] = (dp[x][(j+z)%<span class="number">3</span>] + dp[y][j] + z*tc[y][j])%P;</span><br><span class="line">tc[x][(j+z)%<span class="number">3</span>] = (tc[x][(j+z)%<span class="number">3</span>] + tc[y][j])%P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line"><span class="built_in">memset</span>(tc,<span class="number">0</span>,<span class="keyword">sizeof</span> tc);</span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span> ans);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) tc[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 统计答案并输出 */</span> </span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,ans[i]*<span class="number">2</span>%P);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[<span class="number">2</span>]*<span class="number">2</span>%P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head); tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addEdge(x+<span class="number">1</span>,y+<span class="number">1</span>,z); addEdge(y+<span class="number">1</span>,x+<span class="number">1</span>,z);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href&gt;测试地址&lt;/a&gt;&lt;br&gt;&lt;strong&gt;题意简述：&lt;/strong&gt;&lt;br&gt;树上任意两点之间的路径按照模 3 为 012 分类，将两点间距离加和，乘 2 即为答案。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解题思路：&lt;/strong&gt;&lt;br&gt;可以采用树上dp解决，也
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树上DP" scheme="http://valenshi.top/tags/%E6%A0%91%E4%B8%8ADP/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces Round 586(Div1+Div2)</title>
    <link href="http://valenshi.top/2019/09/21/cf-586/"/>
    <id>http://valenshi.top/2019/09/21/cf-586/</id>
    <published>2019-09-21T07:11:48.000Z</published>
    <updated>2019-09-25T02:50:15.189Z</updated>
    
    <content type="html"><![CDATA[<h4 id="A-Cards"><a href="#A-Cards" class="headerlink" title="A. Cards"></a>A. Cards</h4><p><a href="https://codeforces.com/contest/1220/problem/A" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定一个长度为 n 的字符串，该字符串可以组合出来几个one和几个zero，每个字符只能用一次。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> nn;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,z,e,r,o;</span><br><span class="line">n = z = e = r = o = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= nn;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i] == <span class="string">'o'</span>) o++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'z'</span>) z++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'r'</span>) r++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'e'</span>) e++;</span><br><span class="line"><span class="keyword">else</span> n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> one,zero;</span><br><span class="line">one = min(n,min(o,e));</span><br><span class="line">n -= one, o -= one, e -= one;</span><br><span class="line">zero = min(o,min(e,min(z,r)));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= one;i++) <span class="built_in">printf</span>(<span class="string">"1 "</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= zero;i++) <span class="built_in">printf</span>(<span class="string">"0 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;nn);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="B-Multiplication-Table"><a href="#B-Multiplication-Table" class="headerlink" title="B. Multiplication Table"></a>B. Multiplication Table</h4><p><a href="https://codeforces.com/contest/1220/problem/B" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定一个n <em> n表格，其中$M_{i,j} = a_i </em> a_j$，现在有个坏蛋把序列a给扔了，同时把M_{i,i}都给扣走了，现在请你利用剩下的信息求出a序列。</p><p><strong>解题思路：</strong><br>不是高斯消元题，其实是个找规律题。如果我们能求出来$a_1$，那么我们就可以根据第一列求出所有答案。而我们又可以根据$a_1a_2 = x$ , $a_1a_3 = y$ , $a_2a_3 = z$来求出$a_1$，于是就可以在求出其他所有结果了。<br><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line">ll mat[N][N],ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">ans[<span class="number">1</span>] = mat[<span class="number">1</span>][<span class="number">2</span>]*mat[<span class="number">1</span>][<span class="number">3</span>]/mat[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">ans[<span class="number">1</span>] = (ll)<span class="built_in">sqrt</span>(ans[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">ans[i] = mat[<span class="number">1</span>][i]/ans[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">printf</span>(<span class="string">"%I64d "</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>,&amp;mat[i][j]);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-Substring-Game-in-the-Lesson"><a href="#C-Substring-Game-in-the-Lesson" class="headerlink" title="C. Substring Game in the Lesson"></a>C. Substring Game in the Lesson</h4><p><a href="https://codeforces.com/contest/1220/problem/C" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>Ann和Mike在玩游戏，有一个字符串s，初始时有l  = r = k ，每个人轮流操作：</p><ul><li>选择l’ &lt; l , r’ &lt; r，且s[l’,r’] 字典序小于 s[l,r]，然后令l = l’, r = r’。</li><li>若不能做任何操作，则失败。</li></ul><p>Ann先手，对于每个位置k，输出谁必胜。</p><p><strong>题意简述：</strong><br>简单的博弈论，首先必败态是“在 l 之前不存在l’ &lt; l ， 且s[l’ , r] 字典序小于 s[l ,r] ”，而若当前不是必败态，则一定可以使得下一个状态一定是必败态，于是只需要判断每个位置前面是否有字典序比其小的字符即可。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mi = (<span class="keyword">int</span>)str[<span class="number">0</span>],n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mi &lt; (<span class="keyword">int</span>)str[i]) vis[i] = <span class="number">1</span>;</span><br><span class="line">mi = min(mi,(<span class="keyword">int</span>)str[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line"><span class="keyword">if</span>(vis[i]) <span class="built_in">printf</span>(<span class="string">"Ann\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Mike"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="D-Alex-and-Julian"><a href="#D-Alex-and-Julian" class="headerlink" title="D. Alex and Julian"></a>D. Alex and Julian</h4><p><a href="https://codeforces.com/contest/1220/problem/D" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定一个正整数集合B，令全集Z(所有整数)内的元素作为无向图的顶点，对于图中内任意两点i 和 j，若abs(i - j)属于集合B，则 i 和 j 之间有一条无向边。现在请问最少删除B中几个顶点可以使得剩下的图是二分图。</p><p><strong>解题思路：</strong><br>不是二分图问题，只用到了“一张图是二分图，当且仅当图中不存在奇环”这一二分图判定定理。<br>至于为啥不能用二分图算法来解决呢，从问题规模就可以猜到，因为要构造图需要$O((1e18)^2)$，显然n的规模不允许这样做。</p><p>那么从数学角度考虑（找规律），若有节点0和节点a，那么0 到 a有边，若还存在节点2 <em> a ，那么a 和2 </em> a也有边，且2 <em> a与 0也有边，这就是奇环了（哪怕还有3 </em> a，也还是奇环+一个偶环），因此不能有2 <em> a，同理也不能有4 </em> a，因此若想保留a，那么2 <em> a，4 </em> a， 8 * a， … 都要删去。<br>但是这样做法复杂度过高，因为顶点集合是[1, 1e18]，挨个计算显然不现实，因此我们可以对集合B中每个元素b，B中有哪些元素可以和b一起被保留。</p><p>若a中有x个因数2，b中有y个因数2（x != y），那么a和b一定不能同时存在；假设c = lcm(a ,b)那么0 -&gt; a -&gt; 2 <em> a -&gt; … -&gt; c -&gt; … -&gt; 2 </em> b -&gt; b -&gt; 0一定可以构成一个奇环 ，因此a和b不能同时存在。所以若是x != y，则a和b不能同时存在（a和b都是集合B内元素）。</p><p>若是x = y，那么a和b可以同时存在，因为它们不存在a是b的倍数，或者b是a的倍数这种情况，也就不能删去0，因此若有环则一定是偶环。</p><p>综上所述，我们通过统计B集合中每个元素有多少个因子2即可判断最多同时存在多少个元素，即最少删去多少个元素。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="keyword">int</span> tc[N],num[N],n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ll tmp = a[i];</span><br><span class="line"><span class="keyword">while</span>(tmp &amp;&amp; tmp%<span class="number">2</span> == <span class="number">0</span>) tc[i]++,tmp/=<span class="number">2</span>;</span><br><span class="line">num[tc[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">64</span>;i++)</span><br><span class="line"><span class="keyword">if</span>(num[p] &lt; num[i]) p = i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n-num[p]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line"><span class="keyword">if</span>(tc[i] != p) <span class="built_in">printf</span>(<span class="string">"%I64d "</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="E-Tourism"><a href="#E-Tourism" class="headerlink" title="E. Tourism"></a>E. Tourism</h4><p><a href="https://codeforces.com/contest/1220/problem/E" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>一共有n个点和m条无向边，每个点有权值，同一条边不能<strong>连续经过</strong>两次；每个点的权值最多只能加一次；给出每个点的权值以及无向图的边，给出起点编号s，求出怎样才能走才能使得权值和最大。</p><p><strong>解题思路：</strong><br>很容易发现如果经过一个环，那么该环上所有点的权值都可以拿到，且可以从环上任意一点出环，于是我们就可以将一个环缩为一个点，将图中所有环都缩为点后，无向图就成了无根树。题目就成了求无根树上从s出发的最远路径。于是该方法需要Tarjan缩点+树上dp，同时需要注意叶子节点不能缩（一定不是环）。</p><p>另一种方法就是利用拓扑排序。我们可以通过画图等模拟发现，最终答案一定是一些环与从环上出发的一条最长链。<br>于是我们可以考虑如下算法：</p><ol><li>利用拓扑排序，每次都从叶子节点出发，将路径上的权值累加到环上的对应节点（另开数组存放）并终止，并标记路径上的所有点。</li><li>由于环上所有点可互相到达，因此将所有未被标记的点的权值累加（有可能好几个环，但是环与环之间的路径未被标记，并且可达），即为可获得的环上最大权值和。</li><li>找从环上某点出发的最长链，与上述结果相加即为最终答案。</li></ol><p>很显然上述算法是正确的，我们将答案分为了两部分：可互达的“连通环”以及“从环上出发的最长链”。又由于我们是从s出发的，上述算法我们是累加未被标记的节点，因此如果标记的时候遇到了s，那么就将结果累加到s的附加域并终止；最终累加时候因为从 s 出发的链未被标记，因此依然会被累加。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[M],ver[M],nex[M];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> deg[N];<span class="comment">//入度,初始值为0 </span></span><br><span class="line">ll w[N],cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; </span><br><span class="line">head[x] = tot; deg[y]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> n,m,s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line"><span class="keyword">if</span>(deg[i] == <span class="number">1</span> &amp;&amp; i != s) q.push(i);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">deg[x] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(deg[y] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">deg[y]--;</span><br><span class="line">cnt[y] = max(cnt[y],cnt[x]+w[x]);</span><br><span class="line"><span class="keyword">if</span>(deg[y] == <span class="number">1</span> &amp;&amp; y != s) q.push(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll s1 = <span class="number">0</span>,s2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(deg[i] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">s1 += w[i];</span><br><span class="line">s2 = max(s2,cnt[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,s1+s2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,w+i); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;A-Cards&quot;&gt;&lt;a href=&quot;#A-Cards&quot; class=&quot;headerlink&quot; title=&quot;A. Cards&quot;&gt;&lt;/a&gt;A. Cards&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1220/pro
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="博弈论" scheme="http://valenshi.top/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
      <category term="数论" scheme="http://valenshi.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="图论" scheme="http://valenshi.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="拓扑排序" scheme="http://valenshi.top/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>5 连续内存分配</title>
    <link href="http://valenshi.top/2019/09/20/os5/"/>
    <id>http://valenshi.top/2019/09/20/os5/</id>
    <published>2019-09-20T14:52:54.000Z</published>
    <updated>2019-09-23T12:16:26.853Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机体系结构和内存层次"><a href="#计算机体系结构和内存层次" class="headerlink" title="计算机体系结构和内存层次"></a>计算机体系结构和内存层次</h3><ul><li>计算机体系结构</li><li>内存层次</li><li>操作系统的内存管理方式</li></ul><h4 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h4><p>基本的分配和释放的管理要求。cpu高速缓存，存储管理单元（MMU），内存最小访问单位8bit；32位的意思是一次可以读写32位；高速缓存用来存放会重复使用的数据，用来提高效率；</p><h4 id="内存层次"><a href="#内存层次" class="headerlink" title="内存层次"></a>内存层次</h4><p>缓存速度最快，首先去缓存找数据，若未命中则去内存中找，若仍未命中则去外存（虚拟内存）中找，这三者速度差别很大。</p><h4 id="操作系统的内存管理"><a href="#操作系统的内存管理" class="headerlink" title="操作系统的内存管理"></a>操作系统的内存管理</h4><p>知识点：我们希望的理想状态。逻辑存储单元。<br><strong>存储管理要达到的效果：</strong></p><ul><li>抽象：逻辑地址空间</li><li>保护：独立地址空间</li><li>共享：访问相同内存</li><li>虚拟化：更大的地址空间</li></ul><h4 id="操作系统中采用的内存管理方式："><a href="#操作系统中采用的内存管理方式：" class="headerlink" title="操作系统中采用的内存管理方式："></a>操作系统中采用的内存管理方式：</h4><ul><li>重定位（relocation）</li><li>分段（segmentation）</li><li>分页（paging）</li><li>虚拟存储（目前多数系统，如Linux，采用按需页式虚拟存储）</li></ul><p><strong>实现高度依赖硬件：</strong></p><ul><li>与计算机存储架构紧耦合</li><li>MMU（内存管理单元）：处理CPU存储访问请求的硬件</li></ul><h3 id="地址空间和地址生成"><a href="#地址空间和地址生成" class="headerlink" title="地址空间和地址生成"></a>地址空间和地址生成</h3><h4 id="地址空间的定义"><a href="#地址空间的定义" class="headerlink" title="地址空间的定义"></a>地址空间的定义</h4><p>物理地址空间-硬件支持的地址空间（地址总线条数）。</p><ul><li>起始地址为0，知道$MAX_{sys}$</li></ul><p>逻辑地址空间-在CPU运行的进程看到的地址</p><ul><li>起始地址为0，直到$MAX_{prog}$</li></ul><p>地址是从哪里来的？</p><h4 id="逻辑地址生成"><a href="#逻辑地址生成" class="headerlink" title="逻辑地址生成"></a>逻辑地址生成</h4><p><img src="/2019/09/20/os5/1.png" alt="1"></p><p><center>图1：逻辑地址生成图示</center></p><h4 id="地址生成时机和限制"><a href="#地址生成时机和限制" class="headerlink" title="地址生成时机和限制"></a>地址生成时机和限制</h4><p>编译时：</p><ul><li>假设起始地址已知</li><li>如果起始地址改变，必须重新编译</li></ul><p>加载时：</p><ul><li>如编译时起始位置位置，编译器需生成可重定位的代码</li><li>加载时，生成绝对地址</li></ul><p>执行时：</p><ul><li>执行时代码可移动</li><li>需地址转换（映射）硬件支持</li></ul><h4 id="地址生成过程"><a href="#地址生成过程" class="headerlink" title="地址生成过程"></a>地址生成过程</h4><p>CPU：</p><ul><li>ALU：需要逻辑地址的内存内容</li><li>MMU：进行逻辑地址和物理地址的转换</li></ul><p>内存：</p><ul><li>发送物理地址的内容给CPU</li><li>或接受CPU数据到物理地址</li></ul><p>操作系统：</p><ul><li>建立逻辑地址LA和物理地址PA的映射</li></ul><h4 id="地址检查"><a href="#地址检查" class="headerlink" title="地址检查"></a>地址检查</h4><p>检查段的长度和偏移量是否为有效范围。</p><h3 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h3><h4 id="连续内存分配和内存碎片"><a href="#连续内存分配和内存碎片" class="headerlink" title="连续内存分配和内存碎片"></a>连续内存分配和内存碎片</h4><p><strong>连续内存分配：</strong> 给进程分配一块不小于指定大小的连续的物理内存。<br><strong>内存碎片：</strong> 空闲内存不能被利用。<br><strong>外部碎片：</strong> 分配单元之间的未被使用的内存。<br><strong>内部碎片：</strong> 分配单元内部的未被使用的内存，取决于分配单元大小是否要调整。</p><h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p><strong>动态内存分配：</strong></p><ul><li>当程序被加载可执行时，分配一个进程指定大小可变的分区（块，内存块）</li><li>分区的地址是连续的</li></ul><p><strong>操作系统需要维护的数据结构：</strong></p><ul><li>所有进程的已分配分区</li><li>空闲分区（Empty-blocks）</li></ul><p><strong>动态分区分配策略：</strong></p><ul><li>最先匹配</li><li>最优匹配</li><li>最差匹配</li></ul><h4 id="最先匹配（First-Fit-Allocation）策略"><a href="#最先匹配（First-Fit-Allocation）策略" class="headerlink" title="最先匹配（First Fit Allocation）策略"></a>最先匹配（First Fit Allocation）策略</h4><p>思路：分配n个字节时，使用第一个可用的空间比n大的空闲块。<br>原理&amp;实现：</p><ul><li>空闲分区列表按照地址顺序排序</li><li>分配过程中，搜索一个合适的分区</li><li>释放分区时，检查是否可与临近的空闲分区合并</li></ul><p>优点：</p><ul><li>简单</li><li>在高地址上有大块的空闲分区</li></ul><p>缺点：</p><ul><li>外部碎片多</li><li>分配大块时较慢</li></ul><h4 id="最佳匹配（Best-Fit-Allocation）策略"><a href="#最佳匹配（Best-Fit-Allocation）策略" class="headerlink" title="最佳匹配（Best Fit Allocation）策略"></a>最佳匹配（Best Fit Allocation）策略</h4><p>思路：分配n个字节时，查找并使用不小于n的最小空闲分区<br>原理&amp;实现：</p><ul><li>空闲分区列表按照大小排序</li><li>分配时，查找一个合适的分区</li><li>释放时，查找并合并临近的空闲分区（如果找到）</li></ul><p>优点： 大部分分配的尺寸较小时，效果很好</p><ul><li>可避免大的空闲分区被拆分</li><li>可减小外部碎片的大小</li><li>相对简单</li></ul><p>缺点：</p><ul><li>外部碎片</li><li>释放分区慢</li><li>容易产生很多无用的小碎片</li></ul><h4 id="最差匹配（Worst-Fit-Allocation）策略"><a href="#最差匹配（Worst-Fit-Allocation）策略" class="headerlink" title="最差匹配（Worst Fit Allocation）策略"></a>最差匹配（Worst Fit Allocation）策略</h4><p>思路：分配n字节，使用尺寸不小于n的最大空闲分区。<br>原理&amp;实现：</p><ul><li>空闲分区按从大到小排序</li><li>分配时，选最大的分区</li><li>释放时，检查是否可与临近的空闲分区合并，进行可能的合并，并调整空闲分区列表的顺序</li></ul><p>优点：</p><ul><li>中等大小的分配较多时，效果最好</li><li>避免出现太多的小碎片</li></ul><p>缺点：</p><ul><li>释放分区较慢</li><li>外部碎片</li><li>容易破坏大的空闲分区，因此后续难以分配大的分区</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;计算机体系结构和内存层次&quot;&gt;&lt;a href=&quot;#计算机体系结构和内存层次&quot; class=&quot;headerlink&quot; title=&quot;计算机体系结构和内存层次&quot;&gt;&lt;/a&gt;计算机体系结构和内存层次&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;计算机体系结构&lt;/li&gt;
&lt;li&gt;内存层次&lt;/l
      
    
    </summary>
    
      <category term="计算机操作系统" scheme="http://valenshi.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="内存分配" scheme="http://valenshi.top/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Dudu&#39;s maze 解题报告</title>
    <link href="http://valenshi.top/2019/09/15/dudu-maze/"/>
    <id>http://valenshi.top/2019/09/15/dudu-maze/</id>
    <published>2019-09-15T05:29:21.000Z</published>
    <updated>2019-09-15T05:30:57.412Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://nanti.jisuanke.com/t/41402" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>在一个无向图中，有 k 个怪物点，n-k个糖果点，每个糖果点有1个糖果，且可以移动到相邻的点，但是每个点的糖果只能拿一次（但是可以经过多次）。而每个怪物点没糖果，但是可以随机传送到相邻的点，只能传送一次（即只能进一次怪物房），请问最终拿到糖果的最优期望是多少？<br><strong>解题思路：</strong><br>dfs求连通块+染色，我现在还是不明白我单独染色为什么一直超时，无语了，就按照下面的代码写吧，用标记数组单独存放被染色的连通块糖果数，相当于记忆化。当然节点1所在的连通块糖果都能拿到，然后再选择走和1相连的且期望最大的怪物点即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[<span class="number">2</span>*N],nex[<span class="number">2</span>*N],tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,t,k;</span><br><span class="line"><span class="keyword">int</span> vis[N],mst[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y;nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> vm[N],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"><span class="keyword">int</span> tc[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="number">1</span>; ans++; tc[x]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i != <span class="number">-1</span>;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(mst[y])&#123;</span><br><span class="line">vm[++cnt] = y;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">dfs1(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num[col]) <span class="keyword">return</span> num[col];</span><br><span class="line"><span class="keyword">if</span>(vis[x] || mst[x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> res = <span class="number">1</span>; vis[x] = col;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i != <span class="number">-1</span>;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y] || mst[y]) <span class="keyword">continue</span>;</span><br><span class="line">res += dfs2(y,col);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">ans = <span class="number">0</span>; cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span> num);</span><br><span class="line">dfs1(<span class="number">1</span>); <span class="keyword">double</span> mx = <span class="number">0</span>; <span class="keyword">int</span> col = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++)&#123;</span><br><span class="line"><span class="keyword">double</span> pp = <span class="number">0</span>,ecnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = head[vm[i]] ;j != <span class="number">-1</span>;j = nex[j]) ecnt++;</span><br><span class="line"><span class="comment">//printf("ecnt: %f\n",ecnt);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = head[vm[i]] ;j != <span class="number">-1</span>;j = nex[j])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[j]; <span class="keyword">double</span> tmp;</span><br><span class="line"><span class="keyword">if</span>(vis[y]) tmp = num[vis[y]];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">tmp = dfs2(y,++col);</span><br><span class="line">num[col] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">pp += tmp;</span><br><span class="line"><span class="comment">//printf("%d %f\n",ver[j] ,tmp);</span></span><br><span class="line">&#125;</span><br><span class="line">pp /= ecnt;</span><br><span class="line"><span class="keyword">if</span>(mx - pp &lt; <span class="number">0</span>) mx = pp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.7f\n"</span>,mx+ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">t = getInt();</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">tot = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(mst,<span class="number">0</span>,<span class="keyword">sizeof</span> mst);</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">n = getInt(), m = getInt(),k = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">addEdge(x,y);addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= k;i++) x = getInt() , mst[x] = <span class="number">1</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://nanti.jisuanke.com/t/41402&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测试地址&lt;/a&gt;&lt;br&gt;&lt;strong&gt;题意简述：&lt;/strong&gt;&lt;br&gt;在一个无向图中，有 k 个怪物点，n-k个糖果
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="dfs连通块" scheme="http://valenshi.top/tags/dfs%E8%BF%9E%E9%80%9A%E5%9D%97/"/>
    
      <category term="染色" scheme="http://valenshi.top/tags/%E6%9F%93%E8%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>Educational Codeforces Round 72 解题报告</title>
    <link href="http://valenshi.top/2019/09/10/cf-r72/"/>
    <id>http://valenshi.top/2019/09/10/cf-r72/</id>
    <published>2019-09-10T13:36:28.000Z</published>
    <updated>2019-09-10T13:40:39.340Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1217" target="_blank" rel="noopener">题集链接</a></p><h4 id="A-Creating-a-Character"><a href="#A-Creating-a-Character" class="headerlink" title="A.Creating a Character"></a>A.Creating a Character</h4><p><strong>题意简述：</strong><br>有三个数a，b，c，将c分配在a和b上，使得a&gt;b，请问有多少种分配方案？两个方案不同，当且仅当它们对应的a或b不相等。</p><p><strong>解题思路：</strong><br>假设将c分配给a和b后使得a = b = res，那么显然若原始的a &gt; res，就说明b+c &lt; a，那么答案就是c+1（当然特判b+c&lt;a也行）；否则a &lt;= res，此时分配给a的值一定要大于res - a，所以共c - (res-a) = c-res + a 种不同方案。 </p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a,b,c,t,d;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a+c &lt;= b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = a+b+c&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a &gt; res) <span class="keyword">return</span> c+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> c-res+a; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="B-Zmei-Gorynich"><a href="#B-Zmei-Gorynich" class="headerlink" title="B.Zmei Gorynich"></a>B.Zmei Gorynich</h4><p><strong>题意简述：</strong><br>一条恶龙共 x 滴血，勇士有n件武器，每件武器有伤害值 d 和 副作用 h，表示着将会给恶龙造成 d 点伤害，之后会给恶龙回 h 点血。当某一时刻恶龙血量低于0时则会死亡，请问勇者最少砍多少次才能杀死恶龙？如果杀不死输出-1，一个武器可以重复使用。<br><strong>解题思路：</strong><br>如果当前有一个武器能杀死恶龙（d &gt;= x），那么就可以忽略他的副作用 h ，直接秒杀恶龙；否则我们就要选择一个d-h最大的来砍恶龙，所以我们最多用两把武器，一把用来消耗，一把用来终结恶龙。当无法秒杀恶龙，也无法消耗恶龙时，说明无法杀死恶龙。否则就可以通过计算最少需要消耗多少次来O(1)计算答案。</p><p>特别注意是否能一刀秒杀恶龙等特殊情况。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> t1,t2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//恶龙本来就死了</span></span><br><span class="line"><span class="keyword">if</span>(t1 &gt;= x) <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//秒杀恶龙</span></span><br><span class="line"><span class="keyword">if</span>(t2 &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//无法杀死恶龙</span></span><br><span class="line">x -= t1;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x%t2) res++;</span><br><span class="line">res += x/t2;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;x); t1 = t2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,ta,tb;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;ta,&amp;tb);</span><br><span class="line">t1 = max(t1,ta);</span><br><span class="line">t2 = max(t2,ta-tb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="C-The-Number-Of-Good-Substrings"><a href="#C-The-Number-Of-Good-Substrings" class="headerlink" title="C.The Number Of Good Substrings"></a>C.The Number Of Good Substrings</h4><p><strong>题意简述：</strong><br>给定一个01串 s ，假设 sub 是 s 的子串，定义f(sub) = “sub十进制的值”。若f(sub) = len(sub)，f(sub) = 子串sub的长度，那么称sub为“优秀的子串”。<br>现在给定字符串s，试求出s的“优秀的子串”的数量。</p><p><strong>解题思路：</strong><br>刚开始想用KMP算法：对于每一可能的长度（共2e5种可能的情况）转化为二进制的01串，再用KMP计算该串在 s 中出现的次数，将所有情况累加即为答案。<br>但是KMP超时了，还是对KMP不太熟悉，上述算法复杂度应该是$O(N^2)$，是不行的。</p><p>再考虑由于$2^{20} &gt; 2e5$ 所以我们其实可以通过将 s 所有长度为 [1 , 20] 的子串挨个判断是否为“优秀的子串”，如此O(20N)时间内求出结果。具体做法是从左向右，将上一个 1 作为子串左端点，然后依次向右延申，长度+1，并将其转化为十进制，如果该十进制要大于区间长度，则后续肯定也不可能是“优秀子串”，故退出。能这样做是因为左边的0不影响十进制数的大小，而右边的0影响。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> last = <span class="number">0</span>,x,l,len = <span class="built_in">strlen</span>(str); ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;str[i];i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i] == <span class="string">'0'</span>) <span class="keyword">continue</span>; x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; len &amp;&amp; j &lt;= i+<span class="number">25</span>;j++)&#123;</span><br><span class="line">x = x*<span class="number">2</span>+str[j]-<span class="string">'0'</span>;</span><br><span class="line">l = j-x+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= last) <span class="keyword">break</span>;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">last = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="D-Coloring-Edges"><a href="#D-Coloring-Edges" class="headerlink" title="D.Coloring Edges"></a>D.Coloring Edges</h4><p><strong>题意简述：</strong><br>给定一个有 n 个点 m 条边的有向图，该有向图无自环无重边。我们对该有向图进行染色，一个好的染色方案当且仅当图中没有一个环是同一个颜色。请问要想使得该染色方案是好的，最少需要多少种不同的颜色？并输出每条边的颜色。<br><strong>解题思路：</strong><br>首先通过手画几种样例可以得出，我们最多只需要2种不同的颜色就可以完成图的着色。因此若图中有环，则k = 2，否则k = 1。而当k = 2时，即图中有环，需要2种不同颜色染色时，我们知道有向图中，若存在环，则必然有从编号小的点指向编号大的点，也有编号大的点指向编号小的点。因此，若边u-&gt;v，若u &lt; v则染颜色1，否则染颜色2，这样可以保证该环被拆分成两种颜色。</p><p><em>注：若有向图中不存在环，则不一定有 “从编号小的点指向编号大的点，同时也有从编号大的点指向编号小的点。”</em></p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[N],ver[N],nex[N];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x];</span><br><span class="line">head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,xx[N],yy[N];</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span>;</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y] == <span class="number">1</span>)&#123;</span><br><span class="line">flag = <span class="literal">true</span>; <span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!vis[y]) dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">vis[x] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!vis[i]) dfs(i);</span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(xx[i] &gt; yy[i]) <span class="built_in">printf</span>(<span class="string">"2 "</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"1 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">printf</span>(<span class="string">"1 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;xx[i],&amp;yy[i]);</span><br><span class="line">addEdge(xx[i],yy[i]);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/1217&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题集链接&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;A-Creating-a-Character&quot;&gt;&lt;a href=&quot;#A-Crea
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="图论" scheme="http://valenshi.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>hdu6629 string matching（拓展KMP）</title>
    <link href="http://valenshi.top/2019/09/06/hdu6629-String-Match/"/>
    <id>http://valenshi.top/2019/09/06/hdu6629-String-Match/</id>
    <published>2019-09-06T08:22:55.000Z</published>
    <updated>2019-09-06T08:25:42.812Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6629" target="_blank" rel="noopener">hdu6629string matching</a><br><strong>Description:</strong><br>给出一个字符串S，我们执行“求出S所有后缀与S的最长公共前缀长度”这个操作，我们采取暴力算法(算法流程见题面)，请问我们在该算法中共执行了多少次比较操作？<br><strong>Input:</strong><br>第一行一个整数t，接下来共t组测试用例，每个测试用例输入一个长度小于1e6的字符串S。<br><strong>解题思路：</strong><br>可以用拓展KMP做，其中S是原串，T也是原串。暴力算法的比较次数就等同于所有后缀的最长公共前缀长度和，若没有比到字符串末尾，则还要加上一次失配的操作比较。由于本题T也是S，故可以在计算nex数组的同时便统计答案。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> nex[N];<span class="comment">//nex[i] = T[i,n-1]与T[0,n-1]最长公共前缀 </span></span><br><span class="line"><span class="keyword">char</span> S[N];<span class="comment">//S为目标串,T为模式串 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str) ,i = <span class="number">0</span>,j,p0 ;</span><br><span class="line">nex[<span class="number">0</span>] = len;</span><br><span class="line"><span class="keyword">while</span>(i+<span class="number">1</span> &lt; len &amp;&amp; str[i] == str[i+<span class="number">1</span>]) i++;</span><br><span class="line">nex[<span class="number">1</span>] = i; p0 = <span class="number">1</span>; ans += nex[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(nex[<span class="number">1</span>] != len<span class="number">-1</span>) ans++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex[i-p0]+i &lt; nex[p0]+p0) nex[i] = nex[i-p0];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j = nex[p0]+p0-i;</span><br><span class="line"><span class="keyword">if</span>(j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i+j &lt; len &amp;&amp; str[j] == str[j+i]) j++;</span><br><span class="line">nex[i] = j; p0 = i;</span><br><span class="line">&#125;</span><br><span class="line">ans += nex[i];</span><br><span class="line"><span class="keyword">if</span>(nex[i] != len-i) ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算并返回答案*/</span></span><br><span class="line">ans = <span class="number">0</span>; getNex(S);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,S);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6629&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hdu6629string matching&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="拓展KMP" scheme="http://valenshi.top/tags/%E6%8B%93%E5%B1%95KMP/"/>
    
  </entry>
  
  <entry>
    <title>拓展KMP算法</title>
    <link href="http://valenshi.top/2019/09/06/exkmp/"/>
    <id>http://valenshi.top/2019/09/06/exkmp/</id>
    <published>2019-09-06T08:22:41.000Z</published>
    <updated>2019-09-06T08:24:34.010Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题模型：</strong><br>给定字符串S和子串T，S的长度为n，T的长度为m；求字符串T与字符串S的每一个后缀d的最长公共前缀。</p><h4 id="拓展KMP算法"><a href="#拓展KMP算法" class="headerlink" title="拓展KMP算法"></a>拓展KMP算法</h4><p>假设 extend[] 数组： extend[i] 表示 T 与 S[i, n] 的最长公共前缀，目的是求出所有的 extend[0~n-1]。<br>（注意到，如果存在extend[i] = m，则说明 T 在 S 中完全出现过，那么问题就变成标准KMP算法了。）<br>我们下面的目标就是如何在较短的时间内更新extend数组；与KMP算法类似，我们通过利用next数组来阻止指针的回退。</p><p><strong>下面先通过一般的例子来看我们是如何更新extend数组的：</strong></p><p>S = “aaaabaa” , T = “aaaaa”。</p><p>显然extend[0] = 4，显然当匹配到第5个时失配，共匹配了5次。<br>我们考虑利用已知的信息来计算extend[1]，已知S[1 , 3] = T[1 , 3]，现在要用S[1 , n-1]和T[0 , n-1]进行匹配，如果我们设 nex[1] 存放 T[1 , n-1] 与 T[0 , n-1] 的最长公共前缀，nex[1] = 4，这就说明<strong>对于S[1, n-1]，T[1 , n-1]能匹配上的字符，T[0,n-1]的前nex[1]个也能匹配的上</strong>，由于T[1,n-1]只能匹配S[1 , 3]共3个字符，那么显然前 3 个字符都可以成功匹配，我们直接匹配下一位即可；于是extend[1] = 3。</p><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><p><strong>定义extend[]数组：</strong> extend[i] 表示字符串 T 与字符串 S[i , n] 的最长公共前缀长度。<br><strong>定义nex[]数组：</strong> nex[i] 表示 T[i , n] 与 T[1 , n] 的最长公共前缀的长度。</p><p>首先我们从左到右计算extend数组，假设在某一时刻 extend[0 , k] 已经计算完毕，并且之前匹配过程中所达到的最远距离为p，所谓最远距离即 p = MAX{ i+extend[i]  (0 &lt;= i &lt;= k) } 的最大值，p’ 为达到最远距离时的 i 。</p><p><strong>现在来利用已知的信息求extend[k+1]：</strong><br>已知S[p’ , p] = T[0, p-p’]，即S[k+1 , p] = T[k+1 - p’ , p-p’]。<br>设 len = nex[k+1 - p’] ，即 len 为 T[k+1 - p’ , n-1] 与 T[0 , n-1]的最长公共前缀。</p><ul><li>如果k+len &lt; p，则extend[k+1] = len：<br>此时由于已知条件 以及 nex数组性质，可以知道前 len 个字符一定是匹配的。若S[k+ len+1] = T[len]，则说明 nex 是len+1而非len，于是与nex数组矛盾，故不成立；因此若k+len &lt; p，则extend[k+1] = len。</li></ul><p><img src="/2019/09/06/exkmp/1.png" alt="1"><br>(图1：当k+len&lt;p时情形，其中po = p’，图片来自 <em>dyx心心</em> 的博客)</p><ul><li>若k+len &gt;= p：<br>此时已知的是S[k+1 , p] = T[0 , p-k-1]，但是 S[p+1] 是否等同于 T[p-k] 尚且未知，因此需要向后遍历判断，同时更新p与p’。</li></ul><p><img src="/2019/09/06/exkmp/2.png" alt="2"><br>(图2：当k+len &gt;= p时情形，其中po = p’，图片来自 <em>dyx心心</em> 的博客)</p><p>对于nex数组，其求法和extend数组类似，详情参考代码中getNex()函数实现方法。</p><h4 id="例题模板"><a href="#例题模板" class="headerlink" title="例题模板"></a>例题模板</h4><p><a href="https://www.luogu.org/problem/P5410" target="_blank" rel="noopener">洛谷P5410拓展KMP模板</a><br><strong>题意简述：</strong><br>给定字符串S和T，输出next数组以及extend数组。</p><p><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> nex[N];<span class="comment">//nex[i] = T[i,n-1]与T[0,n-1]最长公共前缀 </span></span><br><span class="line"><span class="keyword">char</span> S[N],T[N]; <span class="comment">//S为目标串,T为模式串 </span></span><br><span class="line"><span class="keyword">int</span> extend[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算nex数组*/</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str) ,i = <span class="number">0</span>, j, p0 ;</span><br><span class="line">nex[<span class="number">0</span>] = len;</span><br><span class="line"><span class="keyword">while</span>(i+<span class="number">1</span> &lt; len &amp;&amp; str[i] == str[i+<span class="number">1</span>]) i++;</span><br><span class="line">nex[<span class="number">1</span>] = i; p0 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex[i-p0]+i &lt; nex[p0]+p0) nex[i] = nex[i-p0];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j = nex[p0]+p0-i;</span><br><span class="line"><span class="keyword">if</span>(j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i+j &lt; len &amp;&amp; str[j] == str[j+i]) j++;</span><br><span class="line">nex[i] = j; p0 = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exKMP</span><span class="params">(<span class="keyword">char</span>* str1,<span class="keyword">char</span> *str2)</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算str2与str1的所有后缀的最长公共前缀长度,存放在extend数组中*/</span> </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>,j,p0,l1 = <span class="built_in">strlen</span>(S), l2 = <span class="built_in">strlen</span>(T);</span><br><span class="line">getNex(str2);</span><br><span class="line"><span class="keyword">while</span>(i &lt; l1 &amp;&amp; i &lt; l2 &amp;&amp; str1[i] == str2[i]) i++;</span><br><span class="line">extend[<span class="number">0</span>] = i;p0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; l1;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex[i-p0]+i &lt; extend[p0]+p0) extend[i] = nex[i-p0];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">j = extend[p0]+p0-i;</span><br><span class="line"><span class="keyword">if</span>(j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i+j &lt; l1 &amp;&amp; j &lt; l2 &amp;&amp; str1[j+i] == str2[j]) j++;</span><br><span class="line">extend[i] = j; p0 = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算并输出答案*/</span></span><br><span class="line"><span class="keyword">int</span> l1 = <span class="built_in">strlen</span>(S), l2 = <span class="built_in">strlen</span>(T);</span><br><span class="line">exKMP(S,T);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; l2;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,nex[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; l1;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,extend[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,S,T);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://blog.csdn.net/dyx404514/article/details/41831947#commentBox" target="_blank" rel="noopener">dyx心心的博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;问题模型：&lt;/strong&gt;&lt;br&gt;给定字符串S和子串T，S的长度为n，T的长度为m；求字符串T与字符串S的每一个后缀d的最长公共前缀。&lt;/p&gt;
&lt;h4 id=&quot;拓展KMP算法&quot;&gt;&lt;a href=&quot;#拓展KMP算法&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="拓展KMP" scheme="http://valenshi.top/tags/%E6%8B%93%E5%B1%95KMP/"/>
    
  </entry>
  
  <entry>
    <title>hdu6638 Snowy Smile-线段树维护最大子矩阵</title>
    <link href="http://valenshi.top/2019/09/03/hdu6638-Snowy-Smile/"/>
    <id>http://valenshi.top/2019/09/03/hdu6638-Snowy-Smile/</id>
    <published>2019-09-03T12:53:13.000Z</published>
    <updated>2019-09-03T12:54:05.891Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6638" target="_blank" rel="noopener">题目链接</a></p><h4 id="Snowy-Smile"><a href="#Snowy-Smile" class="headerlink" title="Snowy Smile"></a>Snowy Smile</h4><p><strong>题意简述：</strong><br>给出平面上n(n &lt;= 2000)个点，点的坐标在-1e9~1e9之间，试求出最大子矩阵的和是多少。</p><p><strong>解题思路：</strong><br>考虑数据范围，2e3个点离散化后可能会有2e3个，本题中各个点是离散的，所以用普通的动态规划比较麻烦，因此本题采用$O(N^2log_2N)$的线段树+枚举。<br>我们对x，枚举所有可能的x[i]和x[j]其中x[i]为上界，x[j]为下界，这个枚举花费时间为$O(N^2)$，而对于每一种可能的组合，再利用线段树$O(log_2N)$求出最大连续子段和，因此总时间$O(N^2log_2N)$。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3010</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">int</span> tmp[N];<span class="comment">//离散化用</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Chest</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,val;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Chest &amp; B) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt; B.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;cs[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="comment">/*分别为区间和,区间最大子段和,</span></span><br><span class="line"><span class="comment">从左侧开始的最大子段和,从右侧开始的最大子段和*/</span></span><br><span class="line">ll sum,mx,lx,rx; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mx(x) tr[x].mx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lx(x) tr[x].lx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rx(x) tr[x].rx </span></span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*在区间[l,r]上建立一棵线段树*/</span></span><br><span class="line">sum(rt) = mx(rt) = lx(rt) = rx(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid);</span><br><span class="line">BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="comment">/*用于根据rt的子节点更新rt的4个数据*/</span></span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>)+sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">mx(rt) = max(rx(rt*<span class="number">2</span>)+lx(rt*<span class="number">2</span>+<span class="number">1</span>),max(mx(rt*<span class="number">2</span>),mx(rt*<span class="number">2</span>+<span class="number">1</span>)));</span><br><span class="line">lx(rt) = max(lx(rt*<span class="number">2</span>),sum(rt*<span class="number">2</span>)+lx(rt*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">rx(rt) = max(rx(rt*<span class="number">2</span>+<span class="number">1</span>),sum(rt*<span class="number">2</span>+<span class="number">1</span>)+rx(rt*<span class="number">2</span>));</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p,<span class="keyword">int</span> val,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将线段树p位置的值设为val;l,r是辅助作用哦*/</span></span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum(rt) += val;</span><br><span class="line">lx(rt) = rx(rt) = mx(rt) = sum(rt); </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= mid) Insert(rt*<span class="number">2</span>,p,val,l,mid);</span><br><span class="line"><span class="keyword">else</span> Insert(rt*<span class="number">2</span>+<span class="number">1</span>,p,val,mid+<span class="number">1</span>,r);</span><br><span class="line">spread(rt);<span class="comment">//在回溯时更新节点的值 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回当前最大连续子段和*/</span></span><br><span class="line"><span class="keyword">return</span>  tr[<span class="number">1</span>].mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">sort(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">int</span> cnt = unique(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+n)-tmp<span class="number">-1</span>;</span><br><span class="line">sort(cs+<span class="number">1</span>,cs+<span class="number">1</span>+n);</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*我们对每一个x[i]上限,枚举所有可能x[j]的下限,</span></span><br><span class="line"><span class="comment">并利用线段树求出x[i]~x[j]最大字段和*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(cs[i].x == cs[i<span class="number">-1</span>].x &amp;&amp; i != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,cnt);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(cs[j].x != cs[j<span class="number">-1</span>].x &amp;&amp; i != j) ans = max(ans,ask());</span><br><span class="line"><span class="keyword">int</span> y = lower_bound(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+cnt,cs[j].y)-tmp;</span><br><span class="line">Insert(<span class="number">1</span>,y,cs[j].val,<span class="number">1</span>,cnt);</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans,ask());<span class="comment">//如果全部相等,在此处特判 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;cs[i].x,&amp;cs[i].y,&amp;cs[i].val);</span><br><span class="line">tmp[i] = cs[i].y;</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6638&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;Snowy-Smile&quot;&gt;&lt;a href=&quot;#Snowy
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="线段树" scheme="http://valenshi.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="最大子矩阵" scheme="http://valenshi.top/tags/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>2019航电多校7部分题解</title>
    <link href="http://valenshi.top/2019/09/02/hdu7/"/>
    <id>http://valenshi.top/2019/09/02/hdu7/</id>
    <published>2019-09-02T13:54:31.000Z</published>
    <updated>2019-09-02T13:56:38.206Z</updated>
    
    <content type="html"><![CDATA[<h4 id="A-A-B-C"><a href="#A-A-B-C" class="headerlink" title="A. A + B = C"></a>A. <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6646" target="_blank" rel="noopener">A + B = C</a></h4><p>有空再写，麻烦死了。</p><h4 id="F-Final-Exam"><a href="#F-Final-Exam" class="headerlink" title="F. Final Exam"></a>F. <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6651" target="_blank" rel="noopener">Final Exam</a></h4><p><strong>题意简述</strong><br>题意有点绕，一份考试总分为m分n道题，每道题可能为 n 类科目中的一类。如果我们想做出一道分值为 a 的题，那么我们至少要复习该题所在的科目 a+1 分钟以上。请问如果我们要想最少做出k题，需要花多长时间？</p><p><strong>解题思路:</strong><br>首先搞清题意，就是我们目标是最少做出k题需要花费的最少时间，那么最坏情况就是老师针对我们，出我们复习时间最少的n - k + 1道题，令每道题都等于该学生复习的时间（因为总分确定，这样才最优）。那么如果我想通过，那就要令自己复习时间最少的n-k+1门科目复习总时间 &gt; m，这样老师就无论如何也针对不了我了。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">ll n,m,k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = n-k+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = m/tmp + <span class="number">1</span>;</span><br><span class="line">ll ans = (k<span class="number">-1</span>)*b + m+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="K-Kejin-Player"><a href="#K-Kejin-Player" class="headerlink" title="K. Kejin Player"></a>K. <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6656" target="_blank" rel="noopener">Kejin Player</a></h4><p><strong>题意简述：</strong><br>满级为n+1级，从第 i 级升到 i+1 级需要a[i]金币，成功几率为r[i] / s[i] ，如果成功则等级从i变为i+1，失败则等级从 i 变为 x[i] （x[i] &lt;= i）。<br>请问从l升到r级，需要多少金币？<br><strong>解题思路：</strong><br>这是一道概率dp题，且概率可以加减，设f[ x ] 为从1级升到x级需要的金币，那么从l级升到r级需要f[r] - f[l]金币。这是因为升到某一级需要的金币数是固定的，所以满足加减原则。<br>加速我们当前在 i 级，有 p 的概率花费a[i]金币升到 i+1 级，假设我们尝试了t次才升级成功，即： </p><script type="math/tex; mode=display">f[i+1] = f[i] + a[i]  + (t - 1) * a[i] + (t - 1) * (f[ i ] - f[ x[i] ])</script><p>又因为$\frac{t-1}{t} = p$，得$t = \frac{s[i]}{r[i]}$，带入得：</p><script type="math/tex; mode=display">f[i+1] = f[i] +  \frac{s[i]}{r[i]} * a[i] + (\frac{s[i]}{r[i]} - 1) * (f[ i ] - f[ x[i] ])</script><p>遇到这种概率题，设试了t次才成功，然后用概率表示 t 即可得出递推公式。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll r[N],s[N],x[N],a[N];<span class="comment">//p = r/s</span></span><br><span class="line"><span class="keyword">int</span> t,n,q;</span><br><span class="line"><span class="keyword">const</span> ll P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll f[N];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b,ll m)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = res*a%m;</span><br><span class="line">a = a*a%m;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*预处理出所有答案*/</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ll pp = s[i]*qpow(r[i],P<span class="number">-2</span>,P)%P; <span class="comment">//s[i]/r[i]的逆元 </span></span><br><span class="line">f[i+<span class="number">1</span>] = (f[i] + pp*a[i]%P </span><br><span class="line">+ (pp<span class="number">-1</span>)*(f[i]-f[x[i]])%P+P)%P;</span><br><span class="line"><span class="comment">//printf("%lld\n",f[i+1]);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>,r+i,s+i,x+i,a+i);</span><br><span class="line">solve();<span class="comment">//离线 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,tl,tr;i &lt;= q;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;tl,&amp;tr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(f[tr]-f[tl]+P)%P);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;A-A-B-C&quot;&gt;&lt;a href=&quot;#A-A-B-C&quot; class=&quot;headerlink&quot; title=&quot;A. A + B = C&quot;&gt;&lt;/a&gt;A. &lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6646&quot; 
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="博弈论" scheme="http://valenshi.top/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
      <category term="概率dp" scheme="http://valenshi.top/tags/%E6%A6%82%E7%8E%87dp/"/>
    
  </entry>
  
  <entry>
    <title>拓展欧拉定理+幂塔函数</title>
    <link href="http://valenshi.top/2019/09/02/exphi/"/>
    <id>http://valenshi.top/2019/09/02/exphi/</id>
    <published>2019-09-02T02:19:14.000Z</published>
    <updated>2019-09-02T02:21:24.215Z</updated>
    
    <content type="html"><![CDATA[<h4 id="拓展欧拉定理与幂塔函数"><a href="#拓展欧拉定理与幂塔函数" class="headerlink" title="拓展欧拉定理与幂塔函数"></a>拓展欧拉定理与幂塔函数</h4><p><strong>欧拉定理：</strong> 若gcd(a,p) = 1，则 $a^p \equiv a^{b \% \varphi (p)}(mod \: p)$，其中gcd(a,p) = 1。<br><strong>拓展欧拉定理：</strong> 假设a为任意数，b和m为正整数，且$b &gt; \varphi(m)$，a和m不一定要互质，那么有如下公式：</p><script type="math/tex; mode=display">a^b~\equiv~\begin{cases}a^{b~Mod~\phi(m)} &\gcd(a,m)~=~1 \\a^b &\gcd(a,m)~\neq~1~\land~b~<~\phi(m) \\ a^{b~Mod~\phi(m)~+~\phi(m)} &\gcd(a,m)~\neq~1~\land~b~\geq~\phi(m)\end{cases} \:\:(Mod\: m)</script><p><em>注：拓展欧拉定理的证明可以参考<a href="https://zhuanlan.zhihu.com/p/24902174" target="_blank" rel="noopener">证明</a></em></p><p><strong>幂塔函数</strong>： 形如</p><script type="math/tex; mode=display">a^{a^{a^{...}}} mod \: m</script><p>的函数我们称为幂塔函数，该函数应从上向下计算，即$a^{a^{a^a}} = a^{(a^{({a^a})})}$，因此其中间变量会急剧上升，普通方法无法计算。</p><h4 id="例题：2019南京icpc网络赛-B-Super-Log"><a href="#例题：2019南京icpc网络赛-B-Super-Log" class="headerlink" title="例题：2019南京icpc网络赛 B.Super_Log"></a>例题：2019南京icpc网络赛 B.Super_Log</h4><p><a href="https://nanti.jisuanke.com/t/41299" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定a和k以及m，试求出</p><script type="math/tex; mode=display">a^{a^{a^{...}}} mod \: m</script><p>其中共k层幂塔。其中a，k和m小于等于1e6。<br><strong>解题思路：</strong><br>首先使用拓展欧拉定理需要 $b &gt; \varphi(m)$，所以对于不同的b要分类讨论一下。设</p><script type="math/tex; mode=display">f(a,k,m) = a^{a^{a^{...}}} \% m</script><p>其中a是有k层的幂塔。</p><ol><li>首先，当a = 1或者b = 0时特判，得出答案为 1%m。</li><li>本题中b = f(a, k-1,INF)，如果a &gt;= phi(m)，那么显然b一定大于phi(m)，即满足拓展欧拉定理中第3种情况；</li><li>如果k = 1，则b = f(a,k-1,INF) = 1，此时只需判断phi(m)是否大于1即可判断当然情况符合拓展欧拉定理第3还是第2种情况。</li><li>剩下的情况我们就可以通过递归来判断b是否大于phi(m)，因为若b &gt;= phi(m)，那么$log_ab &gt;= log_a phi(m)$</li></ol><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b,ll m)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = res*a%m;</span><br><span class="line">a = a*a%m;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> v[N],primes[N],phi[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i])&#123;</span><br><span class="line">primes[cnt++] = i;</span><br><span class="line">v[i] = i;</span><br><span class="line">phi[i] = i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cnt;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(primes[j] &gt; v[i] || primes[j]*i &gt;= N)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">v[i*primes[j]] = primes[j];</span><br><span class="line">phi[i*primes[j]] = phi[i]*(i%primes[j] ? primes[j]<span class="number">-1</span> : primes[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll a,ll b,ll p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> p &lt;= <span class="number">1</span>;<span class="comment">//f(a,0,p) = 1</span></span><br><span class="line"><span class="keyword">if</span>(a &gt;= p) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//f(a,b,INF) &gt; p</span></span><br><span class="line"><span class="keyword">return</span> check(a,b<span class="number">-1</span>,<span class="built_in">log</span>(p)/<span class="built_in">log</span>(a)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll a,ll b,ll m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(m == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//递归终止条件1,此时之后答案恒为0 </span></span><br><span class="line"><span class="keyword">if</span>(b &lt;= <span class="number">1</span>) <span class="keyword">return</span> qpow(a,b,m);<span class="comment">//递归终止条件2 </span></span><br><span class="line">ll ph = phi[m];</span><br><span class="line"><span class="comment">//printf("%lld\n",ph);</span></span><br><span class="line"><span class="keyword">if</span>(gcd(a,m) == <span class="number">1</span>) <span class="keyword">return</span> qpow(a,f(a,b<span class="number">-1</span>,ph),m);<span class="comment">//欧拉定理 </span></span><br><span class="line"><span class="keyword">if</span>(check(a,b<span class="number">-1</span>,ph)) <span class="keyword">return</span> qpow(a,f(a,b<span class="number">-1</span>,ph)+ph,m);<span class="comment">//拓展欧拉定理情况1 </span></span><br><span class="line"><span class="keyword">return</span> qpow(a,f(a,b<span class="number">-1</span>,ph),m); <span class="comment">//拓展欧拉定理情况2 </span></span><br><span class="line">&#125;</span><br><span class="line">ll a,b,m;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f(a,b,m));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.cnblogs.com/SovietPower/p/8353374.html" target="_blank" rel="noopener">SovietPower的博客</a></li><li>《算法竞赛进阶指南》,李煜东,P142-143.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;拓展欧拉定理与幂塔函数&quot;&gt;&lt;a href=&quot;#拓展欧拉定理与幂塔函数&quot; class=&quot;headerlink&quot; title=&quot;拓展欧拉定理与幂塔函数&quot;&gt;&lt;/a&gt;拓展欧拉定理与幂塔函数&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;欧拉定理：&lt;/strong&gt; 若gcd(a,p) =
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数论" scheme="http://valenshi.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="幂塔函数" scheme="http://valenshi.top/tags/%E5%B9%82%E5%A1%94%E5%87%BD%E6%95%B0/"/>
    
      <category term="拓展欧拉定理" scheme="http://valenshi.top/tags/%E6%8B%93%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>2018南京icpc网络赛</title>
    <link href="http://valenshi.top/2019/08/30/2018nanjing/"/>
    <id>http://valenshi.top/2019/08/30/2018nanjing/</id>
    <published>2019-08-30T14:53:57.000Z</published>
    <updated>2019-08-30T14:54:56.784Z</updated>
    
    <content type="html"><![CDATA[<p>有嗲难，还有些卡时，思路还有些难想，虽然都是经典模型。</p><h4 id="A-An-Olympian-Math-Problem"><a href="#A-An-Olympian-Math-Problem" class="headerlink" title="A. An Olympian Math Problem"></a>A. An Olympian Math Problem</h4><p><a href="https://nanti.jisuanke.com/t/A1947" target="_blank" rel="noopener">原题链接</a><br><strong>解题思路：</strong><br>如果是比赛时我估计会推公式，但在这通过率面前，我猜了个公式就交了，然后过了。答案就是n-1。</p><h4 id="E-AC-Challenge"><a href="#E-AC-Challenge" class="headerlink" title="E. AC Challenge"></a>E. AC Challenge</h4><p><a href="https://nanti.jisuanke.com/t/A1951" target="_blank" rel="noopener">原题链接</a><br><strong>解题思路：</strong><br>状压dp，这类题做的很少，没忘这方面想。开始用的拓扑排序，但是很明显没有考虑到所有情况。用状压的话，就这题而言，是需要先判断当前状态是否合法，判断完之后再更新答案数组dp，最终答案是dp[(1&lt;<n+1)-2]，这与我代码设计有关，因为我是设右边第2位（也就是左移1）为第一题，而我们更新答案时是将所有“未做但是能做的题”更新成“已做该题”，那么最终答案显然就是1111...1共n个1，由于最低位没用，就是111...10即n个1和1个0，所以答案状态是(1<<n+1)-2。 以后n小于20要往状压dp上想。上述介绍请结合代码以及注释看。 **代码示例：** 以后这个状态最好不要用 i 表示，看起来太乱了。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N],s[N],p[N][N];</span><br><span class="line">ll dp[<span class="number">1</span>&lt;&lt;<span class="number">23</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= (<span class="number">1</span>&lt;&lt;n+<span class="number">1</span>);i++)&#123;</span><br><span class="line"><span class="comment">/*先判断是否该状态合法,若合法则计算其值*/</span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>((<span class="number">1</span>&amp;(i&gt;&gt;j)) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= s[j];k++)</span><br><span class="line"><span class="keyword">if</span>((<span class="number">1</span>&amp;(i&gt;&gt;p[j][k])) == <span class="number">0</span>)&#123;</span><br><span class="line">flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(!flag) <span class="keyword">break</span>; <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!(i&gt;&gt;j&amp;<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">ll t = <span class="number">0</span>,s = i;</span><br><span class="line"><span class="keyword">while</span>(s)&#123;</span><br><span class="line"><span class="keyword">if</span>(s&amp;<span class="number">1</span>) t++; s &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">dp[i] = max(dp[i],dp[i^(<span class="number">1</span>&lt;&lt;j)]+t*a[j]+b[j]);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dp[(<span class="number">1</span>&lt;&lt;n+<span class="number">1</span>)<span class="number">-2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,a+i,b+i,s+i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= s[i];j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></n+1)-2]，这与我代码设计有关，因为我是设右边第2位（也就是左移1）为第一题，而我们更新答案时是将所有“未做但是能做的题”更新成“已做该题”，那么最终答案显然就是1111...1共n个1，由于最低位没用，就是111...10即n个1和1个0，所以答案状态是(1<<n+1)-2。></p><h4 id="J-Sum"><a href="#J-Sum" class="headerlink" title="J. Sum"></a>J. Sum</h4><p><a href="https://nanti.jisuanke.com/t/A1956" target="_blank" rel="noopener">原题链接</a><br><strong>解题思路：</strong><br>我想了一个O(9N)的算法，但是超时了，本机大概1.6-2.5s，很难受；是采用唯一分解定理判断每一个数可以分解为多少个“数对”相乘。然后改用线性筛，思想当然没变，但是利用线性筛的O(N)常数较小，本机0.7~1.1s，通过率大概1/4。<br>然后是朋友提供的解法思路，主要是统计“平方对”，不单独统计每个数对s的贡献，而是直接计算s，也是O(N)，但是更快，稳过。<br><strong>代码示例1：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll f[N],s[N];<span class="comment">//f数组表示单个元素结果,表示所求答案 </span></span><br><span class="line"><span class="keyword">int</span> v[N],primes[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*利用线性筛预处理f数组与s数组*/</span> </span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">primes[++cnt] = i;</span><br><span class="line">v[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= cnt;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(primes[j] &gt; v[i] || primes[j]*i &gt; N) <span class="keyword">break</span>;</span><br><span class="line">v[i*primes[j]] = primes[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">s[<span class="number">1</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//f[1]也要初始化 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(v[i] == i) f[i] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = i,k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x%v[i] == <span class="number">0</span>)&#123;</span><br><span class="line">x /= v[i];k++;</span><br><span class="line"><span class="keyword">if</span>(k &gt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k &gt; <span class="number">2</span>) f[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">2</span>) f[i] = f[x];<span class="comment">//dp思想 </span></span><br><span class="line"><span class="keyword">else</span> f[i] = f[x]*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">s[i] = s[i<span class="number">-1</span>]+f[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*会卡常,有时过有时不过,真正比赛还需要稍微优化,大概1/4过*/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">solve();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,s[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>代码示例2：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 20000070</span></span><br><span class="line"><span class="keyword">int</span> square[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXN;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        square[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;MAXN;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> k=i*i;</span><br><span class="line">        <span class="keyword">if</span>(!square[k]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=k;j&lt;MAXN;j+=k)</span><br><span class="line">        &#123;</span><br><span class="line">            square[j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;MAXN;i++)</span><br><span class="line">        cnt[i]=cnt[i<span class="number">-1</span>]+square[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!square[i])<span class="keyword">continue</span>;</span><br><span class="line">            sum+=(cnt[n/i]-cnt[i])*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="L-Magical-Girl-Haze"><a href="#L-Magical-Girl-Haze" class="headerlink" title="L. Magical Girl Haze"></a>L. Magical Girl Haze</h4><p><a href="https://nanti.jisuanke.com/t/A1958" target="_blank" rel="noopener">原题链接</a><br><strong>解题思路：</strong><br>先把图分层，再进行Dijkstra算法，做过好几遍了，但还是超时很多法，空间大小没计算好，以后一定要注意。<br><strong>代码示例:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">6e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[N],nex[M],ver[M],tot;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">edge[++tot] = z; ver[tot] = y;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t,n,k,m;</span><br><span class="line">ll d[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line">priority_queue&lt;pair&lt;ll,ll&gt; &gt; q;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1l</span>l&lt;&lt;<span class="number">60</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">q.push(make_pair(<span class="number">0</span>,s));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= (k+<span class="number">1</span>)*n;i++) d[i] = INF;</span><br><span class="line">d[s] = <span class="number">0</span>;<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.top().second; q.pop();</span><br><span class="line"><span class="keyword">if</span>(vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">vis[x] = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(d[y] &gt; d[x]+z)&#123;</span><br><span class="line">d[y] = d[x]+z;</span><br><span class="line"><span class="keyword">if</span>(!vis[y]) q.push(make_pair(-d[y],y));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">dijkstra(<span class="number">1</span>);ll ans = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k+<span class="number">1</span>;i++) ans = min(ans,d[i*n]);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k); </span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head); tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= k;j++) addEdge(x+n*j,y+n*j,z);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= k;j++) addEdge(x+n*(j<span class="number">-1</span>),y+n*j,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有嗲难，还有些卡时，思路还有些难想，虽然都是经典模型。&lt;/p&gt;
&lt;h4 id=&quot;A-An-Olympian-Math-Problem&quot;&gt;&lt;a href=&quot;#A-An-Olympian-Math-Problem&quot; class=&quot;headerlink&quot; title=&quot;A. An
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="状压dp" scheme="http://valenshi.top/tags/%E7%8A%B6%E5%8E%8Bdp/"/>
    
      <category term="线性筛" scheme="http://valenshi.top/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
    
      <category term="最短路" scheme="http://valenshi.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>2019航电暑期多校10部分题解</title>
    <link href="http://valenshi.top/2019/08/30/hdu10/"/>
    <id>http://valenshi.top/2019/08/30/hdu10/</id>
    <published>2019-08-30T05:08:50.000Z</published>
    <updated>2019-08-30T15:03:09.105Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1005-Welcome-Party"><a href="#1005-Welcome-Party" class="headerlink" title="1005 Welcome Party"></a>1005 Welcome Party</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6695" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>一共有n名同学，每位同学都会唱歌和跳舞，第 i 位同学的唱歌和跳舞的能力值分别为$x_i,y_i$，现在将这些同学分为唱歌队和跳舞队，每队的价值等于该队中该能力值最高的同学的能力值，请问两队价值差最小是多少呢？</p><p><strong>解题思路：</strong><br>这题其实不算太难，但是思路容易乱。首先由于每队的价值等于该队中最高的能力值，所以可以从高到低枚举每一位同学的x，并更新ans；对当前枚举到的x，我们在所有其他同学中找到最接近 x 的 y （即abs(x-y)最小），这个y必须是 <strong>比所有被枚举过的同学的y要大。</strong> 否则该同学就不是跳舞队中最大能力值（因为被枚举过的同学一定去跳舞了），该y就不能更新答案了。<br>当然细节在于如何找寻最接近x的y。</p><p><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">pair&lt;ll,ll&gt; a[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="built_in">multiset</span>&lt;ll&gt; s2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">s2.clear();</span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n); ll ans = <span class="number">1l</span>l&lt;&lt;<span class="number">60</span>, mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) s2.insert(a[i].y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line"><span class="comment">//先把当前同学的y删掉,防止选到同一位同学 </span></span><br><span class="line">s2.erase(s2.find(a[i].y)); </span><br><span class="line"><span class="comment">//要么比mx大的值更新ans,要么就mx更新ans </span></span><br><span class="line"><span class="keyword">if</span>(mx) ans = min(ans,<span class="built_in">abs</span>(mx-a[i].x));</span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;ll&gt;::iterator it = s2.lower_bound(a[i].x);</span><br><span class="line"><span class="keyword">if</span>(it == s2.end()) it--;</span><br><span class="line"><span class="keyword">if</span>(*it &gt;= mx) ans = min(ans,<span class="built_in">abs</span>(*it-a[i].x));</span><br><span class="line"><span class="keyword">if</span>(it != s2.begin()) it--;</span><br><span class="line"><span class="keyword">if</span>(*it &gt;= mx) ans = min(ans,<span class="built_in">abs</span>(*it-a[i].x));</span><br><span class="line">mx = max(mx,a[i].y);</span><br><span class="line"><span class="comment">//printf("%lld %lld %lld %lld %lld\n",mx,a[i].x,a[i].y,*it,ans);</span></span><br><span class="line"></span><br><span class="line">s2.insert(a[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1011-Make-Rounddog-Happy"><a href="#1011-Make-Rounddog-Happy" class="headerlink" title="1011 Make Rounddog Happy"></a>1011 Make Rounddog Happy</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6701" target="_blank" rel="noopener">测试地址</a></p><p><strong>题意简述：</strong><br>给出一个包含n个元素的序列a，其中 $1 &lt;= a_i &lt;= n$，友好子串的定义如下：</p><ul><li>[l , r]位置上的所有元素各不相同。</li><li>$Max(a_l, a_{l+1} , … , a_r) - (r - l + 1) &lt;= k$。</li></ul><p>给出一个序列，请问该序列中有多少友好子串。</p><p><strong>解题思路：</strong><br>这题是启发式分治，所谓启发式算法主要是指基于直观或经验而构造的算法，它不一定是最优的，但一定是可行的，并且时间要在可接受范围内。现阶段的启发式算法主要以仿自然算法（模拟）为主。<br>假设一个区间[l,r]内最大的元素下标为p，那么对于a[p]，在[l,r]内有多少个子区间包含p，且满足a[p] - k &lt;= r-l+1，这是子问题。我们可以将该问题分为[l , p]与[p , r]来看，我们对于这两个区间任选其一统计即可，于是我们可以选元素较少的那一个区间，这样元素最多不超过(r-l+1)/2。<br>假设左区间 [l  , p] 元素较少，我们在本次统计中（对[l , r]上以a[p]为最大值的子区间个数）对于每个位置 i （i 属于[l , p]）来计算以 i 为左端点，有多少个子区间满足要求；而满足要求的子区间个数等于tr-tl+1，因为[tl , tr]中任意一个位置都可以作为右端点，因为其满足a[p] - k &lt;= R-L（R为[tl ,tr]内一点，L为 i ）。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> a[N],st[N][<span class="number">25</span>],Log[N]; </span><br><span class="line"><span class="keyword">int</span> t,n,k;</span><br><span class="line"><span class="keyword">int</span> L[N],R[N];<span class="comment">//记录每个位置左右最远 不重复 且比其小的数的数量 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*初始化st表*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)) &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> t1 = st[i][j<span class="number">-1</span>],t2 = st[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>];</span><br><span class="line">st[i][j] = a[t1] &lt; a[t2]?t2:t1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回[l,r]内最大的数的下标*/</span> </span><br><span class="line"><span class="keyword">int</span> kk = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> t1 = st[l][kk], t2 = st[r-(<span class="number">1</span>&lt;&lt;kk)+<span class="number">1</span>][kk];</span><br><span class="line"><span class="keyword">return</span> a[t1] &lt; a[t2]?t2:t1;</span><br><span class="line">&#125; </span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*递归统计答案*/</span></span><br><span class="line"><span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> p = ask(l,r); <span class="keyword">int</span> tt = a[p]-k;</span><br><span class="line"><span class="keyword">if</span>(p-l &lt; r-p)&#123;<span class="comment">//左边点更少 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt;= p;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> tr = min(R[i],r), tl = max(p,i+tt<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(tl &gt; tr) <span class="keyword">continue</span>;</span><br><span class="line">ans += tr-tl+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = r;i &gt;= p;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> tl = max(l,L[i]), tr = min(i-tt+<span class="number">1</span>,p);</span><br><span class="line"><span class="keyword">if</span>(tl &gt; tr) <span class="keyword">continue</span>;</span><br><span class="line">ans += tr-tl+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cal(l,p<span class="number">-1</span>);</span><br><span class="line">cal(p+<span class="number">1</span>,r);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> vis[N];<span class="comment">//记录i最后一次出现的位置 </span></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回答案*/</span></span><br><span class="line">init(); ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="comment">/*以下代码用于更新L与R数组,通过简单的尺取法思想*/</span> </span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[a[i]]) pre = max(pre,vis[a[i]]+<span class="number">1</span>);</span><br><span class="line">L[i] = pre; vis[a[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line">pre = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) vis[i] = n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[a[i]] != n+<span class="number">1</span>) pre = min(vis[a[i]]<span class="number">-1</span>,pre);</span><br><span class="line">R[i] = pre; vis[a[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line">cal(<span class="number">1</span>,n);<span class="comment">//递归分治计算 </span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1005-Welcome-Party&quot;&gt;&lt;a href=&quot;#1005-Welcome-Party&quot; class=&quot;headerlink&quot; title=&quot;1005 Welcome Party&quot;&gt;&lt;/a&gt;1005 Welcome Party&lt;/h4&gt;&lt;p&gt;&lt;a hre
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="思维" scheme="http://valenshi.top/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="启发式分治" scheme="http://valenshi.top/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>可持久化线段树（主席树）</title>
    <link href="http://valenshi.top/2019/08/28/dynamic-zx/"/>
    <id>http://valenshi.top/2019/08/28/dynamic-zx/</id>
    <published>2019-08-28T12:45:37.000Z</published>
    <updated>2019-08-29T01:55:49.636Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>主席树，又称可持久化线段树，属于可持久化数据结构。“主席”这一名词是由于发明者缩写为HJT，和某位主席拼音缩写相同（有些牵强），故将该数据结构称为主席树。<br>主席树既保留了线段树的灵活，也拥有了可持久化数据结构的特点，在处理某些特定问题时有着其它数据结构不具有的优势。<br>本文将首先介绍什么是“可持久化数据结构”，随后介绍主席树的思想，关于代码实现将结合例题讲解。</p><h4 id="可持久化数据结构"><a href="#可持久化数据结构" class="headerlink" title="可持久化数据结构"></a>可持久化数据结构</h4><p>可持久数据结构主要指的是我们可以查询历史版本的情况并支持插入，利用使用之前历史版本的数据结构来减少对空间的消耗（能够对历史进行修改的是函数式编程 [1]）。</p><p>我们经常会遇到这样的问题：我们需要维护一个数据结构，我们可以修改单一结点的值，查询单一结点的值，但是最关键的是我们可能还需要回退之前做过的某些操作。这里回退是指回到未做这些操作之前的状态。</p><p>在无回退操作的情况下，我们有大把的数据结构可供选择来解决这些问题。但是一旦涉及到回退操作，选择就少的多了。我们将支持回退操作的数据结构称为可持久化数据结构。</p><p>稍微思考一下如何可以在原来数据结构的基础上使其变得可持久化，有一个很简单的方案。我们每次操作都将重新建立一个新的数据结构，并将之前的操作都先在其上执行一次，之后执行该次操作。我们按操作执行顺序将这些数据结构维护成一个序列S，此时S[0]表示未经任何操作的初始数据结构。对于i&gt;0，S[i]表示在S[0]的基础上执行过序号1到i的所有操作后得到的新的数据结构。在这样的做法下，我们称S[i]为版本i，回退操作等价于切换到某个特定版本。若操作i表示切换为版本j，那么我们可以直接将S[i]设置为S[j]的克隆。</p><p>上面提到的做法下很容易发现可以使得任意数据结构都可以支持回退操作，但是缺点也是非常明显，空间和时间的复杂度都奇高。每一次操作都需要累加之前操作的时间复杂度，空间也是，我们为了保存各个版本需要耗费大量的内存。</p><p>先说明时间复杂度的优化，对于i号操作，我们完全可以直接克隆版本S[i-1]并在其上执行i号操作，这样时间复杂度基本上就向空间复杂度看齐了。下面我们就可以专注于空间复杂度的优化（对应的也就是时间复杂度的优化）。</p><p>数据结构是用于保存数据的，我们将其保存数据的单元称为结点，我们可以利用结点来刻画整个数据结构的骨架。数据结构基本分为两类，一类是稳定的，一类是不稳定的。稳定的数据结构，其特定是在修改的结点的值之后不会改变结点之间的关系，而不稳定的数据结构在结点值变更后需要重新维护结点之间的关联。稳定的数据结构有线段树，后缀数组，前缀树等等，不稳定的数据结构主要就是各种二叉平衡树。对于稳定的树状结构，若孩子没有保存指向父结点的指针，即由父亲负责记录所有的孩子，我们很容易发现，当我们对某个结点更改时（修改值，新增，删除等操作），我们只需要同时修改该结点的所有祖先结点即可，那我们是不是也可以只克隆这些结点而非整个数据结构呢？答案是肯定的。由于父亲维护孩子，因此一个孩子允许有多个父亲，故所有没有被直接影响的结点都可以继续复用。我们将部分树状数据结构（特定是稳定和父亲维护父子关系）的一次操作的空间复杂度优化到了O(h)，其中h是树状数据结构的高度。</p><p>当我们将上面的想法作用到线段树时，就得到了常说的主席树。其高度为$O(log_2(n))$，其中n为线段树维护的区间大小，同时其时间和空间复杂度均为$O(log_2(n)^2)$。</p><p><em>引用自：<a href="https://www.cnblogs.com/dalt/p/8324781.html" target="_blank" rel="noopener">陶无语的博客</a></em></p><h4 id="静态主席树"><a href="#静态主席树" class="headerlink" title="静态主席树"></a>静态主席树</h4><p>我们按照“是否支持修改”来将主席树划分为静态和动态。静态主席树一旦建树成功，就不再支持修改，只能够用于查询。静态主席树维护元素出现次数的前缀和。</p><blockquote><p>例题：洛谷P3834，查询区间第k大值<br>给定n个元素，共m个询问，每次询问给出[l ,r]和k，回答区间[l , r]内第k大元素值是多少。</p></blockquote><h5 id="建树："><a href="#建树：" class="headerlink" title="建树："></a>建树：</h5><p>考虑用主席树解决上述问题，给出如下建树步骤：</p><ol><li>新建一棵完整的空树，其根节点编号存放在root[0]内。</li><li>依次将n个元素插入到“版本0”的空树中，他们的“版本号”（根节点）存放在root[i]中。</li></ol><p>对于每一个“新版本”，我们都在原来基础上新增“需要修改的节点”，并将其根节点记录在root数组中。<br>如此我们的时空花费都与修改的路径成正比，即每次$O(log_2N)$。</p><p>当然这些都是从理论思想上来讲的，比较抽象；具体到这一题，我们令线段树维护区间内元素数量，每个节点有三个变量，分别是 ls , rs , sum，即左儿子编号，右儿子编号，区间内元素个数。<br>初始时sum都为0，随后将n个元素依次插入形成n棵新的线段树，而这n+1棵（包括编号为0的空树）构成了一棵静态主席树。<br>所以建树操作其实分为两步：BuildTree()建立一棵空树并返回根节点编号；updata()在原树基础上“增加一棵新树”，并返回该版本的根节点编号。</p><p>虽然不同历史版本的线段树节点之间有交叉以重复利用，但每个历史版本都有唯一且独立的根节点</p><h5 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h5><p>由于线段树维护的是区间内元素的数量，所以不同版本的线段树的对应节点是可以加减的，那么root[i] - root[j]意义就是“第 i 个版本的线段树比第 j 个版本的线段树多几个元素”。如果我们再加上区间范围限制[l , r]，那么我们也可以查询“第 i 个版本比第 j 个版本，在[l , r]上多几个元素”。</p><p>具体到本题，我们需要查询区间[l , r]内第k大的元素，已知线段树可以加减，那么对于询问(l , r , k)，我们就需要在root[l-1] 与 root[r]两棵线段树上找寻答案，不要忘记了这颗线段树是根据权值建立的，也就是所谓的权值线段树。那么在res个数中找第k个，显然二分（树上），参见代码。</p><h5 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h5><p>见附录部分code-1：洛谷P3834静态主席树模板-求区间第k大值</p><h4 id="动态主席树"><a href="#动态主席树" class="headerlink" title="动态主席树"></a>动态主席树</h4><p>静态主席树虽然支持历史查询，但其功能还是不太强大，因为其不支持更改。我们将支持修改的主席树称为动态主席树，但是这个功能添加起来并不容易。静态主席树还可以看作是线段树通过小修改得到，而动态主席树则是树套树。</p><p>思想依旧是维护元素出现次数的前缀和，可以类比差分数组，我们都知道前缀和数组是不支持修改的，如果要修改，就需要用 树状数组/线段树 来维护，这里也是类似。</p><p>我们考虑“外层用树状数组，内层用记录区间内数值出现次数的线段树”来实现支持修改的可持久化线段树，也即动态主席树。</p><p>在静态主席树上，可以通过两个权值线段树相减来求得区间第k大值，在这里我们仍旧是通过这种方法求区间第k大，不同的是我们需要保证所有线段树的数据是正确的（维护修改）。<br>如果我们用树状数组来维护不同版本的权值线段树的编号，那么对于“将位置 p 的 x 修改为 y”这一操作，我们需要修改共logN个版本的权值线段树，如此修改操作的时间复杂度是$O((log_2N)^2)$。<br>值得注意的是，此时空间复杂度 = 树状数组空间 * 权值线段树空间 = $N^2$，但是树状数组实际上只保存权值线段树的“版本号”而已，因此实际上用到的空间也就只有权值线段树上的$O(N(log_2N)^2)$个节点的空间，因此动态开点即可。</p><h5 id="例题2：洛谷P2617"><a href="#例题2：洛谷P2617" class="headerlink" title="例题2：洛谷P2617"></a>例题2：洛谷P2617</h5><p><strong>代码模板：</strong> 见附录部分code-2</p><h4 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h4><p>[1] 函数式编程：“函数式编程”是一种“编程范式”(programming paradigm)，也就是如何编写程序的方法论。它属于“结构化编程”的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。</p><p><em>引用自：<a href="https://www.cnblogs.com/aezero/p/4979890.html" target="_blank" rel="noopener">aezero的博客</a></em></p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p><strong>code-1：洛谷P3834静态主席树模板-求区间第k大值</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zxTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls,rs,sum;<span class="comment">//左右儿子,区间内元素个数</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(x) tr[x].ls</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(x) tr[x].rs</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[x].sum</span></span><br><span class="line">&#125; tr[N*<span class="number">40</span>];<span class="comment">//注意数组大小</span></span><br><span class="line"><span class="keyword">int</span> sz = <span class="number">0</span>;<span class="comment">//不同版本的树的总数 </span></span><br><span class="line"><span class="keyword">int</span> root[N];<span class="comment">//root[i]存放第i棵树的树根的编号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*建树,和普通线段树相同*/</span></span><br><span class="line">    <span class="keyword">int</span> rt = ++sz;sum(rt) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> rt;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ls(rt) = BuildTree(l,mid);</span><br><span class="line">    rs(rt) = BuildTree(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> pre,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*新建一棵树,其比pre树多一个元素x*/</span></span><br><span class="line">    <span class="keyword">int</span> rt = ++sz;</span><br><span class="line">    tr[rt] = tr[pre]; sum(rt)++;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> rt;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) ls(rt) = updata(ls(pre),l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> rs(rt) = updata(rs(pre),mid+<span class="number">1</span>,r,x);</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> pre,<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*  依次是:上一个树根,当前树根,区间左右端点,所求区间第k大</span></span><br><span class="line"><span class="comment">        返回该区间第k大数的下标 */</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> res = sum(ls(rt)) - sum(ls(pre));</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(res &gt;= k) <span class="keyword">return</span> ask(ls(pre),ls(rt),l,mid,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ask(rs(pre),rs(rt),mid+<span class="number">1</span>,r,k-res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i),tmp[i] = a[i];</span><br><span class="line">    <span class="comment">//离散化</span></span><br><span class="line">    sort(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">int</span> tot = unique(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+n)-tmp<span class="number">-1</span>;</span><br><span class="line">    root[<span class="number">0</span>] = BuildTree(<span class="number">1</span>,tot);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot,a[i])-tmp;</span><br><span class="line">        root[i] = updata(root[i<span class="number">-1</span>],<span class="number">1</span>,tot,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用主席树可以加减原理计算</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,l,r,k;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;k);</span><br><span class="line">        <span class="keyword">int</span> x = ask(root[l<span class="number">-1</span>],root[r],<span class="number">1</span>,tot,k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tmp[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>code2-洛谷P2617动态主席树</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="comment">/*线段树节点,要存放左右儿子编号,区间内元素个数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls,rs,sum;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(x) tr[x].ls</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(x) tr[x].rs</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[x].sum</span></span><br><span class="line">&#125;tr[N*<span class="number">400</span>];<span class="comment">//空间要N(logN)^2大小</span></span><br><span class="line"><span class="comment">/*因为要离散化,所以要提前读取所有操作*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,k;<span class="comment">//查询操作,询问区间[l,r]内第k大数的值</span></span><br><span class="line">    <span class="keyword">int</span> p,x;    <span class="comment">//修改操作,修改位置p位置上的元素为x</span></span><br><span class="line">&#125;qy[N];</span><br><span class="line"><span class="keyword">int</span> sz = N;<span class="comment">/*不同版本的线段树总数,</span></span><br><span class="line"><span class="comment">即动态申请节点编号,初始值要为N,因为前n个节点被使用*/</span></span><br><span class="line"><span class="keyword">int</span> a[N],n,m,tot = <span class="number">0</span>;<span class="comment">//tot离散化用</span></span><br><span class="line"><span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*对以rt为根的线段树,区间[l,r]内新增一个元素x*/</span></span><br><span class="line">    sum(rt) += d;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>; <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!ls(rt)) ls(rt) = ++sz;<span class="comment">//如果该子树没有子节点则新建</span></span><br><span class="line">    <span class="keyword">if</span>(!rs(rt)) rs(rt) = ++sz;<span class="comment">//动态申请节点</span></span><br><span class="line">    <span class="keyword">if</span>(p &lt;= mid) Insert(ls(rt),l,mid,p,d);</span><br><span class="line">    <span class="keyword">else</span> Insert(rs(rt),mid+<span class="number">1</span>,r,p,d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> p,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*向树状数组中的 线段树中 位置p值+d,要从l开始哦*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = l;x &lt;= n;x += x&amp;-x) Insert(x,<span class="number">1</span>,tot,p,y); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t1[N],t2[N],c1,c2;<span class="comment">//临时记录遍历路径</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*返回区间[l,r]内第k大元素的值(离散化后的)*/</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c1;i++) res -= sum(ls(t1[i]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c2;i++) res += sum(ls(t2[i]));</span><br><span class="line">    <span class="keyword">if</span>(res &gt;= k)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c1;i++) t1[i] = ls(t1[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c2;i++) t2[i] = ls(t2[i]);</span><br><span class="line">    <span class="keyword">return</span> ask(l,mid,k);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c1;i++) t1[i] = rs(t1[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c2;i++) t2[i] = rs(t2[i]);</span><br><span class="line"><span class="keyword">return</span> ask(mid+<span class="number">1</span>,r,k-res);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp[N*<span class="number">2</span>];<span class="comment">//离散化用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">c1 = c2 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*我们将树状数组上待查询的线段树的左儿子编号先存储*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l;i;i -= i&amp;-i) t1[++c1] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = r;i;i -= i&amp;-i) t2[++c2] = i;</span><br><span class="line"><span class="keyword">int</span> x = ask(<span class="number">1</span>,tot,k);<span class="comment">//注意查询区间是[1,tot] </span></span><br><span class="line"><span class="keyword">return</span> tmp[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i),tmp[++tot] = a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'C'</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;qy[i].p,&amp;qy[i].x);</span><br><span class="line">            tmp[++tot] = qy[i].x;<span class="comment">//先存储,方便离散化</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;qy[i].l,&amp;qy[i].r,&amp;qy[i].k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//离散化</span></span><br><span class="line">    sort(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot);</span><br><span class="line">    tot = unique(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot)-tmp<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p = lower_bound(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot,a[i])-tmp;</span><br><span class="line">        add(i,p,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(qy[i].l)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = qy[i].l, r = qy[i].r;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(l<span class="number">-1</span>,r,qy[i].k));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> p = lower_bound(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot,qy[i].x)-tmp;</span><br><span class="line">            <span class="keyword">int</span> pre = lower_bound(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot,a[qy[i].p])-tmp;</span><br><span class="line">            add(qy[i].p,pre,<span class="number">-1</span>); add(qy[i].p,p,<span class="number">1</span>); a[qy[i].p] = qy[i].x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;主席树，又称可持久化线段树，属于可持久化数据结构。“主席”这一名词是由于发明者缩写为HJT，和某位主席拼音缩写相同（有些牵强），故将该数据结
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>权值线段树</title>
    <link href="http://valenshi.top/2019/08/27/qz-tree/"/>
    <id>http://valenshi.top/2019/08/27/qz-tree/</id>
    <published>2019-08-27T04:38:59.000Z</published>
    <updated>2019-08-27T04:40:08.779Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>权值线段树是在普通线段树的基础上进行更改，利用值域建树而非定义域（下标）；这使得线段树具有了一些新的功能，本文就将从权值线段树的来历，用途以及算法流程方面来介绍该数据结构。最终我们会用两个例题来体现权值线段树的用途，当然该代码也作为参考模板。</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>线段树是将下标不断二分，使得树上每个节点对应一段区间，从而将区间操作拆分成有关若干节点的操作。权值线段树与之类似，都是将一段区间不断二分，并令树上每个节点对应一段区间，以此实现“将区间操作变为对树上某条路径的操作”，只不过这里划分的区间不再是下标，而是权值。</p><p>至此其实权值线段树的特点已经很明显了，一般的线段树对下标建树，而权值线段树对权值建树；普通线段树对下标上的值进行操作（加减乘除），而权值线段树对值所对应的下标进行操作。</p><h4 id="权值线段树的用途"><a href="#权值线段树的用途" class="headerlink" title="权值线段树的用途"></a>权值线段树的用途</h4><p>这就好比一个是对 <strong>定义域</strong> 建树，而另一个是对 <strong>值域</strong> 建树，所以权值线段树具有如下用途：</p><ul><li>统计范围内元素的个数（这里的范围是指值域上的范围，例如：求逆序对）。</li><li>查询序列中，下标大于r的 第一个大于 k 的数。</li></ul><p>只是对线段树进行简单的更改，就使其拥有了这些功能（虽然这些功能其它数据结构也能实现），可见线段树的灵活性。</p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>第一步：通常元素的值域范围很大，但是个数很少，所以一般会先对这n个数离散化处理，处理之后就只有tot个不同的值([1 , tot])。</p><p>第二步：对区间[1, tot]建立线段树。</p><p>第三步：按照题意进行操作。</p><h4 id="例题1：求逆序对"><a href="#例题1：求逆序对" class="headerlink" title="例题1：求逆序对"></a>例题1：求逆序对</h4><p><a href="https://www.luogu.org/problem/P1908" target="_blank" rel="noopener">测试地址：洛谷P1908</a><br>虽然我们有更好的求逆序对的方法，例如归并、CDQ分治、树状数组等，但是这题其实也很好的体现权值线段树的思路，作为入门还是很好理解的。</p><p>首先我们将较为分散的n个元素按照权值离散化，离散化之后这n个元素取值范围（映射集合）就在[1,tot]之间，而若  i &gt; j，那么 i 代表的元素一定比 j 代表的元素大。</p><p>接下来从前向后遍历原数组的n个元素，找到其离散化后的标号i，再统计线段树中&gt;i的元素个数有多少个，累加到答案即可。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">权值线段树模板 最后修改:2019/8/25 </span></span><br><span class="line"><span class="comment">洛谷P1908:给出n个数求逆序对数量 </span></span><br><span class="line"><span class="comment">由于值域过于分散,且数字太大,采用离散化方法 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,sum;</span><br><span class="line"><span class="comment">/* 左端点,右端点,[l,r]内元素总数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[x].sum</span></span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ll val;<span class="keyword">int</span> id;</span><br><span class="line"><span class="comment">/*元素的值,序号,用于离散化*/</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; rhs)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &lt; rhs.val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;tmp[N]; </span><br><span class="line"><span class="keyword">int</span> n,tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*对[l,r]建立一棵子树,该子树根节点是rt*/</span></span><br><span class="line">l(rt) = l, r(rt) = r, sum(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid);</span><br><span class="line">BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">/*查询大于等于y的数的个数*/</span> </span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt)) <span class="keyword">return</span> sum(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(y &lt;= mid) <span class="keyword">return</span> ask(rt*<span class="number">2</span>,y)+sum(rt*<span class="number">2</span>+<span class="number">1</span>); <span class="comment">//加上整段右区间 </span></span><br><span class="line"><span class="keyword">return</span> ask(rt*<span class="number">2</span>+<span class="number">1</span>,y);<span class="comment">//答案在右子树 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将p位置+1*/</span></span><br><span class="line"><span class="keyword">if</span>(l(rt) &lt;= p &amp;&amp; p &lt;= r(rt)) sum(rt)++;</span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt)) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= mid) updata(rt*<span class="number">2</span>,p);</span><br><span class="line"><span class="keyword">else</span> updata(rt*<span class="number">2</span>+<span class="number">1</span>,p);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//首先离散化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) tmp[i].val = a[i],tmp[i].id = i; </span><br><span class="line">sort(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+n); tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">1</span> || tmp[i].val != tmp[i<span class="number">-1</span>].val) ++tot;</span><br><span class="line">a[tmp[i].id] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//离散化之后值域[1,tot],以此为区间建树</span></span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,tot); </span><br><span class="line"><span class="comment">//下一步就是查询与更新了</span></span><br><span class="line">ll ans = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ans += ask(<span class="number">1</span>,a[i]+<span class="number">1</span>);<span class="comment">//在前i-1个数中,比a[i]大的有多少</span></span><br><span class="line">updata(<span class="number">1</span>,a[i]);<span class="comment">//值为a[i]的数+1 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="例题2：2019CCPC网络赛-B-array"><a href="#例题2：2019CCPC网络赛-B-array" class="headerlink" title="例题2：2019CCPC网络赛 B.array"></a>例题2：2019CCPC网络赛 B.array</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6703" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定1~n共n个数组成的序列，有m次操作，每次操作有两种可能：</p><ol><li>(1,pos)令 $a_{pos} = a_{pos}+1,000,000$。</li><li>(2, r , k) 回答不在$a_i(1&lt;= i &lt;= r)$内的，大于等于k的最小值。</li></ol><p>强制在线。<br><strong>解题思路：</strong><br>首先是理解题意，然后如果按照题目要求来解题，我们需要每次都通过遍历来排除[1,r]内的元素，显然会超时。由于题目中$a_i$是各不相同的，又是小于n的，因此我们可以将原问题转化为求“大于等于k的所有元素中，第一个下标大于r的元素的值”。对于这个问题我们每次需要询问所有值在[k,n+10]内，第一个下标大于r的即可。</p><p>于是我们可以通过建立权值线段树，线段树的下标是值$a_i$，值是下标i，对于每个操作1，就相当于把pos位置上的数删掉了。加上一些小剪枝就可以过。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="comment">/*区间[l,r]内元素个数为sum*/</span></span><br><span class="line"><span class="keyword">int</span> l,r,sum,mx;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mx(x) tr[x].mx</span></span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="comment">/*a数组存放序列,b数组离散化用</span></span><br><span class="line"><span class="comment">tot是离散化后不同元素个数 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ll a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> n,m,tot,t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*对[l,r]建立一棵根为rt的子树*/</span></span><br><span class="line">l(rt) = l, r(rt) = r , mx(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid);</span><br><span class="line">BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="comment">/*p位置值+1(值为p的元素的数量+1)*/</span></span><br><span class="line"><span class="comment">//printf("%d %d %d %d %d\n",rt,l(rt),r(rt),p,d);</span></span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">mx(rt) = d; <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= mid) Insert(rt*<span class="number">2</span>,p,d);</span><br><span class="line"><span class="keyword">else</span> Insert(rt*<span class="number">2</span>+<span class="number">1</span>,p,d); </span><br><span class="line">mx(rt) = max(mx(rt*<span class="number">2</span>),mx(rt*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> k,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">//printf("%d %d %d %d %d %d\n",rt,l(rt),r(rt),k,r,mx(rt));</span></span><br><span class="line"><span class="comment">/*返回[k,n]中第一个大于r的值*/</span></span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line"><span class="keyword">if</span>(mx(rt) &lt;= r) <span class="keyword">return</span> -INF;</span><br><span class="line"><span class="keyword">return</span> l(rt);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(k &lt;= mid &amp;&amp; mx(rt*<span class="number">2</span>) &gt; r) res = ask(rt*<span class="number">2</span>,k,r);</span><br><span class="line"><span class="keyword">if</span>(res &lt;= <span class="number">0</span>) <span class="keyword">return</span> ask(rt*<span class="number">2</span>+<span class="number">1</span>,k,r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,a+i);</span><br><span class="line">Insert(<span class="number">1</span>,a[i],i);<span class="comment">//a[i]下标为 i </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n+<span class="number">1</span>;i &lt;= n+<span class="number">10</span>;i++) Insert(<span class="number">1</span>,i,INF);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,op,pos,r,k;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op);</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;pos);</span><br><span class="line">pos ^= ans;</span><br><span class="line">Insert(<span class="number">1</span>,a[pos],INF);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;r,&amp;k);</span><br><span class="line">k ^= ans, r ^= ans;</span><br><span class="line">ans = ask(<span class="number">1</span>,k,r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;权值线段树是在普通线段树的基础上进行更改，利用值域建树而非定义域（下标）；这使得线段树具有了一些新的功能，本文就将从权值线段树的来历，用途以
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构域算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%9F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
