<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ValenShi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://valenshi.top/"/>
  <updated>2019-11-16T03:46:50.788Z</updated>
  <id>http://valenshi.top/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>STL之map容器速率测试</title>
    <link href="http://valenshi.top/2019/11/16/mapDemo/"/>
    <id>http://valenshi.top/2019/11/16/mapDemo/</id>
    <published>2019-11-16T03:46:09.000Z</published>
    <updated>2019-11-16T03:46:50.788Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>不止一次在使用 map 时被卡时限，map 是 c++ 的 STL 中一个常用且方便的容器，其是基于树来实现的，它的插入与查找效率实际上更接近O(log N )（N为插入的元素个数）。当然在 c++ 的 STL 中还有用哈希实现的无序关联容器，这里不做讨论。<br>在实际应用中，常常会有人把 map 时间复杂度看作O(1)，确实在大多数时候 map 表现是令人满意的，但在大量使用的时候，map却不尽人意。</p><p>我们将测试如下几种情形下使用 map 容器的效率（时间）：</p><ul><li>仅插入元素（元素类型为int）</li><li>插入以及查找（元素类型为int）<h4 id="测试环境准备"><a href="#测试环境准备" class="headerlink" title="测试环境准备"></a>测试环境准备</h4></li></ul><p>为了给定一个对照的标准，先给出如下数据：</p><ul><li>测试机空循环 1e6 次平均花费 0.0641 s</li><li>测试机读取 1e6 个int型数据（快读+从文件输入）平均花费 0.2142 s</li></ul><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><h5 id="仅插入元素"><a href="#仅插入元素" class="headerlink" title="仅插入元素"></a>仅插入元素</h5><p><strong>本机平均花费时间：</strong> 1.1015 s<br><strong>测试代码</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> gap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">mp[i*gap%P] = <span class="number">1</span>; gap += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="插入以及查找元素"><a href="#插入以及查找元素" class="headerlink" title="插入以及查找元素"></a>插入以及查找元素</h5><p><strong>本机平均花费时间：</strong> 1.238 s<br><strong>测试代码</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> gap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">mp[i*gap%P] = <span class="number">1</span>; gap += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(mp.count(i));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总体上测试结果是符合预期的，虽然 STL 容器已经很优化的，但是毕竟还是用树来实现的，达不到 O(1) 的时间复杂度，所以如果是对时限要求很高的话，最好还是采用手动写哈希表。<br>上述设计的实验有很多缺陷，如未对 long long转化、取模 以及其它多余的操作进行排除影响，另外本来还测试了char、string、set等类型的元素，但是要设计一个好的测试代码太麻烦了，就删了，总的结论来说就是 int 是所有测试的数据类型中最慢的一种（甚至慢于 set 和 string ，如果只考虑插入和查找）。<br>最终结论就是如果需要一个 O(1) 时间复杂度的插入和查找（int 类型的元素），那么就用哈希表。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;不止一次在使用 map 时被卡时限，map 是 c++ 的 STL 中一个常用且方便的容器，其是基于树来实现的，它的插入与查找效率实际上更接
      
    
    </summary>
    
    
      <category term="map" scheme="http://valenshi.top/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>最大流笔记</title>
    <link href="http://valenshi.top/2019/11/15/maxFlow/"/>
    <id>http://valenshi.top/2019/11/15/maxFlow/</id>
    <published>2019-11-15T05:19:48.000Z</published>
    <updated>2019-11-15T05:21:49.131Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>正如可以通过将道路交通图模型化为有向图来找到从一个城市到另一个城市之间的最短路，我们也可以将一个有向图看作一个“流网络”，并使用它来回答关于物料流动方面的问题。这种流网络可以用来建模很多实际问题，包括液体在管道中的流动、装配线上的部件的流动、电网中电流的流动和通信网络中信息的流动。<br>本文首先介绍网络流中的相关概念，然后给出最大流问题的一般解法思路，以及优化后的算法。我们应该将主要精力放在思维锻炼和题目分析上，而不要过于执着于那些经典算法的细节优化。本文中整理的算法在算法竞赛中已经够用。</p><h4 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h4><p><strong>流网络：</strong> 流网络 G = (V , E) 是一个有向图，图中每条边 (u , v) 都有一个非负的<strong>容量值c(u , v)</strong> 。而且，如果边集合 E 包含一条边(u , v) ，则图中不存在反向边(v , u)。</p><p><strong>源节点s和汇点t：</strong> 在流网络的所有节点中，我们分辨出两个特殊的节点，分别是源点s和汇点t；源点是所有路径的起点，而汇点是路径的终点。在某些情况下，源点和汇点需要人为指定。</p><p><strong>流网络 G 中的流：</strong> G中流的大小（值）用 f 表示，f(u , v)表示从点 u 到点 v 的流的大小。整张图的流是 $|f| = \sum_{v \epsilon V}f(s, v) - \sum_{v \epsilon V}f(v ,s)$（前后两个 v 含义不同），即从源点 s 流出的流量和，或称为流入汇点 t 的流量和。</p><p><strong>容量限制：</strong> 对于所有的节点$u, v \epsilon V$，要求$0 &lt;= f(u , v) &lt;= c(u , v)$<br><strong>流量守恒：</strong> 对于所有的节点 $u \epsilon V$ - { s , t }，要求流入 u 的流量等于流出 u 的流量，即：</p><script type="math/tex; mode=display">\sum_{v \epsilon V}f(v,u) = \sum_{v \epsilon V}f(u,v)</script><p>（前后两个 v 的含义不同，一个是入边的起点，一个是出边的终点）</p><p><strong>问题模型：</strong> 在最大流问题中，给定一个流网络G 、一个源节点s、一个汇点t，我们希望找到值最大的一个流。</p><h4 id="Edmonds-Karp算法"><a href="#Edmonds-Karp算法" class="headerlink" title="Edmonds-Karp算法"></a>Edmonds-Karp算法</h4><p>若一条从源点 s 到汇点 t 的路径上的各条边的剩余容量都大于 0，则称这条路径为一条增广路径。显然，可以让一股流沿着增广路径从 s 流到 t，使网络的流量增大。Edmonds-Karp算法思想就是不断用BFS寻找增广路，直至网络上不存在增广路为止。<br>该算法的时间复杂度为$O(nm^2)$。然而在实际运用中则远远达不到这个上界，效率较高，一般能够处理 $10^3 - 10^4$规模的网络。</p><p><strong>算法思路：</strong><br>这里介绍的是利用 bfs 寻找增广路的Edmonds-Karp增广路算法。在该算法中，我们不断的寻找增广路，并增加增广路上的流；重复这一步骤直至不存在增广路。<br>在每轮寻找增广路的过程中，Edmonds-Karp算法只考虑图中所有 f(x ,y) &lt; c(x, y)的边，用BFS找到任意一条从 s 到 t 的路径，同时计算出路径上各边的剩余容量的最小值 minf，则网络的流量就可以增加 minf。</p><p>需要注意的是，当一条边的流量 f(x ,y) &gt; 0时，根据斜对称性质，它的反向边流量 f(y ,x) &lt; 0，此时必定有 f(y , x) &lt; c(y ,x)。故Edmonds-Karp算法在BFS时除了原图的边集 E 外，还应考虑遍历 E 中每条边的反向边。<br>具体实现时，本文采用邻接表“成对存储”技巧（即’2’和’3’是一对，’4’和’5’是一对）。每条边只记录剩余容量 c-f 即可，当一条边 (x ,y) 流过大小为 e 的流时，令 (x ,y) 的容量减少 e，(y ,x) 的容量增加 e 。</p><p><strong>代码模板：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;<span class="comment">//最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e3</span>+<span class="number">10</span>;<span class="comment">//最大边数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;<span class="comment">//int范围内的无穷大</span></span><br><span class="line"><span class="keyword">int</span> head[N], edge[M], ver[M], nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;<span class="comment">// 共n个点,m条边,s是源点,t是汇点</span></span><br><span class="line"><span class="keyword">int</span> pre[N],incf[N];<span class="comment">//增广路上各边的最小剩余容量</span></span><br><span class="line"><span class="keyword">bool</span> vis[N];<span class="comment">//标记数组</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(s); vis[s] = <span class="literal">true</span>;</span><br><span class="line">incf[s] = INF;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(!z || vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">incf[y] = min(incf[x],z);</span><br><span class="line">pre[y] = i;<span class="comment">//记录前驱*边*</span></span><br><span class="line">q.push(y); vis[y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(y == t) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//找到一条增广路</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回最大流的值*/</span></span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(bfs())&#123;</span><br><span class="line"><span class="keyword">int</span> x = t;</span><br><span class="line"><span class="keyword">while</span>(x != s)&#123;</span><br><span class="line"><span class="keyword">int</span> i = pre[x];<span class="comment">//前驱 *边* </span></span><br><span class="line">edge[i] -= incf[t];</span><br><span class="line">edge[i^<span class="number">1</span>] += incf[t];</span><br><span class="line">x = ver[i^<span class="number">1</span>];<span class="comment">//前驱点 = 反向边的终点</span></span><br><span class="line">&#125;</span><br><span class="line">flow += incf[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addEdge(x,y,z); addEdge(y,x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,EK());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>算法正确性需要用到最小割来证明，详见《挑战程序设计竞赛第二版》P212。</p><h4 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h4><p> 在任意时刻，网络中所有节点以及剩余容量大于0的边构成的子图被称为残量网络。Edmonds-Karp每轮可能会遍历整个残量网络，但只找出 1 条增广路，还有进一步优化的空间。<br> 在宽度优先遍历时，我们可以计算出<strong>节点的层次d[x]</strong> ，它表示 s 到 x 最少需要经过的边数。在残量网络中，满足d[y] = d[x] + 1 的边(x ,y) 构成的子图被称为<strong>分层图</strong> 。分层图显然是一张有向无环图。</p><p> Dinic 算法不断重复以下步骤，直到残量网络中 s 不能到达 t：</p><ol><li>在残量网络上 BFS 求出节点的层次，构造分层图</li><li>在分层图上 DFS 寻找增广路，在回溯时实时更新剩余容量。另外，每个点可以流向多条出边，同时还加入了若干剪枝，详情参考代码示例。</li></ol><p>Dinic 算法的时间复杂度是$O(n^2m)$。实际运用中远远达不到这个上界，可以说是比较容易实现的效率最高的网络流算法之一，一般能够处理$10^4 - 10^5$规模的网络。特别地，Dinic算法求解二分图最大匹配的时间复杂度为$O(m\sqrt n)$，实际表现则更快。</p><p> <strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;<span class="comment">//int所能表示的最大范围的一半</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5</span>*N;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[M],ver[M],nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> d[N];<span class="comment">//记录节点的层次</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*利用bfs来求出节点的层次，构造分层图*/</span></span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="keyword">while</span>(q.size()) q.pop();</span><br><span class="line">q.push(s); d[s] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(q.size())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(!z || d[y]) <span class="keyword">continue</span>;</span><br><span class="line">q.push(y);</span><br><span class="line">d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(y == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 利用递归在分层图上找增广路,返回本次增广的流量 */</span></span><br><span class="line"><span class="keyword">if</span>(x == t) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> res = flow, k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(z &amp;&amp; d[y] == d[x]+<span class="number">1</span>)&#123;</span><br><span class="line">k = dinic(y,min(res,z));<span class="comment">//递归</span></span><br><span class="line"><span class="keyword">if</span>(!k) d[y] = <span class="number">0</span>;<span class="comment">//剪枝,去掉增广完毕的点</span></span><br><span class="line">edge[i] -= k; edge[i^<span class="number">1</span>] += k;</span><br><span class="line">res -= k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow - res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addEdge(x,y,z); addEdge(y,x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>,maxflow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(bfs())</span><br><span class="line"><span class="keyword">while</span>(flow = dinic(s,INF)) maxflow += flow;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,maxflow);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="ISAP算法"><a href="#ISAP算法" class="headerlink" title="ISAP算法"></a>ISAP算法</h4><p>ISAP算法没有正式的名称，首次出现于 Ahuja和Orlin的经典教材《Network Flows：Theory，Algorithms and Applications》中，作者称它是一种：改进版的SAP（Improved SAP，ISAP）“。</p><p>该算法基于这样一个事实：每次增广后，任意节点到汇点（在残量网络中）的最短距离都不会减小。这样，我们可以用一个函数d(x)来表示残量网络中节点 x 到汇点的距离的下界（在Dinic中是用数组 d[]），然后在增广过程中不断修正这个下界（而不是像Dinic 算法那样多次增广以后才重建层次图），则增广的时候和 Dinic 类似，只允许沿着 d(y) = d(x) + 1 的有向边 (x , y) 走。</p><p>严格的说，算法中的 d 函数是满足如下两个条件的非负函数，即 d(t) = 0；对于残量网络中的任意弧 (x ,y)，d(x) &lt;= d(y) + 1。不难证明，只要满足这两个条件，d(x) 就是 x~t 距离的下界。而且当 d(s) &gt;= n时，残量网络中不存在 s-t 路。</p><p><strong>算法思路</strong><br>和 Dinic 算法类似，找增广路的过程是从 s 开始沿着“允许弧”（即在残量网络中的，满足 d[x] = d[y] + 1 的弧 x —&gt; y）往前走（ISAP 算法中叫Advance）如果走不动了怎么办？在Dinic算法中，直接“往回走一步”即可，因为如果找不到增广路，会重新构造层次图；但在ISAP中，并没有一个“一次性修改所有距离标号”的过程，只能边增广边修改。具体来说，在从结点 x 往回走的时候，把 d(x) 修改为 min{d(y) | (x , y)  是残量网络中的弧 } + 1（ISAP算法叫 Retreat）即可。注意，如果残量网络中从 x 出发没有弧，则设 d(x) = n。<br>ISAP算法看上去不难理解，但是实现起来却有诸多细节。首先，我们需要使用一种“当<br>前弧”的数据结构加速 允许弧 的査找，其次，还需要一个 gap 数组维护每个距离标号<br>结点编号。当把一个结点的距离标号从 x 改成 y 的时候,把 gap[x] 减1,gap[y]加1,然后<br>检查 gap[x] 是否为0。如果是 0 的话,说明 s-t 不连通，算法终止。这就是所谓的 gap 优化。最后，初始距离标号可以统一设为 0 ，也可以用逆向BFS找，单次运行时效率相差不大，但如果是多次求解小规模网络流，加上BFS以后速度往往会有明显提升。</p><p>数据结构方面，只多了两个数组：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[N];        <span class="comment">//可增广路的上一条弧</span></span><br><span class="line"><span class="keyword">int</span> gap[N];       <span class="comment">//距离标号计数</span></span><br></pre></td></tr></table></figure></p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5</span>*N;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">/*以下6行是数组模拟邻接表部分*/</span></span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot;</span><br><span class="line"><span class="keyword">int</span> cur[N],dis[N],gap[N],pre[N];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gap[k]:k层有多少个节点</span></span><br><span class="line"><span class="comment">pre[x]:x点前一条边的编号</span></span><br><span class="line"><span class="comment">cur[]是临时数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y, edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;</span><br><span class="line"><span class="keyword">int</span> que[N],front,rear;<span class="comment">//手工模拟队列，节省部分时间</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">front = rear = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">dis[i] = <span class="number">-1</span>,cur[i] = head[i],gap[i]= <span class="number">0</span>;</span><br><span class="line">dis[t] = <span class="number">0</span>;  que[rear++] = t;</span><br><span class="line"><span class="keyword">while</span>(front != rear)&#123;</span><br><span class="line"><span class="keyword">int</span> x = que[front++];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(dis[y] == <span class="number">-1</span>) </span><br><span class="line">que[rear++] = y, dis[y] = dis[x] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ~dis[t];<span class="comment">//-1的补码是11111111,按位取反后是0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ISAP</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = s, ans = <span class="number">0</span>, i;<span class="comment">//时刻注意i不能被覆盖！！！</span></span><br><span class="line">bfs(n);<span class="comment">//一次bfs从汇点向前更新层次数组dis</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= n;i++) gap[dis[i]]++;</span><br><span class="line"><span class="keyword">while</span>(dis[s] &lt; n)&#123;</span><br><span class="line"><span class="keyword">if</span>(k == t)&#123;</span><br><span class="line"><span class="keyword">int</span> mi = INF, loc = t;</span><br><span class="line"><span class="keyword">while</span>(loc != s)&#123;</span><br><span class="line">mi = min(mi,edge[pre[loc]]);</span><br><span class="line">loc = ver[pre[loc]^<span class="number">1</span>];<span class="comment">//前一个顶点</span></span><br><span class="line">&#125;</span><br><span class="line">loc = t;</span><br><span class="line"><span class="keyword">while</span>(loc != s)&#123;</span><br><span class="line">edge[pre[loc]] -= mi;</span><br><span class="line">edge[pre[loc]^<span class="number">1</span>] += mi;</span><br><span class="line">loc = ver[pre[loc]^<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">ans += mi, k = s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = cur[k];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(z &amp;&amp; dis[k] == dis[y]+<span class="number">1</span>)&#123;</span><br><span class="line">pre[y] = cur[k] = i; k = y;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> m = n;</span><br><span class="line"><span class="keyword">for</span>(i = head[k];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(z &amp;&amp; dis[y] &lt; m) m = dis[y], cur[k] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(--gap[dis[k]] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">dis[k] = m+<span class="number">1</span>, ++gap[dis[k]];</span><br><span class="line"><span class="keyword">if</span>(k != s) k = ver[pre[k]^<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;s,&amp;t))&#123;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">0</span> ,<span class="keyword">sizeof</span> head); tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addEdge(x,y,z); addEdge(y,x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ISAP(n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>刘汝佳，算法竞赛入门经典训练指南，北京：清华大学出版社，2012，362-363.</li><li>李煜东，算法竞赛进阶指南，郑州：河南电子音像出版社，2017，410-415.</li><li>秋叶拓哉，挑战程序设计竞赛第2版，北京：人民邮电出版社，2013，209-215.</li><li>Thomas H.Cormen，算法导论（原书第3版），北京：机械工业出版社，2013，414-417.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;正如可以通过将道路交通图模型化为有向图来找到从一个城市到另一个城市之间的最短路，我们也可以将一个有向图看作一个“流网络”，并使用它来回答关于
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://valenshi.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最大流" scheme="http://valenshi.top/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>伙伴算法</title>
    <link href="http://valenshi.top/2019/11/13/buddy-system/"/>
    <id>http://valenshi.top/2019/11/13/buddy-system/</id>
    <published>2019-11-13T12:13:59.000Z</published>
    <updated>2019-11-13T12:16:54.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="伙伴系统（Buddy-System）"><a href="#伙伴系统（Buddy-System）" class="headerlink" title="伙伴系统（Buddy System）"></a>伙伴系统（Buddy System）</h4><p><strong>伙伴系统的特点</strong></p><ul><li>整个可分配的分区大小为 $2^u$。</li><li>需要的分区大小为 $2^{u-1} &lt; s &lt;= 2^u$时，把整个块分配给该进程。</li></ul><p><strong>分配分区的过程：</strong><br>如果 $s &lt;= 2^{i-1}$，则将大小为$2^i$的当前空闲分区划分为两个大小为$2^{i-1}$的空闲分区<br>重复划分过程，直至$2^{i-1} &lt; s &lt;= 2^i$，并把一个空闲分区分配给该进程。</p><h4 id="伙伴系统的实现"><a href="#伙伴系统的实现" class="headerlink" title="伙伴系统的实现"></a>伙伴系统的实现</h4><p><strong>数据结构：</strong></p><ul><li>空闲块按照大小和起始地址组成二维数组。</li><li>初始状态：只有一个大小为$2^u$的空闲块。</li></ul><p><strong>分配过程：</strong></p><ul><li>由大到小在空闲块数组中找到最小的可用空闲块。</li><li>如果空闲块过大，对可用的空闲块进行二等分，直到得到合适的可用的空闲块。</li></ul><p><strong>分配样例图示：</strong><br><img src="/2019/11/13/buddy-system/1.png" alt="1"></p><p><strong>释放过程：</strong></p><ul><li>把释放的空闲块放入空闲数组</li><li>合并满足合并条件的空闲块</li></ul><p><strong>合并条件：</strong></p><ul><li>大小相同，例如都是$2^i$</li><li>地址相邻</li><li>低地址空闲块起始地址为$2^{i+1}$的位数</li></ul><h4 id="伙伴算法的优缺点"><a href="#伙伴算法的优缺点" class="headerlink" title="伙伴算法的优缺点"></a>伙伴算法的优缺点</h4><p><strong>优点：</strong></p><ul><li>较好的解决外部碎片问题</li><li>当需要分配若干个内存页面时，用于DMA的内存页面必须连续，伙伴算法很好的满足了这个要求</li><li>只要请求的块不超过512个页面（2k），内核就尽量分配连续的页面。</li><li>针对大内存分配设计</li></ul><p><strong>缺点：</strong></p><ul><li>合并的要求过于严格，只能是满足伙伴关系的块才能合并</li><li>碎片问题：一个连续的内存中仅仅一个页面被占用，导致整个内存区都不具备合并条件</li><li>浪费问题：伙伴算法只能分配2的幂次方内存区，当需要的内存为$2^i+1$ K 时，例如需要 9K 时，就需要分配16K的内存空间，剩下的 7K 浪费了。</li><li>算法的效率问题：伙伴算法中涉及了比较多的计算还有链表和位图的操作，开销比较大，如果每次合并$2^n$大小的块为$2^{n+1}$的小，那么大小为$2^n$的块会减少，如果随后系统又需要$2^n$大小的块，就又要拆分，这样的立即合并和拆分过程无效率。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;伙伴系统（Buddy-System）&quot;&gt;&lt;a href=&quot;#伙伴系统（Buddy-System）&quot; class=&quot;headerlink&quot; title=&quot;伙伴系统（Buddy System）&quot;&gt;&lt;/a&gt;伙伴系统（Buddy System）&lt;/h4&gt;&lt;p&gt;&lt;stron
      
    
    </summary>
    
      <category term="计算机操作系统" scheme="http://valenshi.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="内存分配" scheme="http://valenshi.top/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下vim简单入门</title>
    <link href="http://valenshi.top/2019/10/26/vim-use/"/>
    <id>http://valenshi.top/2019/10/26/vim-use/</id>
    <published>2019-10-26T02:34:59.000Z</published>
    <updated>2019-10-26T02:36:02.627Z</updated>
    
    <content type="html"><![CDATA[<h4 id="安装vim"><a href="#安装vim" class="headerlink" title="安装vim"></a>安装vim</h4><p>在ubuntu的命令行下输入<code>sudo apt install vim</code> 以获得vim。如遇到报错，可复制报错信息去百度寻找对应解决策略。</p><h4 id="vim的使用"><a href="#vim的使用" class="headerlink" title="vim的使用"></a>vim的使用</h4><p>vim编辑器有三种：命令模式，末行模式，插入模式。</p><p>打开vim时默认的是<strong>命令模式</strong>，此状态下敲击键盘视为输入命令而非字符。若想进入<strong>插入模式</strong>，则要在命令模式下输入 i ，此时可以输入字符，编辑文本；输入完毕后，按ESC可退回到命令模式。<br>命令模式只有一些简单的命令，更多命令需要使用末行模式；在命令模式下输入” : “（不含引号）可进入末行模式，末行模式可以进行更多灵活的操作。</p><p>以上是三种模式的异同以及切换方法。</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>以下复制老师的笔记：</p><p><strong>模式切换</strong></p><ol><li>输入i进入插入模式</li><li>在插入模式中按ESC进入命令模式</li><li>在命令模式中输入 “ : “ 进入末行模式</li></ol><p><strong>保存：</strong></p><ol><li>命令模式中输入ZZ</li><li>在末行模式中输入:wq</li></ol><p><strong>编译：</strong></p><ol><li>g++ -o test test.cpp -Wall</li></ol><p><strong>定位：</strong></p><ol><li>:i 定位到第 i 行</li><li>:/x 定位到x第一次出现的行</li></ol><p><strong>删除行（命令模式下）：</strong></p><ol><li>dd删除当前行</li><li>d2d删除包含当前行的2行，向下的</li></ol><p><strong>撤回：</strong></p><ol><li>命令模式下输入 u</li></ol><p><strong>复制（命令模式下）：</strong></p><ol><li>yy，与dd功能相似</li><li>粘贴时按p</li></ol><h4 id="配置vim"><a href="#配置vim" class="headerlink" title="配置vim"></a>配置vim</h4><p>此时vim可以正常使用，但是界面有些不友好，没有行号，缩进也很难看，更没有自动补全等。<br>我们可以通过在末行模式中输入一些命令来使得界面以及操作更加友好，例如添加行号，设置缩进等，但是这样需要每次打开vim都要重新配置，所以为了方便起见，可以修改配置文件达到自动配置的目的。</p><p>首先通过 <code>cd ~</code> 进入用户根目录，然后<code>vim .vimrc</code> 新建一个隐藏文件<code>.vimrc</code>，并打开编辑；输入如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">set nu          //显示行号</span><br><span class="line">set ts=4        //制表符宽度</span><br><span class="line">set history=1000    </span><br><span class="line">set showmatch   //高亮显示匹配的括号</span><br><span class="line">set ruler       //显示尺寸</span><br><span class="line">set mouse=a     //启用鼠标选择</span><br><span class="line">set autoindent  //自动缩进</span><br><span class="line">set cindent     //自动缩进</span><br><span class="line">set nobackup    //禁止生成临时文件</span><br><span class="line">set smartindent //自动缩进</span><br><span class="line">set shiftwidth=4    //自动缩进的长度</span><br><span class="line">set expandtab   //tab变空格</span><br><span class="line"></span><br><span class="line">//以下是自动补全</span><br><span class="line">inoremap&#123; &#123;&#125;&lt;ESC&gt;i&lt;CR&gt;&lt;ESC&gt;O</span><br><span class="line">inoremap( ()&lt;ESC&gt;i</span><br><span class="line">inoremap[ []&lt;ESC&gt;i</span><br><span class="line">inoremap&apos; &apos;&apos;&lt;ESC&gt;i</span><br><span class="line">inoremap&quot; &quot;&quot;&lt;ESC&gt;i</span><br><span class="line"></span><br><span class="line">set encoding=utf-8</span><br><span class="line">set softtabstop=4</span><br><span class="line"></span><br><span class="line">//定义F6快捷编译运行，在命令模式下</span><br><span class="line">map &lt;F6&gt; :cal CR() &lt;CR&gt;</span><br><span class="line">func! CR()</span><br><span class="line">exec &quot;w&quot;</span><br><span class="line">exec &quot;!g++ % -o %&lt;&quot;</span><br><span class="line">exec &quot;! ./%&lt;&quot;</span><br><span class="line">endfunc</span><br></pre></td></tr></table></figure></p><p>输入完成后按ESC进入命令模式，再 :wq 保存退出即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;安装vim&quot;&gt;&lt;a href=&quot;#安装vim&quot; class=&quot;headerlink&quot; title=&quot;安装vim&quot;&gt;&lt;/a&gt;安装vim&lt;/h4&gt;&lt;p&gt;在ubuntu的命令行下输入&lt;code&gt;sudo apt install vim&lt;/code&gt; 以获得vim。如遇到
      
    
    </summary>
    
      <category term="Linux" scheme="http://valenshi.top/categories/Linux/"/>
    
    
      <category term="vim" scheme="http://valenshi.top/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>单调栈与单调队列</title>
    <link href="http://valenshi.top/2019/10/17/ddz/"/>
    <id>http://valenshi.top/2019/10/17/ddz/</id>
    <published>2019-10-17T05:42:19.000Z</published>
    <updated>2019-10-17T05:42:57.769Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>单调栈和单调队列都可以看作是一种对栈和队列的特殊用法，即要求栈或队列中的元素具有单调性，递增或递减。那么很显然这种数据结构就是基于栈和队列实现的，即它既保留了栈的先进后出（队列就是保留先进先出），又具有单调性。而我们在某些时候正需要其这种性质，我们在讲解了单调栈和单调队列的定义、特性、构造方法后，会各给出一道例题来体现它们的用法。</p><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><h5 id="单调栈的概念"><a href="#单调栈的概念" class="headerlink" title="单调栈的概念"></a>单调栈的概念</h5><p>单调栈是一种特殊的栈，栈内的所有元素都保持着单调性，即单调递增或单调递减。</p><h5 id="单调栈的性质"><a href="#单调栈的性质" class="headerlink" title="单调栈的性质"></a>单调栈的性质</h5><ul><li>单调性。若是单调递增栈，则从栈顶到栈底的元素是严格递增的。若是单调递减栈，则从栈顶到栈底的元素是严格递减的。</li><li>靠近栈底的元素先进栈，越靠后的元素越后进栈。</li></ul><p>单调栈和普通的栈一样，都只能在栈顶操作，压入或弹出。而我们需要通过一些约束来使得栈内元素具有单调性，从而构成单调栈。</p><h5 id="构造单调栈"><a href="#构造单调栈" class="headerlink" title="构造单调栈"></a>构造单调栈</h5><p>以单调递增栈为例：对于当前元素e，若e大于栈顶元素，则进栈，否则弹出栈顶元素，再次进行比较，重复直至栈顶元素小于e或栈为空为止，此时将e压入栈。<br>对于弹出的元素，我们并不需要重新压回，因为一般情况下它们都属于被“淘汰”的元素，后面压入的元素一般又“新鲜”又“美味”，即时间上和数值上都比其优秀。</p><h5 id="例题HDU1506"><a href="#例题HDU1506" class="headerlink" title="例题HDU1506"></a>例题HDU1506</h5><p>先思考一个问题，如果题目中的矩形的高度都是单调递增的，如何得到最优解？显然有一个贪心的策略，就是以每一个矩形的高度作为最终大矩形的高度，看最宽能是多少，然后统计最优解。<br>但如果进来的下一矩形比上一个低，它其实相当于限制了之前矩形的高度，那么之前矩形比这个矩形高出的高度在以后的统计中就没有丝毫用处了，如果我们在这个时候把以之前矩形的高度作为最终高度的答案统计掉，那么反正以后的统计和上一个矩形没有关系，还不如把他删除。<br>这样，我们实际上就得到了单调栈的模型，只需要维护一个单调栈，在维护单调性的弹出操作时统计宽度，更新答案即可在O(n) 时间内得到最优解。<br>为了方便把最后剩下的，以及单调递增的矩形也统计进去，我们假设a[n+1]的位置有一个高度为0的矩形，最后将它加入单调栈时他会将所有矩形都弹出，那么答案也就完成最后的更新了。</p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><p>见附录部分code-1</p><h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>单调队列的概念和单调栈类似，只是把先进后出改成先进先出就可以了。其具有先进先出的特性并且队列中元素具有单调性。<br>单调是一种思想，当我们解决问题的时候发现有许多冗杂无用的状态时，我们可以采用单调思想，用单调队列或类似于单调队列的方法去除冗杂状态，保存我们想要的状态。</p><h5 id="单调队列的性质"><a href="#单调队列的性质" class="headerlink" title="单调队列的性质"></a>单调队列的性质</h5><ul><li>单调队列的最优选择在队首。</li><li>队列元素具有单调性。</li><li>去除冗余状态（无用状态）。</li><li>维护区间最值。</li></ul><h5 id="单调队列的构造方法"><a href="#单调队列的构造方法" class="headerlink" title="单调队列的构造方法"></a>单调队列的构造方法</h5><ul><li>维护队首（对于上题就是如果队首已经是当前元素的m个之前，则队首就应该被删了,head++）</li><li>在队尾插入（每插入一个就要从队尾开始往前去除冗杂状态，保持单调性）</li></ul><p>假如对于序列A：a1,  a2 , … an 建立一个单调递减栈维护长度为m的字段最大值，那么对于当前元素e，若队首元素小于e，那么其位置上不占优势（要被踢出长度为m的字段），而且其数值上也不占优势（比新来的e要小），所以其就要被舍弃。重复这一操作，直至队首元素大于元素e，那么说明其还有用，就保留。<br>举个应用例子：</p><p>数列为：6 4 10 10 8 6 4 2 12 14<br>N=10,K=3;<br>那么我们构造一个长度为3的单调递减队列：<br>首先，那6和它的位置0放入队列中，我们用(6,0)表示，每一步插入元素时队列中的元素如下<br>插入6：(6,0);<br>插入4：(6,0),(4,1);<br>插入10：(10,2);<br>插入第二个10，保留后面那个：(10,3);<br>插入8：(10,3),(8,4);<br>插入6：(10,3),(8,4),(6,5);<br>插入4，之前的10已经超出范围所以排掉：(8,4),(6,5),(4,6);<br>插入2，同理：(6,5),(4,6),(2,7);<br>插入12：(12,8);<br>插入14：(14,9);<br>那么f(i)就是第i步时队列当中的首元素：6,6,10,10,10,10,8,6,12,14同理，最小值也可以用单调队列来做。</p><h5 id="例题Poj-2823"><a href="#例题Poj-2823" class="headerlink" title="例题Poj 2823"></a>例题Poj 2823</h5><p>给定一个数列，从左至右输出每个长度为m的数列段内的最小数和最大数。数列长度：$N&lt;=10^6，m&lt;=N$<br><strong>解题思路：</strong><br>我们知道，暴力枚举的过程中，有一个地方是重复比较了，就是在找当前的f(i)的时候，i的前面其它m-1个数在算f(i-1)的时候我们就比较过了。当你一个个往下找时，每一次都是少一个然后多一个，如果少的不是最大值，然后再问新加进来的，看起来很省时间对吧，那么如果少了的是最大值呢？第二个最大值是什么？？那么我们能不能保存上一次的结果呢？当然主要是i的前k-1个数中的最大值了。答案是可以，这就要用到单调队列。</p><h5 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h5><p>见附录部分code-2</p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><h5 id="code-1：-HDU1506"><a href="#code-1：-HDU1506" class="headerlink" title="code-1： HDU1506"></a>code-1： HDU1506</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],n,Stack[N],w[N];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="function">ll <span class="title">max</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(Stack,<span class="number">0</span>,<span class="keyword">sizeof</span> Stack);</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;ans = <span class="number">0</span>;a[n+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(Stack[top] &lt; a[i])&#123;</span><br><span class="line">Stack[++top] = a[i];</span><br><span class="line">w[top] = <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">ll sumw = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(Stack[top] &gt; a[i])&#123;</span><br><span class="line">sumw += w[top];</span><br><span class="line">ans = max(ans,sumw*Stack[top]);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line">Stack[++top] = a[i];w[top] = sumw + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="code-2-Poj2823"><a href="#code-2-Poj2823" class="headerlink" title="code-2 Poj2823"></a>code-2 Poj2823</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;v[<span class="number">1010000</span>]; <span class="comment">//x表示值，y表示位置 可以理解为下标</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1010000</span>],n,m,mx[<span class="number">1010000</span>],mn[<span class="number">1010000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,head=<span class="number">1</span>,tail=<span class="number">0</span>;<span class="comment">// 默认起始位置为1 因为插入是v[++tail]故初始化为0</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail &amp;&amp; v[tail].x&gt;=a[i]) tail--;</span><br><span class="line">        v[++tail].x=a[i],v[tail].y=i;</span><br><span class="line">                <span class="comment">// 根据题目 前m-1个先直接进入队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail &amp;&amp; v[tail].x&gt;=a[i]) tail--;</span><br><span class="line">        v[++tail].x=a[i],v[tail].y=i;</span><br><span class="line">        <span class="keyword">while</span>(v[head].y&lt;i-m+<span class="number">1</span>) head++;</span><br><span class="line">        mn[i-m+<span class="number">1</span>]=v[head].x;</span><br><span class="line">               <span class="comment">// 道理同上，当然了 要把已经超出范围的从head开始排出</span></span><br><span class="line">               <span class="comment">//  然后每个队首则是目前m个数的最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmax</span><span class="params">()</span> <span class="comment">//最大值同最小值的道理，只不过是维护的是递减队列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail &amp;&amp; v[tail].x&lt;=a[i]) tail--;</span><br><span class="line">        v[++tail].x=a[i],v[tail].y=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail &amp;&amp; v[tail].x&lt;=a[i]) tail--;</span><br><span class="line">        v[++tail].x=a[i],v[tail].y=i;</span><br><span class="line">        <span class="keyword">while</span>(v[head].y&lt;i-m+<span class="number">1</span>) head++;</span><br><span class="line">        mx[i-m+<span class="number">1</span>]=v[head].x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    getmin();</span><br><span class="line">    getmax();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n-m+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"%d"</span>,mn[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" %d"</span>,mn[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n-m+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"%d"</span>,mx[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" %d"</span>,mx[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;单调栈和单调队列都可以看作是一种对栈和队列的特殊用法，即要求栈或队列中的元素具有单调性，递增或递减。那么很显然这种数据结构就是基于栈和队列实
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="单调栈" scheme="http://valenshi.top/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
      <category term="单调队列" scheme="http://valenshi.top/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>后缀数组题集</title>
    <link href="http://valenshi.top/2019/10/17/lcp-problems/"/>
    <id>http://valenshi.top/2019/10/17/lcp-problems/</id>
    <published>2019-10-17T05:13:33.000Z</published>
    <updated>2019-10-17T05:19:45.526Z</updated>
    
    <content type="html"><![CDATA[<p>sa[i]：排名为i的后缀起始位置是多少。<br>rank[i]：从 i 位置起始的后缀在所有后缀中字典序排序后序号，与sa互逆。<br>lcp[i]：S[sa[i] ,…] 与 S[sa[i+1] , …]的最长公共前缀。</p><h4 id="Musical-Theme"><a href="#Musical-Theme" class="headerlink" title="Musical Theme"></a>Musical Theme</h4><p><a href="http://poj.org/problem?id=1743" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给n个数组成的串，求是否有多个“相似”且不重叠的子串的长度大于等于5，两个子串相似当且仅当长度相等且每一位的数字差都相等。</p><p><strong>解题思路</strong><br>本题题意有些难理解。就是利用后缀数组+高度数组解决最长不重复子串问题，解法很套路，就是二分+判断。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POJ1743</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sa[N],rk[N],lcp[N],tmp[N];</span><br><span class="line"><span class="keyword">int</span> len,k;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= len?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= len?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line">len = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; len?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+len,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]]+compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j + h &lt; len &amp;&amp; i + h &lt; len;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(lcp[<span class="number">1</span>] &gt;= x) pre = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!pre &amp;&amp; lcp[i] &gt;= x) pre = i;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= x)<span class="comment">//注意一下到底是i还是i-1</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(sa[pre] - sa[i]) &gt; x) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(a,sa);</span><br><span class="line">construct_lcp(a,sa,lcp);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = n;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(++r &lt; <span class="number">5</span>) r = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n)&#123;</span><br><span class="line"><span class="comment">//注意，该模板必须从下标0开始存！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) b[i] = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) a[i] = b[i]-b[i<span class="number">-1</span>]+<span class="number">100</span>;</span><br><span class="line">a[<span class="number">0</span>] = b[<span class="number">0</span>]+<span class="number">100</span>; solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Milk-Patterns"><a href="#Milk-Patterns" class="headerlink" title="Milk Patterns"></a>Milk Patterns</h4><p><a href="http://poj.org/problem?id=3261" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>求可重叠的，出现k次的最长重复子串。<br><strong>解题思路</strong><br>这个就是可重叠的最长重复子串了，要求求出最长的，重复出现k次以上的子串，通过题意以及样例观察可知，是允许子串重复的。解决方法和上题类似，也是后缀数组+二分。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POJ3261</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,a[N],kk;</span><br><span class="line"><span class="keyword">int</span> rk[N],sa[N],lcp[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//别把全局变量的k覆盖了！！！</span></span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= x) cnt++;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt &gt;= kk) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt &gt;= kk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(a,sa);</span><br><span class="line">construct_lcp(a,sa,lcp);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line"><span class="comment">//for(int i = 1;i &lt;= n;i++) printf("%d ",lcp[i]);</span></span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;kk) != EOF)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="不同子串的个数"><a href="#不同子串的个数" class="headerlink" title="不同子串的个数"></a>不同子串的个数</h4><p><a href="https://www.luogu.org/problem/P2408" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给定一个字符串，求其所有子串中，不同的子串数量。</p><p><strong>解题思路</strong><br>利用后缀数组+高度数组求解。已知高度数组lcp，那么首先可以知道第一个sa[1]有n - sa[1]个不同子串；而2~n，每个sa[i] 有 n - sa[i] - lcp[i-1] 个不同子串。累加即可，注意结果可能爆 int。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P2408不同子串的个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> sa[N],lcp[N],tmp[N],k,rk[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line">sum = n - sa[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">sum += n - sa[i] - lcp[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line">construct_lcp(str,sa,lcp);</span><br><span class="line">calc();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">freopen(<span class="string">"123.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"222.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Substring"><a href="#Substring" class="headerlink" title="Substring"></a>Substring</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5769" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给定一个字符串，求所有不同的，且包含<strong>字符x</strong>的子串数量。</p><p><strong>解题思路</strong><br>和上一题有些类似，但是我们需要确保每一个被统计的子串包含字符x。那么我们可以用一个数组pos[p]来记录 p 后面第一个字符 x 的位置，那么我们从头开始统计时，sa[1]有n - pos[ sa[1] ] 个合法子串，其它位置有 n - max(pos[ sa[i] ] , sa[i] + lcp[i])个合法子串，将它们累加起来即可。<br>这题选G++编译器就超时，选C++就可以通过，猜测可能和STL有关。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hdu5769,G++超时,C++AC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">char</span> str[N],lv[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> rk[N],sa[N],lcp[N],tmp[N],k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pos[N];<span class="comment">//pos[x]:x后面第一个lv出现的位置</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line">construct_lcp(str,sa,lcp);</span><br><span class="line">pos[n] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(str[i] == lv[<span class="number">0</span>]) pos[i] = i;</span><br><span class="line"><span class="keyword">else</span> pos[i] = pos[i+<span class="number">1</span>];</span><br><span class="line">sum = n - pos[sa[<span class="number">1</span>]];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">sum += n - max(pos[sa[i]],sa[i]+lcp[i<span class="number">-1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>,++idx,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">freopen(<span class="string">"123.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"222.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,lv,str);</span><br><span class="line">n = <span class="built_in">strlen</span>(str);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Life-Forms"><a href="#Life-Forms" class="headerlink" title="Life Forms"></a>Life Forms</h4><p><a href="http://poj.org/problem?id=3294" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给定n个字符串，请问它们之间出现次数超过一半的最长公共子串是什么？如果有多个，按字典序输出。</p><p><strong>解题思路</strong><br>利用后缀数组+高度数组求解。我们将n个字符串拼接中一个“母串”，中间用不同的字符间隔；然后对母串求高度数组lcp，我们依旧是用二分搜索判定长度p是否合法，每次判定从前向后用O(N)时间遍历统计一遍即可。当我们得到最长的合法长度 p 后，再利用类似的方法输出所有的子串。</p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> str,s;</span><br><span class="line"><span class="keyword">int</span> n,k,len;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> sa[N],rk[N],lcp[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line">    <span class="keyword">int</span> ri = i+k &lt;= len?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> rj = j+k &lt;= len?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="built_in">string</span> S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line">    len = S.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line">        sa[i] = i;</span><br><span class="line">        rk[i] = i &lt; len ? S[i]:<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//k一定不能设置成局部变量导致覆盖全局变量！！！</span></span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= len;k *= <span class="number">2</span>)&#123;</span><br><span class="line">        sort(sa,sa+len+<span class="number">1</span>,compare_sa);</span><br><span class="line">        tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++)</span><br><span class="line">            tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="built_in">string</span> S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line">    len = S.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line">        <span class="keyword">for</span>(;j+h &lt; len &amp;&amp; i+h &lt; len;h++)</span><br><span class="line">            <span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">        lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">110</span>],idx[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    vis[idx[sa[<span class="number">1</span>]]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &lt; p)&#123;</span><br><span class="line">            cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!vis[idx[sa[i]]]) cnt++,vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= n/<span class="number">2</span>+<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    vis[idx[sa[<span class="number">1</span>]]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= len+<span class="number">1</span>;i++)&#123;  <span class="comment">//lcp[len+1] = 0,作为结束标志</span></span><br><span class="line">        <span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &lt; p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt;= n/<span class="number">2</span>+<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = sa[i<span class="number">-1</span>];j &lt; sa[i<span class="number">-1</span>]+p;j++) <span class="built_in">cout</span> &lt;&lt; str[j];</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!vis[idx[sa[i]]]) cnt++,vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    construct_sa(str,sa);</span><br><span class="line">    construct_lcp(str,sa,lcp);</span><br><span class="line">    <span class="comment">/*sa[i]：存放排名第i的后缀的起始位置*/</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"?"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> print(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; str; <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">2</span>,tot = <span class="number">0</span>; str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s; str += s+<span class="keyword">char</span>(++cnt);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= s.length();j++) idx[tot++] = i;</span><br><span class="line">        &#125; </span><br><span class="line">        solve();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Maximum-repetition-substring"><a href="#Maximum-repetition-substring" class="headerlink" title="Maximum repetition substring"></a>Maximum repetition substring</h4><p><strong>题意简述</strong><br>求一个字符串中，重复次数最多的连续重复子串是什么（循环次数最多的循环子串）。要求输出字典序最小的。</p><p>例如：ccabababc中，连续循环次数最多的子串是ababab。</p><p><strong>解题思路</strong><br>这题我对照题解写了很久，思想勉强搞懂。<br>先说做法，是枚举长度len（从1到n），然后判断以 len 为循环长度的 连续循环次数 最多的 子串 长度 是多少；假设这个子串长度是 l ，那么它的连续循环次数就是 l/len。<br>我们考虑如何求子串长度 l 。如果有一个字符串的循环节长度为len，那么必然有s[1,n-len] = s[len , n]，因此，如果字符串 s[len, n] 与 s[ 2 <em> len, n] 的公共前缀长度为 lcp，那么 s[len ,n] 的循环节个数为lcp / len + 1（加上的一个是开头为计算在lcp内的循环节 ）。<br>因此我们只需要对s[0] , s[len] ,s[2 </em> len] … , 判断相差 len 的两个相邻后缀的 lcp，就可以计算该子串循环节个数。这是由于如果一个子串的循环节长度为 len，且循环至少两次，那么显然它会包含相邻的两个len，否则就构不成循环了。当然可能起点并不在len的倍数位置上，因此我们还需要向前拓展一下。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> cse = <span class="number">0</span>,n;</span><br><span class="line"><span class="keyword">int</span> k,rk[N],lcp[N],sa[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]]+compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>],Log[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = lcp[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)</span><br><span class="line">st[i][j] = min(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &gt; r) swap(l,r); r--;</span><br><span class="line"><span class="keyword">int</span> kk = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> min(st[l][kk],st[r-(<span class="number">1</span>&lt;&lt;kk)+<span class="number">1</span>][kk]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mxtc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> q[N],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i+len &lt; n;i += len)&#123;</span><br><span class="line"><span class="keyword">int</span> l = ask(rk[i],rk[i+len]);</span><br><span class="line"><span class="keyword">int</span> res = l/len+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> pre = i - (len-l%len);</span><br><span class="line"><span class="keyword">if</span>(pre &gt;= <span class="number">0</span> &amp;&amp; ask(rk[pre],rk[pre+len]) &gt;= len) res++;</span><br><span class="line"><span class="keyword">if</span>(mxtc &lt; res) mxtc = res,cnt = <span class="number">0</span>,q[++cnt] = len;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(mxtc == res &amp;&amp; len != q[cnt]) q[++cnt] = len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAns</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= cnt;j++)</span><br><span class="line"><span class="keyword">if</span>(ask(rk[sa[i]],rk[sa[i]+q[j]]) &gt;= q[j]*(mxtc<span class="number">-1</span>))&#123;</span><br><span class="line">str[sa[i]+q[j]*mxtc] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">puts</span>(str+sa[i]); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line">construct_lcp(str,sa,lcp);<span class="comment">//lcp[n]是恒等于0的</span></span><br><span class="line"><span class="comment">/*下一步求重复次数最多的连续重复子串*/</span></span><br><span class="line">st_init();</span><br><span class="line">mxtc = cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) calc(i); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: "</span>,++cse);</span><br><span class="line">printAns();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str) != EOF)&#123;</span><br><span class="line">n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span> &amp;&amp; str[<span class="number">0</span>] == <span class="string">'#'</span>) <span class="keyword">break</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Common-Substrings"><a href="#Common-Substrings" class="headerlink" title="Common Substrings"></a>Common Substrings</h4><p><a href="http://poj.org/problem?id=3415" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给定2个字符串A和B，以及一个整数k。目标是求出这两个字符串中公共子串的数量，例如A:xx , B:xx，k = 1，那么公共子串数量就是5。<br><strong>解题思路</strong><br>将A和B拼接在一起，中间用一个未出现过的字符间隔，新串S = A+’#’+B；然后对S求高度数组，利用高度数组来求解。<br>对于属于 B 的每一个后缀，统计它与所有属于 A 的后缀的 lcp（最长公共前缀），并统计lcp-m+1，这就是该后缀和 A 的公共子串数量。这样做的复杂度是O(N^2)。</p><p>我们可以利用单调栈来在 O(N) 时间内解决；我们从前向后遍历lcp数组，将属于A的后缀的 lcp 压入栈；由于两个字符串的后缀是取它们中间的最小值，所以我们应该维护单调递减栈，同时需要维护的是 sum，sum代表当前 A 中相同的子串数量，也就是说如果当前后缀属于 B ，则直接加上sum即可。</p><p>由于我们是顺序遍历的，只统计了A对B的贡献，再反过来统计一次B对A的贡献即可。<br><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> A[N],B[N];</span><br><span class="line"><span class="keyword">int</span> rk[N],tmp[N],lcp[N],sa[N],k;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = i+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j =sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> idx[N];<span class="comment">//初始化为0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ll h,cnt;</span><br><span class="line">&#125;Stack[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(A,sa);</span><br><span class="line">construct_lcp(A,sa,lcp);</span><br><span class="line">ll ans = <span class="number">0</span>,sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ll cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top &amp;&amp; Stack[top].h &gt;= lcp[i<span class="number">-1</span>])&#123;</span><br><span class="line">cnt += Stack[top].cnt;</span><br><span class="line">sum -= Stack[top].cnt * (Stack[top].h-m+<span class="number">1</span>);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= m)&#123;</span><br><span class="line">cnt += idx[sa[i<span class="number">-1</span>]] == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt) Stack[++top] = Node&#123;lcp[i<span class="number">-1</span>],cnt&#125;;</span><br><span class="line">sum += (lcp[i<span class="number">-1</span>]-m+<span class="number">1</span>)*cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(idx[sa[i]] == <span class="number">1</span>) ans += sum;</span><br><span class="line">&#125;</span><br><span class="line">top = <span class="number">0</span>; sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ll cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top &amp;&amp; Stack[top].h &gt;= lcp[i<span class="number">-1</span>])&#123;</span><br><span class="line">cnt += Stack[top].cnt;</span><br><span class="line">sum -= Stack[top].cnt * (Stack[top].h-m+<span class="number">1</span>);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= m)&#123;</span><br><span class="line">cnt += idx[sa[i<span class="number">-1</span>]] == <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt) Stack[++top] = Node&#123;lcp[i<span class="number">-1</span>],cnt&#125;;</span><br><span class="line">sum += (lcp[i<span class="number">-1</span>]-m+<span class="number">1</span>)*cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!idx[sa[i]]) ans += sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m) != EOF &amp;&amp; m)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,A);</span><br><span class="line"><span class="built_in">memset</span>(idx,<span class="number">0</span>,<span class="keyword">sizeof</span> idx);</span><br><span class="line">n = <span class="built_in">strlen</span>(A); </span><br><span class="line">idx[n] = <span class="number">2</span>; A[n++] = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) idx[i] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,A+n);</span><br><span class="line">n = <span class="built_in">strlen</span>(A);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;sa[i]：排名为i的后缀起始位置是多少。&lt;br&gt;rank[i]：从 i 位置起始的后缀在所有后缀中字典序排序后序号，与sa互逆。&lt;br&gt;lcp[i]：S[sa[i] ,…] 与 S[sa[i+1] , …]的最长公共前缀。&lt;/p&gt;
&lt;h4 id=&quot;Musical-Them
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="后缀数组" scheme="http://valenshi.top/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>后缀数组的常见应用</title>
    <link href="http://valenshi.top/2019/10/17/lcp-use/"/>
    <id>http://valenshi.top/2019/10/17/lcp-use/</id>
    <published>2019-10-17T05:13:32.000Z</published>
    <updated>2019-10-17T05:20:01.958Z</updated>
    
    <content type="html"><![CDATA[<h3 id="后缀数组的应用"><a href="#后缀数组的应用" class="headerlink" title="后缀数组的应用"></a>后缀数组的应用</h3><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>后缀数组是处理字符串相关问题的有力工具，后缀数组的题型与解法相对固定，因此对于本文中的几种题型要掌握解法与原理。本文假设读者已经掌握求后缀数组（sa）以及高度数组（lcp）的算法。<br>本文将介绍4类后缀数组的应用，分别是：</p><ul><li>最长公共前缀</li><li>单个字符串相关问题</li><li>两个字符串相关问题</li><li>多个字符串相关问题<h4 id="相关符号说明"><a href="#相关符号说明" class="headerlink" title="相关符号说明"></a>相关符号说明</h4>S 是原字符串。<br>suffix( i )表示字符串 S 从位置 i 开始的后缀。<br>sa( i )表示排名为第 i 的后缀的起始位置。<br>rk( i )表示 起始位置为 i 的后缀的排名。<br>lcp( i )表示排名为 i 的后缀与排名为 i+1 的后缀的最长公共前缀的长度。</li></ul><h4 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h4><p><strong>例1：</strong> 给定一个字符串，询问某两个后缀的最长公共前缀。<br><strong>解题思路：</strong><br>我们已经知道lcp[ i ]是排名为 i 的后缀与排名为 i+1 的后缀的最长公共前缀的长度，而我们又可以通过sa数组来得到任意俩个后缀的排名，因此对于给定的两个后缀，我们可以先求出它们的排名，分别设为 i 和 j （i &lt;= j），那么ans = min{ lcp[i] , lcp[i+1] , … , lcp[j - 1] }，也就相当于求RMQ问题，所以接下来的询问可以当做RMQ问题来采用合适的算法（例如st表）。</p><h4 id="单个字符串相关问题"><a href="#单个字符串相关问题" class="headerlink" title="单个字符串相关问题"></a>单个字符串相关问题</h4><p>这类问题的一个常用做法是先求后缀数组和lcp数组，然后利用lcp数组求解。</p><h5 id="重复子串问题"><a href="#重复子串问题" class="headerlink" title="重复子串问题"></a>重复子串问题</h5><p><strong>重复子串：</strong> 字符串R在字符串L中至少出现两次，则称 R 是 L 的重复子串。</p><p><strong>例2：可重叠最长重复子串</strong><br>给定一个字符串，求最长重复子串，这两个子串可以重叠。<br><strong>解题思路：</strong><br>求最长重复子串，等价于求两个后缀的最长公共前缀的最大值。于是我们只需要求出lcp数组中的最大值即可。由于任意两个后缀的最长公共前缀一定是lcp数组中某一段的最小值，那么这个值一定不大于lcp数组里的最大值。所以最长重复子串的长度就是lcp数组里的最大值。该做法时间复杂度为O(N)。</p><p><strong>例3：不可重叠最长重复子串</strong><br>给定一个字符串，求最长重复子串，这两个子串不能重叠。<br><strong>Musical Theme</strong><br><a href="http://poj.org/problem?id=1743" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给n个数组成的串，求是否有多个“相似”且不重叠的子串的长度大于等于5，两个子串相似当且仅当长度相等且每一位的数字差都相等。</p><p><strong>解题思路</strong><br>本题题意有些难理解。就是利用后缀数组+高度数组解决最长不重复子串问题，解法很套路，就是二分+判断。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POJ1743</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sa[N],rk[N],lcp[N],tmp[N];</span><br><span class="line"><span class="keyword">int</span> len,k;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= len?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= len?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line">len = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; len?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+len,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]]+compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j + h &lt; len &amp;&amp; i + h &lt; len;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(lcp[<span class="number">1</span>] &gt;= x) pre = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!pre &amp;&amp; lcp[i] &gt;= x) pre = i;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= x)<span class="comment">//注意一下到底是i还是i-1</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(sa[pre] - sa[i]) &gt; x) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(a,sa);</span><br><span class="line">construct_lcp(a,sa,lcp);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = n;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(++r &lt; <span class="number">5</span>) r = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n)&#123;</span><br><span class="line"><span class="comment">//注意，该模板必须从下标0开始存！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) b[i] = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) a[i] = b[i]-b[i<span class="number">-1</span>]+<span class="number">100</span>;</span><br><span class="line">a[<span class="number">0</span>] = b[<span class="number">0</span>]+<span class="number">100</span>; solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>例4：可重叠的k次最长重复子串POJ3261</strong><br><a href="http://poj.org/problem?id=3261" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>求可重叠的，出现k次的最长重复子串。<br><strong>解题思路</strong><br>这个就是可重叠的最长重复子串了，要求求出最长的，重复出现k次以上的子串，通过题意以及样例观察可知，是允许子串重复的。解决方法和上题类似，也是后缀数组+二分。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POJ3261</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,a[N],kk;</span><br><span class="line"><span class="keyword">int</span> rk[N],sa[N],lcp[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//别把全局变量的k覆盖了！！！</span></span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= x) cnt++;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt &gt;= kk) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt &gt;= kk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(a,sa);</span><br><span class="line">construct_lcp(a,sa,lcp);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line"><span class="comment">//for(int i = 1;i &lt;= n;i++) printf("%d ",lcp[i]);</span></span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;kk) != EOF)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="子串的个数"><a href="#子串的个数" class="headerlink" title="子串的个数"></a>子串的个数</h5><p><strong>例5：求不同子串的个数</strong><br><strong>题意简述</strong><br>给定一个字符串，求其所有子串中，不同的子串数量。<br><strong>解题思路</strong><br>利用后缀数组+高度数组求解。已知高度数组lcp，那么首先可以知道第一个sa[1]有n - sa[1]个不同子串；而2~n，每个sa[i] 有 n - sa[i] - lcp[i-1] 个不同子串。累加即可，注意结果可能爆 int。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P2408不同子串的个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> sa[N],lcp[N],tmp[N],k,rk[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line">sum = n - sa[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">sum += n - sa[i] - lcp[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line">construct_lcp(str,sa,lcp);</span><br><span class="line">calc();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">freopen(<span class="string">"123.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"222.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h5><p><strong>例6：求最长回文子串</strong></p><p>穷举每一位，然后计算以这个字符为中心的最长回文子串。注意这里要对长度分奇偶讨论。两种情况都可以转化为求一个后缀和一个反过来写的后缀的最长公共前缀。具体做法是：将整个字符反过来放在原字符串后面，中间用一个特殊字符隔开，这样就转化为了求新串的某两个后缀的最长公共前缀。</p><h5 id="连续重复子串"><a href="#连续重复子串" class="headerlink" title="连续重复子串"></a>连续重复子串</h5><p><strong>例7：重复次数最多的连续子串</strong><br><strong>Maximum repetition substring</strong><br><strong>题意简述</strong><br>求一个字符串中，重复次数最多的连续重复子串是什么（循环次数最多的循环子串）。要求输出字典序最小的。</p><p>例如：ccabababc中，连续循环次数最多的子串是ababab。</p><p><strong>解题思路</strong><br>这题我对照题解写了很久，思想勉强搞懂。<br>先说做法，是枚举长度len（从1到n），然后判断以 len 为循环长度的 连续循环次数 最多的 子串 长度 是多少；假设这个子串长度是 l ，那么它的连续循环次数就是 l/len。<br>我们考虑如何求子串长度 l 。如果有一个字符串的循环节长度为len，那么必然有s[1,n-len] = s[len , n]，因此，如果字符串 s[len, n] 与 s[ 2 <em> len, n] 的公共前缀长度为 lcp，那么 s[len ,n] 的循环节个数为lcp / len + 1（加上的一个是开头为计算在lcp内的循环节 ）。<br>因此我们只需要对s[0] , s[len] ,s[2 </em> len] … , 判断相差 len 的两个相邻后缀的 lcp，就可以计算该子串循环节个数。这是由于如果一个子串的循环节长度为 len，且循环至少两次，那么显然它会包含相邻的两个len，否则就构不成循环了。当然可能起点并不在len的倍数位置上，因此我们还需要向前拓展一下。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> cse = <span class="number">0</span>,n;</span><br><span class="line"><span class="keyword">int</span> k,rk[N],lcp[N],sa[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]]+compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>],Log[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = lcp[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)</span><br><span class="line">st[i][j] = min(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &gt; r) swap(l,r); r--;</span><br><span class="line"><span class="keyword">int</span> kk = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> min(st[l][kk],st[r-(<span class="number">1</span>&lt;&lt;kk)+<span class="number">1</span>][kk]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mxtc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> q[N],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i+len &lt; n;i += len)&#123;</span><br><span class="line"><span class="keyword">int</span> l = ask(rk[i],rk[i+len]);</span><br><span class="line"><span class="keyword">int</span> res = l/len+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> pre = i - (len-l%len);</span><br><span class="line"><span class="keyword">if</span>(pre &gt;= <span class="number">0</span> &amp;&amp; ask(rk[pre],rk[pre+len]) &gt;= len) res++;</span><br><span class="line"><span class="keyword">if</span>(mxtc &lt; res) mxtc = res,cnt = <span class="number">0</span>,q[++cnt] = len;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(mxtc == res &amp;&amp; len != q[cnt]) q[++cnt] = len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAns</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= cnt;j++)</span><br><span class="line"><span class="keyword">if</span>(ask(rk[sa[i]],rk[sa[i]+q[j]]) &gt;= q[j]*(mxtc<span class="number">-1</span>))&#123;</span><br><span class="line">str[sa[i]+q[j]*mxtc] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">puts</span>(str+sa[i]); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line">construct_lcp(str,sa,lcp);<span class="comment">//lcp[n]是恒等于0的</span></span><br><span class="line"><span class="comment">/*下一步求重复次数最多的连续重复子串*/</span></span><br><span class="line">st_init();</span><br><span class="line">mxtc = cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) calc(i); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: "</span>,++cse);</span><br><span class="line">printAns();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str) != EOF)&#123;</span><br><span class="line">n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span> &amp;&amp; str[<span class="number">0</span>] == <span class="string">'#'</span>) <span class="keyword">break</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="两个字符串相关问题"><a href="#两个字符串相关问题" class="headerlink" title="两个字符串相关问题"></a>两个字符串相关问题</h4><p>这类问题的一个常用做法是，先连接这两个字符串，然后求后缀数组和高度数组，再利用高度数组求解。</p><h5 id="公共子串"><a href="#公共子串" class="headerlink" title="公共子串"></a>公共子串</h5><p><strong>例8：公共子串的数量：Common Substrings</strong></p><p><strong>题意简述</strong><br>给定2个字符串A和B，以及一个整数k。目标是求出这两个字符串中公共子串的数量，例如A:xx , B:xx，k = 1，那么公共子串数量就是5。<br><strong>解题思路</strong><br>将A和B拼接在一起，中间用一个未出现过的字符间隔，新串S = A+’#’+B；然后对S求高度数组，利用高度数组来求解。<br>对于属于 B 的每一个后缀，统计它与所有属于 A 的后缀的 lcp（最长公共前缀），并统计lcp-m+1，这就是该后缀和 A 的公共子串数量。这样做的复杂度是O(N^2)。</p><p>我们可以利用单调栈来在 O(N) 时间内解决；我们从前向后遍历lcp数组，将属于A的后缀的 lcp 压入栈；由于两个字符串的后缀是取它们中间的最小值，所以我们应该维护单调递减栈，同时需要维护的是 sum，sum代表当前 A 中相同的子串数量，也就是说如果当前后缀属于 B ，则直接加上sum即可。</p><p>由于我们是顺序遍历的，只统计了A对B的贡献，再反过来统计一次B对A的贡献即可。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> A[N],B[N];</span><br><span class="line"><span class="keyword">int</span> rk[N],tmp[N],lcp[N],sa[N],k;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = i+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j =sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> idx[N];<span class="comment">//初始化为0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ll h,cnt;</span><br><span class="line">&#125;Stack[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(A,sa);</span><br><span class="line">construct_lcp(A,sa,lcp);</span><br><span class="line">ll ans = <span class="number">0</span>,sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ll cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top &amp;&amp; Stack[top].h &gt;= lcp[i<span class="number">-1</span>])&#123;</span><br><span class="line">cnt += Stack[top].cnt;</span><br><span class="line">sum -= Stack[top].cnt * (Stack[top].h-m+<span class="number">1</span>);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= m)&#123;</span><br><span class="line">cnt += idx[sa[i<span class="number">-1</span>]] == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt) Stack[++top] = Node&#123;lcp[i<span class="number">-1</span>],cnt&#125;;</span><br><span class="line">sum += (lcp[i<span class="number">-1</span>]-m+<span class="number">1</span>)*cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(idx[sa[i]] == <span class="number">1</span>) ans += sum;</span><br><span class="line">&#125;</span><br><span class="line">top = <span class="number">0</span>; sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ll cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top &amp;&amp; Stack[top].h &gt;= lcp[i<span class="number">-1</span>])&#123;</span><br><span class="line">cnt += Stack[top].cnt;</span><br><span class="line">sum -= Stack[top].cnt * (Stack[top].h-m+<span class="number">1</span>);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= m)&#123;</span><br><span class="line">cnt += idx[sa[i<span class="number">-1</span>]] == <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt) Stack[++top] = Node&#123;lcp[i<span class="number">-1</span>],cnt&#125;;</span><br><span class="line">sum += (lcp[i<span class="number">-1</span>]-m+<span class="number">1</span>)*cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!idx[sa[i]]) ans += sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m) != EOF &amp;&amp; m)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,A);</span><br><span class="line"><span class="built_in">memset</span>(idx,<span class="number">0</span>,<span class="keyword">sizeof</span> idx);</span><br><span class="line">n = <span class="built_in">strlen</span>(A); </span><br><span class="line">idx[n] = <span class="number">2</span>; A[n++] = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) idx[i] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,A+n);</span><br><span class="line">n = <span class="built_in">strlen</span>(A);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="多个字符串相关问题"><a href="#多个字符串相关问题" class="headerlink" title="多个字符串相关问题"></a>多个字符串相关问题</h4><p>这类问题的一个常用做法是，先将所有的字符串连接起来，然后求后缀数组和高度数组，再利用高度数组进行求解。中间可能还要利用二分答案。</p><p><strong>例9：不小于k个字符串中的最长子串。</strong></p><p><strong>Life Forms</strong><br><a href="http://poj.org/problem?id=3294" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给定n个字符串，请问它们之间出现次数超过一半的最长公共子串是什么？如果有多个，按字典序输出。</p><p><strong>解题思路</strong><br>利用后缀数组+高度数组求解。我们将n个字符串拼接中一个“母串”，中间用不同的字符间隔；然后对母串求高度数组lcp，我们依旧是用二分搜索判定长度p是否合法，每次判定从前向后用O(N)时间遍历统计一遍即可。当我们得到最长的合法长度 p 后，再利用类似的方法输出所有的子串。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> str,s;</span><br><span class="line"><span class="keyword">int</span> n,k,len;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> sa[N],rk[N],lcp[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line">    <span class="keyword">int</span> ri = i+k &lt;= len?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> rj = j+k &lt;= len?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="built_in">string</span> S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line">    len = S.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line">        sa[i] = i;</span><br><span class="line">        rk[i] = i &lt; len ? S[i]:<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//k一定不能设置成局部变量导致覆盖全局变量！！！</span></span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= len;k *= <span class="number">2</span>)&#123;</span><br><span class="line">        sort(sa,sa+len+<span class="number">1</span>,compare_sa);</span><br><span class="line">        tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++)</span><br><span class="line">            tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="built_in">string</span> S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line">    len = S.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line">        <span class="keyword">for</span>(;j+h &lt; len &amp;&amp; i+h &lt; len;h++)</span><br><span class="line">            <span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">        lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">110</span>],idx[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    vis[idx[sa[<span class="number">1</span>]]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &lt; p)&#123;</span><br><span class="line">            cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!vis[idx[sa[i]]]) cnt++,vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= n/<span class="number">2</span>+<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    vis[idx[sa[<span class="number">1</span>]]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= len+<span class="number">1</span>;i++)&#123;  <span class="comment">//lcp[len+1] = 0,作为结束标志</span></span><br><span class="line">        <span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &lt; p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt;= n/<span class="number">2</span>+<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = sa[i<span class="number">-1</span>];j &lt; sa[i<span class="number">-1</span>]+p;j++) <span class="built_in">cout</span> &lt;&lt; str[j];</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!vis[idx[sa[i]]]) cnt++,vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    construct_sa(str,sa);</span><br><span class="line">    construct_lcp(str,sa,lcp);</span><br><span class="line">    <span class="comment">/*sa[i]：存放排名第i的后缀的起始位置*/</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"?"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> print(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; str; <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">2</span>,tot = <span class="number">0</span>; str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s; str += s+<span class="keyword">char</span>(++cnt);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= s.length();j++) idx[tot++] = i;</span><br><span class="line">        &#125; </span><br><span class="line">        solve();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>罗穗骞，后缀数组——处理字符串的有利工具，2009.1</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;后缀数组的应用&quot;&gt;&lt;a href=&quot;#后缀数组的应用&quot; class=&quot;headerlink&quot; title=&quot;后缀数组的应用&quot;&gt;&lt;/a&gt;后缀数组的应用&lt;/h3&gt;&lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="后缀数组" scheme="http://valenshi.top/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>树链剖分题集</title>
    <link href="http://valenshi.top/2019/10/12/lct-problems/"/>
    <id>http://valenshi.top/2019/10/12/lct-problems/</id>
    <published>2019-10-12T06:30:05.000Z</published>
    <updated>2019-10-12T06:32:22.569Z</updated>
    
    <content type="html"><![CDATA[<p>树链剖分常用于处理静态树上操作，效率很高，写起来也就是固定的轻重边拆分+线段树，但是代码一般都是100行+，容易出错。<br>本题集中的树链剖分练习题，在解决思路上没什么难点，主要是如何设计线段树以及如何更新+询问，也就是说要想好怎么维护线段树，其它地方没什么太难的，但是代码长就容易出bug，多写写就好了。最后一题是线段树动态开点，这和可持久化权值线段树（动态主席树）一样的思想，只需要将普通的线段树给稍微修改一下即可。</p><h4 id="树的统计"><a href="#树的统计" class="headerlink" title="树的统计"></a>树的统计</h4><p><strong>题意简述</strong><br>原题来自：ZJOI 2008<br>一树上有 n 个节点，编号分别为 1 到 n，每个节点都有一个权值 w。我们将以下面的形式来要求你对这棵树完成一些操作：</p><p>1.CHANGE u t ：把节点 u 权值改为 t；</p><p>2.QMAX u v ：询问点 u 到点 v 路径上的节点的最大权值；</p><p>3.QSUM u v ：询问点 u 到点 v 路径上的节点的权值和。</p><p>注意：从点 u 到点 v 路径上的节点包括 u 和 v 本身。</p><p><strong>解题思路</strong><br>树链剖分+线段树上单点修改，区间查询，需要注意查询操作，利用到了LCA倍增思想，树链剖分中很多区间修改和查询操作都是这样完成的。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y, edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,q,a[N];</span><br><span class="line"><span class="comment">/*父亲,深度,子树大小,重儿子,重路径顶部节点,</span></span><br><span class="line"><span class="comment">    树中节点在线段树中下标,线段树中节点对应树中位置*/</span></span><br><span class="line"><span class="keyword">int</span> par[N],deep[N],size[N],son[N],top[N],seg[N],rev[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*利用深搜更新par,size,deep,son数组*/</span></span><br><span class="line">    vis[x] = <span class="literal">true</span>; size[x] = <span class="number">1</span>;</span><br><span class="line">    par[x] = fa; deep[x] = deep[fa]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(y == fa || vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y,x);</span><br><span class="line">        size[x] += size[y]; <span class="comment">//累加子树大小</span></span><br><span class="line">        <span class="keyword">if</span>(size[y] &gt; size[son[x]]) son[x] = y;<span class="comment">//求重儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x])&#123; <span class="comment">//先走重儿子,使得重路径在线段树中连续</span></span><br><span class="line">        seg[son[x]] = ++seg[<span class="number">0</span>];<span class="comment">//0位置用不到,利用来计数</span></span><br><span class="line">        top[son[x]] = top[x];</span><br><span class="line">        rev[seg[<span class="number">0</span>]] = son[x];</span><br><span class="line">        dfs2(son[x],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(top[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">/*若y没有被遍历过,即y不是x的重儿子或者父亲*/</span></span><br><span class="line">        seg[y] = ++seg[<span class="number">0</span>]; rev[seg[<span class="number">0</span>]] = y;</span><br><span class="line">        top[y] = y; dfs2(y,x);</span><br><span class="line">        <span class="comment">/*如果x--&gt;y是轻边,那么y就是其所在重路径顶部节点*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    ll mx, sum;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mx(x) t[x].mx</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    l(rt) = l, r(rt) = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        mx(rt) = sum(rt) = a[rev[l]]; <span class="comment">//线段树上l节点对应着树上rev[l]点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    BuildTree(rt*<span class="number">2</span>,l,mid); BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    mx(rt) = max(mx(rt&lt;&lt;<span class="number">1</span>),mx(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>) + sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preHandle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>); <span class="comment">//我们以1号节点为根</span></span><br><span class="line">    <span class="comment">/*根节点所在重路径的顶部节点也是根节点,赋初值*/</span></span><br><span class="line">    seg[<span class="number">0</span>] = seg[<span class="number">1</span>] = top[<span class="number">1</span>] = rev[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    BuildTree(<span class="number">1</span>,<span class="number">1</span>,seg[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">ll tmx,tsum;<span class="comment">//利用全局变量同时统计2个答案</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*将以rt为根的区间内属于[l,r]部分的和累加到tsum上,并更新tmx*/</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">        tsum += sum(rt); tmx = max(tmx,mx(rt));</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) query(rt&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*返回x与y之间路径上权值最大点的权值*/</span></span><br><span class="line">    <span class="keyword">int</span> fx = top[x] , fy = top[y];</span><br><span class="line">    <span class="keyword">while</span>(fx != fy)&#123;<span class="comment">//先将x和y条整到同一个重链上</span></span><br><span class="line">        <span class="keyword">if</span>(deep[fx] &lt; deep[fy]) swap(x,y),swap(fx,fy);</span><br><span class="line">        query(<span class="number">1</span>,seg[fx],seg[x]);</span><br><span class="line">        x = par[fx]; fx = top[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deep[x] &gt; deep[y]) swap(x,y);<span class="comment">//路径浅的编号小</span></span><br><span class="line">    query(<span class="number">1</span>,seg[x],seg[y]); <span class="comment">//再更新一次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*把线段树节点x的权值改为val*/</span></span><br><span class="line">    <span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">        mx(rt) = sum(rt) = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt) + r(rt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; mid) change(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,val);</span><br><span class="line">    <span class="keyword">else</span> change(rt&lt;&lt;<span class="number">1</span>,x,val);</span><br><span class="line">    mx(rt) = max(mx(rt&lt;&lt;<span class="number">1</span>),mx(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>) + sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">"123.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">"222.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        addEdge(x,y,<span class="number">1</span>); addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    preHandle();<span class="comment">//树链剖分预处理</span></span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= q;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>,op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'C'</span>) change(<span class="number">1</span>,seg[x],y);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmx = -INF; tsum = <span class="number">0</span>;</span><br><span class="line">            ask(x,y);<span class="comment">//同时更新最大值与路径和</span></span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">'M'</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,tmx);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,tsum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="「HAOI2015」树上操作"><a href="#「HAOI2015」树上操作" class="headerlink" title="「HAOI2015」树上操作"></a>「HAOI2015」树上操作</h4><p><strong>题意简述</strong><br>有一棵点数为 N 的树，以点 1 为根，且树有点权。然后有 M 个操作，分为三种：</p><p>1、把某个节点 x 的点权增加 a 。</p><p>2、把某个节点 x 为根的子树中所有点的点权都增加 a 。</p><p>3、询问某个节点 x 到根的路径中所有点的点权和。</p><p><strong>解题思路</strong><br>树链剖分+线段树上区间修改，区间查询。用到了线段树上的延迟标记，其实和普通线段树没啥区别，就是查询和修改时候要用LCA倍增思想将树上的链转化为线段树上的区间。只要理解了树上节点和线段树下标是通过seg[x] 和 rev[seg[x]]来转换的即可。</p><p>另外还需要明白线段树上重链的seg[]值是连续的，同一个子树上的所有节点下标也是连续的，这个结论可以通过观察dfs2的实现得到。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y,edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">        ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> deep[N],par[N],top[N],size[N],son[N],seg[N],rev[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>; par[x] = fa;</span><br><span class="line">    deep[x] = deep[fa]+<span class="number">1</span>; size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(vis[y] || y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y,x);</span><br><span class="line">        size[x] += size[y]; </span><br><span class="line">        <span class="keyword">if</span>(size[y] &gt; size[son[x]]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x])&#123;</span><br><span class="line">        seg[son[x]] = ++seg[<span class="number">0</span>];</span><br><span class="line">        rev[seg[<span class="number">0</span>]] = son[x];</span><br><span class="line">        top[son[x]] = top[x];</span><br><span class="line">        dfs2(son[x],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(top[y]) <span class="keyword">continue</span>;</span><br><span class="line">        seg[y] = ++seg[<span class="number">0</span>]; rev[seg[<span class="number">0</span>]] = y;</span><br><span class="line">        top[y] = y; dfs2(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    ll sum,add;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> add(x) t[x].add</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    l(rt) = l,r(rt) = r,add(rt) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        sum(rt) = a[rev[l]]; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    BuildTree(rt&lt;&lt;<span class="number">1</span>,l,mid); BuildTree(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>) + sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preHandle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    seg[<span class="number">0</span>] = seg[<span class="number">1</span>] = top[<span class="number">1</span>] = rev[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    BuildTree(<span class="number">1</span>,<span class="number">1</span>,seg[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!add(rt)) <span class="keyword">return</span>;</span><br><span class="line">    sum(rt&lt;&lt;<span class="number">1</span>) += (r(rt&lt;&lt;<span class="number">1</span>)-l(rt&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>)*add(rt);</span><br><span class="line">    sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) += (r(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)-l(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)+<span class="number">1</span>)*add(rt);</span><br><span class="line">    add(rt&lt;&lt;<span class="number">1</span>) += add(rt); add(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) += add(rt);</span><br><span class="line">    add(rt) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">        sum(rt) += (r(rt) - l(rt)+<span class="number">1</span>)*val;</span><br><span class="line">        add(rt) += val; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spread(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) Add(rt&lt;&lt;<span class="number">1</span>,l,r,val);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) Add(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,val);</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>)+sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> sum(rt);</span><br><span class="line">    spread(rt); ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt) + r(rt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res += query(rt&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res += query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*从节点x到根节点的路径和*/</span></span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        res += query(<span class="number">1</span>,seg[top[x]],seg[x]);</span><br><span class="line">        x = par[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = getInt(); m = getInt();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line">        x = getInt(); y = getInt();</span><br><span class="line">        addEdge(x,y,<span class="number">1</span>); addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    preHandle();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,op,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">        op = getInt();</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            x = getInt(); y = getInt();</span><br><span class="line">            Add(<span class="number">1</span>,seg[x],seg[x],y);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line">            x = getInt(); y = getInt();</span><br><span class="line">            Add(<span class="number">1</span>,seg[x],seg[x]+size[x]<span class="number">-1</span>,y);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            x = getInt(); <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="「NOI2015」软件包管理器"><a href="#「NOI2015」软件包管理器" class="headerlink" title="「NOI2015」软件包管理器"></a>「NOI2015」软件包管理器</h4><p><strong>题意简述</strong><br>Linux 用户和 OSX 用户一定对软件包管理器不会陌生。通过软件包管理器，你可以通过一行命令安装某一个软件包，然后软件包管理器会帮助你从软件源下载软件包，同时自动解决所有的依赖（即下载安装这个软件包的安装所依赖的其它软件包），完成所有的配置。Debian/Ubuntu 使用的 apt-get，Fedora/CentOS 使用的 yum，以及 OSX 下可用的 Homebrew 都是优秀的软件包管理器。</p><p>你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包 A 依赖软件包 B，那么安装软件包 A 以前，必须先安装软件包 B。同时，如果想要卸载软件包 B，则必须卸载软件包 A。现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除 0 号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而 0 号软件包不依赖任何一个软件包。依赖关系不存在环（若有m(m≥2) 个软件包A1,A2,A3,…,Am ，其中 A1 依赖 A2，A2依赖 A3 依赖 A4 ，……，Am−1 依赖 Am ，而 Am 依赖 A1 ，则称这 m 个软件包的依赖关系构成环），当然也不会有一个软件包依赖自己。</p><p>现在你要为你的软件包管理器写一个依赖解决程序。根据反馈，用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包），你的任务就是实现这个部分。注意，安装一个已安装的软件包，或卸载一个未安装的软件包，都不会改变任何软件包的安装状态，即在此情况下，改变安装状态的软件包数为 0。</p><p><strong>解题思路</strong><br>要画图理解题意，若A依赖B，则安装A之前要安装B，若卸载B要先卸载A。也就是说要安装A，就要确保A到根节点路径上软件都已安装；若卸载A，就要确保 A 的子树为空。</p><p>于是就是树上操作，若卸载一个软件 x ，就是查询它子树上已安装的软件个数（包括它自己），输出后再删除即可；若安装一个软件 x ，就是查询 x 到根节点路径上未安装的软件个数（包括它自己），输出后再安装。因为软件安装和卸载只是改变其状态（已安装：1，未安装：0），而不改变结构（彻底删除节点），所以可以用树链剖分+线段树解决。</p><p>但是需要注意的是，怎么把整棵子树都清零，怎么把到根节点的路径都置 1，显然要用延迟标记，但是延迟标记却不应该累加，那要怎么处理？<br>置 1 时延迟标记add = 1，置0时延迟标记add = -1，每一个节点如果延迟标记不为0，那么该节点为根的子树所有软件状态相同。我们下传延迟标记操作封装在spread函数内，可以参考如何实现延迟标记的更新。</p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y, edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> par[N],deep[N],size[N],son[N],top[N],seg[N],rev[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>; par[x] = fa;</span><br><span class="line">    deep[x] = deep[fa]+<span class="number">1</span>; size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y,x);</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">        <span class="keyword">if</span>(size[y] &gt; size[son[x]]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x])&#123;</span><br><span class="line">        seg[son[x]] = ++seg[<span class="number">0</span>];</span><br><span class="line">        rev[seg[<span class="number">0</span>]] = son[x];</span><br><span class="line">        top[son[x]] = top[x];</span><br><span class="line">        dfs2(son[x],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(top[y]) <span class="keyword">continue</span>;</span><br><span class="line">        seg[y] = ++seg[<span class="number">0</span>]; rev[seg[<span class="number">0</span>]] = y;</span><br><span class="line">        top[y] = y; dfs2(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,sum,add;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> add(x) t[x].add</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    l(rt) = l,r(rt) = r,add(rt) = sum(rt) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    BuildTree(rt&lt;&lt;<span class="number">1</span>,l,mid); BuildTree(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>) + sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preHandle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    seg[<span class="number">0</span>] = seg[<span class="number">1</span>] = top[<span class="number">1</span>] = rev[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    BuildTree(<span class="number">1</span>,<span class="number">1</span>,seg[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!add(rt)) <span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">if</span>(add(rt) == <span class="number">-1</span>)&#123;</span><br><span class="line">        sum(rt&lt;&lt;<span class="number">1</span>) = sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">        add(rt&lt;&lt;<span class="number">1</span>) = add(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = add(rt);</span><br><span class="line">        add(rt) = <span class="number">0</span>; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum(rt&lt;&lt;<span class="number">1</span>) = (r(rt&lt;&lt;<span class="number">1</span>)-l(rt&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>)*add(rt);</span><br><span class="line">    sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = (r(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)-l(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)+<span class="number">1</span>)*add(rt);</span><br><span class="line">    add(rt&lt;&lt;<span class="number">1</span>) = add(rt); add(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = add(rt);</span><br><span class="line">    add(rt) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(val == <span class="number">-1</span>) sum(rt) = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> sum(rt) = (r(rt) - l(rt)+<span class="number">1</span>);</span><br><span class="line">        add(rt) = val; </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spread(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) Add(rt&lt;&lt;<span class="number">1</span>,l,r,val);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) Add(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,val);</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>)+sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> sum(rt);</span><br><span class="line">    spread(rt); ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt) + r(rt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res += query(rt&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res += query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> query(<span class="number">1</span>,seg[x],seg[x]+size[x]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        res += query(<span class="number">1</span>,seg[top[x]],seg[x]);</span><br><span class="line">        x = par[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        Add(<span class="number">1</span>,seg[top[x]],seg[x],<span class="number">1</span>);</span><br><span class="line">        x = par[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        addEdge(x+<span class="number">1</span>,i+<span class="number">1</span>,<span class="number">1</span>); addEdge(i+<span class="number">1</span>,x+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    preHandle();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m); <span class="keyword">char</span> op[<span class="number">22</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>,op,&amp;x); x++;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'u'</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask1(x));</span><br><span class="line">            Add(<span class="number">1</span>,seg[x],seg[x]+size[x]<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,deep[x]-ask2(x));</span><br><span class="line">            Add2(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="染色"><a href="#染色" class="headerlink" title="染色"></a>染色</h4><p><strong>题意简述</strong><br>原题来自：SDOI 2011<br>给定一棵有 n 个节点的无根树和 m 个操作，操作共两类。<br>1、将节点 a 到节点 b 路径上的所有节点都染上颜色；<br>2、询问节点 a 到节点 b 路径上的颜色段数量，连续相同颜色的认为是同一段，例如 112221 由三段组成：11 、 222、1。</p><p>请你写一个程序依次完成操作。</p><p><strong>解题思路</strong><br>如果不是在树上，是在区间上，该如何操作？用线段树解决。线段树上每个节点有lc：左端点颜色，rc：右端点颜色，same：区间颜色是否唯一（1表示唯一，0表示不唯一），sum：区间内颜色段数量。<br>那么更新显然要用延迟标记，标记在same上，而合并操作需要考虑中间相接的端点颜色是否相同，若相同则颜色段数量要-1。于是区间上“染色”问题就可以用线段树解决了。</p><p>在树上显然类似，因为我们可以通过树链剖分来将树给转化为区间。唯一麻烦的地方就是端点颜色问题，在区间上，我们只需要判断左子树的右端点、右子树的左端点是否颜色相同即可，但是树上的路径是通过倍增来找的，显然需要记录每一条链的端点颜色，麻烦在于如何记录并判断。</p><p>树链剖分后节点越浅，其seg越小，于是需要判断颜色是否相同的是seg[fx]和 seg[par[fx]]，这是由于我们在倍增调整深度时候是自底向上的，自然要判断深度浅的节点。为了美观以及简便，设 getcol(x) 返回该节点的颜色。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[M],ver[M],nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y, edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> deep[N],seg[N],rev[N],top[N],son[N],size[N],par[N];</span><br><span class="line"><span class="keyword">int</span> vis[N],a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>; par[x] = fa;</span><br><span class="line">    deep[x] = deep[fa]+<span class="number">1</span>; size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(vis[y] || y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y,x);</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">        <span class="keyword">if</span>(size[y] &gt; size[son[x]]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x])&#123;</span><br><span class="line">        seg[son[x]] = ++seg[<span class="number">0</span>];</span><br><span class="line">        rev[seg[<span class="number">0</span>]] = son[x];</span><br><span class="line">        top[son[x]] = top[x];</span><br><span class="line">        dfs2(son[x],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(top[y]) <span class="keyword">continue</span>;</span><br><span class="line">        seg[y] = ++seg[<span class="number">0</span>]; rev[seg[<span class="number">0</span>]] = y;</span><br><span class="line">        top[y] = y; dfs2(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="comment">/*lc:区间左端点颜色,rc:区间右端点颜色,sum:区间内颜色段数*/</span></span><br><span class="line">    <span class="keyword">int</span> l,r,lc,rc,sum;</span><br><span class="line">    <span class="keyword">int</span> same;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) t[x].lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) t[x].rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> same(x) t[x].same</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Updata</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;<span class="comment">//更新节点rt的same、rc、lc和sum</span></span><br><span class="line">    same(rt) = same(rt&lt;&lt;<span class="number">1</span>) &amp;&amp; same(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) &amp;&amp; rc(rt&lt;&lt;<span class="number">1</span>) == lc(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>)+sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(rc(rt&lt;&lt;<span class="number">1</span>) == lc(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)) sum(rt)--;</span><br><span class="line">    lc(rt) = lc(rt&lt;&lt;<span class="number">1</span>); rc(rt) = rc(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    l(rt) = l,r(rt) = r,same(rt) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        lc(rt) = rc(rt) = a[rev[l]];</span><br><span class="line">        sum(rt) = <span class="number">1</span>; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    BuildTree(rt&lt;&lt;<span class="number">1</span>,l,mid); BuildTree(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    Updata(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preHandle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    seg[<span class="number">0</span>] = seg[<span class="number">1</span>] = rev[<span class="number">1</span>] = top[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    BuildTree(<span class="number">1</span>,<span class="number">1</span>,seg[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!same(rt)) <span class="keyword">return</span>;<span class="comment">//将懒惰标记下传，即对子树染相同颜色</span></span><br><span class="line">    sum(rt&lt;&lt;<span class="number">1</span>) = sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = <span class="number">1</span>;</span><br><span class="line">    lc(rt&lt;&lt;<span class="number">1</span>) = rc(rt&lt;&lt;<span class="number">1</span>) = lc(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = rc(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = lc(rt);</span><br><span class="line">    same(rt&lt;&lt;<span class="number">1</span>) = same(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = <span class="number">1</span>; same(rt) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">        sum(rt) = <span class="number">1</span>; lc(rt) = rc(rt) = col;</span><br><span class="line">        same(rt) = <span class="number">1</span>; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spread(rt);<span class="comment">//懒惰标记</span></span><br><span class="line">    <span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) modify(rt&lt;&lt;<span class="number">1</span>,l,r,col);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) modify(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,col);</span><br><span class="line">    Updata(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = top[x],fy = top[y];</span><br><span class="line">    <span class="keyword">while</span>(fx != fy)&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[fx] &lt; deep[fy]) swap(x,y),swap(fx,fy);</span><br><span class="line">        modify(<span class="number">1</span>,seg[fx],seg[x],z);</span><br><span class="line">        x = par[fx]; fx = top[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deep[x] &gt; deep[y]) swap(x,y);</span><br><span class="line">    modify(<span class="number">1</span>,seg[x],seg[y],z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> sum(rt);</span><br><span class="line">    spread(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span> ,res= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res += query(rt&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res += query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="comment">/*合并时中间颜色相同,要减去一段*/</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid &amp;&amp; mid &lt; r &amp;&amp; rc(rt&lt;&lt;<span class="number">1</span>) == lc(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)) res--;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getcol</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//这个函数太好用了，哭哭</span></span><br><span class="line">    <span class="keyword">if</span>(l(rt) == r(rt)) <span class="keyword">return</span> lc(rt);</span><br><span class="line">    spread(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="keyword">return</span> getcol(rt&lt;&lt;<span class="number">1</span>,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> getcol(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = top[x], fy = top[y], res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fx != fy)&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[fx] &lt; deep[fy]) swap(fx,fy),swap(x,y);</span><br><span class="line">        res += query(<span class="number">1</span>,seg[fx],seg[x]);</span><br><span class="line">        <span class="keyword">if</span>(getcol(<span class="number">1</span>,seg[fx]) == getcol(<span class="number">1</span>,seg[par[fx]])) res--;</span><br><span class="line">        x = par[fx]; fx = top[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deep[x] &gt; deep[y]) swap(x,y);</span><br><span class="line">    res += query(<span class="number">1</span>,seg[x],seg[y]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y); </span><br><span class="line">        addEdge(x,y,<span class="number">1</span>); addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    preHandle(); <span class="keyword">char</span> op[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x,y));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            change(x,y,z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="「SDOI2014」旅行"><a href="#「SDOI2014」旅行" class="headerlink" title="「SDOI2014」旅行"></a>「SDOI2014」旅行</h4><p><strong>题意简述</strong><br>S 国有 N 个城市，编号从 1 到 N。城市间用 N−1 条双向道路连接，满足从一个城市出发可以到达其它所有城市。每个城市信仰不同的宗教，如飞天面条神教、隐形独角兽教、绝地教都是常见的信仰。为了方便，我们用不同的正整数代表各种宗教，S 国境内总共有 C 种不同的宗教。<br>S 国的居民常常旅行。旅行时他们总会走最短路，并且为了避免麻烦，只在信仰和他们相同的城市留宿。当然旅程的终点也是信仰与他相同的城市。S 国政府为每个城市标定了不同的旅行评级，旅行者们常会记下途中（包括起点和终点）留宿过的城市的评级总和或最大值。<br>在 S 国的历史上常会发生以下几种事件：</p><p>1、CC x c：城市 x 的居民全体改信了 c 教；</p><p>2、CW x w：城市 x 的评级调整为 w；</p><p>3、QS x y：一位旅行者从城市 x 出发，到城市 y，并记下了途中留宿过的城市的评级总和；</p><p>4、QM x y：一位旅行者从城市 x 出发，到城市 y，并记下了途中留宿过的城市的评级最大值。<br>由于年代久远，旅行者记下的数字已经遗失了，但记录开始之前每座城市的信仰与评级，还有事件记录本身是完好的。请根据这些信息，还原旅行者记下的数字。</p><p>为了方便，我们认为事件之间的间隔足够长，以致在任意一次旅行中，所有城市的评级和信仰保持不变。<br><strong>解题思路</strong><br>如果没有信仰，那就是简单的树链剖分模板题，但这题多了个信仰，正常思路是开数组存放对应信仰的评级，但是显然不现实，从空间角度来看。<br>这题用到了动态开点，和可持久化线段树类似，只需要稍微改一下线段树模板即可。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y,edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> deep[N],par[N],size[N],top[N],seg[N],rev[N],son[N];</span><br><span class="line"><span class="keyword">int</span> vis[N],a[N],c[N];<span class="comment">//a:初始评级 c:初始信仰</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    deep[x] = deep[fa]+<span class="number">1</span>;par[x] = fa;</span><br><span class="line">    size[x] = <span class="number">1</span>;vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(vis[y] || y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y,x);</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">        <span class="keyword">if</span>(size[y] &gt; size[son[x]]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x])&#123;</span><br><span class="line">        seg[son[x]] = ++seg[<span class="number">0</span>];</span><br><span class="line">        rev[seg[<span class="number">0</span>]] = son[x];</span><br><span class="line">        top[son[x]] = top[x];</span><br><span class="line">        dfs2(son[x],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(top[y]) <span class="keyword">continue</span>;</span><br><span class="line">        seg[y] = ++seg[<span class="number">0</span>]; rev[seg[<span class="number">0</span>]] = y;</span><br><span class="line">        top[y] = y; dfs2(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls,rs;</span><br><span class="line">    ll mx,sum;</span><br><span class="line">    SegmentTree()&#123;</span><br><span class="line">        ls = rs = mx = sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(x) t[x].ls</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(x) t[x].rs</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mx(x) t[x].mx</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">&#125;t[N*<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> root[N],sz = <span class="number">1</span>;<span class="comment">//最多有多少个根节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preHandle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    seg[<span class="number">0</span>] = seg[<span class="number">1</span>] = rev[<span class="number">1</span>] = top[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> &amp;rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos,ll val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) rt = ++sz;</span><br><span class="line">    mx(rt) = max(mx(rt),val); sum(rt) += val;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>; <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid) Add(ls(rt),l,mid,pos,val);</span><br><span class="line">    <span class="keyword">else</span> Add(rs(rt),mid+<span class="number">1</span>,r,pos,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        sum(rt) = mx(rt) = <span class="number">0</span>; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid) Delete(ls(rt),l,mid,pos);</span><br><span class="line">    <span class="keyword">else</span> Delete(rs(rt),mid+<span class="number">1</span>,r,pos);</span><br><span class="line">    sum(rt) = sum(ls(rt)) + sum(rs(rt));</span><br><span class="line">    mx(rt) = max(mx(ls(rt)),mx(rs(rt)));</span><br><span class="line">&#125;</span><br><span class="line">ll mx,sum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="comment">//  printf("%d %d %d %d %d\n",rt,L,R,l,r);</span></span><br><span class="line">    <span class="keyword">if</span>(!rt) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= L &amp;&amp; R &lt;= r)&#123;</span><br><span class="line">      <span class="comment">//  printf("%d %d\n",mx(rt),sum(rt));</span></span><br><span class="line">        mx = max(mx,mx(rt)); sum += sum(rt); <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) query(ls(rt),L,mid,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) query(rs(rt),mid+<span class="number">1</span>,R,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*返回x到y路径上信仰rt的评级最大值以及总和*/</span></span><br><span class="line">    <span class="keyword">int</span> fx = top[x],fy = top[y];</span><br><span class="line">    <span class="keyword">while</span>(fx != fy)&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[fx] &lt; deep[fy]) swap(x,y),swap(fx,fy);</span><br><span class="line">        query(rt,<span class="number">1</span>,seg[<span class="number">0</span>],seg[fx],seg[x]);</span><br><span class="line">        x = par[fx]; fx = top[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deep[x] &gt; deep[y]) swap(x,y);</span><br><span class="line">    query(rt,<span class="number">1</span>,seg[<span class="number">0</span>],seg[x],seg[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,a+i,c+i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        addEdge(x,y,<span class="number">1</span>); addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    preHandle();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        Add(root[c[i]],<span class="number">1</span>,seg[<span class="number">0</span>],seg[i],a[i]);</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>,op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">'C'</span>)&#123;</span><br><span class="line">            Delete(root[c[x]],<span class="number">1</span>,seg[<span class="number">0</span>],seg[x]);</span><br><span class="line">            Add(root[c[x] = y],<span class="number">1</span>,seg[<span class="number">0</span>],seg[x],a[x]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">'W'</span>)&#123;</span><br><span class="line">            Delete(root[c[x]],<span class="number">1</span>,seg[<span class="number">0</span>],seg[x]);</span><br><span class="line">            Add(root[c[x]],<span class="number">1</span>,seg[<span class="number">0</span>],seg[x],a[x] = y);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mx = sum = <span class="number">0</span>;<span class="comment">//一起更新，少写代码，美滋滋</span></span><br><span class="line">            ask(root[c[x]],x,y);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">'S'</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,mx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;树链剖分常用于处理静态树上操作，效率很高，写起来也就是固定的轻重边拆分+线段树，但是代码一般都是100行+，容易出错。&lt;br&gt;本题集中的树链剖分练习题，在解决思路上没什么难点，主要是如何设计线段树以及如何更新+询问，也就是说要想好怎么维护线段树，其它地方没什么太难的，但是代
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树链剖分" scheme="http://valenshi.top/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>树链剖分笔记</title>
    <link href="http://valenshi.top/2019/10/10/lct/"/>
    <id>http://valenshi.top/2019/10/10/lct/</id>
    <published>2019-10-10T05:03:03.000Z</published>
    <updated>2019-10-10T07:58:48.913Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>树链剖分是用来维护静态树上路径信息的数据结构，静态即树的形态不能改变（增删点或者换根，改变了构造）。<br>其思想是将树上的路径分为重路径和轻边，然后为每个节点分配一个编号，重路径上节点的编号是连续的；接着对这些编号建立一棵线段树，这样就可以将重路径当作区间来维护了；利用了“每个点到根的路径上都有不超过O(logN)条轻边和O(logN)条重路径”结论来保证时间复杂度。</p><h4 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h4><p>树链剖分通常用于解决一类维护静态树上路径信息的问题，例如，给定一棵点带权的树，接下来每次操作会修改某条路径上所有点的权值（修改为同一个值或是加上同一个值等），以及询问某条路径上所有点的权值和。</p><p>当这棵树是一条链时，这个问题实际上就是一个序列上区间修改、区间询问的问题，可以用线段树等数据结构解决。</p><p>对于其他情况，由于树的形态是不变的，因此树链剖分的策略是将这些点按某种方式组织起来，剖分成若干条链，每条链就相当于一个序列。这样，操作的路径可以拆分为某几条链，也就是若干个完整序列或是某个序列上的一段区间，此时可利用线段树等处理序列上区间操作的数据结构解决问题。</p><p>树链剖分的核心是如何恰当的将树剖分为若干条链。当链的划分方式确定后，我们只要将它们看作是一个个序列，将所有序列按顺序拼接起来，每条链就成了一段区间，而序列上的区间问题是我们所熟悉和擅长的。</p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><h5 id="划分轻重边"><a href="#划分轻重边" class="headerlink" title="划分轻重边"></a>划分轻重边</h5><p>下面以点带权的树为例，结合路径权值修改、路径询问权值和问题，介绍常用的剖分方法，该方法是轻、重边剖分。<br>我们将树中的边分为两种：轻边 和 重边。如图1所示，图中红色的边是重边，其余的是轻边。<br><img src="/2019/10/10/lct/1.png" alt="1"><br>图1：节点数字代表子树大小（size）<br>我们可以以任意点为根，然后记size( u )为以u为根的子树的节点个数，令 v 为 u 所有儿子中 size 值最大的一个，则(u,v)是重边，v 称为 u 的重儿子。u 到其余儿子的边为轻边。</p><h5 id="轻重边的性质"><a href="#轻重边的性质" class="headerlink" title="轻重边的性质"></a>轻重边的性质</h5><p>轻重边有如下几个性质：</p><ol><li>如果(u , v)为轻边，则 size( v ) &lt;= size( u ) / 2。</li><li>从根到某一点v的路径上的轻边个数不多于O(logN)。</li><li>我们称某条路径为重路径（链），当且仅当它全部由重边组成（特殊地，一个点也算一条重路径）。那么对于每个点到根的路径上都有不超过O(logN)条轻边和O(logN)条重路径。</li></ol><p>同时我们也容易发现，一个点在且只在一条重路径上，而每条重路径一定是一条从根节点方向向叶节点方向延申的深度递增的路径（因为一个非叶节点有且只有一个重儿子）。</p><h5 id="如何处理树上的路径"><a href="#如何处理树上的路径" class="headerlink" title="如何处理树上的路径"></a>如何处理树上的路径</h5><p>对树进行轻、重边剖分后，操作所要处理的路径（u , v），我们可以分别处理u，v两个点到其最近公共祖先的路径。根据性质3，路径可以分解为最多O(logN)条的重路径和最多O(logN)的轻边，那么现在我们<strong>只考虑如何维护这两种对象。</strong></p><p>对于重路径，它们此时相当于一个序列，因此我们只需要用线段树维护。而对于轻边，我们可以直接跳过，访问下一条重路径，因为轻边的两端点一定在某两条重路径上。这两种操作的时间复杂度分别为$O(log^2N)$和O(logN)，因此总的时间复杂度为$O(log^2N)$。</p><h5 id="剖分方法"><a href="#剖分方法" class="headerlink" title="剖分方法"></a>剖分方法</h5><p>轻、重边剖分的过程可以用两次dfs实现，有时为了防止递归过深而导致栈溢出，也可以用bfs实现。<br><strong>剖分过程中主要计算如下7个值：</strong><br>par[x] : x在树中的父亲。<br>deep[x]：x在树中的深度。<br>size[x]：x的子树节点数（子树大小）。<br>son[x]：x的重儿子，即u-&gt;son[u]为重边。<br>top[x]：x所在重路径的顶部节点（深度最小）。<br>seg[x]：x所在线段树中的位置（下标）。<br>rev[x]：线段树中第x个位置对应的树中节点编号，即rev[seg[x] ] = x。</p><p>第一遍 dfs 时可以计算前 4 个值，第二遍 dfs 可以计算后 3 个值。而计算 seg 时，同一条重路径上的点需要按顺序排在连续的一段位置，也就是一段区间。</p><p>将一条路径(u ,v)拆分为若干条重路径的过程，实际上就是一个寻找最近公共祖先的过程。考虑“暴力”的做法，我们会选择u，v中深度较大的点向上走一步，直到u = v。现在有了重路径，由于我们记录了重路径的顶部节点top[x]，还记录了每个点在序列中的位置，因此我们不需要一步步走。假定top[u]和top[v]不同，那么它们的最近公共祖先可能在其中一条重路径上，也可能在其他的重路径上，因为LCA显然不可能在top深度较大的那条重路径上，所以我们先处理top深度较大的。假设u是深度较大的，则可以直接条到par[top[u]]处，且跳过的这一段，在线段树中是一段区间，若我们按照深度从小到大来存储点，则这段区间为：[seg[top[x]] , seg[x]]。当u，v的top相同时，说明它们走到了同一条重路径上，这时它们之间的路径也是序列上的一段区间，且u，v中深度较小的那点是原路径的LCA。</p><p>这样我们就可以将给出的任意路径拆分成若干条重路径，也就是若干个区间，并用线段树等数据结构处理操作。</p><h4 id="例题模板"><a href="#例题模板" class="headerlink" title="例题模板"></a>例题模板</h4><p>原题来自：ZJOI 2008</p><p>一树上有 n 个节点，编号分别为 1 到 n，每个节点都有一个权值 w。我们将以下面的形式来要求你对这棵树完成一些操作：<br>1.CHANGE u t ：把节点 u 权值改为 t；<br>2.QMAX u v ：询问点 u 到点 v 路径上的节点的最大权值；<br>3.QSUM u v ：询问点 u 到点 v 路径上的节点的权值和。<br>注意：从点 u 到点 v 路径上的节点包括 u 和 v 本身。</p><p>模板使用说明：</p><ul><li>将树拆分成若干条链，为树上每个点分配一个编号，同一条链上的编号连续，然后在这些编号上建立线段树维护。seg[x]是树上的节点x在线段树的下标，rev[y]是线段树下标为 y 节点在树中的编号。</li><li>树的节点编号要从1开始，不能从0。</li><li>子树在线段树中的下标是连续的，以 x 为根的子树起点下标是seg[x]，终点是seg[x]+size[x]-1。</li></ul><p><strong>代码模板</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y, edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,q,a[N];</span><br><span class="line"><span class="comment">/*父亲,深度,子树大小,重儿子,重路径顶部节点,</span></span><br><span class="line"><span class="comment">    树中节点在线段树中下标,线段树中节点对应树中位置*/</span></span><br><span class="line"><span class="keyword">int</span> par[N],deep[N],size[N],son[N],top[N],seg[N],rev[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*利用深搜更新par,size,deep,son数组*/</span></span><br><span class="line">    vis[x] = <span class="literal">true</span>; size[x] = <span class="number">1</span>;</span><br><span class="line">    par[x] = fa; deep[x] = deep[fa]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(y == fa || vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y,x);</span><br><span class="line">        size[x] += size[y]; <span class="comment">//累加子树大小</span></span><br><span class="line">        <span class="keyword">if</span>(size[y] &gt; size[son[x]]) son[x] = y;<span class="comment">//求重儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x])&#123; <span class="comment">//先走重儿子,使得重路径在线段树中连续</span></span><br><span class="line">        seg[son[x]] = ++seg[<span class="number">0</span>];<span class="comment">//0位置用不到,利用来计数</span></span><br><span class="line">        top[son[x]] = top[x];</span><br><span class="line">        rev[seg[<span class="number">0</span>]] = son[x];</span><br><span class="line">        dfs2(son[x],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(top[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">/*若y没有被遍历过,即y不是x的重儿子或者父亲*/</span></span><br><span class="line">        seg[y] = ++seg[<span class="number">0</span>]; rev[seg[<span class="number">0</span>]] = y;</span><br><span class="line">        top[y] = y; dfs2(y,x);</span><br><span class="line">        <span class="comment">/*如果x--&gt;y是轻边,那么y就是其所在重路径顶部节点*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    ll mx, sum;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mx(x) t[x].mx</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    l(rt) = l, r(rt) = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        mx(rt) = sum(rt) = a[rev[l]]; <span class="comment">//线段树上l节点对应着树上rev[l]点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    BuildTree(rt*<span class="number">2</span>,l,mid); BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    mx(rt) = max(mx(rt&lt;&lt;<span class="number">1</span>),mx(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>) + sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preHandle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>); <span class="comment">//我们以1号节点为根</span></span><br><span class="line">    <span class="comment">/*根节点所在重路径的顶部节点也是根节点,赋初值*/</span></span><br><span class="line">    seg[<span class="number">0</span>] = seg[<span class="number">1</span>] = top[<span class="number">1</span>] = rev[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    BuildTree(<span class="number">1</span>,<span class="number">1</span>,seg[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">ll tmx,tsum;<span class="comment">//利用全局变量同时统计2个答案</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*将以rt为根的区间内属于[l,r]部分的和累加到tsum上,并更新tmx*/</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">        tsum += sum(rt); tmx = max(tmx,mx(rt));</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) query(rt&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*返回x与y之间路径上权值最大点的权值*/</span></span><br><span class="line">    <span class="keyword">int</span> fx = top[x] , fy = top[y];</span><br><span class="line">    <span class="keyword">while</span>(fx != fy)&#123;<span class="comment">//先将x和y条整到同一个重链上</span></span><br><span class="line">        <span class="keyword">if</span>(deep[fx] &lt; deep[fy]) swap(x,y),swap(fx,fy);</span><br><span class="line">        query(<span class="number">1</span>,seg[fx],seg[x]);</span><br><span class="line">        x = par[fx]; fx = top[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deep[x] &gt; deep[y]) swap(x,y);<span class="comment">//路径浅的编号小</span></span><br><span class="line">    query(<span class="number">1</span>,seg[x],seg[y]); <span class="comment">//再更新一次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*把线段树节点x的权值改为val*/</span></span><br><span class="line">    <span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">        mx(rt) = sum(rt) = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt) + r(rt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; mid) change(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,val);</span><br><span class="line">    <span class="keyword">else</span> change(rt&lt;&lt;<span class="number">1</span>,x,val);</span><br><span class="line">    mx(rt) = max(mx(rt&lt;&lt;<span class="number">1</span>),mx(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>) + sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">"123.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">"222.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        addEdge(x,y,<span class="number">1</span>); addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    preHandle();<span class="comment">//树链剖分预处理</span></span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= q;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>,op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'C'</span>) change(<span class="number">1</span>,seg[x],y);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmx = -INF; tsum = <span class="number">0</span>;</span><br><span class="line">            ask(x,y);<span class="comment">//同时更新最大值与路径和</span></span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">'M'</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,tmx);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,tsum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;树链剖分是用来维护静态树上路径信息的数据结构，静态即树的形态不能改变（增删点或者换根，改变了构造）。&lt;br&gt;其思想是将树上的路径分为重路径和
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="树链剖分" scheme="http://valenshi.top/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>树上倍增LCA题集</title>
    <link href="http://valenshi.top/2019/10/09/lca-problems/"/>
    <id>http://valenshi.top/2019/10/09/lca-problems/</id>
    <published>2019-10-09T12:04:00.000Z</published>
    <updated>2019-10-09T12:16:10.691Z</updated>
    
    <content type="html"><![CDATA[<p>树上倍增法可以用于求LCA，当然在其它场合也有应用，在很多时候看似不是树形的问题，我们也可以通过转化成树形结构，然后在树中进行操作，这种操作可以是求二者之间的最近状态，或者是二者之间的距离，如最后一题。<br>另外关于树的题型，最好还是根据样例画图思考，往往可以比空想获得更多思路。</p><h4 id="点的距离"><a href="#点的距离" class="headerlink" title="点的距离"></a>点的距离</h4><p><strong>题意简述</strong><br>给定一棵 n 个点的树，Q 个询问，每次询问点 x 到点 y 两点之间的距离。<br><strong>解题思路</strong><br>模板题，用树上倍增法，初始化时间为O(NlogN)，查询时间O(logN)。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="comment">//anc[x][i]表示x往上走2^i步的祖先编号 </span></span><br><span class="line"><span class="keyword">int</span> anc[N][<span class="number">25</span>], deep[N],dis[N];</span><br><span class="line"><span class="keyword">int</span> root = <span class="number">1</span>;<span class="comment">//这棵树的根,无特殊说明可以为1 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++)</span><br><span class="line">anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i] , z = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dis[y] || y == root) <span class="keyword">continue</span>;</span><br><span class="line">deep[y] = deep[x]+<span class="number">1</span>;</span><br><span class="line">dis[y] = dis[x] + z;</span><br><span class="line">anc[y][<span class="number">0</span>] = x; dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[u] &lt; deep[v]) swap(u,v);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(deep[anc[u][i]] &gt;= deep[v]) u = anc[u][i];</span><br><span class="line"><span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(anc[u][i] != anc[v][i])&#123;</span><br><span class="line">u = anc[u][i]; v= anc[v][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">/*logN时间内返回x与y之间的距离,注意是否会爆int*/</span> </span><br><span class="line"><span class="keyword">return</span> dis[x] + dis[y] - <span class="number">2</span>*dis[Lca(x,y)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);<span class="comment">//双向边 </span></span><br><span class="line">&#125;</span><br><span class="line">deep[<span class="number">0</span>] = <span class="number">-1</span>; dfs(root);<span class="comment">//完成预处理 </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= q;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="暗的锁链"><a href="#暗的锁链" class="headerlink" title="暗的锁链*"></a>暗的锁链*</h4><p><strong>题意简述</strong><br>原题来自：POJ 3417</p><p>Dark 是一张无向图，图中有 N 个节点和两类边，一类边被称为主要边，而另一类被称为附加边。Dark 有 N–1 条主要边，并且 Dark 的任意两个节点之间都存在一条只由主要边构成的路径。另外，Dark 还有 M 条附加边。</p><p>你的任务是把 Dark 斩为不连通的两部分。一开始 Dark 的附加边都处于无敌状态，你只能选择一条主要边切断。一旦你切断了一条主要边，Dark 就会进入防御模式，主要边会变为无敌的而附加边可以被切断。但是你的能力只能再切断 Dark 的一条附加边。</p><p>现在你想要知道，一共有多少种方案可以击败 Dark。注意，就算你第一步切断主要边之后就已经把 Dark 斩为两截，你也需要切断一条附加边才算击败了 Dark。</p><p><strong>解题思路</strong><br>这是一道需要观察和转化题意的问题。<br>在树上如果有一条附加边，就形成了一个环，可知每个环内最多有一条附加边。如果一条主要边在环中，则称该主要边被<strong>覆盖</strong> ，它在几个环内，就被覆盖了几次。可知一个主要边最多被覆盖2次。<br>如果一条主要边被覆盖了 2 次，那么我们无论怎么切都切不断 Dark，因为切断了主要边后，还是一个环，而切断一个环需要切断两条边。如果一条主要边被覆盖了 1 次，那么我们切断该主要边后，再切断它的附加边即可，即只有一种方案。如果一条主要边被覆盖0次，那么我们切完该主要边后，可以任意切一条附加边，共 m 中方案（m 是附加边的条数）。综上所述，我们只需要求出每条主要边被附加边覆盖次数即可，我们设 f[x] 为 x 到其父节点的主要边被覆盖的次数。</p><p>我们可以利用<strong>树上差分</strong>来求 f 数组，树上差分的思想就不额外介绍了，具体做法是如果有一条附加边(x, y)，那么f[x]++ ,f[y]++，同时 f[ Lca(x, y) ] -= 2，这样当我们添加完附加边后，将 f 数组从叶子节点向上累加，即可更新完毕 f 数组。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x];head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,f[N];</span><br><span class="line"><span class="keyword">int</span> dis[N],deep[N],anc[N][<span class="number">24</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++) </span><br><span class="line">anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dis[y] || y == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">deep[y] = deep[x] + <span class="number">1</span>;</span><br><span class="line">dis[y] = dis[x] + z;</span><br><span class="line">anc[y][<span class="number">0</span>] = x; dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[x] &lt; deep[y]) swap(x,y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(deep[anc[x][i]] &gt;= deep[y]) x = anc[x][i];</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(anc[x][i] != anc[y][i])&#123;</span><br><span class="line">x = anc[x][i]; y = anc[y][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">f[x] += dfs2(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">f[x]++; f[y]++; f[Lca(x,y)] -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">dfs2(<span class="number">1</span>); <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(!f[i]) ans += m;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(f[i] == <span class="number">1</span>) ans++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="异象石"><a href="#异象石" class="headerlink" title="异象石*"></a>异象石*</h4><p><strong>题意简述</strong><br>原题来自：Contest Hunter Round #56</p><p>在 Adera 的异时空中有一张地图。这张地图上有 N 个点，有 N−1 条双向边把它们连通起来。起初地图上没有任何异象石，在接下来的 M 个时刻中，每个时刻会发生以下三种类型的事件之一：</p><p>地图的某个点上出现了异象石（已经出现的不会再次出现）；</p><p>地图某个点上的异象石被摧毁（不会摧毁没有异象石的点）；</p><p>向玩家询问使所有异象石所在的点连通的边集的总长度最小是多少。</p><p>请你作为玩家回答这些问题。下图是一个例子，灰色节点表示出现了异象石，加粗的边表示被选为连通异象石的边集。</p><p><strong>解题思路</strong><br>我也不太能理解这题的思路是怎么发现的。<br>很自然的想法就是求所有 k 个异象石两两之间的距离和，然后 / (k-1) 即为答案，但显然会超时。<br>正解是利用一个结论，该结论题解没给出证明，搞懂了再补上。<br>对这颗树先进行dfs遍历，给每个节点打上一个时间戳，设节点 x 的时间戳为 dfn[x]；设已存在的异象石中，dfn序是 x 前驱的节点编号为 pre，后继节点编号为 nex，那么在 x 处插入异象石后， ans += Dis(pre , x) + Dis(x, nex) - Dis(pre, nex)。<br>删除一个异象石同理，减去就好。<br>证明暂时没有，另外这个要做法记住，是用来求树上多个节点之间的最短总路径用的。</p><p>还要注意set的用法，如果set为空，那么begin() = end()，此时如果用指向end()的迭代器自增或自减都是不合法的。</p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x];head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,f[N];</span><br><span class="line"><span class="keyword">int</span> dis[N],deep[N],anc[N][<span class="number">24</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++) </span><br><span class="line">anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dis[y] || y == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">deep[y] = deep[x] + <span class="number">1</span>;</span><br><span class="line">dis[y] = dis[x] + z;</span><br><span class="line">anc[y][<span class="number">0</span>] = x; dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[x] &lt; deep[y]) swap(x,y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(deep[anc[x][i]] &gt;= deep[y]) x = anc[x][i];</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(anc[x][i] != anc[y][i])&#123;</span><br><span class="line">x = anc[x][i]; y = anc[y][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">f[x] += dfs2(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">f[x]++; f[y]++; f[Lca(x,y)] -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">dfs2(<span class="number">1</span>); <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(!f[i]) ans += m;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(f[i] == <span class="number">1</span>) ans++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树*"></a>次小生成树*</h4><p>这是阳哥哥负责的题型，我就不越界了。</p><h4 id="Dis"><a href="#Dis" class="headerlink" title="Dis"></a>Dis</h4><p><strong>题意简述</strong><br>给出 n 个点的一棵树，多次询问两点之间的最短距离。<br>注意：边是双向的。<br><strong>解题思路</strong><br>这个就是标准的模板题了，和第一题一样，注意一下细节即可。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],edge[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x];</span><br><span class="line">edge[tot] = z; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">int</span> anc[N][<span class="number">25</span>], deep[N],dis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++)</span><br><span class="line">anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i] , z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(dis[y] || y == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">deep[y] = deep[x]+<span class="number">1</span>;</span><br><span class="line">dis[y] = dis[x] + z;</span><br><span class="line">anc[y][<span class="number">0</span>] = x; dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[u] &lt; deep[v]) swap(u,v);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(deep[anc[u][i]] &gt;= deep[v]) u = anc[u][i];</span><br><span class="line"><span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(anc[u][i] != anc[v][i])&#123;</span><br><span class="line">u = anc[u][i]; v= anc[v][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> dis[x] + dis[y] - <span class="number">2</span>*dis[Lca(x,y)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addEdge(x,y,z); addEdge(y,x,z);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>);<span class="comment">//完成预处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= q;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="祖孙询问"><a href="#祖孙询问" class="headerlink" title="祖孙询问"></a>祖孙询问</h4><p><strong>题意简述</strong><br>已知一棵 n 个节点的有根树。有 m 个询问，每个询问给出了一对节点的编号 x 和 y，询问 x 与 y 的祖孙关系。<br><strong>解题思路</strong><br>简单的模板题，需要注意的是如果 x == y，那么是属于<strong>其它情况</strong>哦。<br>另外还需要注意一下，deep[0] = -1，否则会和根节点数值相等而出错。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> anc[N][<span class="number">25</span>], dis[N],deep[N];</span><br><span class="line"><span class="keyword">int</span> root;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++)</span><br><span class="line">anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(dis[y] || y == root) <span class="keyword">continue</span>;</span><br><span class="line">deep[y] = deep[x]+<span class="number">1</span>;</span><br><span class="line">dis[y] = dis[x] + <span class="number">1</span>;</span><br><span class="line">anc[y][<span class="number">0</span>] = x; dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[x] &lt; deep[y]) swap(x,y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(deep[anc[x][i]] &gt;= deep[y]) x = anc[x][i];</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(anc[x][i] != anc[y][i])&#123;</span><br><span class="line">x = anc[x][i]; y = anc[y][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">if</span>(y == <span class="number">-1</span>) root = x;</span><br><span class="line"><span class="keyword">else</span> addEdge(x,y,<span class="number">1</span>), addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 因为deep[root] = 0,如果deep[0] = 0,则会认为 0 号节点也是根 */</span></span><br><span class="line">deep[<span class="number">0</span>] = <span class="number">-1</span>; dfs(root);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">int</span> par = Lca(x,y);</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(par == x) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(par == y) <span class="built_in">puts</span>(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="聚会"><a href="#聚会" class="headerlink" title="聚会*"></a>聚会*</h4><p><strong>题意简述</strong><br>原题来自：AHOI 2008</p><p>Y 岛风景美丽宜人，气候温和，物产丰富。Y 岛上有 N 个城市，有 N−1 条城市间的道路连接着它们。每一条道路都连接某两个城市。幸运的是，小可可通过这些道路可以走遍 Y 岛的所有城市。神奇的是，乘车经过每条道路所需要的费用都是一样的。</p><p>小可可，小卡卡和小 YY 经常想聚会，每次聚会，他们都会选择一个城市，使得三个人到达这个城市的总费用最小。</p><p>由于他们计划中还会有很多次聚会，每次都选择一个地点是很烦人的事情，所以他们决定把这件事情交给你来完成。他们会提供给你地图以及若干次聚会前他们所处的位置，希望你为他们的每一次聚会选择一个合适的地点。</p><p><strong>解题思路</strong><br>在一棵树上求三个点 (x, y ,z) 之间的最短路径，我们求出dis[x, y] + dis[x , z] + dis[y , z]，画图就会发现每一段路径都被重复计算了 2 次，于是我们再将答案 / 2就得到了三个点之间的路径。<br>假设这个聚会点为 p ，那么显然 p 是三条路径的交汇点，否则路径和肯定不会是最短。下一步的目标就是求出这个交汇点的坐标。</p><p>如果我们以某个点为根，为每个节点更新深度deep（就像我们在求LCA时一样），那么显然 p 点就是 Lca[x, y] , Lca[x , z] , Lca[y , z] 三者中deep最大（最深）的点，这也可以通过画图观察出来，也很容易证明。</p><p>于是我们就可以利用树上倍增法求出Lca，在O(NlogN)时间内解决该题，但是常数不太优秀，极限数据还是会被卡掉，如果想满分需要用树链剖分，不过该思路已经可以通过一本通oj上的数据了。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y, edge[tot] = z;</span><br><span class="line">nex[tot] = head[x] , head[x] = tot;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) </span><br><span class="line">res = res*<span class="number">10</span>+c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> root = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> deep[N],anc[N][<span class="number">24</span>],dis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++)</span><br><span class="line">anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(dis[y] || y == root) <span class="keyword">continue</span>;</span><br><span class="line">deep[y] = deep[x] + <span class="number">1</span>;</span><br><span class="line">dis[y] = dis[x] + <span class="number">1</span>;</span><br><span class="line">anc[y][<span class="number">0</span>] = x; dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[x] &lt; deep[y]) swap(x,y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(deep[anc[x][i]] &gt;= deep[y]) x = anc[x][i];</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(anc[x][i] != anc[y][i])&#123;</span><br><span class="line">x = anc[x][i]; y = anc[y][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dis</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> dis[x] + dis[y] - <span class="number">2</span>*dis[Lca(x,y)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">print(x/<span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">addEdge(x,y,<span class="number">1</span>); addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">deep[<span class="number">0</span>] = <span class="number">-1</span>; dfs(root);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt(); z = getInt();</span><br><span class="line"><span class="keyword">int</span> par = Lca(x,y); </span><br><span class="line"><span class="keyword">int</span> p2 = Lca(x,z) , p3 = Lca(y,z);</span><br><span class="line"><span class="keyword">if</span>(deep[par] &lt; deep[p2]) par = p2;</span><br><span class="line"><span class="keyword">if</span>(deep[par] &lt; deep[p3]) par = p3;</span><br><span class="line"><span class="keyword">int</span> res = Dis(x,y) + Dis(x,z) + Dis(y,z) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">print(par); <span class="built_in">putchar</span>(<span class="string">' '</span>); print(res); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="跳跳棋"><a href="#跳跳棋" class="headerlink" title="跳跳棋**"></a>跳跳棋**</h4><p><strong>题意简述</strong><br>原题来自：BZOJ 2144</p><p>跳跳棋是在一条数轴上进行的。棋子只能摆在整点上。每个点不能摆超过一个棋子。我们用跳跳棋来做一个简单的游戏：棋盘上有三颗棋子，分别在 a,b,c 这三个位置。我们要通过最少的跳动把他们的位置移动成 x,y,z（注意：棋子是没有区别的）。</p><p>跳动的规则很简单，任意选一颗棋子，对一颗中轴棋子跳动。跳动后两颗棋子距离不变。一次只允许跳过一颗棋子。</p><p>写一个程序，首先判断是否可以完成任务。如果可以，输出最少需要的跳动次数。<br><img src="/2019/10/09/lca-problems/1.png" alt="1"><br><strong>解题思路</strong><br>这题有好几个难点，思路也不是那么容易想到。</p><p>首先比较容易想到的是，有哪些点是可以达到的；设a,b,c升序，l1 = b-a, l2 = c-b，那么(l1, l2)可以转移到 (l1, l2-l1) 和 (l1-l2 , l2)。<br>那么每次转移了多少长度，向哪个方向转移的我们都知道了，自然就可以得到点的转移。就比如 (l1 , l2)  —&gt; (l1 , l2 - l1) ，就对应着(a ,b ,c)—&gt;(b, 2b-a, c)。</p><p>既然我们知道点如何转移，那么问题就变成了判断 (a , b, c) 和 (x , y , z) 是否可以转移到同一个状态。</p><p>我们上面只讨论了两端节点向中间跳（对应着合法长度的相减，a跳到b、c中间，c跳到a、b中间），没考虑中间节点向两边跳（a关于c跳，或c关于a跳，或b关于a、c跳，对应着合法长度的相加），实际上两者都成立，比如(l1 , l2)—&gt;(l1, l1+l2)对应着(a ,b ,c) —&gt; (b , a , c) ，但是如果我们将其中两点之间的距离不断变大，会终止于正无穷，但如果不断缩小，就会终止于某一个非负整数；基于此我们只考虑“两边的点向中间跳”这种情况，这对应着开始介绍的两个减法转移。</p><p>到此就有些明朗了，每个状态看作一个节点，转移一次就看作向上走一步，最终一定会终止于某一个状态，这个状态就可以看作根节点；我们将(a ,b ,c) 与 (x, y , z)同时“向上”转移，如果它们终止于同一个状态，就说明它们可以互相抵达，否则则不能。</p><p>接下来就是要判断最小的步数，即(a ,b ,c) 到 (x , y , z) 的最少转移次数。这就相当于求二者的LCA，因为它们有共同的“根节点”，并且有着到根节点的唯一路径，所以可以将它们的转移看作一棵树，边权为1，求着两个状态之间的距离。</p><p>由于我们利用的是合法长度的转移来对应着点的状态的转移，即(l1, l2) —&gt; (l1 , l2-l1)或(l1-l2, l2)。这和更相减损术 gcd(a, b) = gcd(a, b-a) = gcd(a-b, a)相同，而欧几里得又告诉我们 gcd(a ,b) = gcd(b ,a%b)，于是本来 O(N) 的减法变成了 O(log N)的除法（取模）。</p><p>我们可以在O(logN)的时间内转移到任意一个父状态，但是我们不知道该向上转移几步才是最少步数，于是我们要先将二者的<strong>深度</strong>调到相同，然后同时向上走 k 步，这可以用倍增实现，也可以用二分搜索实现。求深度我们可以在求第一问时顺便求解，同时深度也是最长路径，用于二分。</p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>],b[<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line">Node()&#123;&#125;</span><br><span class="line">Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z):x(x),y(y),z(z)&#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> Node&amp; B) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(x == B.x &amp;&amp; y == B.y &amp;&amp; z == B.z);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> deep;</span><br><span class="line"><span class="function">Node <span class="title">jump</span><span class="params">(Node h, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回从位置h向上跳step步后的状态,顺便记录一下当前深度(距根距离)*/</span></span><br><span class="line">Node res = h;</span><br><span class="line"><span class="keyword">int</span> t1 = h.y-h.x, t2 = h.z - h.y;</span><br><span class="line"><span class="keyword">if</span>(t1 == t2) <span class="keyword">return</span> res; </span><br><span class="line"><span class="keyword">if</span>(t1 &lt; t2)&#123;</span><br><span class="line"><span class="keyword">int</span> t = min(step,(t2<span class="number">-1</span>)/t1);<span class="comment">//用除法优化 </span></span><br><span class="line">step -= t; deep += t;<span class="comment">//记录一下深度 </span></span><br><span class="line">res.y += t*t1; res.x += t*t1;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = min(step,(t1<span class="number">-1</span>)/t2);</span><br><span class="line">step -= t; deep += t;</span><br><span class="line">res.y -= t*t2; res.z -= t*t2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(step) <span class="keyword">return</span> jump(res,step);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,Node h1,Node h2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(jump(h1,x) != jump(h2,x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span>;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span>;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,b+i);</span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">4</span>); sort(b+<span class="number">1</span>,b+<span class="number">4</span>);</span><br><span class="line">Node h1(a[1],a[2],a[3]) , h2(b[1],b[2],b[3]);</span><br><span class="line">Node aa = jump(h1,INF); <span class="keyword">int</span> d1 = deep; deep = <span class="number">0</span>;</span><br><span class="line">Node bb = jump(h2,INF); <span class="keyword">int</span> d2 = deep; deep = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(aa != bb)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"NO"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line"><span class="comment">/*计算步数：先调整到同一深度,再二分一起跳*/</span></span><br><span class="line"><span class="keyword">if</span>(d1 &lt; d2) swap(d1,d2),swap(h1,h2);</span><br><span class="line">h1 = jump(h1,d1-d2);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = d1;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid,h1,h2)) r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="number">2</span>*l+d1-d2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;树上倍增法可以用于求LCA，当然在其它场合也有应用，在很多时候看似不是树形的问题，我们也可以通过转化成树形结构，然后在树中进行操作，这种操作可以是求二者之间的最近状态，或者是二者之间的距离，如最后一题。&lt;br&gt;另外关于树的题型，最好还是根据样例画图思考，往往可以比空想获得更
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="lca" scheme="http://valenshi.top/tags/lca/"/>
    
      <category term="树上倍增" scheme="http://valenshi.top/tags/%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树相关问题</title>
    <link href="http://valenshi.top/2019/10/09/MSTs/"/>
    <id>http://valenshi.top/2019/10/09/MSTs/</id>
    <published>2019-10-09T10:47:52.000Z</published>
    <updated>2019-10-09T10:48:57.678Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>在对最小生成树算法有一定理解后，我们对典型的最小生成树题型应该不难解决，但是对于由最小生成树模型变形而来的几种模型，我们仍需做一次总结与记录。<br>首先我们需要提出最小生成树几个性质，便于推导算法；然后我们将介绍6种最小生成树相关问题模型，并讨论一般解法与更优解法；其中有的解法显而易见，接受起来也很简单，但有的解法却需要从理论上逻辑严密的进行推导，构造算法并证明算法的正确性，这部分难度稍大。<br>这6个相关问题分别是：增量最小生成树，最小瓶颈生成树，最小瓶颈路，每对节点的最小瓶颈路，次小生成树，最小有向生成树。</p><h4 id="图论中的2个性质："><a href="#图论中的2个性质：" class="headerlink" title="图论中的2个性质："></a>图论中的2个性质：</h4><ul><li><strong>切割性质：</strong> 假定所有边权均不相同。设S为既非空集也非全集的V的子集，边e是满足一个端点在S内，另一个端点不在S内的所有边中权值最小的一个，则图G的所有生成树均包含e。</li><li><strong>回路性质：</strong> 假定所有边权值均不相同。设C是图G中任意回路，边e是C上权值最大的边，则图G的所有生成树均不包含e。</li></ul><p>在此不给出证明。</p><h4 id="增量最小生成树"><a href="#增量最小生成树" class="headerlink" title="增量最小生成树"></a>增量最小生成树</h4><p><strong>问题描述：</strong><br>从包含n个点的空图开始，依次加入m条带权边。每加入一条边，输出当前图中的最小生成树权值（如果当前图不连通，则输出无解）。<br><strong>解题思路：</strong><br>如果每次重新求完整的最小生成树问题，总时间复杂度高达O(m^2 log n)。根据回路的性质，可以得到如下改进算法：</p><blockquote><p>每次求出新的最小生成树后，把其它的边删除。由于每次只需计算一个n条边（原生成树有 n - 1条，新加入一条）的图的最小生成树，Kruskal算法的时间复杂度降为O(n log n)，总时间复杂度为O(nm log n)。</p></blockquote><p>这个算法可以进一步改进:</p><blockquote><p>加入一条边e = (u, v)之后，图中恰好包含一个环。根据回路性质，删除该回路上权值最大的边即可，因此只需在加边之前的MST上找到u到v的唯一路径上的权值最大的边，再和e比较，删除权值较大的一条。由于路径唯一，可以用DFS或BFS找到这条u到v的路径，总时间复杂度为O(nm)。</p></blockquote><h4 id="最小瓶颈生成树"><a href="#最小瓶颈生成树" class="headerlink" title="最小瓶颈生成树"></a>最小瓶颈生成树</h4><p><strong>问题描述：</strong><br>给出加权无向图，求一棵生成树，使得最大边权值尽量小。</p><p><strong>解题思路：</strong><br>由于只关心最大边权值，我们可以从一个空图开始，按照权值从小到大的顺序依次加入各条边，则图第一次连通时，该图的最小生成树就是原图的最小瓶颈生成树。可以发现，原图的最小生成树就是一棵最小瓶颈生成树（但不是每棵最小瓶颈生成树都是最小生成树）。</p><h4 id="最小瓶颈路"><a href="#最小瓶颈路" class="headerlink" title="最小瓶颈路"></a>最小瓶颈路</h4><p><strong>问题描述：</strong><br>给定加权无向图的两个节点u和v，求出从u到v的一条路径，使得路径上最长边尽量短。</p><p><strong>解题思路：</strong><br>这个问题可以用二分法+BFS解决，但我们有更好的算法。先求出这个图的最小生成树，则起点和终点在树上的唯一路径就是我们要找的路径，这条路径上的最长边就是问题的答案。</p><h4 id="每对结点间的最小瓶颈路"><a href="#每对结点间的最小瓶颈路" class="headerlink" title="每对结点间的最小瓶颈路"></a>每对结点间的最小瓶颈路</h4><p><strong>问题描述：</strong><br>给出加权无向图，求每两个节点u和v之间的最小瓶颈路的最大边长f(u,v)。</p><p><strong>解题思路：</strong></p><blockquote><p>先求最小生成树。接下来，用DFS把最小生成树变成有根树，同时计算f(u,v)，当新访问一个节点u时，考虑所有已经访问过的老节点x，更新f(x,u) = max(f(x,v) , w(u,v))，其中v是u的父节点。每个f(u,v)只需经过常数时间计算，因此是时间复杂度为O(n^2)。</p></blockquote><h4 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a>次小生成树</h4><p><strong>问题描述：</strong><br>把所有生成树按照权值之和从大到小的顺序排列，求排在第二位的生成树。注意，如果最小生成树不唯一，次小生成树的权值与最小生成树相同。</p><p><strong>解题思路：</strong> </p><blockquote><p>次小生成树不会与最小生成树完全相同，因此可以枚举最小生成树中不在次小生成树中出现的边。注意最小生成树只有n-1条边，所以只需枚举n-1次。每次在剩下的边里求一次最小生成树，则这n-1棵“缺一条边的图”的最小生成树中权最小的就是原图的次小生成树。</p></blockquote><p>还有一种更好的方法：</p><blockquote><p>枚举要加入哪条新边。在最小生成树上加一条边u-v之后，图上会出现一条回路，因此删除的边必须在最小生成树上u到v的路径上，且是这条路径上的最长边。可以证明，次小生成树一定可以由最小生成树加一条边再删一条边得到（称为边交换），因此只需按照“每对节点之间的最小瓶颈路”的方法求出每对节点u和v在最小生成树中唯一路径的最大边权maxcost[u][v]，则剩下的部分只需要O(m)时间（枚举所有m-n+1条边进行交换，每次花O(1)时间求出新生成树的权值）。总时间复杂度为O(n^2)。</p></blockquote><h4 id="最小有向生成树"><a href="#最小有向生成树" class="headerlink" title="最小有向生成树"></a>最小有向生成树</h4><p><strong>问题描述：</strong><br>给定一个有向带权图G和其中一个节点u，找出一个以u为根节点，权和最小的有向生成树。有向生成树（directed spanning tree）也叫树形图（arborescence），是指一个类似树的有向图，满足以下条件：</p><ul><li>恰好有一个入度为0的点，称为根节点</li><li>其它节点的入度均为1</li><li>可以从根节点到达其它所有节点</li></ul><p>不难发现，如果树形图的节点数为n，它的边数一定为n-1，且树形图中不存在有向环。</p><p><strong>解题思路：</strong><br>固定根的最小树形图可以用朱-刘算法解决。</p><blockquote><p>首先是预处理，删除自环并判断根节点是否可以到达其它所有节点。如果不是，输出无解并终止程序。<br>接下来是算法的主过程：<br>首先，给所有非根节点选择一条权最小的入边。如果选出来的n-1条边不构成圈，则可以证明这些边就形成了一个最小树形图，否则把每个圈各收缩成一个点，继续上述过程。<br>缩圈之后，圈上所有边都消失了，因此在最终答案里需要加上这些边权之和。但这样做有个问题：假设在算法的某次迭代中，把圈C收缩为人工节点v，则在下一次迭代中，给v选择的入弧将与在圈C中的入弧发生冲突。（假设X在圈中已经有了入弧Y-&gt;X）因此如果收缩之后又选了一个入弧Z-&gt;X，必须把弧Y-&gt;X从最小树形图中删除。这等价于把弧Z-&gt;X的权值减少了Y-&gt;X的权值。</p></blockquote><h5 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h5><ul><li>刘汝佳，算法竞赛入门经典训练指南，北京：清华大学出版社，2012，343-344</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;在对最小生成树算法有一定理解后，我们对典型的最小生成树题型应该不难解决，但是对于由最小生成树模型变形而来的几种模型，我们仍需做一次总结与记录。&lt;br&gt;首先我们需要提出最小生成树几个性质，便于推导算法；然后我们将介绍6种最小生成
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线段树题集</title>
    <link href="http://valenshi.top/2019/10/07/segmentTree-problems/"/>
    <id>http://valenshi.top/2019/10/07/segmentTree-problems/</id>
    <published>2019-10-07T09:47:28.000Z</published>
    <updated>2019-10-07T09:51:23.835Z</updated>
    
    <content type="html"><![CDATA[<h4 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h4><p><strong>题意简述</strong><br>给定一数列，规定有两种操作，一是修改某个元素，二是求区间的连续和。<br><strong>解题思路</strong><br>线段树单点修改，区间查询的模板。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll dat;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dat(x) t[x].dat</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*为区间[l,r]建立以rt为根节点的子树*/</span></span><br><span class="line">l(rt) = l, r(rt) = r,dat(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid);</span><br><span class="line">BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">dat(rt) += val; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt) + r(rt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= mid) Add(rt*<span class="number">2</span>,p,val);</span><br><span class="line"><span class="keyword">else</span> Add(rt*<span class="number">2</span>+<span class="number">1</span>,p,val);</span><br><span class="line">dat(rt) = dat(rt*<span class="number">2</span>) + dat(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(rt) == l &amp;&amp; r(rt) == r) <span class="keyword">return</span> dat(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt) + r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> ask(rt*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r &lt;= mid) <span class="keyword">return</span> ask(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> ask(rt*<span class="number">2</span>,l,mid)+ask(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,k,a,b;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;k,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">if</span>(k) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(<span class="number">1</span>,a,b));</span><br><span class="line"><span class="keyword">else</span> Add(<span class="number">1</span>,a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="A-Simple-Problem-with-Integers"><a href="#A-Simple-Problem-with-Integers" class="headerlink" title="A Simple Problem with Integers"></a>A Simple Problem with Integers</h4><p><strong>题意简述</strong><br>这是一道模板题。</p><p>给定数列 a[1],a[2],…,a[n]，你需要依次进行 q 个操作，操作有两类：</p><p>C l r x：给定 l,r,x，对于所有 i∈[l,r]，将 a[i] 加上 x（换言之，将 a[l],a[l+1],…,a[r] 分别加上 x）；</p><p>Q l r：给定 l,r，求 ∑ri=la[i] 的值（换言之，求 a[l]+a[l+1]+⋯+a[r] 的值）。<br><strong>解题思路</strong><br>这题也是POJ3468。可以用很多种方法解决，是个练手的模板题。线段树区间修改+区间查询，延迟标记的简单使用。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll sum,add;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(x) t[x].add</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">l(rt) = l, r(rt) = r;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum(rt) = a[l]; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid); BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将延迟标记向下传一层*/</span></span><br><span class="line"><span class="keyword">if</span>(!add(p)) <span class="keyword">return</span>;</span><br><span class="line">sum(p*<span class="number">2</span>) += (r(p*<span class="number">2</span>)-l(p*<span class="number">2</span>)+<span class="number">1</span>)*add(p);</span><br><span class="line">sum(p*<span class="number">2</span>+<span class="number">1</span>) += (r(p*<span class="number">2</span>+<span class="number">1</span>)-l(p*<span class="number">2</span>+<span class="number">1</span>)+<span class="number">1</span>)*add(p);</span><br><span class="line">add(p*<span class="number">2</span>) += add(p); add(p*<span class="number">2</span>+<span class="number">1</span>) += add(p);</span><br><span class="line">add(p) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="comment">/*[l,r]内所有位置上元素都+val*/</span> </span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">sum(rt) += (r(rt)-l(rt)+<span class="number">1</span>)*val;</span><br><span class="line">add(rt) += val; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">spread(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) change(rt*<span class="number">2</span>,l,r,val);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) change(rt*<span class="number">2</span>+<span class="number">1</span>,l,r,val);</span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*回答[l,r]区间和*/</span> </span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> sum(rt);</span><br><span class="line">spread(rt); ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) res += ask(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) res += ask(rt*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,l,r,x;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'C'</span>)&#123;</span><br><span class="line">l = getInt(); r = getInt(); x = getInt();</span><br><span class="line">change(<span class="number">1</span>,l,r,x);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">l = getInt(); r = getInt();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(<span class="number">1</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="最大数"><a href="#最大数" class="headerlink" title="最大数"></a>最大数</h4><p><strong>题意简述</strong><br>原题来自：JSOI 2008</p><p>给定一个正整数数列 a1,a2,a3,⋯,an ，每一个数都在 0∼p–1 之间。可以对这列数进行两种操作：</p><p>添加操作：向序列后添加一个数，序列长度变成 n+1；</p><p>询问操作：询问这个序列中最后 L 个数中最大的数是多少。</p><p>程序运行的最开始，整数序列为空。写一个程序，读入操作的序列，并输出询问操作的答案。<br><strong>解题思路</strong><br>因为最多有N个数，那么先根据[1 , N]建立线段树，提前把位置空出来就好了，now指针记录最后一个位置，每次把新加入的元素插入++now，而询问最后L个数的最大值，则用ask(now - L , now)来查询即可，其它的就是线段树上维护区间最大值。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll mx;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mx(x) t[x].mx</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">l(rt) = l, r(rt) = r, mx(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid); BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">mx(rt) = val; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &gt; mid) change(rt*<span class="number">2</span>+<span class="number">1</span>,p,val);</span><br><span class="line"><span class="keyword">else</span> change(rt*<span class="number">2</span>,p,val);</span><br><span class="line">mx(rt) = max(mx(rt*<span class="number">2</span>),mx(rt*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> mx(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt) + r(rt)&gt;&gt;<span class="number">1</span> , res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) res = ask(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) res = max(res,ask(rt*<span class="number">2</span>+<span class="number">1</span>,l,r));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m,p,ans,now;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;p);</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,N<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%d"</span>,op,&amp;x);</span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'A'</span>) change(<span class="number">1</span>,++now,(x*<span class="number">1l</span>l+ans)%p);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans = ask(<span class="number">1</span>,now-x+<span class="number">1</span>,now));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="花神游历各国"><a href="#花神游历各国" class="headerlink" title="花神游历各国*"></a>花神游历各国*</h4><p><strong>题意简述</strong><br>原题来自：BZOJ 3211</p><p>花神喜欢步行游历各国，顺便虐爆各地竞赛。花神有一条游览路线，它是线型的，也就是说，所有游历国家呈一条线的形状排列，花神对每个国家都有一个喜欢程度（当然花神并不一定喜欢所有国家）。</p><p>每一次旅行中，花神会选择一条旅游路线，它在那一串国家中是连续的一段，这次旅行带来的开心值是这些国家的喜欢度的总和，当然花神对这些国家的喜欢程序并不是恒定的，有时会突然对某些国家产生反感，使他对这些国家的喜欢度 δ 变为 $\sqrtδ$（可能是花神虐爆了那些国家的 OI，从而感到乏味）。</p><p>现在给出花神每次的旅行路线，以及开心度的变化，请求出花神每次旅行的开心值。</p><p><strong>解题思路</strong><br>我刚开始想的是如何把修改延迟，但是后来发现不太容易实现。很容易的发现的就是1e9开根10次后就是1了（当然还有下取整），所以题目范围内所有数最多开根10次就会变成1或0，也就是说我们可以记录每个点被修改了多少次，如果已经修改了10次以上，那么再修改也无意义了。<br>于是我们可以每次修改都修改到叶子节点（因为无法延迟或整段修改），同时记录每个节点被修改了多少次，如果一段区间修改次数最小的节点都修改了10次，那么这一段区间就都不用修改了；这就会大大降低时间复杂度，因为每一个节点最多被修改10次，O(10NlogN)。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,mi;</span><br><span class="line">ll sum;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mi(x) t[x].mi</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">l(rt) = l,r(rt) = r,mi(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum(rt) = a[l]; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid); BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(mi(rt) &gt; <span class="number">10</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">sum(rt) = a[l(rt)] = <span class="built_in">sqrt</span>(a[l(rt)]); </span><br><span class="line">mi(rt)++; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt) + r(rt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) change(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) change(rt*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">mi(rt) = min(mi(rt*<span class="number">2</span>),mi(rt*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> sum(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>; ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) res += ask(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) res += ask(rt*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,op,l,r;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;op,&amp;l,&amp;r);</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(<span class="number">1</span>,l,r));</span><br><span class="line"><span class="keyword">else</span> change(<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="维护序列"><a href="#维护序列" class="headerlink" title="维护序列*"></a>维护序列*</h4><p><strong>题意简述</strong><br>原题来自：AHOI 2009</p><p>老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。</p><p>有长为 n 的数列，不妨设为 a1,a2,⋯,an 。有如下三种操作形式：</p><p>把数列中的一段数全部乘一个值；</p><p>把数列中的一段数全部加一个值；</p><p>询问数列中的一段数的和，由于答案可能很大，你只需输出这个数模 P 的值。</p><p><strong>解题思路</strong><br>这个如果修改操作只有 2 或 1，那么就是一个区间修改-延迟标记的模板题，但是它把“乘”和“加”操作放在了一起，当然还是需要用延迟标记来做，add表示待加上的值，mul表示待乘的值。<br>有一个问题，就是我们在向下传递延迟标记时，是先传递加法呢，还是乘法呢？其实问题的根源不在这，而在于我们在做乘法时，对加法的延迟标记也要乘 val，即 add = add * val，因为满足结合律。搞完这点剩下就是写起来比较麻烦而已，没别的难点了</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll add,mul,sum;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x) t[x].mul</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(x) t[x].add</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,P;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">l(rt) = l, r(rt) = r, add(rt) = <span class="number">0</span>, mul(rt) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum(rt) = a[l]; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid); BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread_add</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将累加标记向下传一层*/</span></span><br><span class="line"><span class="keyword">if</span>(!add(p)) <span class="keyword">return</span>;</span><br><span class="line">sum(p*<span class="number">2</span>) = (sum(p*<span class="number">2</span>) + (r(p*<span class="number">2</span>) - l(p*<span class="number">2</span>)+<span class="number">1</span>)*add(p)%P)%P;</span><br><span class="line">sum(p*<span class="number">2</span>+<span class="number">1</span>) = (sum(p*<span class="number">2</span>+<span class="number">1</span>) + (r(p*<span class="number">2</span>+<span class="number">1</span>) - l(p*<span class="number">2</span>+<span class="number">1</span>)+<span class="number">1</span>)*add(p)%P)%P;</span><br><span class="line">add(p*<span class="number">2</span>) = (add(p*<span class="number">2</span>) + add(p))%P; </span><br><span class="line">add(p*<span class="number">2</span>+<span class="number">1</span>) = (add(p*<span class="number">2</span>+<span class="number">1</span>)+add(p))%P; </span><br><span class="line">add(p) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread_mul</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将累乘标记向下传一层,累乘标记对累加标记也有影响*/</span> </span><br><span class="line"><span class="keyword">if</span>(mul(p) == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">sum(p*<span class="number">2</span>) = sum(p*<span class="number">2</span>)*mul(p)%P;</span><br><span class="line">sum(p*<span class="number">2</span>+<span class="number">1</span>) = sum(p*<span class="number">2</span>+<span class="number">1</span>)*mul(p)%P;</span><br><span class="line">mul(p*<span class="number">2</span>) = mul(p*<span class="number">2</span>)*mul(p)%P;</span><br><span class="line">mul(p*<span class="number">2</span>+<span class="number">1</span>) = mul(p*<span class="number">2</span>+<span class="number">1</span>)*mul(p)%P;</span><br><span class="line"><span class="comment">/*更新add标记*/</span> </span><br><span class="line">add(p*<span class="number">2</span>) = add(p*<span class="number">2</span>)*mul(p)%P;</span><br><span class="line">add(p*<span class="number">2</span>+<span class="number">1</span>) = add(p*<span class="number">2</span>+<span class="number">1</span>)*mul(p)%P; </span><br><span class="line">mul(p) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">add(rt) = add(rt)*val%P;<span class="comment">//更新add标记！ </span></span><br><span class="line">sum(rt) = sum(rt)*val%P;</span><br><span class="line">mul(rt) = mul(rt)*val%P;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">spread_mul(rt);spread_add(rt); </span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) Mul(rt*<span class="number">2</span>,l,r,val);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) Mul(rt*<span class="number">2</span>+<span class="number">1</span>,l,r,val);</span><br><span class="line">sum(rt) = (sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>))%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">sum(rt) = (sum(rt) + (r(rt)-l(rt)+<span class="number">1</span>)*val % P)%P;</span><br><span class="line">add(rt) = (add(rt)+val)%P; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">spread_mul(rt); spread_add(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) Add(rt*<span class="number">2</span>,l,r,val);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) Add(rt*<span class="number">2</span>+<span class="number">1</span>,l,r,val);</span><br><span class="line">sum(rt) = (sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>))%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> sum(rt)%P;</span><br><span class="line">spread_mul(rt); spread_add(rt) ;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) res += ask(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) res += ask(rt*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> res%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;P);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,a+i), a[i] %= P;</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,op,t,g,c;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op);</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;t,&amp;g,&amp;c);</span><br><span class="line">Mul(<span class="number">1</span>,t,g,c);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;t,&amp;g,&amp;c);</span><br><span class="line">Add(<span class="number">1</span>,t,g,c);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t,&amp;g);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(<span class="number">1</span>,t,g));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;区间和&quot;&gt;&lt;a href=&quot;#区间和&quot; class=&quot;headerlink&quot; title=&quot;区间和&quot;&gt;&lt;/a&gt;区间和&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;题意简述&lt;/strong&gt;&lt;br&gt;给定一数列，规定有两种操作，一是修改某个元素，二是求区间的连续和。&lt;br&gt;&lt;str
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="线段树" scheme="http://valenshi.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>一维RMQ问题题集</title>
    <link href="http://valenshi.top/2019/10/07/st-problems/"/>
    <id>http://valenshi.top/2019/10/07/st-problems/</id>
    <published>2019-10-07T05:10:12.000Z</published>
    <updated>2019-10-07T05:13:59.758Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/index.php" target="_blank" rel="noopener">书本配套OJ</a><br><a href="http://www.mfstem.org/" target="_blank" rel="noopener">本校OJ</a></p><p>ST表使用说明：</p><ul><li>常用于离线问题，或当作辅助数据结构，查询时间非常优秀，O(1)</li><li>二维st表也很好实现，不过本题集中未涉及</li><li>st表内也可以维护的是下标而非值，在某些时候很有用</li></ul><h4 id="数列区间最大值"><a href="#数列区间最大值" class="headerlink" title="数列区间最大值"></a>数列区间最大值</h4><p><strong>题意简述</strong><br>输入一串数字，给你 M 个询问，每次询问就给你两个数字 X,Y，要求你说出 X 到 Y 这段区间内的最大数。<br><strong>解题思路</strong><br>st表模板题。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>] ,Log[N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'-'</span> &amp;&amp; (c &lt;<span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i]= Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)&#123;</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="最敏捷的机器人"><a href="#最敏捷的机器人" class="headerlink" title="最敏捷的机器人"></a>最敏捷的机器人</h4><p><strong>题意简述</strong><br>Wind 设计了很多机器人。但是它们都认为自己是最强的，于是，一场比赛开始了……</p><p>机器人们都想知道谁是最敏捷的，于是它们进行了如下一个比赛。首先，他们面前会有一排共 n 个数，它们比赛看谁能最先把每连续 k 个数中最大和最小值写下来，当然，这些机器人运算速度都很快，它们比赛的是谁写得快。</p><p>但是 Wind 也想知道答案，你能帮助他吗？<br><strong>解题思路</strong><br>st表模板题，不过还要维护一下最小值，多开一个数组即可。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>] ,Log[N], st2[N][<span class="number">22</span>];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'-'</span> &amp;&amp; (c &lt;<span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i]= Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st2[i][<span class="number">0</span>] = st[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)&#123;</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">st2[i][j] = min(st2[i][j<span class="number">-1</span>],st2[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> mx = max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"><span class="keyword">int</span> mi = min(st2[l][k],st2[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,mx,mi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n-m+<span class="number">1</span>;i++) ask(i,i+m<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="与众不同"><a href="#与众不同" class="headerlink" title="与众不同*"></a>与众不同*</h4><p><strong>题意简述</strong><br>A 是某公司的 CEO，每个月都会有员工把公司的盈利数据送给 A，A 是个与众不同的怪人，A 不注重盈利还是亏本，而是喜欢研究「完美序列」：一段连续的序列满足序列中的数互不相同。<br>A 想知道区间 [L,R] 之间最长的完美序列长度。</p><p><strong>解题思路</strong><br>我们可以通过标记数组在O(N)时间内求出每个位置“作为结束位置”时的最长完美序列长度，以及它的起点。<br>设last[ x ] 表示 x 上次出现的位置；bgn[ p ]表示以位置 p 为末尾的完美序列的起点位置；len[p] 表示以位置 p 为末尾的完美序列的长度。显然我们可以在一次遍历内更新完毕上述三个数组，O(N)。<br>那么对于任意区间[ L , R ]，其内的最长完美序列长度仅有 2 种可能，一种是终点在区间内，起点不在；另一种是起点和终点都在区间内。此时我们已经可以通过一次遍历来求答案了，但是复杂度最差O(N)，不可取。由于bgn[]是单调递增的，所以对于某个位置 pos，[ L , pos-1] 所有位置上的起点都小于 L，[pos , R]上所有位置上的起点都大于L，那么我们可以通过ST表维护 [pos ,R] 上的最大的 len 值，在O(1)时间内求出，那么答案就是max(pos-L , ask(pos , R) )。</p><p>我们可以通过二分搜索来查找 pos ,复杂度 O(log N)，根据len数组构造st表，O(NlogN)，总时间复杂度O( (N+M)logN )。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">1e6</span>;</span><br><span class="line"><span class="comment">/*last[x]为x上一次出现的位置;</span></span><br><span class="line"><span class="comment">bgn[p]为以位置p结尾的起点位置;len[p]为以p结尾的完美序列长度*/</span></span><br><span class="line"><span class="keyword">int</span> last[SZ],bgn[N],len[N];</span><br><span class="line"><span class="keyword">int</span> a[N],Log[N],st[N][<span class="number">22</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_st</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = len[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;<span class="number">1</span>&lt;&lt;j &lt;= n;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(bgn[mid] &gt;= x) r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">bgn[i] = max(bgn[i<span class="number">-1</span>],last[a[i]+B]+<span class="number">1</span>);<span class="comment">//起始位置必须合法 </span></span><br><span class="line">len[i] = i - bgn[i] + <span class="number">1</span>;</span><br><span class="line">last[a[i]+B] = i;</span><br><span class="line">&#125;</span><br><span class="line">init_st();<span class="comment">//建立len数组的st表 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,p,res;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);x++,y++; </span><br><span class="line">p = bsearch(x,y,x);<span class="comment">//找到[x,y]内第一个bgn大于等于x的位置 </span></span><br><span class="line"><span class="keyword">if</span>(p &lt;= y) res = max(p-x,ask(p,y));</span><br><span class="line"><span class="keyword">else</span> res = p-x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="天才的记忆"><a href="#天才的记忆" class="headerlink" title="天才的记忆"></a>天才的记忆</h4><p><strong>代码示例：</strong> 模板模板，题面和思路不说了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>] ,Log[N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'-'</span> &amp;&amp; (c &lt;<span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i]= Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)&#123;</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt();;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">init(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Balanced-Lineup"><a href="#Balanced-Lineup" class="headerlink" title="Balanced Lineup"></a>Balanced Lineup</h4><p><strong>代码示例：</strong> 和“敏捷的机器人”一样，都是要维护最大以及最小值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>] ,Log[N], st2[N][<span class="number">22</span>];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'-'</span> &amp;&amp; (c &lt;<span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i]= Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st2[i][<span class="number">0</span>] = st[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)&#123;</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">st2[i][j] = min(st2[i][j<span class="number">-1</span>],st2[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> mx = max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"><span class="keyword">int</span> mi = min(st2[l][k],st2[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mx-mi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">ask(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="选择客栈"><a href="#选择客栈" class="headerlink" title="选择客栈*"></a>选择客栈*</h4><p><strong>题意描述</strong><br>丽江河边有 n 家很有特色的客栈，客栈按照其位置顺序从 1 到 n 编号。</p><p>每家客栈都按照某一种色调进行装饰（总共 k 种，用整数 0 k−1 表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。</p><p>两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。</p><p>晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 p 。</p><p>他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 p 元的咖啡店小聚。</p><p><strong>解题思路</strong><br>没看正解是啥，我没用到st表，不过倒是用到了求RMQ的步骤。<br>共三个辅助数组，col[k] 表示当前第k种颜色客栈的数量；val[x]表示客栈x的最低消费；mip[x]表示 [x, n] 内第一个最低消费小于等于 p 元的客栈位置。<br>如果第一个人入住客栈x，第二个人能够入住的旅店的位置一定是大于等于mip[x]的，并且要颜色和 x 相同，即col[ a[i] ]种选择方案。所以我们只需要从前往后顺序遍历一遍并统计答案即可，复杂度O(N)。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> col[K];</span><br><span class="line"><span class="keyword">int</span> n,m,p;</span><br><span class="line"><span class="keyword">int</span> a[N],val[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'-'</span> &amp;&amp; (c &lt;<span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mip[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">mip[n+<span class="number">1</span>] = n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(val[i] &gt; p) mip[i] = mip[i+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> mip[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">1</span>; ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> now = mip[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = pre;j &lt; now;j++) col[a[j]]--;</span><br><span class="line"><span class="comment">//printf("%d %d %d\n",pre,now,col[a[i]]);</span></span><br><span class="line">ans += col[a[i]]; pre = now;</span><br><span class="line"><span class="keyword">if</span>(now == i) ans--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt(); p = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= n;i++)&#123;</span><br><span class="line">a[i] = getInt(); val[i] = getInt(); </span><br><span class="line">col[a[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://ybt.ssoier.cn:8088/index.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;书本配套OJ&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.mfstem.org/&quot; target=&quot;_blan
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="st表" scheme="http://valenshi.top/tags/st%E8%A1%A8/"/>
    
      <category term="RMQ问题" scheme="http://valenshi.top/tags/RMQ%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>树状数组题集</title>
    <link href="http://valenshi.top/2019/10/06/BIT-problems/"/>
    <id>http://valenshi.top/2019/10/06/BIT-problems/</id>
    <published>2019-10-06T12:46:38.000Z</published>
    <updated>2019-10-07T11:19:59.049Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/index.php" target="_blank" rel="noopener">书本配套OJ</a><br><a href="http://www.mfstem.org/contests" target="_blank" rel="noopener">我校OJ</a><br><strong>树状数组知识点：</strong></p><ul><li>单点修改，区间求和，O(logN)。</li><li>区间修改，区间求和，O(logN)。</li><li>二维树状数组单点修改，子矩阵求和，时间复杂度O(logN * logN)，空间O(N^2)。</li></ul><p>与线段树相比功能比较单一，不够灵活，但胜在简短易写，可以用来打辅助。</p><p><strong>注意事项</strong></p><ul><li>树状数组修改的下标不能为0，因为 lowbit(0) = 0，这就死循环了。</li><li>注意树状数组的空间，这是由值域来决定的，而不是定义域。</li></ul><h4 id="数列操作"><a href="#数列操作" class="headerlink" title="数列操作"></a>数列操作</h4><p><strong>题目描述</strong><br>给定n个数列,规定有两种操作，一是修改某个元素，二是求子数列[a,b]的连续和。数列元素个数最多10万个，询问操作最多10万次。<br><strong>解题思路</strong><br>模板题。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,m; </span><br><span class="line">ll A[N],c[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">/*把第x位置上的数+y*/</span></span><br><span class="line"><span class="keyword">for</span>(;x &lt;= n;x += x&amp;-x) c[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回[1,x]元素和*/</span></span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x) res += c[x];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">int</span> k,a,b;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,A+i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Add(i,A[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;k,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">if</span>(k) Add(a,b);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(b)-ask(a<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="数星星-Stars"><a href="#数星星-Stars" class="headerlink" title="数星星 Stars"></a>数星星 Stars</h4><p><strong>题意简述</strong><br>给定 n 个点，定义每个点的等级是在该点左下方（含正左、正下）的点的数目，试统计每个等级有多少个点。<br>(详细描述见原题面)</p><p><strong>解题思路</strong><br>由于y是升序的，我们只需要记录比当前x小的star有多少个即可得知其等级 x ，然后用num[x]表示等级为x的星星个数，最终答案就是num数组。<br>CDQ分治也可以写，都是先将一维给变的有序，再统计另一维度。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c[N],n;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//若x=0则死循环 </span></span><br><span class="line"><span class="keyword">for</span>(;x &lt; N;x += x&amp;-x) c[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x) res += c[x];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">ans[ask(x+<span class="number">1</span>)]++;<span class="comment">//要注意x = 0这种情况 </span></span><br><span class="line">Add(x+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="校门外的树"><a href="#校门外的树" class="headerlink" title="校门外的树*"></a>校门外的树*</h4><p><strong>题意简述</strong></p><p>原题来自：Vijos P1448<br>校门外有很多树，学校决定在某个时刻在某一段种上一种树，保证任一时刻不会出现两段相同种类的树，现有两种操作：</p><ul><li>K=1，读入 l,r 表示在 l 到 r 之间种上一种树，每次操作种的树的种类都不同；</li><li>K=2，读入 l,r 表示询问 l 到 r 之间有多少种树。</li></ul><p><strong>解题思路</strong><br>刚开始以为是区间修改的题，后来发现不是。这题利用了差分数组的思想。如果我们假设c0[ x ] 存放 [1, x] 的左端点数量，c1[]存放右端点数量；如果所求区间为[l , r]，那么一共只可能有 6 种不同的线段：</p><ul><li>第一种是全在r右侧；</li><li>第二种是左端点在 [l ,r] 内，右端点在r右侧；</li><li>第三种是左右端点都在[l ,r] 内；</li><li>第四种是右端点在[l ,r]内，左端点在 l 左侧；</li><li>第五种是左右端点全在 l 左侧；</li><li>第六种是左端点在 l 左侧，右端点在 r 右侧。</li></ul><p>那么我们用 l 右侧所有的右端点的数量，减去 r 右侧左端点的数量，可以画图理解，简单。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,m; </span><br><span class="line">ll A[N],c[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> ty,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">/*把第x位置上的数+y*/</span></span><br><span class="line"><span class="keyword">for</span>(;x &lt; N;x += x&amp;-x) c[ty][x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> ty,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回[1,x]元素和*/</span></span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x) res += c[ty][x];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">int</span> k,a,b;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;k,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">Add(<span class="number">0</span>,a,<span class="number">1</span>); Add(<span class="number">1</span>,b,<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">/*分类讨论,所有线段共6种情况 */</span> </span><br><span class="line"><span class="keyword">int</span> t1 = ask(<span class="number">1</span>,N<span class="number">-1</span>) - ask(<span class="number">1</span>,a<span class="number">-1</span>); </span><br><span class="line"><span class="keyword">int</span> t2 = ask(<span class="number">0</span>,N<span class="number">-1</span>) - ask(<span class="number">0</span>,b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,t1-t2);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="清点人数"><a href="#清点人数" class="headerlink" title="清点人数"></a>清点人数</h4><p><strong>题意简述</strong><br>NK 中学组织同学们去五云山寨参加社会实践活动，按惯例要乘坐火车去。由于 NK 中学的学生很多，在火车开之前必须清点好人数。<br>初始时，火车上没有学生。当同学们开始上火车时，年级主任从第一节车厢出发走到最后一节车厢，每节车厢随时都有可能有同学上下。年级主任走到第 m 节车厢时，他想知道前 m 节车厢上一共有多少学生，但是他没有调头往回走的习惯。也就是说每次当他提问时，m 总会比前一次大。<br><strong>解题思路</strong><br>也是模板题。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c[N] ,n,k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;x &lt; N;x += x&amp;-x) c[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x) res += c[x];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= k;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'A'</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x); <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'B'</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y); Add(x,y);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y); Add(x,-y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h4><p><strong>题意简述</strong><br>题目来源：CQOI 2006<br>有一个 n 个元素的数组，每个元素初始均为 0。有 m 条指令，要么让其中一段连续序列数字反转——0 变 1，1 变 0（操作 1），要么询问某个元素的值（操作 2）。</p><p><strong>解题思路</strong><br>一个位置如果反转偶数次，那么它还是0，否则是1，因此我们只需要统计每个位置被反转了几次即可，用到了树状数组区间修改单点查询。树状数组区间修改的推导就不写了，书上有。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">2</span>][N],n,m ,num[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> ty,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;x &lt;= n;x += x&amp;-x) c[ty][x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> ty,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x) res += c[ty][x];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin); </span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line">z = getInt();</span><br><span class="line"><span class="keyword">if</span>(z == <span class="number">1</span>)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">Add(<span class="number">0</span>,x,<span class="number">1</span>); Add(<span class="number">0</span>,y+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">Add(<span class="number">1</span>,x,x); Add(<span class="number">1</span>,y+<span class="number">1</span>,-y<span class="number">-1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">y = getInt(); x = y;</span><br><span class="line"><span class="keyword">int</span> res = (y+<span class="number">1</span>)*ask(<span class="number">0</span>,y) - ask(<span class="number">1</span>,y) - x*ask(<span class="number">0</span>,x<span class="number">-1</span>) + ask(<span class="number">1</span>,x<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res&amp;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="打鼹鼠"><a href="#打鼹鼠" class="headerlink" title="打鼹鼠*"></a>打鼹鼠*</h4><p><strong>题意简述</strong><br>这是一道模板题。<br>给出一个 n×m 的零矩阵 A，你需要完成如下操作：<br>1 x y k：表示元素 Ax,y自增 k；<br>2 a b c d：表示询问左上角为 (a,b)，右下角为 (c,d) 的子矩阵内所有数的和。</p><p><strong>解题思路</strong><br>是二维树状数组模板题，但是空间卡的很紧，开到N = 5000就险过，开到N = (1&lt;&lt;12)+10就好了一点。<br>和vijos那个原题不同，数据不一样，范围也不一样，这题不会出现下标为0的情况。就注意一下二维更新和查询时，每次的y需要恢复原值即可，因此需要用个变量存放一下y初值。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = (<span class="number">1</span>&lt;&lt;<span class="number">12</span>)+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll c[N][N]; </span><br><span class="line"><span class="keyword">int</span> n ,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line"><span class="comment">//printf("%d %d %d\n",x,y,z);</span></span><br><span class="line"><span class="keyword">for</span>(;x &lt;= n;x += x&amp;-x)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> ty = y;ty &lt;= m;ty += ty&amp;-ty) c[x][ty] += z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> ty = y;ty;ty -= ty&amp;-ty) res += c[x][ty];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d,x,y,k,op;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op) != EOF)&#123;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">x = getInt(); y = getInt(); k = getInt();</span><br><span class="line">Add(x,y,k);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">a = getInt(); b = getInt(); c = getInt();d = getInt();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(c,d)-ask(c,b<span class="number">-1</span>)-ask(a<span class="number">-1</span>,d)+ask(a<span class="number">-1</span>,b<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://ybt.ssoier.cn:8088/index.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;书本配套OJ&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.mfstem.org/contests&quot; targe
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树状数组" scheme="http://valenshi.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="二维树状数组" scheme="http://valenshi.top/tags/%E4%BA%8C%E7%BB%B4%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="树状数组区间修改" scheme="http://valenshi.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9/"/>
    
  </entry>
  
  <entry>
    <title>AC自动机题集</title>
    <link href="http://valenshi.top/2019/10/06/ac-problems/"/>
    <id>http://valenshi.top/2019/10/06/ac-problems/</id>
    <published>2019-10-06T03:21:35.000Z</published>
    <updated>2019-10-06T03:22:54.780Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Keywords-Search"><a href="#Keywords-Search" class="headerlink" title="Keywords Search"></a>Keywords Search</h4><p><strong>题意描述</strong><br>原题来自：HDU 2222<br>给定 n 个长度不超过 50 的由小写英文字母组成的单词准备查询，以及一篇长为 m 的文章，问：文中出现了多少个待查询的单词。多组数据。<br><strong>解题思路</strong><br>模板题<br><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;<span class="comment">//模式串个数 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">10</span>;<span class="comment">//文本串长度 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[N][<span class="number">50</span>],s[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">50</span>*N;<span class="comment">//trie节点数 </span></span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],End[SZ],tot ;</span><br><span class="line"><span class="keyword">int</span> fail[SZ];<span class="comment">//失配指针,类似于nex</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="keyword">sizeof</span> trie);</span><br><span class="line"><span class="built_in">memset</span>(End,<span class="number">0</span>,<span class="keyword">sizeof</span> End); tot = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 向trie树中插入字符串s */</span> </span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*利用bfs更新fail数组*/</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) trie[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop();</span><br><span class="line"><span class="comment">//printf("%d\n",q.size());</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.push(trie[p][i]);</span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 统计匹配成功的模式串个数并累加到ans上 */</span> </span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">int</span> k = trie[p][ch];</span><br><span class="line"><span class="keyword">while</span>(k &gt; <span class="number">1</span>)&#123;</span><br><span class="line">ans += End[k]; End[k] = <span class="number">0</span>;</span><br><span class="line">k = fail[k];</span><br><span class="line">&#125;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t,n;<span class="comment">//数组组数, 模式串个数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line">getFail(); ans = <span class="number">0</span>;</span><br><span class="line">ask(s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">init();<span class="comment">//多组数据不要忘了初始化！ </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[i]);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="玄武密码"><a href="#玄武密码" class="headerlink" title="玄武密码"></a>玄武密码</h4><p><strong>题意描述</strong></p><p>原题来自：JSOI 2012<br>在美丽的玄武湖畔，鸡鸣寺边，鸡笼山前，有一块富饶而秀美的土地，人们唤作进香河。相传一日，一缕紫气从天而至，只一瞬间便消失在了进香河中。老人们说，这是玄武神灵将天书藏匿在此。很多年后，人们终于在进香河地区发现了带有玄武密码的文字。更加神奇的是，这份带有玄武密码的文字，与玄武湖南岸台城的结构有微妙的关联。于是，漫长的破译工作开始了。<br>经过分析，我们可以用东南西北四个方向来描述台城城砖的摆放，不妨用一个长度为 N 的序列来描述，序列中的元素分别是 E，S，W，N，代表了东南西北四向，我们称之为母串。而神秘的玄武密码是由四象的图案描述而成的 M 段文字。<br>现在，考古工作者遇到了一个难题。对于每一段文字，其前缀在母串上的最大匹配长度是多少呢？</p><p><strong>解题思路</strong><br>求每个子串在母串上的最大匹配长度。如果挨个用子串来匹配母串，复杂度太高，所以要用AC自动机，以母串来匹配子串。<br>将母串在建立好的AC自动机上进行匹配，那么其所能到达的节点，就是可以和母串匹配的长度，所以我们每到一个节点，就对其进行标记，顺便也对其fail指针所指向的节点标记，那么最后一个被标记的节点，就是该子串所能匹配的最大长度。</p><p>那么我们如何找到最后一个被标记的节点呢？通过par数组，par[x]存放x的父亲节点的编号，如此就可以从后向前遍历了（下述代码中是nex数组）。</p><p>所以具体步骤有三步：</p><ul><li>根据所有子串建立AC自动机，同时更新par数组(代码中是nex数组)</li><li>利用母串对自动机上节点进行标记</li><li>利用par数组自底向上查找最后一个被标记的节点，该节点到根节点的路径长度就是与母串最大匹配，为此我们还需要记录每个字串结束时的节点编号End[id]，以及长度Len[id]</li></ul><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s[N],str[M][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = M*<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">5</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> fail[SZ],vis[SZ],End[SZ],nex[SZ];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIdx</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ch == <span class="string">'E'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">'S'</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">'W'</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = getIdx(s[i]);</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot,nex[tot] = p;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) trie[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">q.push(trie[p][i]);</span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mark</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = getIdx(s[i]);</span><br><span class="line"><span class="keyword">int</span> k = trie[p][ch];</span><br><span class="line"><span class="keyword">while</span>(k &gt; <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[k]) <span class="keyword">break</span>;</span><br><span class="line">vis[k] = <span class="number">1</span>; k = fail[k];</span><br><span class="line">&#125;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str[x]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = End[x];i &gt; <span class="number">1</span>;i = nex[i],len--) <span class="keyword">if</span>(vis[i]) <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) End[i] = Insert(str[i]);</span><br><span class="line">getFail();</span><br><span class="line">Mark(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) search(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[i]);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Censoring"><a href="#Censoring" class="headerlink" title="Censoring"></a>Censoring</h4><p><strong>题意简述</strong><br>原题来自：USACO 2015 Feb. Gold<br>有一个长度不超过 105 的字符串 S。Farmer John 希望在 S 中删掉 n 个屏蔽词（一个屏蔽词可能出现多次），这些词记为 t1∼tn。FJ 在 S 中从头开始寻找屏蔽词，一旦找到一个屏蔽词，FJ 就删除它，然后又从头开始寻找（而不是接着往下找）。<br>FJ 会重复这一过程，直到 S 中没有屏蔽词为止。注意删除一个单词后可能会导致 S 中出现另一个屏蔽词。<br>这 n 个屏蔽词不会出现一个单词是另一个单词子串的情况，这意味着每个屏蔽词在 S 中出现的开始位置是互不相同的，请帮助 FJ 完成这些操作并输出最后的 S。<br><strong>解题思路</strong><br>可以用KM+栈来解决，这里用AC自动机解决。<br>很容易想到的一个思路就是，建立好AC自动机后，从根节点开始匹配，如果匹配到叶子节点，即有End标记的节点，就说明当前字串是屏蔽词，删掉它，假设该子串长为 len ，那就将指针 p 回退到 len 步之前，继续匹配。<br>如此一来我们需要记录每个时刻的p指针，以及母串中保留的字符，用栈就可以很好的维护。如果屏蔽词匹配成功，长度为 len，那么母串中保留的字符从栈顶弹出 len 个，同时保存 p 的栈也弹出 len 个元素，栈顶元素就是 len 步之前的指针。</p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N], s[N];</span><br><span class="line"><span class="keyword">int</span> n, fail[SZ];</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],tot = <span class="number">1</span>,End[SZ];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p] = len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) trie[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.push(trie[p][i]); </span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> path[N];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>,Stack[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">getFail();<span class="comment">//为什么非要更新Fail数组呢 </span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,p = <span class="number">1</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = str[i]-<span class="string">'a'</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">Stack[++top] = p; path[top] = str[i];</span><br><span class="line"><span class="keyword">if</span>(End[p]) top -= End[p], p = Stack[top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= top;i++) <span class="built_in">putchar</span>(path[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s); Insert(s);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h4><p><strong>题意简述</strong><br>原题来自：TJOI 2013<br>某人读论文，一篇论文是由许多单词组成。但他发现一个单词会在论文中出现很多次，现在想知道每个单词分别在论文中出现多少次。<br><strong>解题思路</strong><br>这个文章是由这 n 个单词组成的，现在问每个单词出现多少次。直接用母串在fail树上匹配统计相同前缀个数是不对的，因为这样可能出现两个子串的重叠。根据AC自动机的特点啊，如果有个节点 x 的 fail 指针指向 y，那么说明 y 是 x 的前缀，即 y 是 x 的子串，那么自然有多少个 fail 指针指向 y，y就出现了多少次，而这个次数就是我们要求的单词出现的次数。</p><p>那么首先要记录AC自动机上每个节点出现的次数，因为单词可能出现重复。然后要记录结束时该子串对应的节点编号，End[id] = p；由于我们 fail 指针是从上到下更新的，而我们要统计次数需要从下到上转移，于是利用栈来存储 fail 指针转移时的节点编号，而后再更新 num 数组即可。<br><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">220</span>;</span><br><span class="line"><span class="built_in">string</span> str[N], s;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],End[SZ],tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> num[SZ];<span class="comment">// num[x] 为经过节点x的数量 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="keyword">const</span> <span class="keyword">int</span>&amp; id)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = s.length(), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">num[p]++;</span><br><span class="line">&#125;</span><br><span class="line">End[id] = p; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> fail[SZ];</span><br><span class="line"><span class="keyword">int</span> Stack[SZ], top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) trie[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop(); </span><br><span class="line">Stack[++top] = p;<span class="comment">//倒序记录编号 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.push(trie[p][i]);</span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i],i);</span><br><span class="line">getFail();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = top;i &gt; <span class="number">0</span>;--i)&#123;</span><br><span class="line">num[fail[Stack[i]]] += num[Stack[i]];</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cout</span> &lt;&lt; num[End[i]] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; str[i];</span><br><span class="line">solve(); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最短母串"><a href="#最短母串" class="headerlink" title="最短母串"></a>最短母串</h4><p><strong>题意描述</strong><br>原题来自：HNOI 2006<br>给定 n 个字符串 S1,S2,⋯,Sn，要求找到一个最短的字符串 T，使得这 n 个字符串都是 T 的子串。<br><strong>解题思路</strong><br>根据经验容易想到，母串要走完AC自动机上所有 有结束标记（End标记）的节点，而本题的答案就是找到最短的&amp;字典序最小的母串。<br>那提到结束标记 End，就应该想到 End 标记的转移，我们在求fail数组时顺便转移。如果每个结束标记都用不同id标识，那么母串只要能包含所有不同的结束标记即可。</p><p>既然只有最多12个子串，那么可以考虑用状态压缩节省空间。我们用 bfs 来求最短&amp;字典序最小母串。<br>由于母串最长600，而AC自动机上节点个数最多600，但是每个节点状态有1&lt;&lt;12种，因此 <code>vis[606][(1&lt;&lt;12)+1]</code> 用于表示该节点的对应状态是否被访问过； path[(1&lt;&lt;12)+1]用于存放由上一个状态转移而来需要添加的字符；s[606]自然就是存放最终母串。<br>当然还需要一些辅助数组，par[ ip ]记录 ip 的上一个状态的编号，用于查找路径；当然理论上讲path也算辅助数组。<br>接下来我们就可以通过bfs来实现不同状态间的转移了，实质上是bfs+状态压缩，实现起来还是有些难度的。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">60</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">600</span>+<span class="number">10</span>;<span class="comment">//一定要想好大小啊 </span></span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n, fail[SZ];</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>], End[<span class="number">30</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">605</span>][(<span class="number">1</span>&lt;&lt;<span class="number">12</span>)+<span class="number">1</span>]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch]; </span><br><span class="line">&#125;</span><br><span class="line">End[p] |= <span class="number">1</span>&lt;&lt;id;<span class="comment">//状压常用 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) trie[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.push(trie[p][i]);</span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">End[trie[p][i]] |= End[fail[trie[p][i]]];<span class="comment">//常用技巧 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*用来bfs计算最短母串*/</span></span><br><span class="line"><span class="keyword">char</span> path[<span class="number">606</span>*(<span class="number">1</span>&lt;&lt;<span class="number">12</span>)] ,s[<span class="number">606</span>];</span><br><span class="line"><span class="keyword">int</span> par[<span class="number">606</span>*(<span class="number">1</span>&lt;&lt;<span class="number">12</span>)],len = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="comment">/*分别是节点编号,当前状态,当前字符位置 */</span> </span><br><span class="line"><span class="keyword">int</span> p,now,ip;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;Node&gt; q2; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">q2.push(Node&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q2.empty())&#123;</span><br><span class="line">Node x = q2.front(); q2.pop();</span><br><span class="line"><span class="keyword">int</span> p = x.p,now = x.now,ip = x.ip;</span><br><span class="line"><span class="keyword">if</span>(now == (<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="comment">/*所有子串都包含了,可以输出答案了*/</span> </span><br><span class="line"><span class="keyword">for</span>(;ip;ip = par[ip]) s[len++] = path[ip];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,nex;i &lt; <span class="number">26</span>;i++)</span><br><span class="line"><span class="keyword">if</span>(!vis[trie[p][i]][nex = now|End[trie[p][i]]])&#123;</span><br><span class="line"><span class="comment">/*当前节点的第i个字符的 nex 状态未被访问过,访问并压入队列*/</span> </span><br><span class="line">vis[trie[p][i]][nex] = <span class="number">1</span>;</span><br><span class="line">path[++cnt] = i+<span class="string">'A'</span>, par[cnt] = ip;</span><br><span class="line"><span class="comment">/*压入下一个节点的编号,状态,字符结束位置*/</span> </span><br><span class="line">q2.push(Node&#123;trie[p][i],nex,cnt&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">getFail(); bfs();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--) <span class="built_in">putchar</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str); Insert(str,i<span class="number">-1</span>); </span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="POI-2000-病毒"><a href="#POI-2000-病毒" class="headerlink" title="POI 2000 病毒"></a>POI 2000 病毒</h4><p><strong>题意简述</strong></p><p>二进制病毒审查委员会最近发现了如下的规律：某些确定的二进制串是病毒的代码。如果某段代码中不存在任何一段病毒代码，那么我们就称这段代码是安全的。现在委员会已经找出了所有的病毒代码段，试问，是否存在一个无限长的安全的二进制代码。<br>示例：例如如果 {011,11,00000} 为病毒代码段，那么一个可能的无限长安全代码就是 010101⋯。如果 {01,11,000000} 为病毒代码段，那么就不存在一个无限长的安全代码。<br>请写一个程序，读入病毒代码，判断是否存在一个无限长的安全代码，将结果输出。</p><p><strong>解题思路</strong><br>本题要求找出一个无限长的安全的代码，无限长，当且仅当我们有一个安全的子串可以循环使用时才能构成。我们将AC自动机看作树，从根出发，那么叶子节点，即有End标记的节点是不能走的，因为该路径构成了病毒。同样的道理，如果当前节点fail指针所指向的节点有End标记，那么当前节点也不能走，因为它的子串是病毒串，所以我们在更新fail指针时顺便转移End标记（常用技巧）。<br>所以如果有一条路径，它上面的所有节点都没有End标记，且该路径构成环，那么它就可以构成一个无限长的安全字符串。</p><p>于是我们就只需要在AC自动机上通过dfs来找是否存在满足条件的环即可，而用拓扑排序不太好写。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> str[N];</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">3</span>],End[SZ],fail[SZ],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = s.length(), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">bool</span> f[SZ];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line">trie[<span class="number">0</span>][<span class="number">0</span>] = trie[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.push(trie[p][i]);</span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">End[trie[p][i]] |= End[trie[fail[p]][i]];<span class="comment">//转移标记</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> vis[SZ],ins[SZ];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">vis[p] = ins[p] = <span class="number">1</span>;    <span class="comment">//ins判断环,vis访问标记</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> k = trie[p][i];</span><br><span class="line"><span class="keyword">if</span>(ins[k]) flag = <span class="literal">true</span>;<span class="comment">//构成环了,这里也可以return</span></span><br><span class="line"><span class="keyword">if</span>(!End[k] &amp;&amp; !vis[k]) dfs(k);<span class="comment">//下一个满足条件的节点,递归访问它</span></span><br><span class="line">&#125;</span><br><span class="line">ins[p] = <span class="number">0</span>;<span class="comment">//释放p节点的标记</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line">getFail();</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="built_in">cout</span> &lt;&lt; <span class="string">"TAK"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NIE"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; str[i];</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="文本生成器"><a href="#文本生成器" class="headerlink" title="文本生成器"></a>文本生成器</h4><p><strong>题意简述</strong></p><p>原题来自：JSOI 2007JSOI<br>交给队员 ZYX 一个任务，编制一个称之为「文本生成器」的电脑软件：该软件的使用者是一些低幼人群，他们现在使用的是 GW 文本生成器 v6 版。该软件可以随机生成一些文章――总是生成一篇长度固定且完全随机的文章——也就是说，生成的文章中每个字节都是完全随机的。<br>如果一篇文章中至少包含使用者们了解的一个单词，那么我们说这篇文章是可读的（我们称文章 a 包含单词 b，当且仅当单词 b 是文章 a 的子串）。但是，即使按照这样的标准，使用者现在使用的 GW 文本生成器 v6 版所生成的文章也是几乎完全不可读的。<br>ZYX 需要指出 GW 文本生成器 v6 生成的所有文本中可读文本的数量，以便能够成功获得 v7 更新版。你能帮助他吗？</p><p><strong>解题思路</strong><br>首先易得所有不同的文本总数为$26^m$种，我们有两种容易想到的思路来求解，一个是利用容斥原理直接计算可读的文章总数，另一种是想办法计算不可读的文章数，再用不同的文章总数减去它。第一种思路很难实现，主要来看第二种思路如何实现。<br>类似上一题，如果一个文章是不可读的，那么从根出发，它不能经过有End标记的节点，也不能经过“fail指针指向的节点有End标记”的节点。所以不可读的文章总数就等于长度为m的<strong>合法路径</strong>数。所谓的合法路径就是上面提到的，路径上所有节点都没有End标记，且其fail指针指向的节点也没End标记。<br>我们通过动态规划来求<strong>方案总数</strong>，设f(i,j)表示从根节点出发，走了 i 步到达节点 j 时的合法方案总数，那么显然 f(0 , 1) = 1，因为节点 1 是AC自动机的根节点。<br>状态转移方程请结合代码理解。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">6000</span>*<span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">65</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> str[N][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],End[SZ],fail[SZ],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) trie[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.push(trie[p][i]);</span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">End[trie[p][i]] |= End[trie[fail[p]][i]];<span class="comment">//标记转移 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">110</span>][SZ] ,ans ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAns</span><span class="params">()</span></span>&#123;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= tot;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(End[j]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">26</span>;k++)&#123;</span><br><span class="line"><span class="comment">/*f[i][trie[j][k]]的方案总数显然等于它所有父亲的方案总数的和*/</span></span><br><span class="line">f[i][trie[j][k]] = (f[i][trie[j][k]]+f[i<span class="number">-1</span>][j])%P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>,tmp = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot;i++) </span><br><span class="line"><span class="keyword">if</span>(!End[i]) res = (res+f[m][i])%P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) tmp = tmp*<span class="number">26</span>%P;</span><br><span class="line">ans = (tmp-res+P)%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line">getFail();</span><br><span class="line">getAns();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[i]);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Keywords-Search&quot;&gt;&lt;a href=&quot;#Keywords-Search&quot; class=&quot;headerlink&quot; title=&quot;Keywords Search&quot;&gt;&lt;/a&gt;Keywords Search&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;题意描述&lt;/stro
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="AC自动机" scheme="http://valenshi.top/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="状态压缩" scheme="http://valenshi.top/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>AC自动机模板</title>
    <link href="http://valenshi.top/2019/10/02/acji/"/>
    <id>http://valenshi.top/2019/10/02/acji/</id>
    <published>2019-10-02T03:06:43.000Z</published>
    <updated>2019-10-02T03:07:41.832Z</updated>
    
    <content type="html"><![CDATA[<h4 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h4><p>AC自动机是用来处理字符串匹配问题。KMP是处理单模式串匹配问题，而AC自动机是用于处理多模式串匹配问题，例如：给出 n 个单词，再给出一段包含 m 个字符的文章，问有多少个单词在文章中出现过？以下模板就是根据该问题整理。</p><p><strong>使用说明</strong><br>其中的trie树编号是从 1 开始，每次使用前都要初始化 tot = 1，以及trie数组、End数组都要初始化。<br>SZ设计要合理，SZ表示字典树中的节点数目上限，太多或太少都会运行错误。<br>本文利用queue来实现bfs，嫌慢可以手写模拟，不会麻烦多少。</p><p><strong>代码示例</strong><br><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1479" target="_blank" rel="noopener">Keywords Search</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;<span class="comment">//模式串个数 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">10</span>;<span class="comment">//文本串长度 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[N][<span class="number">50</span>],s[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">50</span>*N;<span class="comment">//trie节点数 </span></span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],End[SZ],tot ;</span><br><span class="line"><span class="keyword">int</span> fail[SZ];<span class="comment">//失配指针,类似于nex</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="keyword">sizeof</span> trie);</span><br><span class="line"><span class="built_in">memset</span>(End,<span class="number">0</span>,<span class="keyword">sizeof</span> End); tot = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 向trie树中插入字符串s */</span> </span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*利用bfs更新fail数组*/</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) trie[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop();</span><br><span class="line"><span class="comment">//printf("%d\n",q.size());</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.push(trie[p][i]);</span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 统计匹配成功的模式串个数并累加到ans上 */</span> </span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">int</span> k = trie[p][ch];</span><br><span class="line"><span class="keyword">while</span>(k &gt; <span class="number">1</span>)&#123;</span><br><span class="line">ans += End[k]; End[k] = <span class="number">0</span>;</span><br><span class="line">k = fail[k];</span><br><span class="line">&#125;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t,n;<span class="comment">//数组组数, 模式串个数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line">getFail(); ans = <span class="number">0</span>;</span><br><span class="line">ask(s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">init();<span class="comment">//多组数据不要忘了初始化！ </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[i]);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="对getFail-函数的一些解释"><a href="#对getFail-函数的一些解释" class="headerlink" title="对getFail()函数的一些解释"></a>对getFail()函数的一些解释</h5><p>fail 数组就像是 kmp 算法中的 nex 数组一样，是在失配时转移指针用的，利用它可以使得时间控制在O(N)。<br>就上述代码而言，我们是如何更新fail数组的呢？</p><ul><li>首先根节点若失配，则无法匹配字符，即 fail[1] = 0。</li><li>若当前位置有字符，则它的失配指针指向“它父亲节点失配指针所指向节点 的 下一个节点”，即 <code>fail[ trie[p][i] ]  = fail[ fail[p] ][i]</code>，其思想类似kmp中nex转移。</li><li>若当前位置无字符，即<code>trie[p][i] = 0</code>，那么就让当前节点指向其失配指针的子节点，即<code>trie[p][i] = trie[ fail[p] ][i]</code>。</li></ul><p>第 3 步破坏了 trie 的结构，但这样可以优化时间。若不存在<code>trie[p][i]</code> 的转移边则指向 <code>trie[ fail[p] ][i]</code>，因为在具体问题中，若不存在<code>trie[p][i]</code> 则需要沿着 p 的前缀指针走到第一个满足存在 i 字符的转移边的点 v，得到<code>trie[v][i]</code>，那么我们直接令 <code>trie[p][i] = trie[v][i]</code> 即可使得该情况得到优化，类似记忆化 &amp; 路径压缩。<br>也正是这个原因，我们在构建 fail 数组时，没有处理 v 的转移边 i 不存在的情况，而是直接<code>fail[ trie[p][i] = trie[v][i]</code>（其中 <code>trie[v][i]</code> 在之前已经处理好了）。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>董永建，信息学竞赛一本通提高版，福州：福建教育出版社，2018.6，93-97</li><li><a href="https://bestsort.cn/2019/04/28/402/" target="_blank" rel="noopener">bestsort</a>的博客</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;AC自动机&quot;&gt;&lt;a href=&quot;#AC自动机&quot; class=&quot;headerlink&quot; title=&quot;AC自动机&quot;&gt;&lt;/a&gt;AC自动机&lt;/h4&gt;&lt;p&gt;AC自动机是用来处理字符串匹配问题。KMP是处理单模式串匹配问题，而AC自动机是用于处理多模式串匹配问题，例如：给出
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="AC自动机" scheme="http://valenshi.top/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Trie字典树练习题集</title>
    <link href="http://valenshi.top/2019/09/30/trie-problems/"/>
    <id>http://valenshi.top/2019/09/30/trie-problems/</id>
    <published>2019-09-30T10:37:26.000Z</published>
    <updated>2019-09-30T14:59:47.512Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/index.php" target="_blank" rel="noopener">测试地址</a></p><h4 id="Phone-List"><a href="#Phone-List" class="headerlink" title="Phone List"></a>Phone List</h4><p>原题来自：POJ 3630<br>给定 n 个长度不超过 10 的数字串，问其中是否存在两个数字串 S,T，使得 S 是 T 的前缀，多组数据。</p><p><strong>解题思路</strong><br>Trie的经典应用，可以作为模板题练手。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>], tot;</span><br><span class="line"><span class="keyword">int</span> End[SZ];</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 将字串s插入trie树 */</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s) ,p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][ch] == <span class="number">0</span>) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 字串s是否有前缀 */</span> </span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(End[p]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(search(str[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n); </span><br><span class="line"><span class="comment">/* 初始化trie相关变量 */</span></span><br><span class="line"><span class="built_in">memset</span>(End,<span class="number">0</span>,<span class="keyword">sizeof</span> End); tot = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="keyword">sizeof</span> trie);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[i]);</span><br><span class="line"><span class="keyword">if</span>(solve()) <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="The-XOR-Largest-Pair"><a href="#The-XOR-Largest-Pair" class="headerlink" title="The XOR Largest Pair"></a>The XOR Largest Pair</h4><p><strong>题意简述</strong><br>在给定的 N 个整数 A1,A2,…,AN 中选出两个进行异或运算，得到的结果最大是多少？</p><p><strong>解题思路</strong><br>就是将每个整数看作31位的01字符串，然后全部插入到Trie上，再分别对每个整数从高位到低位优先在Trie上走和该位相反的节点。01字典树。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">5e6</span>+<span class="number">10</span>;<span class="comment">//大小要合理！！！ </span></span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">3</span>], End[SZ], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][ch] == <span class="number">0</span>) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][!ch]) p = trie[p][!ch], res |= <span class="number">1</span>&lt;&lt;i;</span><br><span class="line"><span class="keyword">else</span> p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) calc(a[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Codechef-REBXOR"><a href="#Codechef-REBXOR" class="headerlink" title="Codechef REBXOR*"></a>Codechef REBXOR*</h4><p><strong>题意简述</strong><br><img src="/2019/09/30/trie-problems/1.png" alt="trie-problems/1.png"><br><strong>解题思路</strong><br>这题用的是 “Trie维护异或前缀和”，根据异或的特性，我们从左到右依次将元素插入后，再利用 x^y^x = y 这个特性在常数时间利用 Trie 找最大区间异或和。本题还是很有参考意义的，尤其是异或前缀和这一技巧。<br>当然由于OJ上给定的空间过小，本代码没过，待解决。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">20</span>*N;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">3</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],lmx[N],rmx[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">32</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">32</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][!ch]) p = trie[p][!ch],res |= <span class="number">1</span>&lt;&lt;i;</span><br><span class="line"><span class="keyword">else</span> p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;Insert(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/* x 用于累计异或前缀和,Trie用于求最大异或区间*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">x ^= a[i]; Insert(x);</span><br><span class="line">lmx[i] = max(search(x),lmx[i<span class="number">-1</span>]);</span><br><span class="line"><span class="comment">//包含x的最大区间异或和 与  不包含x的区间的最大异或和 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="keyword">sizeof</span> trie); tot = <span class="number">1</span>;</span><br><span class="line">Insert(<span class="number">0</span>); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">x ^= a[i]; Insert(x);</span><br><span class="line">rmx[i] = max(search(x),rmx[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) ans = max(ans,lmx[i]+rmx[i+<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Immediate-Decodability"><a href="#Immediate-Decodability" class="headerlink" title="Immediate Decodability"></a>Immediate Decodability</h4><p><strong>题意简述</strong><br>原题来自：ACM Pacific NW Region 1998<br>给出一些数字串，判断是否有一个数字串是另一个串的前缀。<br><strong>解题思路</strong><br>和第1题一样，模板题。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> End[SZ];</span><br><span class="line"><span class="keyword">int</span> n,t,cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 将字串s插入trie树 */</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s) ,p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][ch] == <span class="number">0</span>) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 字串s是否有前缀 */</span> </span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(End[p]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(search(str[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[++n]) != EOF)&#123;</span><br><span class="line"><span class="comment">/* 初始化trie相关变量 */</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(str[n]) == <span class="number">1</span> &amp;&amp; str[n][<span class="number">0</span>] == <span class="string">'9'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!solve()) <span class="built_in">printf</span>(<span class="string">"Set %d is immediately decodable\n"</span>,++cnt);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Set %d is not immediately decodable\n"</span>,++cnt);</span><br><span class="line"><span class="built_in">memset</span>(End,<span class="number">0</span>,<span class="keyword">sizeof</span> End); tot = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="keyword">sizeof</span> trie); n = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="L语言"><a href="#L语言" class="headerlink" title="L语言*"></a>L语言*</h4><p><strong>题意简述</strong></p><p>原题来自：HNOI 2004<br>标点符号的出现晚于文字的出现，所以以前的语言都是没有标点的。现在你要处理的就是一段没有标点的文章。<br>一段文章 T 是由若干小写字母构成。一个单词 W 也是由若干小写字母构成。一个字典 D 是若干个单词的集合。<br>我们称一段文章 T 在某个字典 D 下是可以被理解的，是指如果文章 T 可以被分成若干部分，且每一个部分都是字典 D 中的单词。例如字典 D 中包括单词 is , your , what , name ，则文章 whatisyourname 是在字典 D 下可以被理解的，因为它可以分成 4 个单词： what , is , your , name ，且每个单词都属于字典 D，而文章 whatisyouname 在字典 D 下不能被理解，但可以在字典 D′=D+you 下被理解。这段文章的一个前缀 whatis ，也可以在字典 D 下被理解 而且是在字典 D 下能够被理解的最长的前缀。<br>给定一个字典 D ，你的程序需要判断若干段文章在字典 D 下是否能够被理解。 并给出其在字典 D 下能够被理解的最长前缀的位置。<br><strong>解题思路</strong><br>这题有点难的地方是  文章中某个前缀可能由多个单词组合出来，于是我们需要对每个可能是单词末尾的位置再进行下一次匹配，检查其后是否有字典D中的单词。</p><p>我们首先将所有单词插入字典树，由于单词长度小于10，所以对于每个单词，我们最多比较10次就能知道该字串是否为字典D中的单词。每次匹配都要从字典树的根开始匹配。<br>我们设f[i]表示 “文章中第 i 位是否为可以被D理解的某个前缀的末尾”；如果 f[i] 为 1 ，那么说明[1, i]都可以被D理解，接下来只要再从 i+1 位开始尝试在字典树匹配单词即可。<br>这是存在性DP，状态转移很简单，在字典树查找单词时，若当前位置是某个单词的末尾，即End[ p ] = 1，那么f[ pos ] = 1（pos为当前字符位置），时间复杂度为O(10N)。</p><p><strong>优化</strong><br>在 查找/匹配 单词时，我习惯将其封装为一个函数search(char * s)，但是最差情况我们会调用1e6次该函数，虽然该函数内最多只比较10次，但是函数传参以及保护现场以及恢复等步骤还是会大大增加花费的时间。经过测试，写成函数调用形式在1e6数据下大概会比直接展开慢几十秒，当然还是可以通过一些步骤优化函数调用的。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],End[SZ], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> str[N],s[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">bool</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str)<span class="number">-1</span>, ans;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f); f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//printf("%d\n",len);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!f[i]) <span class="keyword">continue</span>;</span><br><span class="line">ans = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>,p = <span class="number">1</span>;j &lt;= len;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = str[j]-<span class="string">'a'</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line"><span class="keyword">if</span>(!p) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(End[p]) f[j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s); Insert(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'#'</span>; solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Secret-Message-秘密信息"><a href="#Secret-Message-秘密信息" class="headerlink" title="Secret Message 秘密信息"></a>Secret Message 秘密信息</h4><p><strong>题意描述</strong><br>原题来自：USACO 2008 Dec. Gold<br>贝茜正在领导奶牛们逃跑。为了联络，奶牛们互相发送秘密信息。信息是二进制的，共有 M 条。反间谍能力很强的约翰已经部分拦截了这些信息，知道了第 i 条二进制信息的前 bi 位。<br>他同时知道，奶牛使用 N 条密码。但是，他仅仅了解第 j 条密码的前 cj位。对于每条密码 j ，他想知道有多少截得的信息能够和它匹配。也就是说，有多少信息和这条密码有着相同的前缀。当然，这个前缀长度必须等于密码和那条信息长度的较小者。</p><p><strong>解题思路</strong><br>根据所给样例呢，可以更加明确题意。首先我们将M条信息看作01字符串，同理N条密码也看作01字符串，题意问的就是对于每个密码，有多少条信息可能和该密码匹配，如果一条信息 A 和密码 B 匹配，那么有 A 是 B 的前缀或 B 是 A 的前缀。<br>于是我们就只需要先把01数组转化为01字符串，再用trie统计即可，当然由于同一信息可能会重复出现，所以 End[p] 记录的是以 p 结尾的字串个数。<br>在本机与洛谷上都是可以AC的，复杂度大概O(5e5)，但是在一本通OJ就过不去，猜测可能是不支持关闭 scanf 同步流？待修改。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="built_in">string</span> str[N],s[N];</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">2</span>],End[SZ],tot = <span class="number">1</span>,tc[SZ];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = s.length(), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">tc[p]++;</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span></span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; s &lt;&lt; "-" &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">int</span> len = s.length(), p = <span class="number">1</span>,res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line"><span class="keyword">if</span>(!p) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(End[p] &amp;&amp; i != len<span class="number">-1</span>) res += End[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res + tc[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">cout</span> &lt;&lt; search(s[i]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("222.txt","w",stdout);</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,k;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>,x;j &lt;= k;j++) <span class="built_in">cin</span> &gt;&gt; x, str[i] += x+<span class="string">'0'</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; str[i] &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,k;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>,x;j &lt;= k;j++) <span class="built_in">cin</span> &gt;&gt; x, s[i] += x+<span class="string">'0'</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; s[i] &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="【SCOI2016】背单词"><a href="#【SCOI2016】背单词" class="headerlink" title="【SCOI2016】背单词*"></a>【SCOI2016】背单词*</h4><p><strong>题意简述</strong><br>Lweb 面对如山的英语单词，陷入了深深的沉思，「我怎么样才能快点学完，然后去玩三国杀呢？」。<br>这时候睿智的凤老师从远处飘来，他送给了 Lweb 一本计划册和一大缸泡椒，然后凤老师告诉 Lweb ，我知道你要学习的单词总共有 n 个，现在我们从上往下完成计划表，对于一个序号为 x 的单词（序号 1…x−1 都已经被填入）：</p><ul><li>如果存在一个单词是它的后缀，并且当前没有被填入表内，那他需要吃 n×n 颗泡椒才能学会；</li><li>当它的所有后缀都被填入表内的情况下，如果在 1…x−1 的位置上的单词都不是它的后缀，那么他吃 x 颗泡椒就能记住它；</li><li>当它的所有后缀都被填入表内的情况下，如果 1…x−1 的位置上存在是它后缀的单词，所有是它后缀的单词中，序号最大为 y，那么你只要吃 x−y 颗泡椒就能把它记住。</li></ul><p>Lweb 是一个吃到辣辣的东西会暴走的奇怪小朋友，所以请你帮助 Lweb，寻找一种最优的填写单词方案，使得他记住这  n 个单词的情况下，吃最少的泡椒。</p><p><strong>解题思路</strong><br>首先把所有字符串反转，那么后缀就变成前缀了，就可以用trie维护。<br>刚开始我是想记录每个字符串的前缀个数，然后根据个数从小到大分配编号，但显然不行。<br>正解是将所有字符串构成一棵树，一个节点的父亲就是它的前缀，而没有前缀的字符串父亲为 0 号节点。我们可以利用 trie中的 search 时填边建树。<br>这样我们就有一棵有向树了，假设我们给节点 x 分配的序号是 f[x] ，那么显然 ans += f[x] - f[par[x] ]，其中 par[x] 代表 x 的父亲节点。所以我们需要让每个节点和它父亲节点的编号相差尽量小，那么自然是优先给节点数少的子树分配编号咯，所以对于每个节点 x ，我们选择节点最小的一棵子树，为它们分配编号。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">6e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> tc[N];<span class="comment">//记录后缀个数</span></span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],End[SZ], tot = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> par[N], head[N], ver[N], nex[N],tot2 = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot2] = y, nex[tot2] = head[x], head[x] = tot2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">int</span> len = s.length(), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p] = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">int</span> len = s.length(), p = <span class="number">1</span> ,res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line"><span class="keyword">if</span>(End[p] &amp;&amp; i != len<span class="number">-1</span>) par[id] = End[p];</span><br><span class="line">&#125;</span><br><span class="line">addEdge(par[id],id);<span class="comment">//顺便建树啦 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> str[N];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> num[N];<span class="comment">//记录子树x的节点个数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i != <span class="number">-1</span>;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line">num[x] += dfs(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num[x]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">priority_queue&lt; pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="keyword">int</span> f[N]; <span class="comment">//记录x编号 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">ans += cnt - f[par[x]]; f[x] = cnt; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i != <span class="number">-1</span>;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line">q.push(make_pair(-num[y],y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> nnex[q.size()],tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> y = q.top().second;q.pop();</span><br><span class="line">nnex[tt++] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tt;i++) cnt++, calc(nnex[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i],i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) search(str[i],i);</span><br><span class="line">num[<span class="number">0</span>] = dfs(<span class="number">0</span>); calc(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; str[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) reverse(str[i].begin(),str[i].end());</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="The-xor-longest-Path"><a href="#The-xor-longest-Path" class="headerlink" title="The xor-longest Path*"></a>The xor-longest Path*</h4><p><strong>题意简述</strong><br>原题来自：POJ 3764<br>给定一棵 n 个点的带权树，求树上最长的异或和路径。</p><p><strong>解题思路</strong><br>设 d[x] 表示 x 到根节点的路径异或和，那么显然由于异或的特性，x^y^x = y，我们任选两个点 x 和 y ，那么d[x] ^ d[y]就是 x 和 y 之间的路径异或和，因为从LCA(x , y)到根节点的路径都被抵消了。<br>所以原问题就成了从 d[1,n] 中选两个数，使它们的异或和最大。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N],nex[N],edge[N],tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,d[N];<span class="comment">//d[x]:x到根节点的路径异或和 </span></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y, nex[tot] = head[x];</span><br><span class="line">edge[tot] = z, head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//printf("%d %d %d\n",x,y,z);</span></span><br><span class="line">d[y] = d[x]^z;</span><br><span class="line">dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">32</span>*N;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">2</span>], tot2 = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>,p = <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot2;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回x与集合中异或和最大的 结果*/</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>,p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][!ch]) p = trie[p][!ch],res |= <span class="number">1</span>&lt;&lt;i;</span><br><span class="line"><span class="keyword">else</span> p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/* 计算并输出答案 */</span></span><br><span class="line">dfs(<span class="number">1</span>); <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(d[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) ans = max(ans,search(d[i]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt; n;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt(); z = getInt();</span><br><span class="line">addEdge(x,y,z); addEdge(y,x,z);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://ybt.ssoier.cn:8088/index.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测试地址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;Phone-List&quot;&gt;&lt;a href=&quot;#Phone-List&quot; class
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Trie" scheme="http://valenshi.top/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法练习题集</title>
    <link href="http://valenshi.top/2019/09/29/kmp-problems/"/>
    <id>http://valenshi.top/2019/09/29/kmp-problems/</id>
    <published>2019-09-29T05:54:36.000Z</published>
    <updated>2019-09-29T06:02:06.919Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/index.php" target="_blank" rel="noopener">测试地址</a></p><h4 id="剪花布条"><a href="#剪花布条" class="headerlink" title="剪花布条"></a>剪花布条</h4><p><strong>题意简述</strong><br>原题来自：HDU 2087<br>一块花布条，里面有些图案，另有一块直接可用的小饰条，里面也有一些图案。对于给定的花布条和小饰条，计算一下能从花布条中尽可能剪出几块小饰条来呢？</p><p><strong>解题思路</strong><br>就是普通的kmp算法，只不过这里的两个模式串不能重叠，我们基于贪心策略遇到一个选一个即可。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> f[N],nex[N];</span><br><span class="line"><span class="keyword">char</span> S[N],T[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getF</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(s)<span class="number">-1</span>, m = <span class="built_in">strlen</span>(t)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; (j == m || s[i] != t[j+<span class="number">1</span>])) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == t[j+<span class="number">1</span>]) j++;</span><br><span class="line">f[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">getNex(T);</span><br><span class="line">getF(S,T);</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(S)<span class="number">-1</span>, m = <span class="built_in">strlen</span>(T)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt; r &amp;&amp; f[i] == m) ans++ ,r = i+m<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,S+<span class="number">1</span>) &amp;&amp; S[<span class="number">1</span>] != <span class="string">'#'</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,T+<span class="number">1</span>); S[<span class="number">0</span>] = T[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Power-Strings"><a href="#Power-Strings" class="headerlink" title="Power Strings"></a>Power Strings</h4><p>在之前的字符串与Hash题集中做过，而且刚过去不久，不整理了。</p><h4 id="Radio-Transmission"><a href="#Radio-Transmission" class="headerlink" title="Radio Transmission"></a>Radio Transmission</h4><p><strong>题意简述</strong><br>给你一个字符串，它是由某个字符串不断自我连接形成的。但是这个字符串是不确定的，现在只想知道它的最短长度是多少。</p><p><strong>解题思路</strong><br>求最短循环节，给定的字符串可能是由循环节循环构成的字串的一个子串，所以就直接用求最短循环节就可以了，省去用字符串hash判断该串是否满足了。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n,nex[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">getNex(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n - nex[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="OKR-Periods-of-Words"><a href="#OKR-Periods-of-Words" class="headerlink" title="OKR-Periods of Words"></a>OKR-Periods of Words</h4><p><strong>题意简述</strong></p><p>原题来自：POI 2006<br>串是有限个小写字符的序列，特别的，一个空序列也可以是一个串。一个串 P 是串 A 的前缀，当且仅当存在串 B，使得 A=PB。如果P≠A并且 P 不是一个空串，那么我们说 P 是 A 的一个 proper 前缀。<br>定义 Q 是 A 的周期，当且仅当 Q 是 A 的一个 proper 前缀并且 A 是 QQ 的前缀（不一定要是 proper 前缀）。比如串 abab 和 ababab 都是串 abababa 的周期。串 A 的最大周期就是它最长的一个周期或者是一个空串（当 A 没有周期的时候），比如说，ababab 的最大周期是 abab。串 abc 的最大周期是空串。<br>给出一个串，求出它所有前缀的最大周期长度之和。</p><p><strong>解题思路</strong><br>题意有一些绕，但是还好给的是中文题面，尚可理解。就是说P是A的一个真子串，且是A的前缀，那么P就是A的proper前缀。若Q是A的proper前缀，且A是QQ（两个Q拼接在一起）的前缀（前缀不必要是真子串），那么Q就是A的周期。<br>现在要求的是A的 所有前缀的 最长周期的长度之和。</p><p>如果要是求最短周期的长度，那么直接就是求最短循环节，跑一遍nex就解决了；现在要求最长周期的长度，相当于求最长的循环节（该循环节不能等于原串！否则就不是proper前缀了），那么就不断的令 j = nex[j]，找到非零的最小 nex[j] （将nex数组看作father数组，一棵father树），那么最长循环节就是 i - j 了。</p><p>这样会超时，因为我们每次令j = nex[j]相当于从叶子节点走到根节点，最坏情况是O(N)才能找到最小的非零 nex[j]，总时间复杂度就是O(N^2)。</p><p><strong>优化</strong><br>我们令 f[j] 表示根到 j 路径上最小非零的值。（我们把nex数组看作一棵树！！！）<br>那么对于任意的nex[p]，若nex[p] != 0，那么最长周期就是 p - f[nex[p] ]。<br>我们在求nex数组时顺便更新 f 数组，和记忆化类似，思路不难理解。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n,nex[N],f[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s)<span class="number">-1</span>; f[<span class="number">0</span>] = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line"><span class="keyword">if</span>(j) f[j] = min(j,f[nex[j]]);</span><br><span class="line"><span class="comment">//printf("%d %d\n",j,f[j]);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">getNex(str);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex[i]) ans += i - f[nex[i]];</span><br><span class="line"><span class="comment">//printf("%d %c\n",ans,str[i]);</span></span><br><span class="line"><span class="comment">//printf("%d %d\n",nex[i],f[i]);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="似乎在梦中见过的样子"><a href="#似乎在梦中见过的样子" class="headerlink" title="似乎在梦中见过的样子"></a>似乎在梦中见过的样子</h4><p><strong>题意简述</strong><br>原题来自：2014 年湖北省队互测 Week2<br>「Madoka，不要相信 QB！」伴随着 Homura 的失望地喊叫，Madoka 与 QB 签订了契约。<br>这是 Modoka 的一个噩梦，也同时是上个轮回中所发生的事。为了使这一次 Madoka 不再与 QB 签订契约，Homura 决定在刚到学校的第一天就解决 QB。然而，QB 也是有许多替身的（但在第八话中的剧情显示它也有可能是无限重生的），不过，意志坚定的 Homura 是不会放弃的——她决定消灭所有可能是 QB 的东西。现在，她已感受到附近的状态，并且把它转化为一个长度为 n 的字符串交给了学 OI 的你。<br>现在你从她的话中知道，所有形似于 A+B+A 的字串都是 QB 或它的替身，且 ∣A∣≥k,∣B∣≥1（位置不同其他性质相同的子串算不同子串，位置相同但拆分不同的子串算同一子串），然后你必须尽快告诉 Homura 这个答案——QB 以及它的替身的数量。<br>注：对于一个字符串 S，∣S∣ 表示 S 的长度。</p><p><strong>解题思路</strong><br>这题需要对照样例来理解题意，经过分析后，发现题意是如果有一个子串满足ABA形式，其中 |A|&gt;=k 且 B 不是空串，那么该子串就是QB大魔王。现在问有多少个这样的子串。</p><p>首先看思路，对于一个字符串(s[1,n])，我们通过求它的nex数组，如果nex[n] &gt;= k 并且 nex[n] 小于 n/2，那么该串就是QB；如果nex[n] &gt;= n/2，那么nex[ nex[n] ] ，一直到根节点的路径上，只要有一个nex大于k且小于n/2，该串就也是QB。</p><p>综上所述，我们对于一个下标为[1, p]的字符串，需要找到nex[p]到根节点（将nex数组看作一棵树）路径上大于等于 k 的最小 nex值（贪心思想）。我们用 f 数组来存放该值。之所以用 f 数组存放，是为了防止最坏情况O(N^2)遍历。</p><p>所以我们对原字符串 S 的每一个后缀都进行上述操作，时间复杂度共O(N^2)，勉强过。但是常数稍微大一些就过不了了，所以统计答案也要在求 nex 和更新 f 数组时顺便累加，如果觉得这样太怂了，还可以进行别的优化，不过我懒得改了。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">15000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> nex[N],k, f[N], ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//f[i]为nex[i]到根中,大于k的最小的一个 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s)<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex); f[<span class="number">0</span>] = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line"><span class="keyword">if</span>(j &lt; k) f[j] = INF; </span><br><span class="line"><span class="keyword">else</span> f[j] = min(j,f[nex[j]]);</span><br><span class="line"><span class="keyword">if</span>(f[j]&lt;&lt;<span class="number">1</span> &lt; i) ans++;</span><br><span class="line"><span class="comment">//printf("%d %d %d %d\n",i,j,f[j],nex[j]);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(str)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">getNex(str+i<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Censoring"><a href="#Censoring" class="headerlink" title="Censoring"></a>Censoring</h4><p>这个我一看就知道KMP很难写，应该用自动机，所以放在自动机专题整理，另外吐槽一下书上的翻译是谁写的，太敷衍了吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://ybt.ssoier.cn:8088/index.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测试地址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;剪花布条&quot;&gt;&lt;a href=&quot;#剪花布条&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="KMP" scheme="http://valenshi.top/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>哈希与哈希表</title>
    <link href="http://valenshi.top/2019/09/28/hash/"/>
    <id>http://valenshi.top/2019/09/28/hash/</id>
    <published>2019-09-28T10:40:00.000Z</published>
    <updated>2019-09-28T10:42:17.956Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>哈希算法是通过一个哈希函数 H，将一种数据（字符串、大数等）转化为能够用变量表示或者能直接作为数组下标的数，通过哈希函数转化得到的数值我们成为哈希值。通过哈希值可以实现快速查找和匹配。本文主要介绍两种哈希算法的应用：字符串 Hash 和哈希表。</p><h4 id="字符串Hash"><a href="#字符串Hash" class="headerlink" title="字符串Hash"></a>字符串Hash</h4><p>字符串Hash有几种不同的用途，但是基于同一个原理，就是通过hash值匹配。<br>首先就是模式串匹配问题，n = |S| , m = |T| ，可以通过维护原串中所有长度为 m 的子串的哈希值，实现在O(1)时间内转移，并在O(1)时间内与 T 串的 hash值判等，若相等则有可能匹配成功。<br>大部分模式串匹配问题是用KMP求解，但是如果要是从主串中每次选出两个子串判断是否匹配的问题，还是需要用字符串 Hash 求解。</p><p><strong>具体流程</strong><br>我们设计的哈希函数 H 应当能在O(1)时间内实现相邻子串间的转移，或在预处理后，对不同的子串应该能在O(1)时间内求出其哈希值；这里用到叫做 滚动哈希 的优化技巧。</p><p>我们选取两个合适的互质的常数 b 和 h(b &lt; h)，假设字符串 $C = c_1c_2…c_m$，那么我们定义函数：$H(C) = (c_1b^{m-1} + c_2b^{m-2} + … + c_mb^0)\:mod\:h$。</p><p>这里的b是基数，相当于把字符串看作是 b 进制数。<br>这一过程是递推计算的，设H(C , k+1)是前 k 个字符构成的字符串的哈希值，则（不考虑取模）：$H(C , k+1) = H(C, k) * b + c_{k+1}$。</p><p>如果我们要<strong>求 C 中从 k 出发长度为 m 的子串的哈希值</strong>，那么$hsh = H(C , k+m) - H(C, k) * b^m$，hsh即为所求。</p><p><strong>预处理</strong></p><p>我们通过预处理求出所有C[a1, k]（k &lt;= n）的哈希值并存储在hash数组中（hash[i] = H(C,i) ），并预处理 base 数组（base[i] = $b^i$），那么我们就可以在O(1)时间内求出任意一个子串的哈希值。</p><p>在实现算法时，我们通常利用32位或者64位无符号整数计算哈希值，并取 $h = 2^{32}$ 或 $h = 2^{64}$，通过自然溢出省去取模运算。通常 b 取131 或 13331时效果较好。</p><p><strong>代码实现</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bse[i] = b^i , hsh[i] = H(str, i) */</span></span><br><span class="line">bse[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//bse和hsh都是unsigned long long </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    hsh[i] = hsh[i<span class="number">-1</span>]*b + str[i]-<span class="string">'a'</span>;</span><br><span class="line">    bse[i] = bse[i<span class="number">-1</span>]*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正确性证明</strong><br>上述做法可以保证相同的字符串所产生的哈希值一定是相同的，但是不同的字符串所产生的哈希值一定是不同的吗？<br>并不一定，但是冲突的几率很小，我们通常认为算法竞赛不会出现不同字符串哈希值冲突的情况。实际上根据生日悖论，对于哈希值在[0 , n)内均匀分布的哈希函数，出现不同字符串哈希值相等的期望步数是 $O(\sqrt N)$，可以作为一个参考。<br>更进一步的，我们还可以使用 <strong>“双哈希”</strong> 降低冲突的概率，即取用不同的模数，把不同的模数算出的哈希值记下来，只有几个哈希值都一样，才判定字符串匹配。我们通常用双哈希就可以将冲突的概率降到很低，如果分别取 h = 1e9+7 和 h = 1e9+9，就几乎不可能发生冲突，因为它们是一对“孪生素数”。</p><h4 id="哈希表与哈希函数"><a href="#哈希表与哈希函数" class="headerlink" title="哈希表与哈希函数"></a>哈希表与哈希函数</h4><p>哈希表是一种高效的数据结构，查找时间效率是常数时间，同时也很容易实现，需要付出的代价是消耗内存，但在如今这点内存已不成问题。</p><p><strong>问题模型</strong><br>给定 n 个数，这些数可能很大，判断每个数在之前有无出现过，出现了几次？</p><p><strong>算法流程</strong><br>这里具体分为三步：构造哈希函数 H()；将元素映射到哈希表；解决冲突。<br>首先要解决存储问题，我们先用线性表，即一维数组来存放元素。对于每个元素val，key = H(val)（这里的 key 是小于 1e7 的，可以当作数组的下标），于是我们就将val存放在数组下标为 key 的位置上。</p><p>而不同的元素它们key值是不同的（理想情况），相同的元素key值一定是相同的（任何情况），于是我们就可以通过O(1)时间的H()转化，读取数组内对应位置上的元素。</p><p>为了减少冲突呢，我们必须构造一个好的哈希函数H，这在后面会单独介绍常用的构造方法。但是不管多么优秀的哈希函数，都不可避免存在冲突，因此我们还需要有解决冲突的对策。我们想到可以用链表来解决冲突，即该一维表的每一个位置都是一条链表，具有相同哈希值的元素都放在同一条链上，当查找时只需要遍历这条链即可。这就叫哈希（链）表。</p><h5 id="哈希函数的构造"><a href="#哈希函数的构造" class="headerlink" title="哈希函数的构造"></a>哈希函数的构造</h5><p>哈希函数是决定哈希表查找效率的关键，只有哈希值分配的足够均匀时，单词查找的复杂度才会尽量小。以下介绍几种效果好的、容易实现的哈希函数。<br><strong>（1）基数转换法</strong><br>基数转换法就是开头的字符串Hash所采用的转换方法：将 val 值看作另一种进制数，然后再把它转化成对应的十进制数，再用除余法对其取余。一般取大于10的数作为转换的基数，并且两个基数是互质的。一般来说，取 131 或 13331较好。</p><p>如 val = 236075 原本是十进制数，现在将它看作十三进制数$(236075) _ {13}$然后再将它转换为十进制数。<br>$(236075)_ {13} = 2 <em> 13^5 + 3 </em> 13^4 + 6 <em> 13^3 + 7 </em> 13 + 5 = (841547) _ {10}$</p><p><strong>（2）除余法</strong><br>选择一个适当的正整数 b，用其对 b 取模的余数作为哈希值，即：H(val) = val mod b，这个方法应用的最多，并且多数情况下性价比也是最高的。关键在于 b 的选取，一般选 b 是数组下标能存储得下并且尽量大的质数（一般根据空间取1e6左右的质数）。选质数是因为 通常b的约数越多，冲突的几率就越大。</p><p><strong>（3）乘积取整法</strong><br>我们用值 val 乘以一个在(0,1)中的实数 A（最好是无理数，$(\sqrt 5 - 1)/2$是一个实际效果很好的数），得到一个(0 , k)之间实数；取其小数部分，乘以哈希表的大小 M 再向下取整，即得 val 在Hash表中的位置。函数表达式可以写成：H(val) = { M( val * A mod 1 ) }。</p><h5 id="散列表模板"><a href="#散列表模板" class="headerlink" title="散列表模板"></a>散列表模板</h5><p>例题：门票(tickets)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">2181271</span>; </span><br><span class="line"><span class="keyword">int</span> nex[N],num[N],head[N],tot = <span class="number">1</span>;<span class="comment">// 用邻接表方式实现哈希表 </span></span><br><span class="line"><span class="keyword">int</span> top , stk[N];<span class="comment">//数组模拟堆栈,用于哈希表的初始化 </span></span><br><span class="line">ll a,b,c;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">tot = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span>(top) head[stk[top--]] = <span class="number">0</span>;<span class="comment">//只清空用了的表,节省时间 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将x插入哈希表*/</span></span><br><span class="line"><span class="keyword">int</span> h = x % P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[h] ;i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i] == x) <span class="keyword">return</span>; <span class="comment">//相同的值已经存放过了 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(!head[h]) stk[++top] = h; <span class="comment">//第一次出现的哈希值入栈</span></span><br><span class="line"><span class="comment">/* 邻接表添加元素基本套路 */</span></span><br><span class="line">nex[++tot] = head[h]; head[h] = tot; num[tot] = x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ask</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 返回 x 是否存在*/</span></span><br><span class="line"><span class="keyword">int</span> h = x%P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[h];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i] == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll x = <span class="number">1</span>; Insert(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">2e6</span>;i++)&#123;</span><br><span class="line">x = (x*a + x%b)%c;</span><br><span class="line"><span class="keyword">if</span>(ask(x)) <span class="keyword">return</span> i;</span><br><span class="line">Insert(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*多组样例要调用init()*/</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>董永建，信息学竞赛一本通提高版，福州：福建教育出版社，2018.6，63-69</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;哈希算法是通过一个哈希函数 H，将一种数据（字符串、大数等）转化为能够用变量表示或者能直接作为数组下标的数，通过哈希函数转化得到的数值我们成
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="hash" scheme="http://valenshi.top/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>字符串循环节问题</title>
    <link href="http://valenshi.top/2019/09/27/xhj/"/>
    <id>http://valenshi.top/2019/09/27/xhj/</id>
    <published>2019-09-27T05:22:29.000Z</published>
    <updated>2019-09-27T05:23:11.718Z</updated>
    
    <content type="html"><![CDATA[<p><strong>循环节与最短循环节：</strong><br>若某个字符串是由某个子串循环构成的，那么就称该子串为原串的循环节，长度最短的循环节就是最短循环节。<br>如abababab，abab和ab都是原串的循环节，而最短循环节是ab。</p><p><strong>结论：</strong><br>如果字符串 s 有个循环节 son，n = |s| , x = |son|，字符数组下标从1开始，那么：</p><ol><li>x 一定是 n 的约数。</li><li>那么s[1,n-x] = s[x, n] = son。</li></ol><p><strong>证明：</strong><br>结论1：如果 x 不是 n 的约数，那么自然 n 就不可能由 若干个 x 相加构成，即不满足 n = k * x ，其中 k 是正整数。<br>结论2：若想s[1 ,n-x] = s[x, n] ，必须s[1, x] = s[ x ,2x] = s[2x , 3x] = … = s[n-x , n]，刚好符合循环节定义，因此 结论2 成立。</p><h4 id="求单个字符串的最短循环节"><a href="#求单个字符串的最短循环节" class="headerlink" title="求单个字符串的最短循环节"></a>求单个字符串的最短循环节</h4><p><strong>例1：</strong> POJ 2406 Power Strings (KMP)<br><a href="http://poj.org/problem?id=2406" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong> 给定一个字符串 s ，求出它最多由某个子串 循环几次 构成。</p><p><strong>解题思路：</strong><br>首先 s 必须是由某个循环节循环若干次构成的，否则无解。题意让求最多循环几次构成，那么既然 s 的长度固定是 n，自然是循环节越短，那么循环次数越多了。<br>我们先求出KMP算法中的nex数组。<br><strong>结论3：</strong> 此时若 s 有解，那么最短循环节长度为 x = n - nex[n] 。</p><p><strong>证明：反证法</strong> </p><ol><li>首先根据结论2，因为 s[1,nex[n] ] = s[n - nex[n] , n]，所以必然存在长度为 x = n - nex[n]的循环节，问题就在于它是不是最短的。</li><li>假设存在循环节，长度为 y（y &lt; x） ，那么根据结论2，一定有： s[1, n-y] = s[y , n]；如此一来nex[n] = n-y &gt; n-x，这和nex数组定义矛盾，因此不存在y &lt; x。</li><li>综上所述，n - nex[n] 一定为最短循环节的长度。</li></ol><p>因此本题的答案就是 n/(n-nex[n])，若不能整除，则无解。</p><p><strong>代码示例：</strong> 见附录部分 code-1：Power Strings</p><h4 id="求任意子串的最短循环节"><a href="#求任意子串的最短循环节" class="headerlink" title="求任意子串的最短循环节"></a>求任意子串的最短循环节</h4><p><strong>例2：</strong> bzoj2795 Horrible Poem<br><a href="http://www.mfstem.org/contest/57/problem/F" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给出一个由小写英文字母组成的字符串 S，再给出 q 个询问，要求回答 S 某个子串的最短循环节长度。如果字符串 B 是字符串 A 的循环节，那么 A 可以由 B 重复若干次得到。</p><p><strong>解题思路：</strong><br>此题的 q 很大，我们不可能对每一个子串都O(n)求出 nex 数组再回答。我们利用 滚动哈希 ，在O(1)时间内利用 结论2 判断某个长度是否为循环节。<br>再根据结论1，可以得知循环节长度一定是子串长度 m 的约数，因此我们$O(\sqrt m)$分解约数，再用O(1)复杂度用hash判断，本题总复杂度就是 $O(q \sqrt m)$。</p><p>一般到这里就该结束了，我们利用了 结论1 和 结论2 大大减少了求循环节的时间。但是在本题还是不够，还需要优化。还能优化的地方就只有求约数的$O(\sqrt m)$复杂度了，我们可以通过质因数分解在$O(log_2^m)$时间内分解约数，于是最终复杂度就是 $O(q\:log_2^n)$，可以通过了。</p><p><strong>代码示例：</strong> 见附录部分code-2：Horrible Poem</p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p><strong>code-1：Power Strings</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> nex[N]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;str[i];i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; str[i] != str[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(str[i] == str[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算答案并输出*/</span></span><br><span class="line">getNex(str);</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(str)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(n%(n-nex[n])) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n/(n-nex[n]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>) &amp;&amp; str[<span class="number">1</span>] != <span class="string">'.'</span>)&#123;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'*'</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>code-2：Horrible Poem</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Q = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line">ull hsh[N],bse[N] , b = <span class="number">31</span>; <span class="comment">//采用无符号长整形,通过自然溢出省去取模 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*判断x是否为子串s[l,r]的最短循环节长度*/</span> </span><br><span class="line">ull h1 = hsh[r-x] - hsh[l<span class="number">-1</span>]*bse[r-x+<span class="number">1</span>-l];</span><br><span class="line">ull h2 = hsh[r] - hsh[l<span class="number">-1</span>+x]*bse[r-x+<span class="number">1</span>-l];</span><br><span class="line"><span class="keyword">return</span> h1 == h2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> v[N],primes[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPri</span><span class="params">()</span></span>&#123;<span class="comment">//线性筛 </span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i])&#123;</span><br><span class="line">primes[cnt++] = i;</span><br><span class="line">v[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cnt;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(primes[j] &gt; v[i] || primes[j]*i &gt; N)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">v[i*primes[j]] = primes[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*回答子串s[l,r]的最短循环节长度*/</span> </span><br><span class="line"><span class="keyword">int</span> len = r-l+<span class="number">1</span>, ans = len, d = len;</span><br><span class="line"><span class="keyword">while</span>(d != <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = v[d];</span><br><span class="line"><span class="keyword">while</span>(d%tmp == <span class="number">0</span> &amp;&amp; check(l,r,ans/tmp)) d /= tmp,ans /= tmp;</span><br><span class="line"><span class="keyword">while</span>(d%tmp == <span class="number">0</span>) d /= tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*预处理出hash数组,v数组*/</span></span><br><span class="line">getPri(); bse[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">hsh[i] = hsh[i<span class="number">-1</span>]*b + str[i]-<span class="string">'a'</span>;</span><br><span class="line">bse[i] = bse[i<span class="number">-1</span>]*b;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>) &#123; x=x*<span class="number">10</span>+c-<span class="string">'0'</span>; c=getchar(); &#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">n = read();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>); str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">q = read();</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,l,r;i &lt;= q;i++)&#123;</span><br><span class="line">l = read(); r = read();</span><br><span class="line">ask(l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;循环节与最短循环节：&lt;/strong&gt;&lt;br&gt;若某个字符串是由某个子串循环构成的，那么就称该子串为原串的循环节，长度最短的循环节就是最短循环节。&lt;br&gt;如abababab，abab和ab都是原串的循环节，而最短循环节是ab。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="KMP" scheme="http://valenshi.top/tags/KMP/"/>
    
      <category term="循环节" scheme="http://valenshi.top/tags/%E5%BE%AA%E7%8E%AF%E8%8A%82/"/>
    
  </entry>
  
</feed>
