<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ValenShi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://valenshi.top/"/>
  <updated>2019-09-26T04:14:09.394Z</updated>
  <id>http://valenshi.top/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KMP算法</title>
    <link href="http://valenshi.top/2019/09/26/kmp/"/>
    <id>http://valenshi.top/2019/09/26/kmp/</id>
    <published>2019-09-26T04:12:11.000Z</published>
    <updated>2019-09-26T04:14:09.394Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>KMP算法，又称模式匹配算法，能够在线性时间内判定字符串 T 是否为 S 的子串，并求出字符串 T 在 S 中各次出现的位置。<br>KMP算法比较晦涩难懂。本文对于思想介绍略简，侧重于实现。</p><h4 id="问题模型与算法思路"><a href="#问题模型与算法思路" class="headerlink" title="问题模型与算法思路"></a>问题模型与算法思路</h4><p><strong>问题模型：</strong> 给定两个字符串 S 和 T ，试求出 T 在 S 中第一次出现的位置。</p><p>上述问题模型是模式串匹配最基础的模型，即单模式串匹配问题，这类问题是KMP算法以及字符串Hash大展身手的题型。</p><p><strong>算法思路1：Hash</strong><br>设|S| = n , |T| = m。如果不考虑冲突，那么我们可以将 S 的所有长度为 m 的子串hash值都求出来，复杂度为O(N)。将这 n-m+1 个子串与T的hash值在O(1)的时间内一一比对，即可通过hash值是否相同来判断是否匹配成功。<br>但实际上如果n和m很大(1e6)，那么散列值冲突是不可避免的，此时需要二次判断或者通过其他方法（构造更好的散列函数）来在保证速度的情况下提升正确性。</p><p><strong>算法思路2：KMP</strong><br>设|S| = n , |T| = m。首先考虑一个朴素算法，那就是将字符串 S 中的每一个长度为m的子串都与 T 进行一次匹配，失配后再匹配下一个，复杂度O(NM)。<br>手动模拟一下可以发现，上述做法中指向字符串 S 的指针和 T 的指针都有回退$^{[1]}$，但实际上我们并不需要发生回退，KMP算法就是通过防止指针回退来提升朴素算法效率的。</p><p>假设我们 S[i] 和 T[j+1] 发生了失配，如果我们知道 “T 中以 j 为末尾的真子串” 和 T[1, j] 的最长公共前缀的长度（假设为len，len一定小于 j ），那么显然 T[1, len] = S[i-len+1, i]；于是此时的 j = len，接着匹配即可。我们用nex数组（见下文）来存放 T 对应位置的“len”。</p><p>详细的讲，<strong>KMP算法分为两步：</strong></p><ol><li>对字符串 T 进行自我“匹配”，求出一个数组 nex，其中 nex[i] 表示“ T 中以 i 结尾的非前缀子串”与“ T 的前缀”能够匹配的最大长度，即：<br>&emsp;&emsp;nex[i] = max{j}，其中j &lt; i 并且 T[i-j+1, i] = T[1 ,j]。</li><li>对字符串 T 与 S 进行匹配，求出一个数组 f ，其中 f[i] 表示“S 中以 i 结尾的子串”与“ T 的前缀”能够匹配的最长长度。即：<br>&emsp;&emsp;f[i] = max{j}，其中j &lt;= i并且 S[i-j+1, i] = T[1, j]</li></ol><p><em>[1] 指针回退：在朴素做法中，如果发生失配，则要将指向 S 串的指针回退到当前子串起始位置，并右移至下一个子串起始位置，同理指向 T 的指针也要回到起始位置。</em></p><h4 id="Next数组"><a href="#Next数组" class="headerlink" title="Next数组"></a>Next数组</h4><p>首先要明白什么是Next数组（以下简称nex数组）。<br>nex[i]表示“T 中以 i 结尾的非前缀子串”与“T 的前缀”能够匹配的最长长度，即：nex[i] = max{j}，其中j &lt; i 并且 T[i-j+1, i] = T[i, j]。</p><blockquote><p>跳过：nex数组起到什么辅助作用，为什么要用nex数组？</p></blockquote><p><strong>nex 数组的求法</strong></p><ol><li>初始化 nex[1] = j = 0，假设nex[1, i-1] 已求出，下面求nex[i]。</li><li>不断尝试拓展匹配长度 j，如果拓展失败（下一个字符不相等），令 j 变为nex[j]，直至 j 为0（应该从头开始匹配）。</li><li>如果能够拓展成功，匹配长度 j 就增加1。nex[i] 的值就是 j 。</li></ol><p><strong>代码块</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/*更新模式串s的nex数组*/</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="f-数组"><a href="#f-数组" class="headerlink" title="f 数组"></a>f 数组</h4><p>按照前面的定义， f[i] 表示“S 中以 i 结尾的子串”与“ T 的前缀”能够匹配的最长长度。可以发现 f 数组和 nex 数组定义是一致的，因此他们的求解过程也基本一致。</p><p><strong>代码块</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getF</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">const</span> <span class="keyword">char</span> *T)</span></span>&#123;</span><br><span class="line"><span class="comment">/*求解 f 数组,S是目标串,T是模式串*/</span> </span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(S),len2 = <span class="built_in">strlen</span>(T);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;i &lt; len1;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; (j == len2 || S[i] != T[j+<span class="number">1</span>])) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(S[i] == T[j+<span class="number">1</span>]) j++;</span><br><span class="line">f[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题讲解"><a href="#例题讲解" class="headerlink" title="例题讲解"></a>例题讲解</h4><p><a href="https://www.luogu.org/problem/P3375" target="_blank" rel="noopener">测试地址</a><br><strong>代码模板</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">KMP算法模板-ValenShi</span></span><br><span class="line"><span class="comment">最后修改：2019/9/26</span></span><br><span class="line"><span class="comment">使用说明：</span></span><br><span class="line"><span class="comment">1.字符串起始位置是1而不是0,修改可能会出错.</span></span><br><span class="line"><span class="comment">2.记得初始化nex与f数组</span></span><br><span class="line"><span class="comment">3.原串长度与模式串长度都在函数中用strlen更新,无需修改全局变量 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s1[N],s2[N];</span><br><span class="line"><span class="keyword">int</span> nex[N],f[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/*更新模式串s的nex数组*/</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getF</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">const</span> <span class="keyword">char</span> *T)</span></span>&#123;</span><br><span class="line"><span class="comment">/*求解 f 数组,S是目标串,T是模式串*/</span> </span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(S),len2 = <span class="built_in">strlen</span>(T);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;i &lt; len1;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; (j == len2 || S[i] != T[j+<span class="number">1</span>])) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(S[i] == T[j+<span class="number">1</span>]) j++;</span><br><span class="line">f[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*求解nex数组与f数组,并 按要求 输出答案*/</span></span><br><span class="line">getNex(s2);</span><br><span class="line">getF(s1,s2);</span><br><span class="line"><span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(s1)<span class="number">-1</span>,len2 = <span class="built_in">strlen</span>(s2)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len1;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(f[i] == len2) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i-len2+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len2;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,nex[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,s1+<span class="number">1</span>,s2+<span class="number">1</span>);</span><br><span class="line">s1[<span class="number">0</span>] = s2[<span class="number">0</span>] = <span class="string">'#'</span>;<span class="comment">//不然strlen函数无法使用 </span></span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>董永建，信息学竞赛一本通提高版，福州：福建教育出版社，2018.6，74-81</li><li>李煜东，算法竞赛进阶指南，郑州：河南电子音像出版社，2017.10，65-67</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;KMP算法，又称模式匹配算法，能够在线性时间内判定字符串 T 是否为 S 的子串，并求出字符串 T 在 S 中各次出现的位置。&lt;br&gt;KMP
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Fish eating fruits</title>
    <link href="http://valenshi.top/2019/09/22/fish-eating-fruit/"/>
    <id>http://valenshi.top/2019/09/22/fish-eating-fruit/</id>
    <published>2019-09-22T06:57:11.000Z</published>
    <updated>2019-09-22T07:00:18.062Z</updated>
    
    <content type="html"><![CDATA[<p><a href>测试地址</a><br><strong>题意简述：</strong><br>树上任意两点之间的路径按照模 3 为 012 分类，将两点间距离加和，乘 2 即为答案。 </p><p><strong>解题思路：</strong><br>可以采用树上dp解决，也可以点分治，这里先给出一种树上dp做法：<br><code>dp[i][k]</code> 表示距 i 模 3 为 k 的节点距离和。<br><code>tc[i][k]</code> 表示距 i 模 3 为 k 的节点数目。<br><code>ans[k]</code>  表示所有路径中模 3 为 k 的路径的总长度。<br>目标答案是<code>ans[k]</code> 。<br>初始状态 <code>tc[i][0] = 1</code> 。</p><p>如果每次只考虑所有经过根 x 的路径，并且路径上的一个端点在x的一个子树上，另一个端点在另一个子树上（其他所有情况都可以在x的祖先或者子节点被考虑到，所以这样可以包含所有情况）。<br>假设当前枚举到x的子节点y，之前遍历的子节点已经使得dp和tc数组更新完成，那么我们要计算的路径起点在y，终点在之前遍历过的所有子节点中。<br><strong>分类讨论答案贡献：</strong></p><ol><li>边 x-y 对答案的贡献：设 j，k属于{0,1,2}，x 到 y 的边权为 z ，那么z对答案的贡献为<code>tc[x][j] * tc[y][k] * z</code>。</li><li>终点是 y 的所有路径长度的贡献：<code>dp[y][k] * tc[x][j] * z</code>。</li><li>起点是 x 的所有路径长度的贡献：<code>dp[x][j] * tc[y][k] * z</code>。</li></ol><p><strong>于是状态转移方程：</strong><br><code>dp[x][(j+z)%3] += dp[y][j] + z * tc[y][j]</code><br><code>tc[x][(j+z)%3] += tc[y][j]</code></p><p>当然，在状态转移前也要更新ans数组。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N],ver[N],edge[N],nex[N];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll tc[N][<span class="number">4</span>], dp[N][<span class="number">4</span>], ans[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 利用dfs进行状态转移,x为当前子树根节点 */</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i != <span class="number">-1</span>;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;<span class="comment">//y是父节点则跳过 </span></span><br><span class="line">dfs(y,x);</span><br><span class="line"><span class="comment">/* 这里统计答案 */</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">3</span>;k++)&#123;</span><br><span class="line">ans[(j+k+z)%<span class="number">3</span>] += (dp[x][j]*tc[y][k]%P+dp[y][k]*tc[x][j]%P)%P;</span><br><span class="line">ans[(j+k+z)%<span class="number">3</span>] += z*tc[x][j]%P*tc[y][k]%P;</span><br><span class="line">ans[(j+k+z)%<span class="number">3</span>] %= P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在这里转移状态 */</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)&#123;</span><br><span class="line">dp[x][(j+z)%<span class="number">3</span>] = (dp[x][(j+z)%<span class="number">3</span>] + dp[y][j] + z*tc[y][j])%P;</span><br><span class="line">tc[x][(j+z)%<span class="number">3</span>] = (tc[x][(j+z)%<span class="number">3</span>] + tc[y][j])%P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line"><span class="built_in">memset</span>(tc,<span class="number">0</span>,<span class="keyword">sizeof</span> tc);</span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span> ans);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) tc[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 统计答案并输出 */</span> </span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,ans[i]*<span class="number">2</span>%P);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[<span class="number">2</span>]*<span class="number">2</span>%P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head); tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addEdge(x+<span class="number">1</span>,y+<span class="number">1</span>,z); addEdge(y+<span class="number">1</span>,x+<span class="number">1</span>,z);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href&gt;测试地址&lt;/a&gt;&lt;br&gt;&lt;strong&gt;题意简述：&lt;/strong&gt;&lt;br&gt;树上任意两点之间的路径按照模 3 为 012 分类，将两点间距离加和，乘 2 即为答案。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解题思路：&lt;/strong&gt;&lt;br&gt;可以采用树上dp解决，也
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树上DP" scheme="http://valenshi.top/tags/%E6%A0%91%E4%B8%8ADP/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces Round 586(Div1+Div2)</title>
    <link href="http://valenshi.top/2019/09/21/cf-586/"/>
    <id>http://valenshi.top/2019/09/21/cf-586/</id>
    <published>2019-09-21T07:11:48.000Z</published>
    <updated>2019-09-25T02:50:15.189Z</updated>
    
    <content type="html"><![CDATA[<h4 id="A-Cards"><a href="#A-Cards" class="headerlink" title="A. Cards"></a>A. Cards</h4><p><a href="https://codeforces.com/contest/1220/problem/A" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定一个长度为 n 的字符串，该字符串可以组合出来几个one和几个zero，每个字符只能用一次。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> nn;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,z,e,r,o;</span><br><span class="line">n = z = e = r = o = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= nn;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i] == <span class="string">'o'</span>) o++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'z'</span>) z++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'r'</span>) r++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'e'</span>) e++;</span><br><span class="line"><span class="keyword">else</span> n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> one,zero;</span><br><span class="line">one = min(n,min(o,e));</span><br><span class="line">n -= one, o -= one, e -= one;</span><br><span class="line">zero = min(o,min(e,min(z,r)));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= one;i++) <span class="built_in">printf</span>(<span class="string">"1 "</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= zero;i++) <span class="built_in">printf</span>(<span class="string">"0 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;nn);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="B-Multiplication-Table"><a href="#B-Multiplication-Table" class="headerlink" title="B. Multiplication Table"></a>B. Multiplication Table</h4><p><a href="https://codeforces.com/contest/1220/problem/B" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定一个n <em> n表格，其中$M_{i,j} = a_i </em> a_j$，现在有个坏蛋把序列a给扔了，同时把M_{i,i}都给扣走了，现在请你利用剩下的信息求出a序列。</p><p><strong>解题思路：</strong><br>不是高斯消元题，其实是个找规律题。如果我们能求出来$a_1$，那么我们就可以根据第一列求出所有答案。而我们又可以根据$a_1a_2 = x$ , $a_1a_3 = y$ , $a_2a_3 = z$来求出$a_1$，于是就可以在求出其他所有结果了。<br><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line">ll mat[N][N],ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">ans[<span class="number">1</span>] = mat[<span class="number">1</span>][<span class="number">2</span>]*mat[<span class="number">1</span>][<span class="number">3</span>]/mat[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">ans[<span class="number">1</span>] = (ll)<span class="built_in">sqrt</span>(ans[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">ans[i] = mat[<span class="number">1</span>][i]/ans[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">printf</span>(<span class="string">"%I64d "</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>,&amp;mat[i][j]);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-Substring-Game-in-the-Lesson"><a href="#C-Substring-Game-in-the-Lesson" class="headerlink" title="C. Substring Game in the Lesson"></a>C. Substring Game in the Lesson</h4><p><a href="https://codeforces.com/contest/1220/problem/C" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>Ann和Mike在玩游戏，有一个字符串s，初始时有l  = r = k ，每个人轮流操作：</p><ul><li>选择l’ &lt; l , r’ &lt; r，且s[l’,r’] 字典序小于 s[l,r]，然后令l = l’, r = r’。</li><li>若不能做任何操作，则失败。</li></ul><p>Ann先手，对于每个位置k，输出谁必胜。</p><p><strong>题意简述：</strong><br>简单的博弈论，首先必败态是“在 l 之前不存在l’ &lt; l ， 且s[l’ , r] 字典序小于 s[l ,r] ”，而若当前不是必败态，则一定可以使得下一个状态一定是必败态，于是只需要判断每个位置前面是否有字典序比其小的字符即可。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mi = (<span class="keyword">int</span>)str[<span class="number">0</span>],n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mi &lt; (<span class="keyword">int</span>)str[i]) vis[i] = <span class="number">1</span>;</span><br><span class="line">mi = min(mi,(<span class="keyword">int</span>)str[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line"><span class="keyword">if</span>(vis[i]) <span class="built_in">printf</span>(<span class="string">"Ann\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Mike"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="D-Alex-and-Julian"><a href="#D-Alex-and-Julian" class="headerlink" title="D. Alex and Julian"></a>D. Alex and Julian</h4><p><a href="https://codeforces.com/contest/1220/problem/D" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定一个正整数集合B，令全集Z(所有整数)内的元素作为无向图的顶点，对于图中内任意两点i 和 j，若abs(i - j)属于集合B，则 i 和 j 之间有一条无向边。现在请问最少删除B中几个顶点可以使得剩下的图是二分图。</p><p><strong>解题思路：</strong><br>不是二分图问题，只用到了“一张图是二分图，当且仅当图中不存在奇环”这一二分图判定定理。<br>至于为啥不能用二分图算法来解决呢，从问题规模就可以猜到，因为要构造图需要$O((1e18)^2)$，显然n的规模不允许这样做。</p><p>那么从数学角度考虑（找规律），若有节点0和节点a，那么0 到 a有边，若还存在节点2 <em> a ，那么a 和2 </em> a也有边，且2 <em> a与 0也有边，这就是奇环了（哪怕还有3 </em> a，也还是奇环+一个偶环），因此不能有2 <em> a，同理也不能有4 </em> a，因此若想保留a，那么2 <em> a，4 </em> a， 8 * a， … 都要删去。<br>但是这样做法复杂度过高，因为顶点集合是[1, 1e18]，挨个计算显然不现实，因此我们可以对集合B中每个元素b，B中有哪些元素可以和b一起被保留。</p><p>若a中有x个因数2，b中有y个因数2（x != y），那么a和b一定不能同时存在；假设c = lcm(a ,b)那么0 -&gt; a -&gt; 2 <em> a -&gt; … -&gt; c -&gt; … -&gt; 2 </em> b -&gt; b -&gt; 0一定可以构成一个奇环 ，因此a和b不能同时存在。所以若是x != y，则a和b不能同时存在（a和b都是集合B内元素）。</p><p>若是x = y，那么a和b可以同时存在，因为它们不存在a是b的倍数，或者b是a的倍数这种情况，也就不能删去0，因此若有环则一定是偶环。</p><p>综上所述，我们通过统计B集合中每个元素有多少个因子2即可判断最多同时存在多少个元素，即最少删去多少个元素。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="keyword">int</span> tc[N],num[N],n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ll tmp = a[i];</span><br><span class="line"><span class="keyword">while</span>(tmp &amp;&amp; tmp%<span class="number">2</span> == <span class="number">0</span>) tc[i]++,tmp/=<span class="number">2</span>;</span><br><span class="line">num[tc[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">64</span>;i++)</span><br><span class="line"><span class="keyword">if</span>(num[p] &lt; num[i]) p = i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n-num[p]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line"><span class="keyword">if</span>(tc[i] != p) <span class="built_in">printf</span>(<span class="string">"%I64d "</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="E-Tourism"><a href="#E-Tourism" class="headerlink" title="E. Tourism"></a>E. Tourism</h4><p><a href="https://codeforces.com/contest/1220/problem/E" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>一共有n个点和m条无向边，每个点有权值，同一条边不能<strong>连续经过</strong>两次；每个点的权值最多只能加一次；给出每个点的权值以及无向图的边，给出起点编号s，求出怎样才能走才能使得权值和最大。</p><p><strong>解题思路：</strong><br>很容易发现如果经过一个环，那么该环上所有点的权值都可以拿到，且可以从环上任意一点出环，于是我们就可以将一个环缩为一个点，将图中所有环都缩为点后，无向图就成了无根树。题目就成了求无根树上从s出发的最远路径。于是该方法需要Tarjan缩点+树上dp，同时需要注意叶子节点不能缩（一定不是环）。</p><p>另一种方法就是利用拓扑排序。我们可以通过画图等模拟发现，最终答案一定是一些环与从环上出发的一条最长链。<br>于是我们可以考虑如下算法：</p><ol><li>利用拓扑排序，每次都从叶子节点出发，将路径上的权值累加到环上的对应节点（另开数组存放）并终止，并标记路径上的所有点。</li><li>由于环上所有点可互相到达，因此将所有未被标记的点的权值累加（有可能好几个环，但是环与环之间的路径未被标记，并且可达），即为可获得的环上最大权值和。</li><li>找从环上某点出发的最长链，与上述结果相加即为最终答案。</li></ol><p>很显然上述算法是正确的，我们将答案分为了两部分：可互达的“连通环”以及“从环上出发的最长链”。又由于我们是从s出发的，上述算法我们是累加未被标记的节点，因此如果标记的时候遇到了s，那么就将结果累加到s的附加域并终止；最终累加时候因为从 s 出发的链未被标记，因此依然会被累加。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[M],ver[M],nex[M];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> deg[N];<span class="comment">//入度,初始值为0 </span></span><br><span class="line">ll w[N],cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; </span><br><span class="line">head[x] = tot; deg[y]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> n,m,s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line"><span class="keyword">if</span>(deg[i] == <span class="number">1</span> &amp;&amp; i != s) q.push(i);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">deg[x] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(deg[y] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">deg[y]--;</span><br><span class="line">cnt[y] = max(cnt[y],cnt[x]+w[x]);</span><br><span class="line"><span class="keyword">if</span>(deg[y] == <span class="number">1</span> &amp;&amp; y != s) q.push(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll s1 = <span class="number">0</span>,s2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(deg[i] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">s1 += w[i];</span><br><span class="line">s2 = max(s2,cnt[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,s1+s2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,w+i); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;A-Cards&quot;&gt;&lt;a href=&quot;#A-Cards&quot; class=&quot;headerlink&quot; title=&quot;A. Cards&quot;&gt;&lt;/a&gt;A. Cards&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1220/pro
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="博弈论" scheme="http://valenshi.top/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
      <category term="数论" scheme="http://valenshi.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="拓扑排序" scheme="http://valenshi.top/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="图论" scheme="http://valenshi.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>5 连续内存分配</title>
    <link href="http://valenshi.top/2019/09/20/os5/"/>
    <id>http://valenshi.top/2019/09/20/os5/</id>
    <published>2019-09-20T14:52:54.000Z</published>
    <updated>2019-09-23T12:16:26.853Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机体系结构和内存层次"><a href="#计算机体系结构和内存层次" class="headerlink" title="计算机体系结构和内存层次"></a>计算机体系结构和内存层次</h3><ul><li>计算机体系结构</li><li>内存层次</li><li>操作系统的内存管理方式</li></ul><h4 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h4><p>基本的分配和释放的管理要求。cpu高速缓存，存储管理单元（MMU），内存最小访问单位8bit；32位的意思是一次可以读写32位；高速缓存用来存放会重复使用的数据，用来提高效率；</p><h4 id="内存层次"><a href="#内存层次" class="headerlink" title="内存层次"></a>内存层次</h4><p>缓存速度最快，首先去缓存找数据，若未命中则去内存中找，若仍未命中则去外存（虚拟内存）中找，这三者速度差别很大。</p><h4 id="操作系统的内存管理"><a href="#操作系统的内存管理" class="headerlink" title="操作系统的内存管理"></a>操作系统的内存管理</h4><p>知识点：我们希望的理想状态。逻辑存储单元。<br><strong>存储管理要达到的效果：</strong></p><ul><li>抽象：逻辑地址空间</li><li>保护：独立地址空间</li><li>共享：访问相同内存</li><li>虚拟化：更大的地址空间</li></ul><h4 id="操作系统中采用的内存管理方式："><a href="#操作系统中采用的内存管理方式：" class="headerlink" title="操作系统中采用的内存管理方式："></a>操作系统中采用的内存管理方式：</h4><ul><li>重定位（relocation）</li><li>分段（segmentation）</li><li>分页（paging）</li><li>虚拟存储（目前多数系统，如Linux，采用按需页式虚拟存储）</li></ul><p><strong>实现高度依赖硬件：</strong></p><ul><li>与计算机存储架构紧耦合</li><li>MMU（内存管理单元）：处理CPU存储访问请求的硬件</li></ul><h3 id="地址空间和地址生成"><a href="#地址空间和地址生成" class="headerlink" title="地址空间和地址生成"></a>地址空间和地址生成</h3><h4 id="地址空间的定义"><a href="#地址空间的定义" class="headerlink" title="地址空间的定义"></a>地址空间的定义</h4><p>物理地址空间-硬件支持的地址空间（地址总线条数）。</p><ul><li>起始地址为0，知道$MAX_{sys}$</li></ul><p>逻辑地址空间-在CPU运行的进程看到的地址</p><ul><li>起始地址为0，直到$MAX_{prog}$</li></ul><p>地址是从哪里来的？</p><h4 id="逻辑地址生成"><a href="#逻辑地址生成" class="headerlink" title="逻辑地址生成"></a>逻辑地址生成</h4><p><img src="/2019/09/20/os5/1.png" alt="1"></p><p><center>图1：逻辑地址生成图示</center></p><h4 id="地址生成时机和限制"><a href="#地址生成时机和限制" class="headerlink" title="地址生成时机和限制"></a>地址生成时机和限制</h4><p>编译时：</p><ul><li>假设起始地址已知</li><li>如果起始地址改变，必须重新编译</li></ul><p>加载时：</p><ul><li>如编译时起始位置位置，编译器需生成可重定位的代码</li><li>加载时，生成绝对地址</li></ul><p>执行时：</p><ul><li>执行时代码可移动</li><li>需地址转换（映射）硬件支持</li></ul><h4 id="地址生成过程"><a href="#地址生成过程" class="headerlink" title="地址生成过程"></a>地址生成过程</h4><p>CPU：</p><ul><li>ALU：需要逻辑地址的内存内容</li><li>MMU：进行逻辑地址和物理地址的转换</li></ul><p>内存：</p><ul><li>发送物理地址的内容给CPU</li><li>或接受CPU数据到物理地址</li></ul><p>操作系统：</p><ul><li>建立逻辑地址LA和物理地址PA的映射</li></ul><h4 id="地址检查"><a href="#地址检查" class="headerlink" title="地址检查"></a>地址检查</h4><p>检查段的长度和偏移量是否为有效范围。</p><h3 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h3><h4 id="连续内存分配和内存碎片"><a href="#连续内存分配和内存碎片" class="headerlink" title="连续内存分配和内存碎片"></a>连续内存分配和内存碎片</h4><p><strong>连续内存分配：</strong> 给进程分配一块不小于指定大小的连续的物理内存。<br><strong>内存碎片：</strong> 空闲内存不能被利用。<br><strong>外部碎片：</strong> 分配单元之间的未被使用的内存。<br><strong>内部碎片：</strong> 分配单元内部的未被使用的内存，取决于分配单元大小是否要调整。</p><h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p><strong>动态内存分配：</strong></p><ul><li>当程序被加载可执行时，分配一个进程指定大小可变的分区（块，内存块）</li><li>分区的地址是连续的</li></ul><p><strong>操作系统需要维护的数据结构：</strong></p><ul><li>所有进程的已分配分区</li><li>空闲分区（Empty-blocks）</li></ul><p><strong>动态分区分配策略：</strong></p><ul><li>最先匹配</li><li>最优匹配</li><li>最差匹配</li></ul><h4 id="最先匹配（First-Fit-Allocation）策略"><a href="#最先匹配（First-Fit-Allocation）策略" class="headerlink" title="最先匹配（First Fit Allocation）策略"></a>最先匹配（First Fit Allocation）策略</h4><p>思路：分配n个字节时，使用第一个可用的空间比n大的空闲块。<br>原理&amp;实现：</p><ul><li>空闲分区列表按照地址顺序排序</li><li>分配过程中，搜索一个合适的分区</li><li>释放分区时，检查是否可与临近的空闲分区合并</li></ul><p>优点：</p><ul><li>简单</li><li>在高地址上有大块的空闲分区</li></ul><p>缺点：</p><ul><li>外部碎片多</li><li>分配大块时较慢</li></ul><h4 id="最佳匹配（Best-Fit-Allocation）策略"><a href="#最佳匹配（Best-Fit-Allocation）策略" class="headerlink" title="最佳匹配（Best Fit Allocation）策略"></a>最佳匹配（Best Fit Allocation）策略</h4><p>思路：分配n个字节时，查找并使用不小于n的最小空闲分区<br>原理&amp;实现：</p><ul><li>空闲分区列表按照大小排序</li><li>分配时，查找一个合适的分区</li><li>释放时，查找并合并临近的空闲分区（如果找到）</li></ul><p>优点： 大部分分配的尺寸较小时，效果很好</p><ul><li>可避免大的空闲分区被拆分</li><li>可减小外部碎片的大小</li><li>相对简单</li></ul><p>缺点：</p><ul><li>外部碎片</li><li>释放分区慢</li><li>容易产生很多无用的小碎片</li></ul><h4 id="最差匹配（Worst-Fit-Allocation）策略"><a href="#最差匹配（Worst-Fit-Allocation）策略" class="headerlink" title="最差匹配（Worst Fit Allocation）策略"></a>最差匹配（Worst Fit Allocation）策略</h4><p>思路：分配n字节，使用尺寸不小于n的最大空闲分区。<br>原理&amp;实现：</p><ul><li>空闲分区按从大到小排序</li><li>分配时，选最大的分区</li><li>释放时，检查是否可与临近的空闲分区合并，进行可能的合并，并调整空闲分区列表的顺序</li></ul><p>优点：</p><ul><li>中等大小的分配较多时，效果最好</li><li>避免出现太多的小碎片</li></ul><p>缺点：</p><ul><li>释放分区较慢</li><li>外部碎片</li><li>容易破坏大的空闲分区，因此后续难以分配大的分区</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;计算机体系结构和内存层次&quot;&gt;&lt;a href=&quot;#计算机体系结构和内存层次&quot; class=&quot;headerlink&quot; title=&quot;计算机体系结构和内存层次&quot;&gt;&lt;/a&gt;计算机体系结构和内存层次&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;计算机体系结构&lt;/li&gt;
&lt;li&gt;内存层次&lt;/l
      
    
    </summary>
    
      <category term="计算机操作系统" scheme="http://valenshi.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="内存分配" scheme="http://valenshi.top/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Dudu&#39;s maze 解题报告</title>
    <link href="http://valenshi.top/2019/09/15/dudu-maze/"/>
    <id>http://valenshi.top/2019/09/15/dudu-maze/</id>
    <published>2019-09-15T05:29:21.000Z</published>
    <updated>2019-09-15T05:30:57.412Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://nanti.jisuanke.com/t/41402" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>在一个无向图中，有 k 个怪物点，n-k个糖果点，每个糖果点有1个糖果，且可以移动到相邻的点，但是每个点的糖果只能拿一次（但是可以经过多次）。而每个怪物点没糖果，但是可以随机传送到相邻的点，只能传送一次（即只能进一次怪物房），请问最终拿到糖果的最优期望是多少？<br><strong>解题思路：</strong><br>dfs求连通块+染色，我现在还是不明白我单独染色为什么一直超时，无语了，就按照下面的代码写吧，用标记数组单独存放被染色的连通块糖果数，相当于记忆化。当然节点1所在的连通块糖果都能拿到，然后再选择走和1相连的且期望最大的怪物点即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[<span class="number">2</span>*N],nex[<span class="number">2</span>*N],tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,t,k;</span><br><span class="line"><span class="keyword">int</span> vis[N],mst[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y;nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> vm[N],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"><span class="keyword">int</span> tc[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="number">1</span>; ans++; tc[x]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i != <span class="number">-1</span>;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(mst[y])&#123;</span><br><span class="line">vm[++cnt] = y;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">dfs1(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num[col]) <span class="keyword">return</span> num[col];</span><br><span class="line"><span class="keyword">if</span>(vis[x] || mst[x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> res = <span class="number">1</span>; vis[x] = col;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i != <span class="number">-1</span>;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y] || mst[y]) <span class="keyword">continue</span>;</span><br><span class="line">res += dfs2(y,col);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">ans = <span class="number">0</span>; cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span> num);</span><br><span class="line">dfs1(<span class="number">1</span>); <span class="keyword">double</span> mx = <span class="number">0</span>; <span class="keyword">int</span> col = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++)&#123;</span><br><span class="line"><span class="keyword">double</span> pp = <span class="number">0</span>,ecnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = head[vm[i]] ;j != <span class="number">-1</span>;j = nex[j]) ecnt++;</span><br><span class="line"><span class="comment">//printf("ecnt: %f\n",ecnt);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = head[vm[i]] ;j != <span class="number">-1</span>;j = nex[j])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[j]; <span class="keyword">double</span> tmp;</span><br><span class="line"><span class="keyword">if</span>(vis[y]) tmp = num[vis[y]];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">tmp = dfs2(y,++col);</span><br><span class="line">num[col] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">pp += tmp;</span><br><span class="line"><span class="comment">//printf("%d %f\n",ver[j] ,tmp);</span></span><br><span class="line">&#125;</span><br><span class="line">pp /= ecnt;</span><br><span class="line"><span class="keyword">if</span>(mx - pp &lt; <span class="number">0</span>) mx = pp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.7f\n"</span>,mx+ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">t = getInt();</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">tot = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(mst,<span class="number">0</span>,<span class="keyword">sizeof</span> mst);</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">n = getInt(), m = getInt(),k = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">addEdge(x,y);addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= k;i++) x = getInt() , mst[x] = <span class="number">1</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://nanti.jisuanke.com/t/41402&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测试地址&lt;/a&gt;&lt;br&gt;&lt;strong&gt;题意简述：&lt;/strong&gt;&lt;br&gt;在一个无向图中，有 k 个怪物点，n-k个糖果
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="dfs连通块" scheme="http://valenshi.top/tags/dfs%E8%BF%9E%E9%80%9A%E5%9D%97/"/>
    
      <category term="染色" scheme="http://valenshi.top/tags/%E6%9F%93%E8%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>Educational Codeforces Round 72 解题报告</title>
    <link href="http://valenshi.top/2019/09/10/cf-r72/"/>
    <id>http://valenshi.top/2019/09/10/cf-r72/</id>
    <published>2019-09-10T13:36:28.000Z</published>
    <updated>2019-09-10T13:40:39.340Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1217" target="_blank" rel="noopener">题集链接</a></p><h4 id="A-Creating-a-Character"><a href="#A-Creating-a-Character" class="headerlink" title="A.Creating a Character"></a>A.Creating a Character</h4><p><strong>题意简述：</strong><br>有三个数a，b，c，将c分配在a和b上，使得a&gt;b，请问有多少种分配方案？两个方案不同，当且仅当它们对应的a或b不相等。</p><p><strong>解题思路：</strong><br>假设将c分配给a和b后使得a = b = res，那么显然若原始的a &gt; res，就说明b+c &lt; a，那么答案就是c+1（当然特判b+c&lt;a也行）；否则a &lt;= res，此时分配给a的值一定要大于res - a，所以共c - (res-a) = c-res + a 种不同方案。 </p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a,b,c,t,d;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a+c &lt;= b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = a+b+c&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a &gt; res) <span class="keyword">return</span> c+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> c-res+a; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="B-Zmei-Gorynich"><a href="#B-Zmei-Gorynich" class="headerlink" title="B.Zmei Gorynich"></a>B.Zmei Gorynich</h4><p><strong>题意简述：</strong><br>一条恶龙共 x 滴血，勇士有n件武器，每件武器有伤害值 d 和 副作用 h，表示着将会给恶龙造成 d 点伤害，之后会给恶龙回 h 点血。当某一时刻恶龙血量低于0时则会死亡，请问勇者最少砍多少次才能杀死恶龙？如果杀不死输出-1，一个武器可以重复使用。<br><strong>解题思路：</strong><br>如果当前有一个武器能杀死恶龙（d &gt;= x），那么就可以忽略他的副作用 h ，直接秒杀恶龙；否则我们就要选择一个d-h最大的来砍恶龙，所以我们最多用两把武器，一把用来消耗，一把用来终结恶龙。当无法秒杀恶龙，也无法消耗恶龙时，说明无法杀死恶龙。否则就可以通过计算最少需要消耗多少次来O(1)计算答案。</p><p>特别注意是否能一刀秒杀恶龙等特殊情况。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> t1,t2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//恶龙本来就死了</span></span><br><span class="line"><span class="keyword">if</span>(t1 &gt;= x) <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//秒杀恶龙</span></span><br><span class="line"><span class="keyword">if</span>(t2 &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//无法杀死恶龙</span></span><br><span class="line">x -= t1;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x%t2) res++;</span><br><span class="line">res += x/t2;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;x); t1 = t2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,ta,tb;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;ta,&amp;tb);</span><br><span class="line">t1 = max(t1,ta);</span><br><span class="line">t2 = max(t2,ta-tb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="C-The-Number-Of-Good-Substrings"><a href="#C-The-Number-Of-Good-Substrings" class="headerlink" title="C.The Number Of Good Substrings"></a>C.The Number Of Good Substrings</h4><p><strong>题意简述：</strong><br>给定一个01串 s ，假设 sub 是 s 的子串，定义f(sub) = “sub十进制的值”。若f(sub) = len(sub)，f(sub) = 子串sub的长度，那么称sub为“优秀的子串”。<br>现在给定字符串s，试求出s的“优秀的子串”的数量。</p><p><strong>解题思路：</strong><br>刚开始想用KMP算法：对于每一可能的长度（共2e5种可能的情况）转化为二进制的01串，再用KMP计算该串在 s 中出现的次数，将所有情况累加即为答案。<br>但是KMP超时了，还是对KMP不太熟悉，上述算法复杂度应该是$O(N^2)$，是不行的。</p><p>再考虑由于$2^{20} &gt; 2e5$ 所以我们其实可以通过将 s 所有长度为 [1 , 20] 的子串挨个判断是否为“优秀的子串”，如此O(20N)时间内求出结果。具体做法是从左向右，将上一个 1 作为子串左端点，然后依次向右延申，长度+1，并将其转化为十进制，如果该十进制要大于区间长度，则后续肯定也不可能是“优秀子串”，故退出。能这样做是因为左边的0不影响十进制数的大小，而右边的0影响。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> last = <span class="number">0</span>,x,l,len = <span class="built_in">strlen</span>(str); ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;str[i];i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i] == <span class="string">'0'</span>) <span class="keyword">continue</span>; x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; len &amp;&amp; j &lt;= i+<span class="number">25</span>;j++)&#123;</span><br><span class="line">x = x*<span class="number">2</span>+str[j]-<span class="string">'0'</span>;</span><br><span class="line">l = j-x+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= last) <span class="keyword">break</span>;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">last = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="D-Coloring-Edges"><a href="#D-Coloring-Edges" class="headerlink" title="D.Coloring Edges"></a>D.Coloring Edges</h4><p><strong>题意简述：</strong><br>给定一个有 n 个点 m 条边的有向图，该有向图无自环无重边。我们对该有向图进行染色，一个好的染色方案当且仅当图中没有一个环是同一个颜色。请问要想使得该染色方案是好的，最少需要多少种不同的颜色？并输出每条边的颜色。<br><strong>解题思路：</strong><br>首先通过手画几种样例可以得出，我们最多只需要2种不同的颜色就可以完成图的着色。因此若图中有环，则k = 2，否则k = 1。而当k = 2时，即图中有环，需要2种不同颜色染色时，我们知道有向图中，若存在环，则必然有从编号小的点指向编号大的点，也有编号大的点指向编号小的点。因此，若边u-&gt;v，若u &lt; v则染颜色1，否则染颜色2，这样可以保证该环被拆分成两种颜色。</p><p><em>注：若有向图中不存在环，则不一定有 “从编号小的点指向编号大的点，同时也有从编号大的点指向编号小的点。”</em></p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[N],ver[N],nex[N];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x];</span><br><span class="line">head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,xx[N],yy[N];</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span>;</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y] == <span class="number">1</span>)&#123;</span><br><span class="line">flag = <span class="literal">true</span>; <span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!vis[y]) dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">vis[x] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!vis[i]) dfs(i);</span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(xx[i] &gt; yy[i]) <span class="built_in">printf</span>(<span class="string">"2 "</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"1 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">printf</span>(<span class="string">"1 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;xx[i],&amp;yy[i]);</span><br><span class="line">addEdge(xx[i],yy[i]);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/1217&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题集链接&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;A-Creating-a-Character&quot;&gt;&lt;a href=&quot;#A-Crea
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="图论" scheme="http://valenshi.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>hdu6629 string matching（拓展KMP）</title>
    <link href="http://valenshi.top/2019/09/06/hdu6629-String-Match/"/>
    <id>http://valenshi.top/2019/09/06/hdu6629-String-Match/</id>
    <published>2019-09-06T08:22:55.000Z</published>
    <updated>2019-09-06T08:25:42.812Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6629" target="_blank" rel="noopener">hdu6629string matching</a><br><strong>Description:</strong><br>给出一个字符串S，我们执行“求出S所有后缀与S的最长公共前缀长度”这个操作，我们采取暴力算法(算法流程见题面)，请问我们在该算法中共执行了多少次比较操作？<br><strong>Input:</strong><br>第一行一个整数t，接下来共t组测试用例，每个测试用例输入一个长度小于1e6的字符串S。<br><strong>解题思路：</strong><br>可以用拓展KMP做，其中S是原串，T也是原串。暴力算法的比较次数就等同于所有后缀的最长公共前缀长度和，若没有比到字符串末尾，则还要加上一次失配的操作比较。由于本题T也是S，故可以在计算nex数组的同时便统计答案。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> nex[N];<span class="comment">//nex[i] = T[i,n-1]与T[0,n-1]最长公共前缀 </span></span><br><span class="line"><span class="keyword">char</span> S[N];<span class="comment">//S为目标串,T为模式串 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str) ,i = <span class="number">0</span>,j,p0 ;</span><br><span class="line">nex[<span class="number">0</span>] = len;</span><br><span class="line"><span class="keyword">while</span>(i+<span class="number">1</span> &lt; len &amp;&amp; str[i] == str[i+<span class="number">1</span>]) i++;</span><br><span class="line">nex[<span class="number">1</span>] = i; p0 = <span class="number">1</span>; ans += nex[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(nex[<span class="number">1</span>] != len<span class="number">-1</span>) ans++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex[i-p0]+i &lt; nex[p0]+p0) nex[i] = nex[i-p0];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j = nex[p0]+p0-i;</span><br><span class="line"><span class="keyword">if</span>(j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i+j &lt; len &amp;&amp; str[j] == str[j+i]) j++;</span><br><span class="line">nex[i] = j; p0 = i;</span><br><span class="line">&#125;</span><br><span class="line">ans += nex[i];</span><br><span class="line"><span class="keyword">if</span>(nex[i] != len-i) ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算并返回答案*/</span></span><br><span class="line">ans = <span class="number">0</span>; getNex(S);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,S);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6629&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hdu6629string matching&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="拓展KMP" scheme="http://valenshi.top/tags/%E6%8B%93%E5%B1%95KMP/"/>
    
  </entry>
  
  <entry>
    <title>拓展KMP算法</title>
    <link href="http://valenshi.top/2019/09/06/exkmp/"/>
    <id>http://valenshi.top/2019/09/06/exkmp/</id>
    <published>2019-09-06T08:22:41.000Z</published>
    <updated>2019-09-06T08:24:34.010Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题模型：</strong><br>给定字符串S和子串T，S的长度为n，T的长度为m；求字符串T与字符串S的每一个后缀d的最长公共前缀。</p><h4 id="拓展KMP算法"><a href="#拓展KMP算法" class="headerlink" title="拓展KMP算法"></a>拓展KMP算法</h4><p>假设 extend[] 数组： extend[i] 表示 T 与 S[i, n] 的最长公共前缀，目的是求出所有的 extend[0~n-1]。<br>（注意到，如果存在extend[i] = m，则说明 T 在 S 中完全出现过，那么问题就变成标准KMP算法了。）<br>我们下面的目标就是如何在较短的时间内更新extend数组；与KMP算法类似，我们通过利用next数组来阻止指针的回退。</p><p><strong>下面先通过一般的例子来看我们是如何更新extend数组的：</strong></p><p>S = “aaaabaa” , T = “aaaaa”。</p><p>显然extend[0] = 4，显然当匹配到第5个时失配，共匹配了5次。<br>我们考虑利用已知的信息来计算extend[1]，已知S[1 , 3] = T[1 , 3]，现在要用S[1 , n-1]和T[0 , n-1]进行匹配，如果我们设 nex[1] 存放 T[1 , n-1] 与 T[0 , n-1] 的最长公共前缀，nex[1] = 4，这就说明<strong>对于S[1, n-1]，T[1 , n-1]能匹配上的字符，T[0,n-1]的前nex[1]个也能匹配的上</strong>，由于T[1,n-1]只能匹配S[1 , 3]共3个字符，那么显然前 3 个字符都可以成功匹配，我们直接匹配下一位即可；于是extend[1] = 3。</p><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><p><strong>定义extend[]数组：</strong> extend[i] 表示字符串 T 与字符串 S[i , n] 的最长公共前缀长度。<br><strong>定义nex[]数组：</strong> nex[i] 表示 T[i , n] 与 T[1 , n] 的最长公共前缀的长度。</p><p>首先我们从左到右计算extend数组，假设在某一时刻 extend[0 , k] 已经计算完毕，并且之前匹配过程中所达到的最远距离为p，所谓最远距离即 p = MAX{ i+extend[i]  (0 &lt;= i &lt;= k) } 的最大值，p’ 为达到最远距离时的 i 。</p><p><strong>现在来利用已知的信息求extend[k+1]：</strong><br>已知S[p’ , p] = T[0, p-p’]，即S[k+1 , p] = T[k+1 - p’ , p-p’]。<br>设 len = nex[k+1 - p’] ，即 len 为 T[k+1 - p’ , n-1] 与 T[0 , n-1]的最长公共前缀。</p><ul><li>如果k+len &lt; p，则extend[k+1] = len：<br>此时由于已知条件 以及 nex数组性质，可以知道前 len 个字符一定是匹配的。若S[k+ len+1] = T[len]，则说明 nex 是len+1而非len，于是与nex数组矛盾，故不成立；因此若k+len &lt; p，则extend[k+1] = len。</li></ul><p><img src="/2019/09/06/exkmp/1.png" alt="1"><br>(图1：当k+len&lt;p时情形，其中po = p’，图片来自 <em>dyx心心</em> 的博客)</p><ul><li>若k+len &gt;= p：<br>此时已知的是S[k+1 , p] = T[0 , p-k-1]，但是 S[p+1] 是否等同于 T[p-k] 尚且未知，因此需要向后遍历判断，同时更新p与p’。</li></ul><p><img src="/2019/09/06/exkmp/2.png" alt="2"><br>(图2：当k+len &gt;= p时情形，其中po = p’，图片来自 <em>dyx心心</em> 的博客)</p><p>对于nex数组，其求法和extend数组类似，详情参考代码中getNex()函数实现方法。</p><h4 id="例题模板"><a href="#例题模板" class="headerlink" title="例题模板"></a>例题模板</h4><p><a href="https://www.luogu.org/problem/P5410" target="_blank" rel="noopener">洛谷P5410拓展KMP模板</a><br><strong>题意简述：</strong><br>给定字符串S和T，输出next数组以及extend数组。</p><p><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> nex[N];<span class="comment">//nex[i] = T[i,n-1]与T[0,n-1]最长公共前缀 </span></span><br><span class="line"><span class="keyword">char</span> S[N],T[N]; <span class="comment">//S为目标串,T为模式串 </span></span><br><span class="line"><span class="keyword">int</span> extend[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算nex数组*/</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str) ,i = <span class="number">0</span>, j, p0 ;</span><br><span class="line">nex[<span class="number">0</span>] = len;</span><br><span class="line"><span class="keyword">while</span>(i+<span class="number">1</span> &lt; len &amp;&amp; str[i] == str[i+<span class="number">1</span>]) i++;</span><br><span class="line">nex[<span class="number">1</span>] = i; p0 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex[i-p0]+i &lt; nex[p0]+p0) nex[i] = nex[i-p0];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j = nex[p0]+p0-i;</span><br><span class="line"><span class="keyword">if</span>(j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i+j &lt; len &amp;&amp; str[j] == str[j+i]) j++;</span><br><span class="line">nex[i] = j; p0 = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exKMP</span><span class="params">(<span class="keyword">char</span>* str1,<span class="keyword">char</span> *str2)</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算str2与str1的所有后缀的最长公共前缀长度,存放在extend数组中*/</span> </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>,j,p0,l1 = <span class="built_in">strlen</span>(S), l2 = <span class="built_in">strlen</span>(T);</span><br><span class="line">getNex(str2);</span><br><span class="line"><span class="keyword">while</span>(i &lt; l1 &amp;&amp; i &lt; l2 &amp;&amp; str1[i] == str2[i]) i++;</span><br><span class="line">extend[<span class="number">0</span>] = i;p0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; l1;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex[i-p0]+i &lt; extend[p0]+p0) extend[i] = nex[i-p0];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">j = extend[p0]+p0-i;</span><br><span class="line"><span class="keyword">if</span>(j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i+j &lt; l1 &amp;&amp; j &lt; l2 &amp;&amp; str1[j+i] == str2[j]) j++;</span><br><span class="line">extend[i] = j; p0 = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算并输出答案*/</span></span><br><span class="line"><span class="keyword">int</span> l1 = <span class="built_in">strlen</span>(S), l2 = <span class="built_in">strlen</span>(T);</span><br><span class="line">exKMP(S,T);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; l2;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,nex[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; l1;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,extend[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,S,T);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://blog.csdn.net/dyx404514/article/details/41831947#commentBox" target="_blank" rel="noopener">dyx心心的博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;问题模型：&lt;/strong&gt;&lt;br&gt;给定字符串S和子串T，S的长度为n，T的长度为m；求字符串T与字符串S的每一个后缀d的最长公共前缀。&lt;/p&gt;
&lt;h4 id=&quot;拓展KMP算法&quot;&gt;&lt;a href=&quot;#拓展KMP算法&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="拓展KMP" scheme="http://valenshi.top/tags/%E6%8B%93%E5%B1%95KMP/"/>
    
  </entry>
  
  <entry>
    <title>hdu6638 Snowy Smile-线段树维护最大子矩阵</title>
    <link href="http://valenshi.top/2019/09/03/hdu6638-Snowy-Smile/"/>
    <id>http://valenshi.top/2019/09/03/hdu6638-Snowy-Smile/</id>
    <published>2019-09-03T12:53:13.000Z</published>
    <updated>2019-09-03T12:54:05.891Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6638" target="_blank" rel="noopener">题目链接</a></p><h4 id="Snowy-Smile"><a href="#Snowy-Smile" class="headerlink" title="Snowy Smile"></a>Snowy Smile</h4><p><strong>题意简述：</strong><br>给出平面上n(n &lt;= 2000)个点，点的坐标在-1e9~1e9之间，试求出最大子矩阵的和是多少。</p><p><strong>解题思路：</strong><br>考虑数据范围，2e3个点离散化后可能会有2e3个，本题中各个点是离散的，所以用普通的动态规划比较麻烦，因此本题采用$O(N^2log_2N)$的线段树+枚举。<br>我们对x，枚举所有可能的x[i]和x[j]其中x[i]为上界，x[j]为下界，这个枚举花费时间为$O(N^2)$，而对于每一种可能的组合，再利用线段树$O(log_2N)$求出最大连续子段和，因此总时间$O(N^2log_2N)$。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3010</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">int</span> tmp[N];<span class="comment">//离散化用</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Chest</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,val;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Chest &amp; B) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt; B.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;cs[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="comment">/*分别为区间和,区间最大子段和,</span></span><br><span class="line"><span class="comment">从左侧开始的最大子段和,从右侧开始的最大子段和*/</span></span><br><span class="line">ll sum,mx,lx,rx; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mx(x) tr[x].mx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lx(x) tr[x].lx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rx(x) tr[x].rx </span></span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*在区间[l,r]上建立一棵线段树*/</span></span><br><span class="line">sum(rt) = mx(rt) = lx(rt) = rx(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid);</span><br><span class="line">BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="comment">/*用于根据rt的子节点更新rt的4个数据*/</span></span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>)+sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">mx(rt) = max(rx(rt*<span class="number">2</span>)+lx(rt*<span class="number">2</span>+<span class="number">1</span>),max(mx(rt*<span class="number">2</span>),mx(rt*<span class="number">2</span>+<span class="number">1</span>)));</span><br><span class="line">lx(rt) = max(lx(rt*<span class="number">2</span>),sum(rt*<span class="number">2</span>)+lx(rt*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">rx(rt) = max(rx(rt*<span class="number">2</span>+<span class="number">1</span>),sum(rt*<span class="number">2</span>+<span class="number">1</span>)+rx(rt*<span class="number">2</span>));</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p,<span class="keyword">int</span> val,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将线段树p位置的值设为val;l,r是辅助作用哦*/</span></span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum(rt) += val;</span><br><span class="line">lx(rt) = rx(rt) = mx(rt) = sum(rt); </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= mid) Insert(rt*<span class="number">2</span>,p,val,l,mid);</span><br><span class="line"><span class="keyword">else</span> Insert(rt*<span class="number">2</span>+<span class="number">1</span>,p,val,mid+<span class="number">1</span>,r);</span><br><span class="line">spread(rt);<span class="comment">//在回溯时更新节点的值 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回当前最大连续子段和*/</span></span><br><span class="line"><span class="keyword">return</span>  tr[<span class="number">1</span>].mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">sort(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">int</span> cnt = unique(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+n)-tmp<span class="number">-1</span>;</span><br><span class="line">sort(cs+<span class="number">1</span>,cs+<span class="number">1</span>+n);</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*我们对每一个x[i]上限,枚举所有可能x[j]的下限,</span></span><br><span class="line"><span class="comment">并利用线段树求出x[i]~x[j]最大字段和*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(cs[i].x == cs[i<span class="number">-1</span>].x &amp;&amp; i != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,cnt);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(cs[j].x != cs[j<span class="number">-1</span>].x &amp;&amp; i != j) ans = max(ans,ask());</span><br><span class="line"><span class="keyword">int</span> y = lower_bound(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+cnt,cs[j].y)-tmp;</span><br><span class="line">Insert(<span class="number">1</span>,y,cs[j].val,<span class="number">1</span>,cnt);</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans,ask());<span class="comment">//如果全部相等,在此处特判 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;cs[i].x,&amp;cs[i].y,&amp;cs[i].val);</span><br><span class="line">tmp[i] = cs[i].y;</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6638&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;Snowy-Smile&quot;&gt;&lt;a href=&quot;#Snowy
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="线段树" scheme="http://valenshi.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="最大子矩阵" scheme="http://valenshi.top/tags/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>2019航电多校7部分题解</title>
    <link href="http://valenshi.top/2019/09/02/hdu7/"/>
    <id>http://valenshi.top/2019/09/02/hdu7/</id>
    <published>2019-09-02T13:54:31.000Z</published>
    <updated>2019-09-02T13:56:38.206Z</updated>
    
    <content type="html"><![CDATA[<h4 id="A-A-B-C"><a href="#A-A-B-C" class="headerlink" title="A. A + B = C"></a>A. <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6646" target="_blank" rel="noopener">A + B = C</a></h4><p>有空再写，麻烦死了。</p><h4 id="F-Final-Exam"><a href="#F-Final-Exam" class="headerlink" title="F. Final Exam"></a>F. <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6651" target="_blank" rel="noopener">Final Exam</a></h4><p><strong>题意简述</strong><br>题意有点绕，一份考试总分为m分n道题，每道题可能为 n 类科目中的一类。如果我们想做出一道分值为 a 的题，那么我们至少要复习该题所在的科目 a+1 分钟以上。请问如果我们要想最少做出k题，需要花多长时间？</p><p><strong>解题思路:</strong><br>首先搞清题意，就是我们目标是最少做出k题需要花费的最少时间，那么最坏情况就是老师针对我们，出我们复习时间最少的n - k + 1道题，令每道题都等于该学生复习的时间（因为总分确定，这样才最优）。那么如果我想通过，那就要令自己复习时间最少的n-k+1门科目复习总时间 &gt; m，这样老师就无论如何也针对不了我了。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">ll n,m,k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = n-k+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = m/tmp + <span class="number">1</span>;</span><br><span class="line">ll ans = (k<span class="number">-1</span>)*b + m+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="K-Kejin-Player"><a href="#K-Kejin-Player" class="headerlink" title="K. Kejin Player"></a>K. <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6656" target="_blank" rel="noopener">Kejin Player</a></h4><p><strong>题意简述：</strong><br>满级为n+1级，从第 i 级升到 i+1 级需要a[i]金币，成功几率为r[i] / s[i] ，如果成功则等级从i变为i+1，失败则等级从 i 变为 x[i] （x[i] &lt;= i）。<br>请问从l升到r级，需要多少金币？<br><strong>解题思路：</strong><br>这是一道概率dp题，且概率可以加减，设f[ x ] 为从1级升到x级需要的金币，那么从l级升到r级需要f[r] - f[l]金币。这是因为升到某一级需要的金币数是固定的，所以满足加减原则。<br>加速我们当前在 i 级，有 p 的概率花费a[i]金币升到 i+1 级，假设我们尝试了t次才升级成功，即： </p><script type="math/tex; mode=display">f[i+1] = f[i] + a[i]  + (t - 1) * a[i] + (t - 1) * (f[ i ] - f[ x[i] ])</script><p>又因为$\frac{t-1}{t} = p$，得$t = \frac{s[i]}{r[i]}$，带入得：</p><script type="math/tex; mode=display">f[i+1] = f[i] +  \frac{s[i]}{r[i]} * a[i] + (\frac{s[i]}{r[i]} - 1) * (f[ i ] - f[ x[i] ])</script><p>遇到这种概率题，设试了t次才成功，然后用概率表示 t 即可得出递推公式。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll r[N],s[N],x[N],a[N];<span class="comment">//p = r/s</span></span><br><span class="line"><span class="keyword">int</span> t,n,q;</span><br><span class="line"><span class="keyword">const</span> ll P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll f[N];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b,ll m)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = res*a%m;</span><br><span class="line">a = a*a%m;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*预处理出所有答案*/</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ll pp = s[i]*qpow(r[i],P<span class="number">-2</span>,P)%P; <span class="comment">//s[i]/r[i]的逆元 </span></span><br><span class="line">f[i+<span class="number">1</span>] = (f[i] + pp*a[i]%P </span><br><span class="line">+ (pp<span class="number">-1</span>)*(f[i]-f[x[i]])%P+P)%P;</span><br><span class="line"><span class="comment">//printf("%lld\n",f[i+1]);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>,r+i,s+i,x+i,a+i);</span><br><span class="line">solve();<span class="comment">//离线 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,tl,tr;i &lt;= q;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;tl,&amp;tr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(f[tr]-f[tl]+P)%P);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;A-A-B-C&quot;&gt;&lt;a href=&quot;#A-A-B-C&quot; class=&quot;headerlink&quot; title=&quot;A. A + B = C&quot;&gt;&lt;/a&gt;A. &lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6646&quot; 
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="博弈论" scheme="http://valenshi.top/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
      <category term="概率dp" scheme="http://valenshi.top/tags/%E6%A6%82%E7%8E%87dp/"/>
    
  </entry>
  
  <entry>
    <title>拓展欧拉定理+幂塔函数</title>
    <link href="http://valenshi.top/2019/09/02/exphi/"/>
    <id>http://valenshi.top/2019/09/02/exphi/</id>
    <published>2019-09-02T02:19:14.000Z</published>
    <updated>2019-09-02T02:21:24.215Z</updated>
    
    <content type="html"><![CDATA[<h4 id="拓展欧拉定理与幂塔函数"><a href="#拓展欧拉定理与幂塔函数" class="headerlink" title="拓展欧拉定理与幂塔函数"></a>拓展欧拉定理与幂塔函数</h4><p><strong>欧拉定理：</strong> 若gcd(a,p) = 1，则 $a^p \equiv a^{b \% \varphi (p)}(mod \: p)$，其中gcd(a,p) = 1。<br><strong>拓展欧拉定理：</strong> 假设a为任意数，b和m为正整数，且$b &gt; \varphi(m)$，a和m不一定要互质，那么有如下公式：</p><script type="math/tex; mode=display">a^b~\equiv~\begin{cases}a^{b~Mod~\phi(m)} &\gcd(a,m)~=~1 \\a^b &\gcd(a,m)~\neq~1~\land~b~<~\phi(m) \\ a^{b~Mod~\phi(m)~+~\phi(m)} &\gcd(a,m)~\neq~1~\land~b~\geq~\phi(m)\end{cases} \:\:(Mod\: m)</script><p><em>注：拓展欧拉定理的证明可以参考<a href="https://zhuanlan.zhihu.com/p/24902174" target="_blank" rel="noopener">证明</a></em></p><p><strong>幂塔函数</strong>： 形如</p><script type="math/tex; mode=display">a^{a^{a^{...}}} mod \: m</script><p>的函数我们称为幂塔函数，该函数应从上向下计算，即$a^{a^{a^a}} = a^{(a^{({a^a})})}$，因此其中间变量会急剧上升，普通方法无法计算。</p><h4 id="例题：2019南京icpc网络赛-B-Super-Log"><a href="#例题：2019南京icpc网络赛-B-Super-Log" class="headerlink" title="例题：2019南京icpc网络赛 B.Super_Log"></a>例题：2019南京icpc网络赛 B.Super_Log</h4><p><a href="https://nanti.jisuanke.com/t/41299" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定a和k以及m，试求出</p><script type="math/tex; mode=display">a^{a^{a^{...}}} mod \: m</script><p>其中共k层幂塔。其中a，k和m小于等于1e6。<br><strong>解题思路：</strong><br>首先使用拓展欧拉定理需要 $b &gt; \varphi(m)$，所以对于不同的b要分类讨论一下。设</p><script type="math/tex; mode=display">f(a,k,m) = a^{a^{a^{...}}} \% m</script><p>其中a是有k层的幂塔。</p><ol><li>首先，当a = 1或者b = 0时特判，得出答案为 1%m。</li><li>本题中b = f(a, k-1,INF)，如果a &gt;= phi(m)，那么显然b一定大于phi(m)，即满足拓展欧拉定理中第3种情况；</li><li>如果k = 1，则b = f(a,k-1,INF) = 1，此时只需判断phi(m)是否大于1即可判断当然情况符合拓展欧拉定理第3还是第2种情况。</li><li>剩下的情况我们就可以通过递归来判断b是否大于phi(m)，因为若b &gt;= phi(m)，那么$log_ab &gt;= log_a phi(m)$</li></ol><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b,ll m)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = res*a%m;</span><br><span class="line">a = a*a%m;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> v[N],primes[N],phi[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i])&#123;</span><br><span class="line">primes[cnt++] = i;</span><br><span class="line">v[i] = i;</span><br><span class="line">phi[i] = i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cnt;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(primes[j] &gt; v[i] || primes[j]*i &gt;= N)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">v[i*primes[j]] = primes[j];</span><br><span class="line">phi[i*primes[j]] = phi[i]*(i%primes[j] ? primes[j]<span class="number">-1</span> : primes[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll a,ll b,ll p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> p &lt;= <span class="number">1</span>;<span class="comment">//f(a,0,p) = 1</span></span><br><span class="line"><span class="keyword">if</span>(a &gt;= p) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//f(a,b,INF) &gt; p</span></span><br><span class="line"><span class="keyword">return</span> check(a,b<span class="number">-1</span>,<span class="built_in">log</span>(p)/<span class="built_in">log</span>(a)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll a,ll b,ll m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(m == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//递归终止条件1,此时之后答案恒为0 </span></span><br><span class="line"><span class="keyword">if</span>(b &lt;= <span class="number">1</span>) <span class="keyword">return</span> qpow(a,b,m);<span class="comment">//递归终止条件2 </span></span><br><span class="line">ll ph = phi[m];</span><br><span class="line"><span class="comment">//printf("%lld\n",ph);</span></span><br><span class="line"><span class="keyword">if</span>(gcd(a,m) == <span class="number">1</span>) <span class="keyword">return</span> qpow(a,f(a,b<span class="number">-1</span>,ph),m);<span class="comment">//欧拉定理 </span></span><br><span class="line"><span class="keyword">if</span>(check(a,b<span class="number">-1</span>,ph)) <span class="keyword">return</span> qpow(a,f(a,b<span class="number">-1</span>,ph)+ph,m);<span class="comment">//拓展欧拉定理情况1 </span></span><br><span class="line"><span class="keyword">return</span> qpow(a,f(a,b<span class="number">-1</span>,ph),m); <span class="comment">//拓展欧拉定理情况2 </span></span><br><span class="line">&#125;</span><br><span class="line">ll a,b,m;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f(a,b,m));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.cnblogs.com/SovietPower/p/8353374.html" target="_blank" rel="noopener">SovietPower的博客</a></li><li>《算法竞赛进阶指南》,李煜东,P142-143.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;拓展欧拉定理与幂塔函数&quot;&gt;&lt;a href=&quot;#拓展欧拉定理与幂塔函数&quot; class=&quot;headerlink&quot; title=&quot;拓展欧拉定理与幂塔函数&quot;&gt;&lt;/a&gt;拓展欧拉定理与幂塔函数&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;欧拉定理：&lt;/strong&gt; 若gcd(a,p) =
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数论" scheme="http://valenshi.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="幂塔函数" scheme="http://valenshi.top/tags/%E5%B9%82%E5%A1%94%E5%87%BD%E6%95%B0/"/>
    
      <category term="拓展欧拉定理" scheme="http://valenshi.top/tags/%E6%8B%93%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>2018南京icpc网络赛</title>
    <link href="http://valenshi.top/2019/08/30/2018nanjing/"/>
    <id>http://valenshi.top/2019/08/30/2018nanjing/</id>
    <published>2019-08-30T14:53:57.000Z</published>
    <updated>2019-08-30T14:54:56.784Z</updated>
    
    <content type="html"><![CDATA[<p>有嗲难，还有些卡时，思路还有些难想，虽然都是经典模型。</p><h4 id="A-An-Olympian-Math-Problem"><a href="#A-An-Olympian-Math-Problem" class="headerlink" title="A. An Olympian Math Problem"></a>A. An Olympian Math Problem</h4><p><a href="https://nanti.jisuanke.com/t/A1947" target="_blank" rel="noopener">原题链接</a><br><strong>解题思路：</strong><br>如果是比赛时我估计会推公式，但在这通过率面前，我猜了个公式就交了，然后过了。答案就是n-1。</p><h4 id="E-AC-Challenge"><a href="#E-AC-Challenge" class="headerlink" title="E. AC Challenge"></a>E. AC Challenge</h4><p><a href="https://nanti.jisuanke.com/t/A1951" target="_blank" rel="noopener">原题链接</a><br><strong>解题思路：</strong><br>状压dp，这类题做的很少，没忘这方面想。开始用的拓扑排序，但是很明显没有考虑到所有情况。用状压的话，就这题而言，是需要先判断当前状态是否合法，判断完之后再更新答案数组dp，最终答案是dp[(1&lt;<n+1)-2]，这与我代码设计有关，因为我是设右边第2位（也就是左移1）为第一题，而我们更新答案时是将所有“未做但是能做的题”更新成“已做该题”，那么最终答案显然就是1111...1共n个1，由于最低位没用，就是111...10即n个1和1个0，所以答案状态是(1<<n+1)-2。 以后n小于20要往状压dp上想。上述介绍请结合代码以及注释看。 **代码示例：** 以后这个状态最好不要用 i 表示，看起来太乱了。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N],s[N],p[N][N];</span><br><span class="line">ll dp[<span class="number">1</span>&lt;&lt;<span class="number">23</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= (<span class="number">1</span>&lt;&lt;n+<span class="number">1</span>);i++)&#123;</span><br><span class="line"><span class="comment">/*先判断是否该状态合法,若合法则计算其值*/</span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>((<span class="number">1</span>&amp;(i&gt;&gt;j)) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= s[j];k++)</span><br><span class="line"><span class="keyword">if</span>((<span class="number">1</span>&amp;(i&gt;&gt;p[j][k])) == <span class="number">0</span>)&#123;</span><br><span class="line">flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(!flag) <span class="keyword">break</span>; <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!(i&gt;&gt;j&amp;<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">ll t = <span class="number">0</span>,s = i;</span><br><span class="line"><span class="keyword">while</span>(s)&#123;</span><br><span class="line"><span class="keyword">if</span>(s&amp;<span class="number">1</span>) t++; s &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">dp[i] = max(dp[i],dp[i^(<span class="number">1</span>&lt;&lt;j)]+t*a[j]+b[j]);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dp[(<span class="number">1</span>&lt;&lt;n+<span class="number">1</span>)<span class="number">-2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,a+i,b+i,s+i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= s[i];j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></n+1)-2]，这与我代码设计有关，因为我是设右边第2位（也就是左移1）为第一题，而我们更新答案时是将所有“未做但是能做的题”更新成“已做该题”，那么最终答案显然就是1111...1共n个1，由于最低位没用，就是111...10即n个1和1个0，所以答案状态是(1<<n+1)-2。></p><h4 id="J-Sum"><a href="#J-Sum" class="headerlink" title="J. Sum"></a>J. Sum</h4><p><a href="https://nanti.jisuanke.com/t/A1956" target="_blank" rel="noopener">原题链接</a><br><strong>解题思路：</strong><br>我想了一个O(9N)的算法，但是超时了，本机大概1.6-2.5s，很难受；是采用唯一分解定理判断每一个数可以分解为多少个“数对”相乘。然后改用线性筛，思想当然没变，但是利用线性筛的O(N)常数较小，本机0.7~1.1s，通过率大概1/4。<br>然后是朋友提供的解法思路，主要是统计“平方对”，不单独统计每个数对s的贡献，而是直接计算s，也是O(N)，但是更快，稳过。<br><strong>代码示例1：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll f[N],s[N];<span class="comment">//f数组表示单个元素结果,表示所求答案 </span></span><br><span class="line"><span class="keyword">int</span> v[N],primes[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*利用线性筛预处理f数组与s数组*/</span> </span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">primes[++cnt] = i;</span><br><span class="line">v[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= cnt;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(primes[j] &gt; v[i] || primes[j]*i &gt; N) <span class="keyword">break</span>;</span><br><span class="line">v[i*primes[j]] = primes[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">s[<span class="number">1</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//f[1]也要初始化 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(v[i] == i) f[i] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = i,k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x%v[i] == <span class="number">0</span>)&#123;</span><br><span class="line">x /= v[i];k++;</span><br><span class="line"><span class="keyword">if</span>(k &gt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k &gt; <span class="number">2</span>) f[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">2</span>) f[i] = f[x];<span class="comment">//dp思想 </span></span><br><span class="line"><span class="keyword">else</span> f[i] = f[x]*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">s[i] = s[i<span class="number">-1</span>]+f[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*会卡常,有时过有时不过,真正比赛还需要稍微优化,大概1/4过*/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">solve();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,s[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>代码示例2：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 20000070</span></span><br><span class="line"><span class="keyword">int</span> square[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXN;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        square[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;MAXN;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> k=i*i;</span><br><span class="line">        <span class="keyword">if</span>(!square[k]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=k;j&lt;MAXN;j+=k)</span><br><span class="line">        &#123;</span><br><span class="line">            square[j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;MAXN;i++)</span><br><span class="line">        cnt[i]=cnt[i<span class="number">-1</span>]+square[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!square[i])<span class="keyword">continue</span>;</span><br><span class="line">            sum+=(cnt[n/i]-cnt[i])*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="L-Magical-Girl-Haze"><a href="#L-Magical-Girl-Haze" class="headerlink" title="L. Magical Girl Haze"></a>L. Magical Girl Haze</h4><p><a href="https://nanti.jisuanke.com/t/A1958" target="_blank" rel="noopener">原题链接</a><br><strong>解题思路：</strong><br>先把图分层，再进行Dijkstra算法，做过好几遍了，但还是超时很多法，空间大小没计算好，以后一定要注意。<br><strong>代码示例:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">6e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[N],nex[M],ver[M],tot;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">edge[++tot] = z; ver[tot] = y;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t,n,k,m;</span><br><span class="line">ll d[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line">priority_queue&lt;pair&lt;ll,ll&gt; &gt; q;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1l</span>l&lt;&lt;<span class="number">60</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">q.push(make_pair(<span class="number">0</span>,s));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= (k+<span class="number">1</span>)*n;i++) d[i] = INF;</span><br><span class="line">d[s] = <span class="number">0</span>;<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.top().second; q.pop();</span><br><span class="line"><span class="keyword">if</span>(vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">vis[x] = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(d[y] &gt; d[x]+z)&#123;</span><br><span class="line">d[y] = d[x]+z;</span><br><span class="line"><span class="keyword">if</span>(!vis[y]) q.push(make_pair(-d[y],y));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">dijkstra(<span class="number">1</span>);ll ans = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k+<span class="number">1</span>;i++) ans = min(ans,d[i*n]);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k); </span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head); tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= k;j++) addEdge(x+n*j,y+n*j,z);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= k;j++) addEdge(x+n*(j<span class="number">-1</span>),y+n*j,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有嗲难，还有些卡时，思路还有些难想，虽然都是经典模型。&lt;/p&gt;
&lt;h4 id=&quot;A-An-Olympian-Math-Problem&quot;&gt;&lt;a href=&quot;#A-An-Olympian-Math-Problem&quot; class=&quot;headerlink&quot; title=&quot;A. An
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="状压dp" scheme="http://valenshi.top/tags/%E7%8A%B6%E5%8E%8Bdp/"/>
    
      <category term="线性筛" scheme="http://valenshi.top/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
    
      <category term="最短路" scheme="http://valenshi.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>2019航电暑期多校10部分题解</title>
    <link href="http://valenshi.top/2019/08/30/hdu10/"/>
    <id>http://valenshi.top/2019/08/30/hdu10/</id>
    <published>2019-08-30T05:08:50.000Z</published>
    <updated>2019-08-30T15:03:09.105Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1005-Welcome-Party"><a href="#1005-Welcome-Party" class="headerlink" title="1005 Welcome Party"></a>1005 Welcome Party</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6695" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>一共有n名同学，每位同学都会唱歌和跳舞，第 i 位同学的唱歌和跳舞的能力值分别为$x_i,y_i$，现在将这些同学分为唱歌队和跳舞队，每队的价值等于该队中该能力值最高的同学的能力值，请问两队价值差最小是多少呢？</p><p><strong>解题思路：</strong><br>这题其实不算太难，但是思路容易乱。首先由于每队的价值等于该队中最高的能力值，所以可以从高到低枚举每一位同学的x，并更新ans；对当前枚举到的x，我们在所有其他同学中找到最接近 x 的 y （即abs(x-y)最小），这个y必须是 <strong>比所有被枚举过的同学的y要大。</strong> 否则该同学就不是跳舞队中最大能力值（因为被枚举过的同学一定去跳舞了），该y就不能更新答案了。<br>当然细节在于如何找寻最接近x的y。</p><p><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">pair&lt;ll,ll&gt; a[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="built_in">multiset</span>&lt;ll&gt; s2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">s2.clear();</span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n); ll ans = <span class="number">1l</span>l&lt;&lt;<span class="number">60</span>, mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) s2.insert(a[i].y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line"><span class="comment">//先把当前同学的y删掉,防止选到同一位同学 </span></span><br><span class="line">s2.erase(s2.find(a[i].y)); </span><br><span class="line"><span class="comment">//要么比mx大的值更新ans,要么就mx更新ans </span></span><br><span class="line"><span class="keyword">if</span>(mx) ans = min(ans,<span class="built_in">abs</span>(mx-a[i].x));</span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;ll&gt;::iterator it = s2.lower_bound(a[i].x);</span><br><span class="line"><span class="keyword">if</span>(it == s2.end()) it--;</span><br><span class="line"><span class="keyword">if</span>(*it &gt;= mx) ans = min(ans,<span class="built_in">abs</span>(*it-a[i].x));</span><br><span class="line"><span class="keyword">if</span>(it != s2.begin()) it--;</span><br><span class="line"><span class="keyword">if</span>(*it &gt;= mx) ans = min(ans,<span class="built_in">abs</span>(*it-a[i].x));</span><br><span class="line">mx = max(mx,a[i].y);</span><br><span class="line"><span class="comment">//printf("%lld %lld %lld %lld %lld\n",mx,a[i].x,a[i].y,*it,ans);</span></span><br><span class="line"></span><br><span class="line">s2.insert(a[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1011-Make-Rounddog-Happy"><a href="#1011-Make-Rounddog-Happy" class="headerlink" title="1011 Make Rounddog Happy"></a>1011 Make Rounddog Happy</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6701" target="_blank" rel="noopener">测试地址</a></p><p><strong>题意简述：</strong><br>给出一个包含n个元素的序列a，其中 $1 &lt;= a_i &lt;= n$，友好子串的定义如下：</p><ul><li>[l , r]位置上的所有元素各不相同。</li><li>$Max(a_l, a_{l+1} , … , a_r) - (r - l + 1) &lt;= k$。</li></ul><p>给出一个序列，请问该序列中有多少友好子串。</p><p><strong>解题思路：</strong><br>这题是启发式分治，所谓启发式算法主要是指基于直观或经验而构造的算法，它不一定是最优的，但一定是可行的，并且时间要在可接受范围内。现阶段的启发式算法主要以仿自然算法（模拟）为主。<br>假设一个区间[l,r]内最大的元素下标为p，那么对于a[p]，在[l,r]内有多少个子区间包含p，且满足a[p] - k &lt;= r-l+1，这是子问题。我们可以将该问题分为[l , p]与[p , r]来看，我们对于这两个区间任选其一统计即可，于是我们可以选元素较少的那一个区间，这样元素最多不超过(r-l+1)/2。<br>假设左区间 [l  , p] 元素较少，我们在本次统计中（对[l , r]上以a[p]为最大值的子区间个数）对于每个位置 i （i 属于[l , p]）来计算以 i 为左端点，有多少个子区间满足要求；而满足要求的子区间个数等于tr-tl+1，因为[tl , tr]中任意一个位置都可以作为右端点，因为其满足a[p] - k &lt;= R-L（R为[tl ,tr]内一点，L为 i ）。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> a[N],st[N][<span class="number">25</span>],Log[N]; </span><br><span class="line"><span class="keyword">int</span> t,n,k;</span><br><span class="line"><span class="keyword">int</span> L[N],R[N];<span class="comment">//记录每个位置左右最远 不重复 且比其小的数的数量 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*初始化st表*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)) &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> t1 = st[i][j<span class="number">-1</span>],t2 = st[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>];</span><br><span class="line">st[i][j] = a[t1] &lt; a[t2]?t2:t1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回[l,r]内最大的数的下标*/</span> </span><br><span class="line"><span class="keyword">int</span> kk = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> t1 = st[l][kk], t2 = st[r-(<span class="number">1</span>&lt;&lt;kk)+<span class="number">1</span>][kk];</span><br><span class="line"><span class="keyword">return</span> a[t1] &lt; a[t2]?t2:t1;</span><br><span class="line">&#125; </span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*递归统计答案*/</span></span><br><span class="line"><span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> p = ask(l,r); <span class="keyword">int</span> tt = a[p]-k;</span><br><span class="line"><span class="keyword">if</span>(p-l &lt; r-p)&#123;<span class="comment">//左边点更少 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt;= p;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> tr = min(R[i],r), tl = max(p,i+tt<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(tl &gt; tr) <span class="keyword">continue</span>;</span><br><span class="line">ans += tr-tl+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = r;i &gt;= p;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> tl = max(l,L[i]), tr = min(i-tt+<span class="number">1</span>,p);</span><br><span class="line"><span class="keyword">if</span>(tl &gt; tr) <span class="keyword">continue</span>;</span><br><span class="line">ans += tr-tl+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cal(l,p<span class="number">-1</span>);</span><br><span class="line">cal(p+<span class="number">1</span>,r);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> vis[N];<span class="comment">//记录i最后一次出现的位置 </span></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回答案*/</span></span><br><span class="line">init(); ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="comment">/*以下代码用于更新L与R数组,通过简单的尺取法思想*/</span> </span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[a[i]]) pre = max(pre,vis[a[i]]+<span class="number">1</span>);</span><br><span class="line">L[i] = pre; vis[a[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line">pre = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) vis[i] = n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[a[i]] != n+<span class="number">1</span>) pre = min(vis[a[i]]<span class="number">-1</span>,pre);</span><br><span class="line">R[i] = pre; vis[a[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line">cal(<span class="number">1</span>,n);<span class="comment">//递归分治计算 </span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1005-Welcome-Party&quot;&gt;&lt;a href=&quot;#1005-Welcome-Party&quot; class=&quot;headerlink&quot; title=&quot;1005 Welcome Party&quot;&gt;&lt;/a&gt;1005 Welcome Party&lt;/h4&gt;&lt;p&gt;&lt;a hre
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="思维" scheme="http://valenshi.top/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="启发式分治" scheme="http://valenshi.top/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>可持久化线段树（主席树）</title>
    <link href="http://valenshi.top/2019/08/28/dynamic-zx/"/>
    <id>http://valenshi.top/2019/08/28/dynamic-zx/</id>
    <published>2019-08-28T12:45:37.000Z</published>
    <updated>2019-08-29T01:55:49.636Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>主席树，又称可持久化线段树，属于可持久化数据结构。“主席”这一名词是由于发明者缩写为HJT，和某位主席拼音缩写相同（有些牵强），故将该数据结构称为主席树。<br>主席树既保留了线段树的灵活，也拥有了可持久化数据结构的特点，在处理某些特定问题时有着其它数据结构不具有的优势。<br>本文将首先介绍什么是“可持久化数据结构”，随后介绍主席树的思想，关于代码实现将结合例题讲解。</p><h4 id="可持久化数据结构"><a href="#可持久化数据结构" class="headerlink" title="可持久化数据结构"></a>可持久化数据结构</h4><p>可持久数据结构主要指的是我们可以查询历史版本的情况并支持插入，利用使用之前历史版本的数据结构来减少对空间的消耗（能够对历史进行修改的是函数式编程 [1]）。</p><p>我们经常会遇到这样的问题：我们需要维护一个数据结构，我们可以修改单一结点的值，查询单一结点的值，但是最关键的是我们可能还需要回退之前做过的某些操作。这里回退是指回到未做这些操作之前的状态。</p><p>在无回退操作的情况下，我们有大把的数据结构可供选择来解决这些问题。但是一旦涉及到回退操作，选择就少的多了。我们将支持回退操作的数据结构称为可持久化数据结构。</p><p>稍微思考一下如何可以在原来数据结构的基础上使其变得可持久化，有一个很简单的方案。我们每次操作都将重新建立一个新的数据结构，并将之前的操作都先在其上执行一次，之后执行该次操作。我们按操作执行顺序将这些数据结构维护成一个序列S，此时S[0]表示未经任何操作的初始数据结构。对于i&gt;0，S[i]表示在S[0]的基础上执行过序号1到i的所有操作后得到的新的数据结构。在这样的做法下，我们称S[i]为版本i，回退操作等价于切换到某个特定版本。若操作i表示切换为版本j，那么我们可以直接将S[i]设置为S[j]的克隆。</p><p>上面提到的做法下很容易发现可以使得任意数据结构都可以支持回退操作，但是缺点也是非常明显，空间和时间的复杂度都奇高。每一次操作都需要累加之前操作的时间复杂度，空间也是，我们为了保存各个版本需要耗费大量的内存。</p><p>先说明时间复杂度的优化，对于i号操作，我们完全可以直接克隆版本S[i-1]并在其上执行i号操作，这样时间复杂度基本上就向空间复杂度看齐了。下面我们就可以专注于空间复杂度的优化（对应的也就是时间复杂度的优化）。</p><p>数据结构是用于保存数据的，我们将其保存数据的单元称为结点，我们可以利用结点来刻画整个数据结构的骨架。数据结构基本分为两类，一类是稳定的，一类是不稳定的。稳定的数据结构，其特定是在修改的结点的值之后不会改变结点之间的关系，而不稳定的数据结构在结点值变更后需要重新维护结点之间的关联。稳定的数据结构有线段树，后缀数组，前缀树等等，不稳定的数据结构主要就是各种二叉平衡树。对于稳定的树状结构，若孩子没有保存指向父结点的指针，即由父亲负责记录所有的孩子，我们很容易发现，当我们对某个结点更改时（修改值，新增，删除等操作），我们只需要同时修改该结点的所有祖先结点即可，那我们是不是也可以只克隆这些结点而非整个数据结构呢？答案是肯定的。由于父亲维护孩子，因此一个孩子允许有多个父亲，故所有没有被直接影响的结点都可以继续复用。我们将部分树状数据结构（特定是稳定和父亲维护父子关系）的一次操作的空间复杂度优化到了O(h)，其中h是树状数据结构的高度。</p><p>当我们将上面的想法作用到线段树时，就得到了常说的主席树。其高度为$O(log_2(n))$，其中n为线段树维护的区间大小，同时其时间和空间复杂度均为$O(log_2(n)^2)$。</p><p><em>引用自：<a href="https://www.cnblogs.com/dalt/p/8324781.html" target="_blank" rel="noopener">陶无语的博客</a></em></p><h4 id="静态主席树"><a href="#静态主席树" class="headerlink" title="静态主席树"></a>静态主席树</h4><p>我们按照“是否支持修改”来将主席树划分为静态和动态。静态主席树一旦建树成功，就不再支持修改，只能够用于查询。静态主席树维护元素出现次数的前缀和。</p><blockquote><p>例题：洛谷P3834，查询区间第k大值<br>给定n个元素，共m个询问，每次询问给出[l ,r]和k，回答区间[l , r]内第k大元素值是多少。</p></blockquote><h5 id="建树："><a href="#建树：" class="headerlink" title="建树："></a>建树：</h5><p>考虑用主席树解决上述问题，给出如下建树步骤：</p><ol><li>新建一棵完整的空树，其根节点编号存放在root[0]内。</li><li>依次将n个元素插入到“版本0”的空树中，他们的“版本号”（根节点）存放在root[i]中。</li></ol><p>对于每一个“新版本”，我们都在原来基础上新增“需要修改的节点”，并将其根节点记录在root数组中。<br>如此我们的时空花费都与修改的路径成正比，即每次$O(log_2N)$。</p><p>当然这些都是从理论思想上来讲的，比较抽象；具体到这一题，我们令线段树维护区间内元素数量，每个节点有三个变量，分别是 ls , rs , sum，即左儿子编号，右儿子编号，区间内元素个数。<br>初始时sum都为0，随后将n个元素依次插入形成n棵新的线段树，而这n+1棵（包括编号为0的空树）构成了一棵静态主席树。<br>所以建树操作其实分为两步：BuildTree()建立一棵空树并返回根节点编号；updata()在原树基础上“增加一棵新树”，并返回该版本的根节点编号。</p><p>虽然不同历史版本的线段树节点之间有交叉以重复利用，但每个历史版本都有唯一且独立的根节点</p><h5 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h5><p>由于线段树维护的是区间内元素的数量，所以不同版本的线段树的对应节点是可以加减的，那么root[i] - root[j]意义就是“第 i 个版本的线段树比第 j 个版本的线段树多几个元素”。如果我们再加上区间范围限制[l , r]，那么我们也可以查询“第 i 个版本比第 j 个版本，在[l , r]上多几个元素”。</p><p>具体到本题，我们需要查询区间[l , r]内第k大的元素，已知线段树可以加减，那么对于询问(l , r , k)，我们就需要在root[l-1] 与 root[r]两棵线段树上找寻答案，不要忘记了这颗线段树是根据权值建立的，也就是所谓的权值线段树。那么在res个数中找第k个，显然二分（树上），参见代码。</p><h5 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h5><p>见附录部分code-1：洛谷P3834静态主席树模板-求区间第k大值</p><h4 id="动态主席树"><a href="#动态主席树" class="headerlink" title="动态主席树"></a>动态主席树</h4><p>静态主席树虽然支持历史查询，但其功能还是不太强大，因为其不支持更改。我们将支持修改的主席树称为动态主席树，但是这个功能添加起来并不容易。静态主席树还可以看作是线段树通过小修改得到，而动态主席树则是树套树。</p><p>思想依旧是维护元素出现次数的前缀和，可以类比差分数组，我们都知道前缀和数组是不支持修改的，如果要修改，就需要用 树状数组/线段树 来维护，这里也是类似。</p><p>我们考虑“外层用树状数组，内层用记录区间内数值出现次数的线段树”来实现支持修改的可持久化线段树，也即动态主席树。</p><p>在静态主席树上，可以通过两个权值线段树相减来求得区间第k大值，在这里我们仍旧是通过这种方法求区间第k大，不同的是我们需要保证所有线段树的数据是正确的（维护修改）。<br>如果我们用树状数组来维护不同版本的权值线段树的编号，那么对于“将位置 p 的 x 修改为 y”这一操作，我们需要修改共logN个版本的权值线段树，如此修改操作的时间复杂度是$O((log_2N)^2)$。<br>值得注意的是，此时空间复杂度 = 树状数组空间 * 权值线段树空间 = $N^2$，但是树状数组实际上只保存权值线段树的“版本号”而已，因此实际上用到的空间也就只有权值线段树上的$O(N(log_2N)^2)$个节点的空间，因此动态开点即可。</p><h5 id="例题2：洛谷P2617"><a href="#例题2：洛谷P2617" class="headerlink" title="例题2：洛谷P2617"></a>例题2：洛谷P2617</h5><p><strong>代码模板：</strong> 见附录部分code-2</p><h4 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h4><p>[1] 函数式编程：“函数式编程”是一种“编程范式”(programming paradigm)，也就是如何编写程序的方法论。它属于“结构化编程”的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。</p><p><em>引用自：<a href="https://www.cnblogs.com/aezero/p/4979890.html" target="_blank" rel="noopener">aezero的博客</a></em></p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p><strong>code-1：洛谷P3834静态主席树模板-求区间第k大值</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zxTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls,rs,sum;<span class="comment">//左右儿子,区间内元素个数</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(x) tr[x].ls</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(x) tr[x].rs</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[x].sum</span></span><br><span class="line">&#125; tr[N*<span class="number">40</span>];<span class="comment">//注意数组大小</span></span><br><span class="line"><span class="keyword">int</span> sz = <span class="number">0</span>;<span class="comment">//不同版本的树的总数 </span></span><br><span class="line"><span class="keyword">int</span> root[N];<span class="comment">//root[i]存放第i棵树的树根的编号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*建树,和普通线段树相同*/</span></span><br><span class="line">    <span class="keyword">int</span> rt = ++sz;sum(rt) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> rt;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ls(rt) = BuildTree(l,mid);</span><br><span class="line">    rs(rt) = BuildTree(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> pre,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*新建一棵树,其比pre树多一个元素x*/</span></span><br><span class="line">    <span class="keyword">int</span> rt = ++sz;</span><br><span class="line">    tr[rt] = tr[pre]; sum(rt)++;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> rt;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) ls(rt) = updata(ls(pre),l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> rs(rt) = updata(rs(pre),mid+<span class="number">1</span>,r,x);</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> pre,<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*  依次是:上一个树根,当前树根,区间左右端点,所求区间第k大</span></span><br><span class="line"><span class="comment">        返回该区间第k大数的下标 */</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> res = sum(ls(rt)) - sum(ls(pre));</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(res &gt;= k) <span class="keyword">return</span> ask(ls(pre),ls(rt),l,mid,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ask(rs(pre),rs(rt),mid+<span class="number">1</span>,r,k-res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i),tmp[i] = a[i];</span><br><span class="line">    <span class="comment">//离散化</span></span><br><span class="line">    sort(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">int</span> tot = unique(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+n)-tmp<span class="number">-1</span>;</span><br><span class="line">    root[<span class="number">0</span>] = BuildTree(<span class="number">1</span>,tot);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot,a[i])-tmp;</span><br><span class="line">        root[i] = updata(root[i<span class="number">-1</span>],<span class="number">1</span>,tot,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用主席树可以加减原理计算</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,l,r,k;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;k);</span><br><span class="line">        <span class="keyword">int</span> x = ask(root[l<span class="number">-1</span>],root[r],<span class="number">1</span>,tot,k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tmp[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>code2-洛谷P2617动态主席树</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="comment">/*线段树节点,要存放左右儿子编号,区间内元素个数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls,rs,sum;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(x) tr[x].ls</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(x) tr[x].rs</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[x].sum</span></span><br><span class="line">&#125;tr[N*<span class="number">400</span>];<span class="comment">//空间要N(logN)^2大小</span></span><br><span class="line"><span class="comment">/*因为要离散化,所以要提前读取所有操作*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,k;<span class="comment">//查询操作,询问区间[l,r]内第k大数的值</span></span><br><span class="line">    <span class="keyword">int</span> p,x;    <span class="comment">//修改操作,修改位置p位置上的元素为x</span></span><br><span class="line">&#125;qy[N];</span><br><span class="line"><span class="keyword">int</span> sz = N;<span class="comment">/*不同版本的线段树总数,</span></span><br><span class="line"><span class="comment">即动态申请节点编号,初始值要为N,因为前n个节点被使用*/</span></span><br><span class="line"><span class="keyword">int</span> a[N],n,m,tot = <span class="number">0</span>;<span class="comment">//tot离散化用</span></span><br><span class="line"><span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*对以rt为根的线段树,区间[l,r]内新增一个元素x*/</span></span><br><span class="line">    sum(rt) += d;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>; <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!ls(rt)) ls(rt) = ++sz;<span class="comment">//如果该子树没有子节点则新建</span></span><br><span class="line">    <span class="keyword">if</span>(!rs(rt)) rs(rt) = ++sz;<span class="comment">//动态申请节点</span></span><br><span class="line">    <span class="keyword">if</span>(p &lt;= mid) Insert(ls(rt),l,mid,p,d);</span><br><span class="line">    <span class="keyword">else</span> Insert(rs(rt),mid+<span class="number">1</span>,r,p,d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> p,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*向树状数组中的 线段树中 位置p值+d,要从l开始哦*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = l;x &lt;= n;x += x&amp;-x) Insert(x,<span class="number">1</span>,tot,p,y); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t1[N],t2[N],c1,c2;<span class="comment">//临时记录遍历路径</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*返回区间[l,r]内第k大元素的值(离散化后的)*/</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c1;i++) res -= sum(ls(t1[i]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c2;i++) res += sum(ls(t2[i]));</span><br><span class="line">    <span class="keyword">if</span>(res &gt;= k)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c1;i++) t1[i] = ls(t1[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c2;i++) t2[i] = ls(t2[i]);</span><br><span class="line">    <span class="keyword">return</span> ask(l,mid,k);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c1;i++) t1[i] = rs(t1[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c2;i++) t2[i] = rs(t2[i]);</span><br><span class="line"><span class="keyword">return</span> ask(mid+<span class="number">1</span>,r,k-res);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp[N*<span class="number">2</span>];<span class="comment">//离散化用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">c1 = c2 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*我们将树状数组上待查询的线段树的左儿子编号先存储*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l;i;i -= i&amp;-i) t1[++c1] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = r;i;i -= i&amp;-i) t2[++c2] = i;</span><br><span class="line"><span class="keyword">int</span> x = ask(<span class="number">1</span>,tot,k);<span class="comment">//注意查询区间是[1,tot] </span></span><br><span class="line"><span class="keyword">return</span> tmp[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i),tmp[++tot] = a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'C'</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;qy[i].p,&amp;qy[i].x);</span><br><span class="line">            tmp[++tot] = qy[i].x;<span class="comment">//先存储,方便离散化</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;qy[i].l,&amp;qy[i].r,&amp;qy[i].k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//离散化</span></span><br><span class="line">    sort(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot);</span><br><span class="line">    tot = unique(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot)-tmp<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p = lower_bound(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot,a[i])-tmp;</span><br><span class="line">        add(i,p,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(qy[i].l)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = qy[i].l, r = qy[i].r;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(l<span class="number">-1</span>,r,qy[i].k));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> p = lower_bound(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot,qy[i].x)-tmp;</span><br><span class="line">            <span class="keyword">int</span> pre = lower_bound(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot,a[qy[i].p])-tmp;</span><br><span class="line">            add(qy[i].p,pre,<span class="number">-1</span>); add(qy[i].p,p,<span class="number">1</span>); a[qy[i].p] = qy[i].x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;主席树，又称可持久化线段树，属于可持久化数据结构。“主席”这一名词是由于发明者缩写为HJT，和某位主席拼音缩写相同（有些牵强），故将该数据结
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>权值线段树</title>
    <link href="http://valenshi.top/2019/08/27/qz-tree/"/>
    <id>http://valenshi.top/2019/08/27/qz-tree/</id>
    <published>2019-08-27T04:38:59.000Z</published>
    <updated>2019-08-27T04:40:08.779Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>权值线段树是在普通线段树的基础上进行更改，利用值域建树而非定义域（下标）；这使得线段树具有了一些新的功能，本文就将从权值线段树的来历，用途以及算法流程方面来介绍该数据结构。最终我们会用两个例题来体现权值线段树的用途，当然该代码也作为参考模板。</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>线段树是将下标不断二分，使得树上每个节点对应一段区间，从而将区间操作拆分成有关若干节点的操作。权值线段树与之类似，都是将一段区间不断二分，并令树上每个节点对应一段区间，以此实现“将区间操作变为对树上某条路径的操作”，只不过这里划分的区间不再是下标，而是权值。</p><p>至此其实权值线段树的特点已经很明显了，一般的线段树对下标建树，而权值线段树对权值建树；普通线段树对下标上的值进行操作（加减乘除），而权值线段树对值所对应的下标进行操作。</p><h4 id="权值线段树的用途"><a href="#权值线段树的用途" class="headerlink" title="权值线段树的用途"></a>权值线段树的用途</h4><p>这就好比一个是对 <strong>定义域</strong> 建树，而另一个是对 <strong>值域</strong> 建树，所以权值线段树具有如下用途：</p><ul><li>统计范围内元素的个数（这里的范围是指值域上的范围，例如：求逆序对）。</li><li>查询序列中，下标大于r的 第一个大于 k 的数。</li></ul><p>只是对线段树进行简单的更改，就使其拥有了这些功能（虽然这些功能其它数据结构也能实现），可见线段树的灵活性。</p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>第一步：通常元素的值域范围很大，但是个数很少，所以一般会先对这n个数离散化处理，处理之后就只有tot个不同的值([1 , tot])。</p><p>第二步：对区间[1, tot]建立线段树。</p><p>第三步：按照题意进行操作。</p><h4 id="例题1：求逆序对"><a href="#例题1：求逆序对" class="headerlink" title="例题1：求逆序对"></a>例题1：求逆序对</h4><p><a href="https://www.luogu.org/problem/P1908" target="_blank" rel="noopener">测试地址：洛谷P1908</a><br>虽然我们有更好的求逆序对的方法，例如归并、CDQ分治、树状数组等，但是这题其实也很好的体现权值线段树的思路，作为入门还是很好理解的。</p><p>首先我们将较为分散的n个元素按照权值离散化，离散化之后这n个元素取值范围（映射集合）就在[1,tot]之间，而若  i &gt; j，那么 i 代表的元素一定比 j 代表的元素大。</p><p>接下来从前向后遍历原数组的n个元素，找到其离散化后的标号i，再统计线段树中&gt;i的元素个数有多少个，累加到答案即可。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">权值线段树模板 最后修改:2019/8/25 </span></span><br><span class="line"><span class="comment">洛谷P1908:给出n个数求逆序对数量 </span></span><br><span class="line"><span class="comment">由于值域过于分散,且数字太大,采用离散化方法 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,sum;</span><br><span class="line"><span class="comment">/* 左端点,右端点,[l,r]内元素总数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[x].sum</span></span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ll val;<span class="keyword">int</span> id;</span><br><span class="line"><span class="comment">/*元素的值,序号,用于离散化*/</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; rhs)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &lt; rhs.val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;tmp[N]; </span><br><span class="line"><span class="keyword">int</span> n,tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*对[l,r]建立一棵子树,该子树根节点是rt*/</span></span><br><span class="line">l(rt) = l, r(rt) = r, sum(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid);</span><br><span class="line">BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">/*查询大于等于y的数的个数*/</span> </span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt)) <span class="keyword">return</span> sum(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(y &lt;= mid) <span class="keyword">return</span> ask(rt*<span class="number">2</span>,y)+sum(rt*<span class="number">2</span>+<span class="number">1</span>); <span class="comment">//加上整段右区间 </span></span><br><span class="line"><span class="keyword">return</span> ask(rt*<span class="number">2</span>+<span class="number">1</span>,y);<span class="comment">//答案在右子树 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将p位置+1*/</span></span><br><span class="line"><span class="keyword">if</span>(l(rt) &lt;= p &amp;&amp; p &lt;= r(rt)) sum(rt)++;</span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt)) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= mid) updata(rt*<span class="number">2</span>,p);</span><br><span class="line"><span class="keyword">else</span> updata(rt*<span class="number">2</span>+<span class="number">1</span>,p);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//首先离散化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) tmp[i].val = a[i],tmp[i].id = i; </span><br><span class="line">sort(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+n); tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">1</span> || tmp[i].val != tmp[i<span class="number">-1</span>].val) ++tot;</span><br><span class="line">a[tmp[i].id] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//离散化之后值域[1,tot],以此为区间建树</span></span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,tot); </span><br><span class="line"><span class="comment">//下一步就是查询与更新了</span></span><br><span class="line">ll ans = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ans += ask(<span class="number">1</span>,a[i]+<span class="number">1</span>);<span class="comment">//在前i-1个数中,比a[i]大的有多少</span></span><br><span class="line">updata(<span class="number">1</span>,a[i]);<span class="comment">//值为a[i]的数+1 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="例题2：2019CCPC网络赛-B-array"><a href="#例题2：2019CCPC网络赛-B-array" class="headerlink" title="例题2：2019CCPC网络赛 B.array"></a>例题2：2019CCPC网络赛 B.array</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6703" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定1~n共n个数组成的序列，有m次操作，每次操作有两种可能：</p><ol><li>(1,pos)令 $a_{pos} = a_{pos}+1,000,000$。</li><li>(2, r , k) 回答不在$a_i(1&lt;= i &lt;= r)$内的，大于等于k的最小值。</li></ol><p>强制在线。<br><strong>解题思路：</strong><br>首先是理解题意，然后如果按照题目要求来解题，我们需要每次都通过遍历来排除[1,r]内的元素，显然会超时。由于题目中$a_i$是各不相同的，又是小于n的，因此我们可以将原问题转化为求“大于等于k的所有元素中，第一个下标大于r的元素的值”。对于这个问题我们每次需要询问所有值在[k,n+10]内，第一个下标大于r的即可。</p><p>于是我们可以通过建立权值线段树，线段树的下标是值$a_i$，值是下标i，对于每个操作1，就相当于把pos位置上的数删掉了。加上一些小剪枝就可以过。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="comment">/*区间[l,r]内元素个数为sum*/</span></span><br><span class="line"><span class="keyword">int</span> l,r,sum,mx;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mx(x) tr[x].mx</span></span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="comment">/*a数组存放序列,b数组离散化用</span></span><br><span class="line"><span class="comment">tot是离散化后不同元素个数 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ll a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> n,m,tot,t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*对[l,r]建立一棵根为rt的子树*/</span></span><br><span class="line">l(rt) = l, r(rt) = r , mx(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid);</span><br><span class="line">BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="comment">/*p位置值+1(值为p的元素的数量+1)*/</span></span><br><span class="line"><span class="comment">//printf("%d %d %d %d %d\n",rt,l(rt),r(rt),p,d);</span></span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">mx(rt) = d; <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= mid) Insert(rt*<span class="number">2</span>,p,d);</span><br><span class="line"><span class="keyword">else</span> Insert(rt*<span class="number">2</span>+<span class="number">1</span>,p,d); </span><br><span class="line">mx(rt) = max(mx(rt*<span class="number">2</span>),mx(rt*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> k,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">//printf("%d %d %d %d %d %d\n",rt,l(rt),r(rt),k,r,mx(rt));</span></span><br><span class="line"><span class="comment">/*返回[k,n]中第一个大于r的值*/</span></span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line"><span class="keyword">if</span>(mx(rt) &lt;= r) <span class="keyword">return</span> -INF;</span><br><span class="line"><span class="keyword">return</span> l(rt);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(k &lt;= mid &amp;&amp; mx(rt*<span class="number">2</span>) &gt; r) res = ask(rt*<span class="number">2</span>,k,r);</span><br><span class="line"><span class="keyword">if</span>(res &lt;= <span class="number">0</span>) <span class="keyword">return</span> ask(rt*<span class="number">2</span>+<span class="number">1</span>,k,r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,a+i);</span><br><span class="line">Insert(<span class="number">1</span>,a[i],i);<span class="comment">//a[i]下标为 i </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n+<span class="number">1</span>;i &lt;= n+<span class="number">10</span>;i++) Insert(<span class="number">1</span>,i,INF);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,op,pos,r,k;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op);</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;pos);</span><br><span class="line">pos ^= ans;</span><br><span class="line">Insert(<span class="number">1</span>,a[pos],INF);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;r,&amp;k);</span><br><span class="line">k ^= ans, r ^= ans;</span><br><span class="line">ans = ask(<span class="number">1</span>,k,r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;权值线段树是在普通线段树的基础上进行更改，利用值域建树而非定义域（下标）；这使得线段树具有了一些新的功能，本文就将从权值线段树的来历，用途以
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构域算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%9F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2019CCPC网络赛部分题解</title>
    <link href="http://valenshi.top/2019/08/25/2019ccpc/"/>
    <id>http://valenshi.top/2019/08/25/2019ccpc/</id>
    <published>2019-08-25T09:06:24.000Z</published>
    <updated>2019-08-26T02:40:36.542Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1001-amp"><a href="#1001-amp" class="headerlink" title="1001 ^&amp;^"></a>1001 ^&amp;^</h4><p><strong>题意简述：</strong><br>给定正整数a和b，找到一个最小的正整数c，使得(a^c)&amp;(b^c)最小。<br><strong>解题思路：</strong><br>两个数按位与最小结果肯定是0啊，所以对于a和b，如果它们对应二进制位上有0，则c置为0即可，因为0^0 = 0 , 这就保证了异或之后肯定有一个是0，再&amp;之后还是0；若它们对应二进制位都是1，则只能置c的对应二进制位为1了，因为1^1 = 0。</p><p>值得注意的是，所求结果c是正整数，所以如果当c = 0时，则需要从低位向高位，将0-1或1-0位时，c对应二进制位 = 1。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">ll a,b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((a&amp;(<span class="number">1l</span>l&lt;&lt;i)) &amp;&amp; (b&amp;(<span class="number">1l</span>l&lt;&lt;i))) c = c|(<span class="number">1l</span>l&lt;&lt;i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((a&amp;(<span class="number">1l</span>l&lt;&lt;i)) != (b&amp;(<span class="number">1l</span>l&lt;&lt;i)))&#123;</span><br><span class="line">                c = c|(<span class="number">1l</span>l&lt;&lt;i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;a,&amp;b);</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1002-array"><a href="#1002-array" class="headerlink" title="1002 array"></a>1002 array</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6703" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定1~n共n个数组成的序列，有m次操作，每次操作有两种可能：</p><ol><li>(1,pos)令 $a_{pos} = a_{pos}+1,000,000$。</li><li>(2, r , k) 回答不在$a_i(1&lt;= i &lt;= r)$内的，大于等于k的最小值。</li></ol><p>强制在线。<br><strong>解题思路：</strong><br>首先是理解题意，然后如果按照题目要求来解题，我们需要每次都通过遍历来排除[1,r]内的元素，显然会超时。由于题目中$a_i$是各不相同的，又是小于n的，因此我们可以将原问题转化为求“大于等于k的所有元素中，第一个下标大于r的元素的值”。对于这个问题我们每次需要询问所有值在[k,n+10]内，第一个下标大于r的即可。</p><p>于是我们可以通过建立权值线段树，线段树的下标是值$a_i$，值是下标i，对于每个操作1，就相当于把pos位置上的数删掉了。加上一些小剪枝就可以过。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="comment">/*区间[l,r]内元素个数为sum*/</span></span><br><span class="line"><span class="keyword">int</span> l,r,sum,mx;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mx(x) tr[x].mx</span></span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="comment">/*a数组存放序列,b数组离散化用</span></span><br><span class="line"><span class="comment">tot是离散化后不同元素个数 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ll a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> n,m,tot,t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*对[l,r]建立一棵根为rt的子树*/</span></span><br><span class="line">l(rt) = l, r(rt) = r , mx(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid);</span><br><span class="line">BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="comment">/*p位置值+1(值为p的元素的数量+1)*/</span></span><br><span class="line"><span class="comment">//printf("%d %d %d %d %d\n",rt,l(rt),r(rt),p,d);</span></span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">mx(rt) = d; <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= mid) Insert(rt*<span class="number">2</span>,p,d);</span><br><span class="line"><span class="keyword">else</span> Insert(rt*<span class="number">2</span>+<span class="number">1</span>,p,d); </span><br><span class="line">mx(rt) = max(mx(rt*<span class="number">2</span>),mx(rt*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> k,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">//printf("%d %d %d %d %d %d\n",rt,l(rt),r(rt),k,r,mx(rt));</span></span><br><span class="line"><span class="comment">/*返回[k,n]中第一个大于r的值*/</span></span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line"><span class="keyword">if</span>(mx(rt) &lt;= r) <span class="keyword">return</span> -INF;</span><br><span class="line"><span class="keyword">return</span> l(rt);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(k &lt;= mid &amp;&amp; mx(rt*<span class="number">2</span>) &gt; r) res = ask(rt*<span class="number">2</span>,k,r);</span><br><span class="line"><span class="keyword">if</span>(res &lt;= <span class="number">0</span>) <span class="keyword">return</span> ask(rt*<span class="number">2</span>+<span class="number">1</span>,k,r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,a+i);</span><br><span class="line">Insert(<span class="number">1</span>,a[i],i);<span class="comment">//a[i]下标为 i </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n+<span class="number">1</span>;i &lt;= n+<span class="number">10</span>;i++) Insert(<span class="number">1</span>,i,INF);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,op,pos,r,k;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op);</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;pos);</span><br><span class="line">pos ^= ans;</span><br><span class="line">Insert(<span class="number">1</span>,a[pos],INF);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;r,&amp;k);</span><br><span class="line">k ^= ans, r ^= ans;</span><br><span class="line">ans = ask(<span class="number">1</span>,k,r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1004-Path"><a href="#1004-Path" class="headerlink" title="1004 Path"></a>1004 Path</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6705" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>一共有n个点m条边和q次询问，每次询问给出一个整数k，请问在图中的所有路径中第k短的路径长度是多少？</p><p><strong>解题思路：</strong><br>刚开始思路有些不对，其实这题并不是求最短路或者A *  或怎样，据说是常见套路。<br>首先前m短的边就是这m条边，我们可以利用优先队列维护 路径，而一条路径由“起点，终点，路径长度，上一个点的编号，该边在上一个点所有边中的排名”构成。</p><p>这样每次从最小堆中弹出一条路径，该路径就是剩下所有路径中最短的一条；而且该路径只有“从当前终点出发走下一条最短边”和“返回到上一个节点par，然后从par走次短边”这两种可能会对最终答案有贡献，所以将这两条路径再压入最小堆即可，如此反复操作直至求得所有最短路径。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x:边的起点,y:终点,par:上一个点的编号,</span></span><br><span class="line"><span class="comment">rk:在上一个点的所有出边中名次,d:路径长度 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> x,y,par,rk;</span><br><span class="line">ll d;</span><br><span class="line">Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y,ll d,<span class="keyword">int</span> par,<span class="keyword">int</span> rk):x(x),y(y),d(d),par(par),rk(rk)&#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; B)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> d &gt; B.d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">ll dis[N];</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"><span class="keyword">int</span> t,n,m,qq,k;</span><br><span class="line"><span class="keyword">int</span> a[N],ord[N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,ll&gt; pa;</span><br><span class="line"><span class="built_in">vector</span>&lt;pa&gt; G[N];<span class="comment">//存储点的所有出边,按权值升序 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">Node e = q.top();q.pop();</span><br><span class="line">dis[++cnt] = e.d;</span><br><span class="line"><span class="keyword">if</span>(cnt &gt; k) <span class="keyword">break</span>;<span class="comment">//统计出来前k个即可</span></span><br><span class="line"><span class="comment">/*只有两种情况可能更新答案*/</span> </span><br><span class="line"><span class="keyword">if</span>(G[e.par].size() &gt; e.rk+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> x = e.x,y = G[e.x][e.rk+<span class="number">1</span>].second , par = x, rk = e.rk+<span class="number">1</span>;</span><br><span class="line">ll z = e.d - G[e.x][e.rk].first+G[e.x][rk].first;</span><br><span class="line">q.push(Node(x,y,z,par,rk));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(G[e.y].size()) </span><br><span class="line">q.push(Node(e.y,G[e.y][<span class="number">0</span>].second,e.d+G[e.y][<span class="number">0</span>].first,e.y,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;qq); k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) G[i].clear(),ord[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">G[x].push_back(make_pair(z,y));</span><br><span class="line">q.push(Node(x,y,z,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) sort(G[i].begin(),G[i].end());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= qq;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i),k = k&gt;a[i]?k:a[i];</span><br><span class="line">solve();<span class="comment">//预处理 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= qq;i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dis[a[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1006-Shuffle-Card"><a href="#1006-Shuffle-Card" class="headerlink" title="1006 Shuffle Card"></a>1006 Shuffle Card</h4><p><strong>解题思路：</strong><br>队友一发过了，听说是个模拟题，ccfnb。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,q,s;</span><br><span class="line"><span class="keyword">int</span> bk[Max];</span><br><span class="line"><span class="keyword">int</span> val[Max];</span><br><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; deq;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val[i]);</span><br><span class="line">        deq.push_back(val[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s);</span><br><span class="line">        deq.push_front(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!deq.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(!bk[deq.front()])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,deq.front());</span><br><span class="line">            bk[deq.front()] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        deq.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1007-Windows-Of-CCPC"><a href="#1007-Windows-Of-CCPC" class="headerlink" title="1007 Windows Of CCPC"></a>1007 Windows Of CCPC</h4><p><strong>题意简述：</strong><br>输出CCPC，当然是2 <em> 2矩阵输出，此为单元。如果n &gt; 1，那么就递归n - 1次，每次递归都把C替换成一个标准单元，把P替换为一个“反单元”（反单元即将标准单元中的C替换为P，P替换为C，即PPCP，也是2 </em> 2矩阵形式）作为新的矩阵。<br>给定n，输出结果。<br><strong>解题思路：</strong><br>就是简单的模拟，用数组，当然最好用putchar，否则可能会超时，还有就是n最大是10，可以输出到txt文件中肉眼观察一下是否正确再提交。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,k;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3400</span>;</span><br><span class="line"><span class="keyword">char</span> G[N][N];</span><br><span class="line"><span class="keyword">char</span> tmp[N][N]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    G[<span class="number">1</span>][<span class="number">1</span>] = G[<span class="number">1</span>][<span class="number">2</span>] = G[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">'C'</span>;</span><br><span class="line">    G[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">'P'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= (<span class="number">1</span>&lt;&lt;i);j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> z = <span class="number">1</span>;z &lt;= (<span class="number">1</span>&lt;&lt;i);z++)&#123;</span><br><span class="line">                <span class="keyword">int</span> r = <span class="number">2</span>*(j<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> c = <span class="number">2</span>*(z<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(G[j][z] == <span class="string">'C'</span>)&#123;</span><br><span class="line">                    tmp[r][c] = tmp[r][c+<span class="number">1</span>] = tmp[r+<span class="number">1</span>][c+<span class="number">1</span>] = <span class="string">'C'</span>;</span><br><span class="line">                    tmp[r+<span class="number">1</span>][c] = <span class="string">'P'</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tmp[r][c] = tmp[r][c+<span class="number">1</span>] = tmp[r+<span class="number">1</span>][c+<span class="number">1</span>] = <span class="string">'P'</span>;</span><br><span class="line">                    tmp[r+<span class="number">1</span>][c] = <span class="string">'C'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= (<span class="number">1</span>&lt;&lt;i);j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> z = <span class="number">1</span>;z &lt;= (<span class="number">1</span>&lt;&lt;i);z++)</span><br><span class="line">              G[j][z] = tmp[j][z];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1</span>&lt;&lt;k;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">1</span>&lt;&lt;k;j++) <span class="built_in">putchar</span>(G[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("out.txt","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1008-Fishing-Master"><a href="#1008-Fishing-Master" class="headerlink" title="1008 Fishing Master"></a>1008 Fishing Master</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6709" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>一共有n条鱼，钓任意一条鱼需要花费时间k，而煮熟一条鱼需要花费$t_i$ 时间，这n条鱼的顺序不固定，即我们每次可以钓我们想要的那条。在钓鱼的k时间内不能中断，即我们不能在钓鱼的时间内去煮或者拿出，当然一次只能煮一条鱼。请问煮熟这n条鱼最少花费多少时间？<br>tip：在钓上来一条鱼后，我们可以选择等锅里的鱼煮熟（如果需要的话），或者直接去钓鱼，回来再说，因为同一时刻我们手里可以有任意多条鱼，不局限于一条。极限情况就是我们先钓完n条鱼，再一条一条煮。</p><p><strong>解题思路：</strong><br>这题细节很多，题意很多地方稍不注意就会有歧义，所以做这种题之前一定要先了解清楚题意到底是什么规则以及要求什么。搞清楚了之后算法的设计就并不难想了，是贪心策略。<br>如果极限情况，我们花费的最多时间就是“先把n条鱼全部钓上来，再挨个煮”，花费的时间是$sum = n * k+\sum_{i = 1}^nt_i$，而我们能减少花费的时间，当且仅当我们在钓鱼的同时去煮鱼；而又由于钓鱼的时间段不能终止，所以就相当于我们有n-1段时间，每段时间大小为k，那么对于任意煮一条鱼的时间$t_i$：</p><ul><li>若$t_i$ 是 k 的倍数，$\frac{t_i}{k} = cnt$ 那么这cnt份时间完全被利用了，即sum -= cnt * k</li><li>若$t_i &gt; k$，那么说明我们可以先煮几段k，而剩下的部分再考虑是等待还是继续钓鱼，$\frac{t_i}{k} = cnt$，sum -= cnt <em> k , $t_i$ -= cnt </em> k</li><li>经过上面的操作之后，剩下的$t_i$就都是小于k的了，那么如果此时我们还剩res段时间，则挑最大的res个$t_i$来煮，这样就能最大化利用时间了，如果res = 0，则算法结束。</li></ul><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> tt,n;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll t[N],k,a[N];</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll ans = n*k;<span class="keyword">int</span> res = n<span class="number">-1</span>,tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i]%k == <span class="number">0</span> &amp;&amp; res) ans -= t[i],res -= t[i]/k;</span><br><span class="line">        <span class="keyword">else</span> a[++tot] = t[i]%k, cnt += t[i]/k;</span><br><span class="line">        ans += t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt;= res)&#123;</span><br><span class="line">        ans -= k*res;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    ans -= cnt*k;res -= cnt;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+tot);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = tot;i &gt;= <span class="number">1</span> &amp;&amp; res;i--)&#123;</span><br><span class="line">       <span class="comment">// printf("%lld %d %lld\n",b[i],res,ans);</span></span><br><span class="line">        ans -= a[i];res--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tt);</span><br><span class="line">    <span class="keyword">while</span>(tt--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>,&amp;n,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,t+i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,solve());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1001-amp&quot;&gt;&lt;a href=&quot;#1001-amp&quot; class=&quot;headerlink&quot; title=&quot;1001 ^&amp;amp;^&quot;&gt;&lt;/a&gt;1001 ^&amp;amp;^&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;题意简述：&lt;/strong&gt;&lt;br&gt;给定正整数a和b，找到一
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="权值线段树" scheme="http://valenshi.top/tags/%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="贪心策略" scheme="http://valenshi.top/tags/%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>JZOJ4920降雷皇(最长上升子序列数量)</title>
    <link href="http://valenshi.top/2019/08/24/JZOJ4920/"/>
    <id>http://valenshi.top/2019/08/24/JZOJ4920/</id>
    <published>2019-08-24T07:51:10.000Z</published>
    <updated>2019-08-24T07:52:38.529Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1742" target="_blank" rel="noopener">测试地址</a></p><h5 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h5><p>哈蒙有n条导线排成一排，每条导线有一个电阻值，神奇的电光只能从一根导线传到电阻比它大的上面，而且必须从左边向右传导，当然导线不必是连续的。</p><p>哈蒙想知道电光最多能通过多少条导线，还想知道这样的方案有多少。</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>第一问就是简单的LIS问题，即询问最长上升子序列的长度。第二问是询问最长上升子序列的数量，如果用暴力做法，只需要多开一个数组记录数量即可，时间复杂度O(N^2)；实际上我们可以利用BIT来代替枚举，使得时间复杂度至O(NlogN)。</p><p>我们用一个结构体Node{v,s}来表示当最长上升子序列长度为v时，方案数是s。那么对于每一个新元素x，我们只需要找出所有 <strong>电阻值小于x的</strong> 最长上升子序列的长度v以及数量s即可（符合BIT维护前缀和功能）。</p><p>当我们求出当前元素 x 的 v(最长上升子序列长度) 和 s(方案数) 后，用来更新ans，并将其插入树状数组第x个位置。由于题目保证x小于1e5，所以树状数组开到1e5即可。</p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*代码参考：信息学奥赛一本通P263*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll P = <span class="number">123456789</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ll v,s;</span><br><span class="line">Node()&#123;</span><br><span class="line">v = <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;tr[N],tmp,ans;</span><br><span class="line"><span class="keyword">int</span> n,ty;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> x,Node y)</span></span>&#123;</span><br><span class="line"><span class="comment">/*更改电阻值为x时的长度和方案数*/</span> </span><br><span class="line"><span class="keyword">while</span>(x &lt;= N)&#123;</span><br><span class="line"><span class="keyword">if</span>(y.v &gt; tr[x].v) tr[x] = y;<span class="comment">//如果长度变长,直接更新答案 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(y.v == tr[x].v) tr[x].s = (tr[x].s+y.s)%P;</span><br><span class="line">x += x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回当电阻 &lt;= x时,最长上升子序列的长度和方案数*/</span></span><br><span class="line">Node res;res.s = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[x].v &gt; res.v) res = tr[x];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tr[x].v == res.v) res.s = (res.s + tr[x].s)%P;</span><br><span class="line">x -= x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ckmax</span><span class="params">(Node &amp;x,<span class="keyword">const</span> Node&amp; y)</span></span>&#123;</span><br><span class="line"><span class="comment">/*更新最终答案,即最长上升子序列以及个数*/</span></span><br><span class="line"><span class="keyword">if</span>(x.v &lt; y.v) x = y;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x.v == y.v) x.s = (x.s+y.s)%P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;ty);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">tmp = ask(x<span class="number">-1</span>);<span class="comment">//因为这里保证x不超过1e5,所以不需要离散化 </span></span><br><span class="line">tmp.v++;</span><br><span class="line">ckmax(ans,tmp);<span class="comment">//更新答案 </span></span><br><span class="line">updata(x,tmp);<span class="comment">//更新树状数组 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans.v);</span><br><span class="line"><span class="keyword">if</span>(ty == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans.s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://ybt.ssoier.cn:8088/problem_show.php?pid=1742&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测试地址&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;题意简述&quot;&gt;&lt;a href=&quot;#题意简述&quot; c
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="LIS" scheme="http://valenshi.top/tags/LIS/"/>
    
      <category term="树状数组" scheme="http://valenshi.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Rikka with Coin 解题报告</title>
    <link href="http://valenshi.top/2019/08/22/hdu6685/"/>
    <id>http://valenshi.top/2019/08/22/hdu6685/</id>
    <published>2019-08-22T06:01:46.000Z</published>
    <updated>2019-08-22T06:02:19.831Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6685" target="_blank" rel="noopener">测试地址</a><br>本题为2019航电icpc暑期多校训练第9场的第6题。</p><h5 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h5><p>有10分，20分，50分，100分的硬币若干（反正够用），商店有n件商品（n&lt;101），每件商品的价格给出；请问要想可以买下任意一件商品，最少带多少个硬币？</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>我一开始思路是背包，然后觉得w（商品的价值）太大了，可能用大背包，就放弃了。原来这题需要转化一下思维，并不是用背包而是简单的遍历。首先我们需要明白，就是如若我们买一件物品需要用2个10分的硬币，那么我们换成一个10分一个20分的肯定是可以的，而且反而能买的价格更多了（从10,20变为10,20,30），同理：</p><ul><li>如果有4个20分的，就可以用1个10分，2个20分，1个50分的硬币代替。因为原来可以表示20,40,60,80,现在可以表示10,20,30,40,50,60,70,80,90,100。</li><li>如果有2个50分的，同理，可以用1个50，1个100替代。</li></ul><p>于是我们知道了10分，20分，50分的硬币最多需要1个，3个，1个，所以三层循环遍历所有可能的情况，对于每种情况，判断是否可以表出所有物品（当然不足的用100分的硬币替代）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= a;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= b;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= c;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>((x-i*<span class="number">10</span>-j*<span class="number">20</span>-k*<span class="number">50</span>)%<span class="number">100</span> == <span class="number">0</span>) </span><br><span class="line">res = min((x-i*<span class="number">10</span>-j*<span class="number">20</span>-k*<span class="number">50</span>)/<span class="number">100</span>,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = check2(w[i],a,b,c);</span><br><span class="line"><span class="keyword">if</span>(tmp == INF) <span class="keyword">return</span> INF; </span><br><span class="line"><span class="keyword">else</span> res = max(res,tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf("%d %d %d %d\n",res,a,b,c);</span></span><br><span class="line"><span class="keyword">return</span> res+a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(w[i]%<span class="number">10</span>)&#123;<span class="built_in">puts</span>(<span class="string">"-1"</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">3</span>;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= <span class="number">1</span>;k++)</span><br><span class="line">ans = min(ans,check(i,j,k));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,w+i);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6685&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测试地址&lt;/a&gt;&lt;br&gt;本题为2019航电icpc暑期多校训练第9场的第6题。&lt;/p&gt;
&lt;h5 i
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="思维" scheme="http://valenshi.top/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>2018徐州icpc网络赛A、B题解</title>
    <link href="http://valenshi.top/2019/08/21/2018xuzhou-icpc/"/>
    <id>http://valenshi.top/2019/08/21/2018xuzhou-icpc/</id>
    <published>2019-08-21T03:26:15.000Z</published>
    <updated>2019-08-21T03:48:15.352Z</updated>
    
    <content type="html"><![CDATA[<h4 id="A-Hard-to-prepare"><a href="#A-Hard-to-prepare" class="headerlink" title="A. Hard to prepare"></a>A. Hard to prepare</h4><p><a href="https://nanti.jisuanke.com/t/A2000" target="_blank" rel="noopener">测试地址</a><br>抱怨一下，这题目真的是长，题意理解起来有点费劲，当然费劲的只是因为题面长而不是表述不清。<br><strong>题意简述：</strong><br>从$[1,2^k-1]$中选出n个数，将n个数围成一圈，要求相邻的两个数NXOR大于0，即异或后按位取反的值大于0。问共有多少种不同的方案。</p><p><strong>解题思路：</strong><br>通过简单证明，我们会发现只有1按位取反的值才是0，所以两个数 异或 != 1 就可以相邻；而与x异或 = 1 的数，有且仅有一个。</p><p>首先如果不是环形，而是一条直线，那么一共 $2 ^ k  *  (2 ^ k - 1) ^ {n-1}$​ 种不同的方案，这里设A = ​2^k​。环形和直线不同之处在于，直线首尾的值异或可能 = 1，即我们之前的答案多算了首尾异或=1的情况。那么我们接下来就需要设法减去这些值。</p><p>我们通过动态规划思想来计算这些多加上的值。假设当前位置为 i ，直线首元素是a，尾元素是b，且a^b = 1；设x是位置 i 元素 = a时的方案数，y是位置 i 元素 = b时的方案数，z是位置 i 不等于a和b时的方案数。</p><p>那么我们初始状态（第2个位置时）x = 1 , y = 0 , z = A - 2；目标是求第n-1 位时的 y + z（首位是a，末位是b时，中间2~n-1位的不同排列情况数）。<br>那么易得：<br>x = x + z;<br>y = y + z;<br>z = z<em>(A-3)+(x+y) </em> (A-2).<br>于是我们从第3位递推到第n-1位即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,k;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = res*a%P;</span><br><span class="line">        a = a*a%P;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll A = qpow(<span class="number">2</span>,k);</span><br><span class="line">    ll ans = A*qpow(A<span class="number">-1</span>,n<span class="number">-1</span>)%P;</span><br><span class="line">    ll x = <span class="number">1</span>,y = <span class="number">0</span>,z = A<span class="number">-2</span>;</span><br><span class="line">    <span class="comment">/*x:当前位置数和A相同方案数,</span></span><br><span class="line"><span class="comment">y:当前位置数和B相同方案数,</span></span><br><span class="line"><span class="comment">z:当前位置的数和AB都不同的方案数。 </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; n;i++)&#123;</span><br><span class="line">        ll t1 = x+z,t2 = y+z;</span><br><span class="line">        z = z*(A<span class="number">-3</span>)%P+(x+y)*(A<span class="number">-2</span>)%P;</span><br><span class="line">        z = z%P;</span><br><span class="line">        x = t1%P, y = t2%P;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//  printf("%lld %lld %lld\n",ans,y,z);</span></span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">2</span>) ans = (ans - A*(y+z)%P+P)%P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="B-BE-GE-or-NE"><a href="#B-BE-GE-or-NE" class="headerlink" title="B. BE,GE or NE"></a>B. BE,GE or NE</h4><p><a href="https://nanti.jisuanke.com/t/A2001" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>这是一个博弈论题。有两个人，小K和小S在玩游戏，该游戏一共有n次操作，俩人轮流进行。初始给定一个数值m，每次操作有三种选择：加上a；减去b；若c为1，则m = -1。每次三选一，其中小K想使得最终值&gt;= k，而小S想使得最终值&lt;= l，否则两人平局。给定这n次操作的a,b,c值，请问两人都采取最优策略，最终结果是谁胜出或是平局？</p><p><strong>解题思路：</strong><br>首先每个决策的选举会影响之后的决策，即不满足无后效，因此我们不能单纯的从后向前推（从动态规划角度）。而从博弈论来看，如果当前局面可以转移到必胜态，则当前选手必胜，换到这题，就是使得当前选手得分最大或最小。由于得分只有200种可能，于是可能的状态只有1000 * 200 = 200,000种，记忆化搜索即可。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">250</span>];</span><br><span class="line"><span class="keyword">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="keyword">int</span> n,m,k,l;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; n) <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">if</span>(f[pos][sum+<span class="number">100</span>] != INF) <span class="keyword">return</span> f[pos][sum+<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">if</span>(pos&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = -INF;</span><br><span class="line">        <span class="keyword">if</span>(a[pos]) x = max(x,dfs(pos+<span class="number">1</span>,min(<span class="number">100</span>,sum+a[pos])));</span><br><span class="line">        <span class="keyword">if</span>(b[pos]) x = max(x,dfs(pos+<span class="number">1</span>,max(<span class="number">-100</span>,sum-b[pos])));</span><br><span class="line">        <span class="keyword">if</span>(c[pos]) x = max(x,dfs(pos+<span class="number">1</span>,-sum));</span><br><span class="line">        f[pos][sum+<span class="number">100</span>] = x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = INF;</span><br><span class="line">        <span class="keyword">if</span>(a[pos]) x = min(x,dfs(pos+<span class="number">1</span>,min(sum+a[pos],<span class="number">100</span>)));</span><br><span class="line">        <span class="keyword">if</span>(b[pos]) x = min(x,dfs(pos+<span class="number">1</span>,max(<span class="number">-100</span>,sum-b[pos])));</span><br><span class="line">        <span class="keyword">if</span>(c[pos]) x = min(x,dfs(pos+<span class="number">1</span>,-sum));</span><br><span class="line">        f[pos][sum+<span class="number">100</span>] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[pos][sum+<span class="number">100</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;k,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,a+i,b+i,c+i);</span><br><span class="line">    <span class="keyword">int</span> ans = dfs(<span class="number">1</span>,m);</span><br><span class="line">    <span class="keyword">if</span>(ans &gt;= k) <span class="built_in">puts</span>(<span class="string">"Good Ending"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ans &lt;= l) <span class="built_in">puts</span>(<span class="string">"Bad Ending"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Normal Ending"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;A-Hard-to-prepare&quot;&gt;&lt;a href=&quot;#A-Hard-to-prepare&quot; class=&quot;headerlink&quot; title=&quot;A. Hard to prepare&quot;&gt;&lt;/a&gt;A. Hard to prepare&lt;/h4&gt;&lt;p&gt;&lt;a href=
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="博弈论" scheme="http://valenshi.top/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
      <category term="动态规划" scheme="http://valenshi.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>第一章 基础数据结构模板</title>
    <link href="http://valenshi.top/2019/08/20/chapter1/"/>
    <id>http://valenshi.top/2019/08/20/chapter1/</id>
    <published>2019-08-20T15:37:44.000Z</published>
    <updated>2019-09-07T02:57:28.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ol><li>并查集</li><li>求最近公共祖先LCA</li><li>平方分割法</li><li>莫队算法（一维，二维）</li><li>st表（一维，二维）</li><li>二叉堆（优先队列）</li><li>单调栈与笛卡尔树</li><li>CDQ分治</li></ol><h3 id="1-并查集"><a href="#1-并查集" class="headerlink" title="1 并查集"></a>1 并查集</h3><h4 id="1-1-并查集“拓展域”"><a href="#1-1-并查集“拓展域”" class="headerlink" title="1.1 并查集“拓展域”"></a>1.1 并查集“拓展域”</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关押罪犯</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> par[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;B) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt; B.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; nodes[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == par[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> par[x] = Find(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    par[Find(x)] = Find(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;nodes[i].a,&amp;nodes[i].b,&amp;nodes[i].c);</span><br><span class="line">        par[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(nodes+<span class="number">1</span>,nodes+<span class="number">1</span>+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = nodes[i].a,y = nodes[i].b,d = nodes[i].c;</span><br><span class="line">        <span class="keyword">int</span> x_en = x+n, y_en = y+n;</span><br><span class="line">        <span class="keyword">if</span>(Find(x) == Find(y))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Merge(x,y_en);Merge(x_en,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-并查集“边带权”"><a href="#1-2-并查集“边带权”" class="headerlink" title="1.2 并查集“边带权”"></a>1.2 并查集“边带权”</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POJ1773</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">21000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,ans;</span><br><span class="line">&#125; q[N];</span><br><span class="line"><span class="keyword">int</span> a[N],par[N],d[N],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    a数组用来离散化，par[x]代表x的父节点编号，d[x]代表</span></span><br><span class="line"><span class="comment">    从x到根节点路径和，cnt也是用于离散化。</span></span><br><span class="line"><span class="comment">    这里根节点即集合的代表节点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x] == x) <span class="keyword">return</span> x;   <span class="comment">//找到根节点，返回</span></span><br><span class="line">    <span class="keyword">int</span> root = Find(par[x]);    <span class="comment">//临时存根节点</span></span><br><span class="line">    d[x] ^= d[par[x]];          <span class="comment">//路径压缩，距离数组d也应该更新</span></span><br><span class="line">    <span class="keyword">return</span> par[x] = root;       <span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">char</span> rs[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;q[i].l,&amp;q[i].r,rs);</span><br><span class="line">        <span class="keyword">if</span>(rs[<span class="number">0</span>] == <span class="string">'o'</span>) q[i].ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> q[i].ans = <span class="number">0</span>;</span><br><span class="line">        a[cnt++] = q[i].l<span class="number">-1</span>;    <span class="comment">//这里需要存l-1，为了使l也包含在内</span></span><br><span class="line">        a[cnt++] = q[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下两行代码离散化用</span></span><br><span class="line">    sort(a,a+cnt);</span><br><span class="line">    <span class="keyword">int</span> len = unique(a,a+cnt)-a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) par[i] = i; <span class="comment">//初始化爸爸数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;      </span><br><span class="line">        <span class="comment">//左右边界在离散化数组中的编号：</span></span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(a,a+len,q[i].l<span class="number">-1</span>)-a;</span><br><span class="line">        <span class="keyword">int</span> y = lower_bound(a,a+len,q[i].r)-a;  </span><br><span class="line">        <span class="comment">//左右边界的祖先分别为ta和tb</span></span><br><span class="line">        <span class="keyword">int</span> ta = Find(x),tb = Find(y);</span><br><span class="line">        <span class="keyword">if</span>(ta == tb)&#123;   <span class="comment">//如果已经在同一个集合内，则判断是否矛盾</span></span><br><span class="line">            <span class="keyword">if</span>((d[x]^d[y]) != q[i].ans)&#123;<span class="comment">//矛盾的条件就是事实和结果不同</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            par[ta] = tb;d[ta] = d[x]^d[y]^q[i].ans;</span><br><span class="line">            <span class="comment">//这里d[ta]的值需要推导一下。</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            我们将x所在的集合和y所在的集合合并，那么就需要更新d数组</span></span><br><span class="line"><span class="comment">            这里d[x]存放的是x到par[x]的距离，所以合并两个集合对于</span></span><br><span class="line"><span class="comment">            非根节点来说并无影响，关键是对于两个根d[ta]和d[tb]如何处理</span></span><br><span class="line"><span class="comment">            如果我们将ta代表的集合归于tb下，那么就需要更新d[ta],而已知</span></span><br><span class="line"><span class="comment">            ans = d[x]^d[y]^d[ta]，即x到y的总路径等于x到ta XOR y到tb XOR </span></span><br><span class="line"><span class="comment">            ta到tb；对上式变形，得：d[ta] = ans^d[x]^d[y],而后三者是已知，</span></span><br><span class="line"><span class="comment">            故可以求出d[ta]。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-倍增法求-LCA"><a href="#2-倍增法求-LCA" class="headerlink" title="2 倍增法求 LCA"></a>2 倍增法求 LCA</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HDU2586求树上任意两个节点的路径的边权和  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2</span>*<span class="number">41000</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N],nex[N],edge[N],tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;x ^= y;y^=x;x^=y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y,edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x],head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    deep[x]表示x的深度,anc[x][i]为x向上走2^i步的祖先 </span></span><br><span class="line"><span class="comment">    dis[x]为节点到根节点的距离,即边权或点权和 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="keyword">int</span> deep[N],anc[N][<span class="number">25</span>],dis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.初始化anc数组，</span></span><br><span class="line"><span class="comment">        2.初始化deep数组</span></span><br><span class="line"><span class="comment">        3.初始化dis数组</span></span><br><span class="line"><span class="comment">        以上三个都可以通过dfs来实现</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++)</span><br><span class="line">        anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(dis[y] || y == <span class="number">1</span>) <span class="keyword">continue</span>;<span class="comment">//防止重复访问</span></span><br><span class="line">        deep[y] = deep[x]+<span class="number">1</span>;</span><br><span class="line">        dis[y] = dis[x] + z;</span><br><span class="line">        anc[y][<span class="number">0</span>] = x;</span><br><span class="line">        dfs(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 先把深度调到一致，再按照二进制拆分思想找寻最近公共祖先 */</span></span><br><span class="line">    <span class="keyword">if</span>(deep[u] &lt; deep[v]) swap(u,v);    <span class="comment">//u是较深的节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[anc[u][i]] &gt;= deep[v]) u = anc[u][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(anc[u][i] != anc[v][i])&#123;</span><br><span class="line">            u = anc[u][i];</span><br><span class="line">            v = anc[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> anc[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回u到v的距离*/</span></span><br><span class="line">    <span class="keyword">return</span> dis[u] + dis[v] <span class="number">-2</span>*dis[Lca(u,v)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">        <span class="built_in">memset</span>(deep,<span class="number">0</span>,<span class="keyword">sizeof</span> deep);</span><br><span class="line">        <span class="built_in">memset</span>(anc,<span class="number">0</span>,<span class="keyword">sizeof</span> anc);</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head);<span class="comment">//head也要初始化</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            addEdge(x,y,z);</span><br><span class="line">            addEdge(y,x,z);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x,y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-平方分割法"><a href="#3-平方分割法" class="headerlink" title="3 平方分割法"></a>3 平方分割法</h3><p><strong>问题模型：</strong></p><blockquote><p>给定一个数列$a_1,a_2,…,a_n$，目标是在O（&radic;n）复杂度内实现以下两个功能：</p><ul><li>给定s，t，求$a_s,a_{s+1},…a_t$的最小值</li><li>给定i，x，把$a_i$的值变为x。</li></ul></blockquote><p><strong>基于平方分割的RMQ的复杂度：</strong><br>在更新值时，由于每个桶内有b个元素，所以复杂度是O(b) = O(&radic;n)<br>而查询为：O(n/b+b) = O(&radic;n+&radic;n) = O(&radic;n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> mi[N/B];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">a[pos] = y;</span><br><span class="line">mi[pos/B] = min(mi[pos/B],y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = INF;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r &amp;&amp; l%B) ans = min(ans,a[l++]);</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r &amp;&amp; r%B) ans = min(ans,a[--r]);</span><br><span class="line"><span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line"><span class="keyword">int</span> b = l/B;</span><br><span class="line">ans = min(ans,mi[b]);</span><br><span class="line">l += B;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N/B;i++) mi[i] = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">mi[i/B] = min(mi[i/B],a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="keyword">int</span> op,x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;op,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>) updata(x,y);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; query(x,y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-莫队算法"><a href="#4-莫队算法" class="headerlink" title="4 莫队算法"></a>4 莫队算法</h3><p><strong>SPOJ D-query：</strong> 给定一个数组，每次询问一个区间内有多少个不同的元素。</p><p><strong>复杂度分析：</strong> 莫队算法是离线算法，可以解决一类离线的区间问题，对于序列上的区间询问问题，如果从 [l,r] 的答案能够 O(1) 扩展到 [l−1,r],[l+1,r],[l,r+1],[l,r−1] 的答案，那么可以在 $O(n\sqrt n)$ 的复杂度内求出所有询问的答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">31000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Q = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],m;</span><br><span class="line"><span class="keyword">int</span> ans,sum[<span class="number">1010000</span>];<span class="comment">//一个全局答案ans和标记数组sum是必要的 </span></span><br><span class="line"><span class="comment">//当然也可以离散化 </span></span><br><span class="line"><span class="keyword">int</span> len;<span class="comment">//块大小，在读入询问前需要先赋值 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,block,id;</span><br><span class="line">Query()&#123;&#125;</span><br><span class="line">Query(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> id):l(l),r(r),id(id)&#123;</span><br><span class="line">block = l/len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Query &amp;B) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(block == B.block) <span class="keyword">return</span> block&amp;<span class="number">1</span>? r &lt; B.r : r &gt; B.r;</span><br><span class="line"><span class="comment">//小优化，使得r呈波浪形 </span></span><br><span class="line"><span class="keyword">return</span> block &lt; B.block;</span><br><span class="line">&#125;</span><br><span class="line">&#125;query[Q];</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//增加或减少一个x位置上的数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">x = a[x]; </span><br><span class="line">sum[x] += v;</span><br><span class="line"><span class="keyword">if</span>(v &gt; <span class="number">0</span>) ans += sum[x] == <span class="number">1</span>;<span class="comment">//判等是为了防止重复计数 </span></span><br><span class="line"><span class="keyword">else</span> ans -= sum[x] == <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">len = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">query[i] = Query(x,y,i);</span><br><span class="line">&#125;</span><br><span class="line">sort(query+<span class="number">1</span>,query+<span class="number">1</span>+m);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>,r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l &lt; query[i].l) Move(l,<span class="number">-1</span>),l++;</span><br><span class="line"><span class="keyword">while</span>(l &gt; query[i].l) Move(l<span class="number">-1</span>,<span class="number">1</span>),l--;</span><br><span class="line"><span class="keyword">while</span>(r &gt; query[i].r) Move(r,<span class="number">-1</span>),r--;</span><br><span class="line"><span class="keyword">while</span>(r &lt; query[i].r) Move(r+<span class="number">1</span>,<span class="number">1</span>),r++;</span><br><span class="line">q.push(make_pair(-query[i].id,ans));<span class="comment">//大根堆变为小根堆 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.top().second;q.pop();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-st表"><a href="#5-st表" class="headerlink" title="5 st表"></a>5 st表</h3><h4 id="5-1一维st表"><a href="#5-1一维st表" class="headerlink" title="5.1一维st表"></a>5.1一维st表</h4><p><strong>问题模型：</strong></p><p>给定一个长度为n的序列，有m次询问，每次给定区间[L , R]，求区间内最大值。</p><p>我们设 <code>st[i][j]</code> 为从 i 开始的 $2^j$ 个数中的最大值。假设这n个数存放的序列a中，根据定义 <code>st[i][j]</code> = max{a[k] | $i &lt;= k &lt;= i+2^j - 1$}。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],st[N][<span class="number">25</span>],Log[N];<span class="comment">//2^20就过一百万了，完全够用 </span></span><br><span class="line"><span class="comment">//初始化st表 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">Log[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//预处理log函数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;<span class="comment">//涉及到位运算多加括号! </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)) &lt;= n;i++)&#123;</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> mx = max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"><span class="comment">//printf("%d %d\n",k,mx);</span></span><br><span class="line"><span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,l,r;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(l,r));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-二维st表"><a href="#5-2-二维st表" class="headerlink" title="5.2 二维st表"></a>5.2 二维st表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">令t1 = st[a][b][c];</span><br><span class="line">令t2 = st[a][b+c-(1&lt;&lt;k)+1][c];</span><br><span class="line">令t3 = st[a+c-(1&lt;&lt;k)+1][b][c];</span><br><span class="line">令t4 = st[a+c-(1&lt;&lt;k)+1][b+c-(1&lt;&lt;k)+1][c];</span><br><span class="line">ans = max&#123;t1 , t2 , t3 , t4&#125;；</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N],n,m,len,Log[N];</span><br><span class="line"><span class="keyword">int</span> st[<span class="number">3</span>][N][N][<span class="number">15</span>];<span class="comment">//0最小，1最大值 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mx = a;<span class="keyword">if</span>(mx &lt; b) mx = b;<span class="keyword">if</span>(mx &lt; c) mx = c;<span class="keyword">if</span>(mx &lt; d) mx = d;</span><br><span class="line"><span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mi = a;<span class="keyword">if</span>(mi &gt; b) mi = b;<span class="keyword">if</span>(mi &gt; c) mi = c;<span class="keyword">if</span>(mi &gt; d) mi = d;</span><br><span class="line"><span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++) </span><br><span class="line">st[<span class="number">0</span>][i][j][<span class="number">0</span>] = st[<span class="number">1</span>][i][j][<span class="number">0</span>] = a[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= <span class="number">12</span>;k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span> &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j + (<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span> &lt;= m;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> t1 = st[<span class="number">0</span>][i][j][k<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> t2 = st[<span class="number">0</span>][i+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][j][k<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> t3 = st[<span class="number">0</span>][i][j+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][k<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> t4 = st[<span class="number">0</span>][i+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][j+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][k<span class="number">-1</span>];</span><br><span class="line">st[<span class="number">0</span>][i][j][k] = min(t1,t2,t3,t4);</span><br><span class="line">t1 = st[<span class="number">1</span>][i][j][k<span class="number">-1</span>];</span><br><span class="line">t2 = st[<span class="number">1</span>][i+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][j][k<span class="number">-1</span>];</span><br><span class="line">t3 = st[<span class="number">1</span>][i][j+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][k<span class="number">-1</span>];</span><br><span class="line">t4 = st[<span class="number">1</span>][i+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][j+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][k<span class="number">-1</span>];</span><br><span class="line">st[<span class="number">1</span>][i][j][k] = max(t1,t2,t3,t4);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[len];</span><br><span class="line"><span class="keyword">int</span> t1 = st[<span class="number">0</span>][r][c][k];</span><br><span class="line"><span class="keyword">int</span> t2 = st[<span class="number">0</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c][k];</span><br><span class="line"><span class="keyword">int</span> t3 = st[<span class="number">0</span>][r][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line"><span class="keyword">int</span> t4 = st[<span class="number">0</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line"><span class="keyword">int</span> mi = min(t1,t2,t3,t4);</span><br><span class="line">t1 = st[<span class="number">1</span>][r][c][k];</span><br><span class="line">t2 = st[<span class="number">1</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c][k];</span><br><span class="line">t3 = st[<span class="number">1</span>][r][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line">t4 = st[<span class="number">1</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line"><span class="keyword">int</span> mx = max(t1,t2,t3,t4);</span><br><span class="line"><span class="comment">//printf("%d %d\n",mx,mi);</span></span><br><span class="line"><span class="keyword">return</span> mx - mi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n-len+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m-len+<span class="number">1</span>;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = ask(i,j,len);</span><br><span class="line">ans = ans &lt; tmp?ans:tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-二叉堆"><a href="#6-二叉堆" class="headerlink" title="6 二叉堆"></a>6 二叉堆</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左儿子：2*rt+1, 右儿子: 2*rt+2,时间复杂度O(N)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> heap[N];</span><br><span class="line"><span class="keyword">int</span> sz = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//i是自己节点的编号 </span></span><br><span class="line"><span class="keyword">int</span> i = sz++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//p是父亲节点的编号</span></span><br><span class="line"><span class="keyword">int</span> p = (i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(heap[p] &lt;= x) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">heap[i] = heap[p];</span><br><span class="line">i = p; </span><br><span class="line">&#125;</span><br><span class="line">heap[i] = x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = heap[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//要提到根的数值x</span></span><br><span class="line"><span class="keyword">int</span> x = heap[--sz];</span><br><span class="line"><span class="comment">//从根开始向下交换 </span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i*<span class="number">2</span> + <span class="number">1</span> &lt; sz)&#123;</span><br><span class="line"><span class="comment">//左右儿子 </span></span><br><span class="line"><span class="keyword">int</span> a = i*<span class="number">2</span>+<span class="number">1</span>,b = i*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(b &lt; sz &amp;&amp; heap[b] &lt; heap[a]) a = b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(heap[a]  &gt;= x) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">heap[i] = heap[a];</span><br><span class="line">i = a;</span><br><span class="line">&#125;</span><br><span class="line">heap[i] = x;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-单调栈与笛卡尔树"><a href="#7-单调栈与笛卡尔树" class="headerlink" title="7 单调栈与笛卡尔树"></a>7 单调栈与笛卡尔树</h3><p>笛卡尔树（Cartesian Tree）是一种同时满足堆性质和二叉搜索树性质的一棵二叉树。因此笛卡尔树的树根对应着该树的极值（堆性质），并且对其中序遍历得到的是原序列一段连续的区间（二叉搜索树性质）。<br>我们假设利用一个整数序列A：a1~an 建立笛卡尔树，那么树上每个节点有2个键值，idx（下标）和 val（值）。我们使树上每个节点的idx满足二叉搜索树性质，而val满足堆性质，于是笛卡尔树就建成了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],tot = <span class="number">0</span>,n;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function">ll <span class="title">max</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b?b:a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> idx,val;<span class="comment">//下标、权值 </span></span><br><span class="line"><span class="keyword">int</span> l,r,par;<span class="comment">//左儿子、右儿子、父亲节点的编号 </span></span><br><span class="line">Node()&#123;&#125;</span><br><span class="line">Node(<span class="keyword">int</span> idx,<span class="keyword">int</span> val)</span><br><span class="line">:idx(idx),val(val)&#123;</span><br><span class="line">l = r = par = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BuildTree</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> k = i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(t[k].val &gt; t[i].val) k = t[k].par;</span><br><span class="line">t[i].l = t[k].r;<span class="comment">//k的右子树作为i的左子树 </span></span><br><span class="line">t[k].r = i;<span class="comment">//i作为k的右子树 </span></span><br><span class="line">t[i].par = k;<span class="comment">//i的父亲是k </span></span><br><span class="line">t[t[i].l].par = i;<span class="comment">//i的左子树的父亲是i </span></span><br><span class="line"><span class="comment">//printf("%d %d\n",i,k);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t[<span class="number">0</span>].r;<span class="comment">//最终树的根节点的编号 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="comment">//printf("%d\n",rt);</span></span><br><span class="line"><span class="keyword">if</span>(rt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">ll sz = <span class="number">1</span>;</span><br><span class="line">sz += dfs(t[rt].l);</span><br><span class="line">sz += dfs(t[rt].r);</span><br><span class="line">ans = max(ans,sz*(t[rt].val));</span><br><span class="line"><span class="keyword">return</span> sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)</span><br><span class="line">t[i] = Node(i,a[i]);</span><br><span class="line">tot = ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> rt = BuildTree();</span><br><span class="line">dfs(rt);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-CDQ分治"><a href="#8-CDQ分治" class="headerlink" title="8 CDQ分治"></a>8 CDQ分治</h3><h4 id="8-2-二维CDQ分治"><a href="#8-2-二维CDQ分治" class="headerlink" title="8.2 二维CDQ分治"></a>8.2 二维CDQ分治</h4><blockquote><p>给定一个N个元素的序列A，初始值全部为0，对这个序列进行以下两种操作：<br>　　操作1：格式为1 x k，把位置x的元素加上k（位置从1标号到N）。<br>　　操作2：格式为2 x y，求出区间[x,y]内所有元素的和。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Q = N*<span class="number">3</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> type,pos;</span><br><span class="line">    ll val;</span><br><span class="line">    Node(<span class="keyword">int</span> type,<span class="keyword">int</span> pos,ll val):type(type),pos(pos),val(val)&#123;&#125;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == b.pos) <span class="keyword">return</span> type &lt; b.type;</span><br><span class="line">        <span class="keyword">return</span> pos &lt; b.pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> aidx = <span class="number">0</span>,qidx = <span class="number">0</span>;</span><br><span class="line">Node query[Q];</span><br><span class="line">Node tmp[Q];</span><br><span class="line">ll ans[Q];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r<span class="number">-1</span>) <span class="keyword">return</span>;<span class="comment">//左闭右开嘛</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    CDQ(l,mid);</span><br><span class="line">    CDQ(mid,r);</span><br><span class="line">    <span class="keyword">int</span> p = l,q = mid,k = <span class="number">0</span>;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; mid &amp;&amp; q &lt; r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(query[p] &lt; query[q])&#123;</span><br><span class="line">            <span class="keyword">if</span>(query[p].type == <span class="number">1</span>)</span><br><span class="line">                sum += query[p].val;</span><br><span class="line">            tmp[k++] = query[p++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> x = query[q].val;</span><br><span class="line">            <span class="keyword">if</span>(query[q].type == <span class="number">2</span>)</span><br><span class="line">                ans[x] -= sum;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(query[q].type == <span class="number">3</span>)</span><br><span class="line">                ans[x] += sum;</span><br><span class="line">            tmp[k++] = query[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; mid) tmp[k++] = query[p++];<span class="comment">//这里不用再累加修改的值，因为用不到了啊 </span></span><br><span class="line">    <span class="keyword">while</span>(q &lt; r)&#123;</span><br><span class="line">    <span class="comment">//这里还需将我们累加的结果进行运算，我们规定就是要累加左区间，查询右区间嘛 </span></span><br><span class="line">        <span class="keyword">int</span> x = query[q].val;</span><br><span class="line">        <span class="keyword">if</span>(query[q].type == <span class="number">2</span>)</span><br><span class="line">            ans[x] -= sum;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(query[q].type == <span class="number">3</span>)</span><br><span class="line">            ans[x] += sum;</span><br><span class="line">        tmp[k++] = query[q++];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++)</span><br><span class="line">        query[i+l] = tmp[i]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        query[qidx++] = Node(<span class="number">1</span>,i,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span>)&#123;</span><br><span class="line">            query[qidx++] = Node(a,b,c);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            query[qidx++] = Node(<span class="number">2</span>,b<span class="number">-1</span>,aidx);</span><br><span class="line">            query[qidx++] = Node(<span class="number">3</span>,c,aidx);</span><br><span class="line">            aidx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CDQ(<span class="number">0</span>,qidx);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; aidx;i++) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-三维CDQ分治"><a href="#8-2-三维CDQ分治" class="headerlink" title="8.2 三维CDQ分治"></a>8.2 三维CDQ分治</h4><p>&emsp;&emsp;在二维偏序问题拓展中，我们利用二维有序当作索引，来查找想要的结果。类似的，我们可不可以用三维有序对来当下标，找寻想要的答案集合T呢？<br><strong>例题：</strong> </p><blockquote><p>&emsp;&emsp;平面上有N个点，每个点的横纵坐标在[0,1e7]之间，有M个询问，每个询问为查询在指定矩形之内有多少个点，矩形用(x1,y1,x2,y2)的方式给出，其中(x1,y1)为左下角坐标，(x2,y2)为右上角坐标。</p></blockquote><p><strong>解题思路：</strong><br>&emsp;&emsp;我们同样将查询区间内点数量分成四个求前缀和操作（这里需要用容斥原理）。将平面上点看成插入操作，查询矩形内点个数看成查询操作。那么对于每个操作，有<time , x y>三个维度作为索引（或者下标），又因为time是默认有序的，所以我们需要根据x归并，同时用树状数组维护y的前缀和。我们按照CDQ分治的思想，统计左边区间节点对右边区间查询的贡献。（这里所说的左右区间概念引自归并排序）详细思想请对照代码。<br><strong>代码示例：</strong> </time></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BZOJ1935</span></span><br><span class="line"><span class="comment">单点修改，区间查询</span></span><br><span class="line"><span class="comment">CDQ+树状数组 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">50</span>;<span class="comment">//最大节点数量 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> op,x,y,val;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">op = 1是修改值操作，2是减去前缀和操作，3是加上前缀和操作</span></span><br><span class="line"><span class="comment">x、y代表坐标</span></span><br><span class="line"><span class="comment">val有两重用法， 当是修改值操作时，val代表要修改的值； </span></span><br><span class="line"><span class="comment">当表示求前缀和操作时，val代表答案数组ans的下标（因为最终结果要累加） </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node &amp;B) <span class="keyword">const</span>&#123; </span><br><span class="line"><span class="comment">//x为第一关键字，y为第二关键字，op为第三关键字，升序排序 </span></span><br><span class="line"><span class="keyword">if</span>(x == B.x)&#123;</span><br><span class="line"><span class="keyword">if</span>(y == B.y) <span class="keyword">return</span> op &lt; B.op;</span><br><span class="line"> <span class="keyword">return</span> y &lt; B.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x &lt; B.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数，无参的用来创建数组，有参的用来快速赋值 </span></span><br><span class="line">Node()&#123;&#125;</span><br><span class="line">Node(<span class="keyword">int</span> op,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> val):op(op),x(x),y(y),val(val)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node Q[<span class="number">7</span>*N];<span class="comment">//为啥是7倍，因为每个查询操作被分成四个子操作了嘛 </span></span><br><span class="line">Node tmp[<span class="number">7</span>*N];</span><br><span class="line"><span class="keyword">int</span> ans[N],st[<span class="number">10100000</span>];<span class="comment">//树状数组没开离散化，当然如果范围再大点就要开了 </span></span><br><span class="line"><span class="keyword">int</span> qidx = <span class="number">0</span>,aidx = <span class="number">2</span>;<span class="comment">//分别代表查询集合Q和答案集合ans的下标 </span></span><br><span class="line"><span class="comment">//以下俩个函数是树状数组的函数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;x &lt; N;x += x&amp;-x) st[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x) sum += st[x];</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CDQ分治的用法 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(r-l &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">solve(l,mid);</span><br><span class="line">solve(mid,r);</span><br><span class="line"><span class="keyword">int</span> p = l,q = mid,k = l;</span><br><span class="line"><span class="keyword">while</span>(p &lt; mid &amp;&amp; q &lt; r)&#123;</span><br><span class="line"><span class="keyword">if</span>(Q[p] &lt; Q[q])&#123;</span><br><span class="line"><span class="keyword">if</span>(Q[p].op == <span class="number">1</span>) add(Q[p].y,Q[p].val);</span><br><span class="line">tmp[k++] = Q[p++];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q[q].op == <span class="number">2</span>)  ans[Q[q].val] -= ask(Q[q].y);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Q[q].op == <span class="number">3</span>)ans[Q[q].val] += ask(Q[q].y);</span><br><span class="line">tmp[k++] = Q[q++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(q &lt; r)&#123;</span><br><span class="line"><span class="keyword">if</span>(Q[q].op == <span class="number">2</span>)  ans[Q[q].val] -= ask(Q[q].y);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Q[q].op == <span class="number">3</span>) ans[Q[q].val] += ask(Q[q].y);</span><br><span class="line">tmp[k++] = Q[q++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们用这种方法来清空树状数组，可以节省时间 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt; p;i++)</span><br><span class="line"><span class="keyword">if</span>(Q[i].op == <span class="number">1</span>) add(Q[i].y,-Q[i].val);</span><br><span class="line"><span class="keyword">while</span>(p &lt; mid) tmp[k++] = Q[p++];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt; r;i++) Q[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">Q[qidx++] = Node(<span class="number">1</span>,x+<span class="number">1</span>,y+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">Q[qidx++] = Node(<span class="number">3</span>,x1,y1,aidx);</span><br><span class="line">Q[qidx++] = Node(<span class="number">2</span>,x1,y2+<span class="number">1</span>,aidx);</span><br><span class="line">Q[qidx++] = Node(<span class="number">2</span>,x2+<span class="number">1</span>,y1,aidx);</span><br><span class="line">Q[qidx++] = Node(<span class="number">3</span>,x2+<span class="number">1</span>,y2+<span class="number">1</span>,aidx++);</span><br><span class="line">&#125;</span><br><span class="line">solve(<span class="number">0</span>,qidx);<span class="comment">//依旧左闭右开 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; aidx;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础数据结构&quot;&gt;&lt;a href=&quot;#基础数据结构&quot; class=&quot;headerlink&quot; title=&quot;基础数据结构&quot;&gt;&lt;/a&gt;基础数据结构&lt;/h2&gt;&lt;h3 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="ValenShi的ACM模板" scheme="http://valenshi.top/categories/ValenShi%E7%9A%84ACM%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
</feed>
