<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ValenShi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://valenshi.top/"/>
  <updated>2020-02-16T02:48:57.602Z</updated>
  <id>http://valenshi.top/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>长链剖分</title>
    <link href="http://valenshi.top/2020/02/16/dsu/"/>
    <id>http://valenshi.top/2020/02/16/dsu/</id>
    <published>2020-02-16T02:48:15.000Z</published>
    <updated>2020-02-16T02:48:57.602Z</updated>
    
    <content type="html"><![CDATA[<h4 id="长链剖分"><a href="#长链剖分" class="headerlink" title="长链剖分"></a>长链剖分</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>长链剖分属于树链剖分的一种，可以把维护子树中只与深度有关的信息做到线性时间。</p><p>一般的树链剖分是指剖分轻重链，其依据子节点的个数进行剖分，可以使得我们可以在任意一个点向上跳跃不超过 log 次就能到达根节点，从而可以高效维护两点之间的链的信息。</p><p>而长链剖分则是依据子树的深度进行剖分，深度最大的作为重儿子，这样原树就可以被分成若干条互不重复的链，并且保证了重链尽量长。因此长链剖分可以维护树中和深度有关的信息。</p><h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><p>在长链剖分中，我们常用如下几个数组：</p><blockquote><p>par[x] : x 在树中的父亲。<br>deep[x]：x 在树中的深度。<br>len[x]：x 为根的子树最大深度。<br>son[x]：x 的重儿子，即u-&gt;son[u]为重边。<br>top[x]：x 所在重路径的顶部节点（深度最小）。</p></blockquote><p>这些数组可以通过一次 dfs 来更新。通过定义可知，如果 top[x] = x，那么 x 就是一条长（重）链的起点，此时 len[x] 就是该链的长度（节点数目）。</p><p>更新代码可以这样来写：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line">dfs(ver[i]);</span><br><span class="line"><span class="keyword">if</span>(len[son[x]] &lt; len[ver[i]]) son[x] = ver[i];</span><br><span class="line">&#125;</span><br><span class="line">len[x] = len[son[x]]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;<span class="comment">//也可以不更新top数组，在此直接压入q1</span></span><br><span class="line"><span class="keyword">if</span>(ver[i] == son[x]) top[son[x]] = top[x];</span><br><span class="line"><span class="keyword">else</span> top[ver[i]] = ver[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码是基于邻接表存储‘单向边构成的有根树’，如果是无根树则需加个标记位来防止重复访问。</p><h5 id="长链剖分的性质"><a href="#长链剖分的性质" class="headerlink" title="长链剖分的性质"></a>长链剖分的性质</h5><p><strong>性质一：</strong> 所有的链的长度之和是 O（N）级别</p><blockquote><p>证明：所有点在且仅在一条长（重）链之中，永远只会被计算一次，所以总长度与 N 成正比</p></blockquote><p><strong>性质二：</strong> 从任意一个点向上跳跃的次数最多 $\sqrt N$ 次。</p><blockquote><p>证明：按照定义，节点 y 的父亲 x 所在的重链的长度一定是不小于 y 所在的重链的，我们知道所有重链的长度之和是 O(N)级别，所以最坏情况就是 1+2+3+…+$\sqrt n$<br>，所以最多跳 $\sqrt N$次</p></blockquote><h4 id="例题应用"><a href="#例题应用" class="headerlink" title="例题应用"></a>例题应用</h4><h5 id="BAPC2019-A-Appeal-to-the-Audience"><a href="#BAPC2019-A-Appeal-to-the-Audience" class="headerlink" title="BAPC2019 A.Appeal to the Audience"></a>BAPC2019 A.Appeal to the Audience</h5><p><strong>题意简述</strong><br>给定一棵有 k 个叶子节点的二叉树，所有非叶子节点的值等于其左右儿子的最大值，现在给定 k 个整数，求把它们分配在 k 个叶子上，使得整颗树的总权值最大（总权值 = 除根节点外所有节点的权值和）</p><p><strong>解题思路</strong><br>要想使得总和最大，就要使最大值被计算的次数最多。要想某个数被计算的多，就要使得它经过尽量多的节点。于是我们的目标就是找到 k 条从长到短的链，这些链互不重合，且一端是叶子节点。</p><p>可以通过长链剖分来将这棵树分为 k 条互不相交的长链，然后按照长度分配元素（长度越大，分配给它的元素值越大）。</p><p><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">/* 邻接表代码 */</span></span><br><span class="line"><span class="keyword">int</span> head[N],nex[M],ver[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 快读代码 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &gt; <span class="string">'9'</span> || c &lt; <span class="string">'0'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len[N],son[N],top[N];</span><br><span class="line"><span class="comment">//依次为当前子树最大深度、重儿子编号、当前链顶节点编号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line">dfs(ver[i]);</span><br><span class="line"><span class="keyword">if</span>(len[son[x]] &lt; len[ver[i]]) son[x] = ver[i];</span><br><span class="line">&#125;</span><br><span class="line">len[x] = len[son[x]]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;<span class="comment">//也可以不更新top数组，在此直接压入q1</span></span><br><span class="line"><span class="keyword">if</span>(ver[i] == son[x]) top[son[x]] = top[x];</span><br><span class="line"><span class="keyword">else</span> top[ver[i]] = ver[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,k,a[N];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line">priority_queue&lt;ll&gt; q1,q2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">top[<span class="number">1</span>] = <span class="number">1</span>; dfs(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) </span><br><span class="line"><span class="keyword">if</span>(top[i] == i) q1.push(len[i]);</span><br><span class="line">q1.push(len[<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span>(q1.size())&#123;</span><br><span class="line">ans += <span class="number">1l</span>l * q1.top() * q2.top();</span><br><span class="line">q1.pop(); q2.pop();</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = getInt(); k = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= k;i++) x = getInt(),q2.push(x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,y;i &lt;= n;i++) y = getInt(), addEdge(y+<span class="number">1</span>,i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Dominant-Indices"><a href="#Dominant-Indices" class="headerlink" title="Dominant Indices"></a>Dominant Indices</h5><p><a href="http://codeforces.com/problemset/problem/1009/F" target="_blank" rel="noopener">测试地址</a></p><p><strong>题意简述</strong><br>给定一颗编号为 1~n 的有根树，根节点编号为 1 。设 $d_{x,i}$ 表示以 x 为根的子树中，距 x 为 i 的节点的数目。求出对于每个节点 x，使 $d_{x,i}$ 最大的 i ，若有多种可能，则输出最小的 i。</p><p><strong>解题思路</strong><br>这道题刚开始以为就是 dfs，但是 dfs 中转移的时间太高了。看题解是用指针数组（* f[N]）来实现 O(1) 时间复杂度内转移的，其效率是由指针的赋值很快保证的，其正确性是由 f[x] = f[son[x] ] + 1 来保证的，即</p><blockquote><p>若 tmp[x, j] 表示距离 x 为 j 的节点数目，那么显然tmp[x, j] = tmp[son[x] , j-1]，其中 1 &lt;= j &lt;= n， 所以直接将 tmp[son[x] ] + 1 赋值给 tmp[ x ] 即可。<br>而我们这里用 dfs 从下往上更新，所以更新到 x 时， son[x] 已经计算完成，它的数据就没必要特意保存，所以即使用指针会修改原数据也无所谓。</p></blockquote><p>不过虽然转移的效率很高，但是回溯的过程中还需要合并，如果我们对每个子树都暴力合并的话，时间复杂度还是很高（主要是因为我们每次只能利用指针 O(1) 转移一次，所以要选最长的转移才最划算），所以我们可以用长链剖分，先将当前子树 x 所有的值合并到 x 所在在重链（长链）上，这样每次合并的次数等于短链的长度，然后只要通过 O(1) 转移长链即可。这样等同于每个点都合并了一次，所以总的时间复杂度为 O(N) 。</p><p><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span> + c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,len[N],son[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(ver[i] == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs(ver[i],x);</span><br><span class="line"><span class="keyword">if</span>(len[son[x]] &lt; len[ver[i]]) son[x] = ver[i];</span><br><span class="line">&#125;</span><br><span class="line">len[x] = len[son[x]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans[N],*f[N],tmp[N],*idx = tmp;</span><br><span class="line"><span class="comment">//f 数组是指针数组，可以利用偏移量实现 O(1) 转移,而 idx 代表当前在 tmp 数组的起点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">f[x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(son[x]) f[son[x]] = f[x]+<span class="number">1</span>, DP(son[x],x), ans[x] = ans[son[x]]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(y == fa || y == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">f[y] = idx; idx += len[y]; DP(y,x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= len[y];j++)&#123;</span><br><span class="line">f[x][j] += f[y][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>((j &lt; ans[x] &amp;&amp; f[x][j] &gt;= f[x][ans[x]]) || (j &gt; ans[x] &amp;&amp; f[x][j] &gt; f[x][ans[x]]))</span><br><span class="line">ans[x] = j;<span class="comment">//这里的判断句要保证取f[x][ans[x]]是最大值,且ans[x]尽量小</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f[x][ans[x]] == <span class="number">1</span>) ans[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>); </span><br><span class="line">f[<span class="number">1</span>] = idx; idx += len[<span class="number">1</span>];</span><br><span class="line">DP(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.cnblogs.com/zhoushuyu/p/9468669.html" target="_blank" rel="noopener">租酥雨的博客</a></li><li><a href="https://www.cnblogs.com/cjyyb/p/9479258.html" target="_blank" rel="noopener">yyb的博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;长链剖分&quot;&gt;&lt;a href=&quot;#长链剖分&quot; class=&quot;headerlink&quot; title=&quot;长链剖分&quot;&gt;&lt;/a&gt;长链剖分&lt;/h4&gt;&lt;h5 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="树链剖分" scheme="http://valenshi.top/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>Leanote与mongodb布置总结</title>
    <link href="http://valenshi.top/2020/02/14/leanote/"/>
    <id>http://valenshi.top/2020/02/14/leanote/</id>
    <published>2020-02-14T11:57:25.000Z</published>
    <updated>2020-02-14T11:57:53.022Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h4><p>Leanote 是一款类似于印象笔记的开源的笔记项目，具体介绍请访问 <a href="https://github.com/leanote/leanote" target="_blank" rel="noopener">Github</a> 该项目。</p><p>在 Github 上该项目有着详细的中文版的介绍以及安装步骤，但是由于 Linux 不熟练，我还是遇到了如下问题：</p><ol><li>虽然根据说明可以成功部署并运行，但是一旦断开会话或关闭终端，mongodb 与 leanote 都会停止工作。</li><li>如何用 fork 命令使得 mongodb 在后台运行。</li><li>如何使用 nohup 命令使得 run.sh 脚本在后台运行。</li><li>如何编写一个 shell 脚本来实现开机自启、一键启动、停止。</li></ol><p>本文主要目的是总结在 Linux 环境下工作的经验，详细记录刚掌握的知识点。</p><h4 id="mongodb-与非关系型数据库"><a href="#mongodb-与非关系型数据库" class="headerlink" title="mongodb 与非关系型数据库"></a>mongodb 与非关系型数据库</h4><p>mongodb 是非关系型数据库的一种，与 MySql 等关系型数据库相比，它的特点有：</p><ol><li>高并发，读写能力强</li><li>弱化数据结构一致性，使用更加灵活</li><li>有良好的拓展性（mysql 等很难横向拓展）</li><li>通用性差 , 没有 sql 语句那样通用的语句             </li><li>操作灵活导致容易出错和混乱             </li><li>没有外键关联等复杂的操作</li></ol><p>总的来说，关系型数据库（mysql）适合存储结构化数据，例如：用户账号、地址等信息；而非关系型数据库适合存储非结构化的数据，例如：文章、评论等。更加具体的区别与用法不做展开。</p><p>总的来说，mongodb 上手轻松，使用简单，而本文用到的指令仅仅三四个。</p><h5 id="mongodb-的安装与配置"><a href="#mongodb-的安装与配置" class="headerlink" title="mongodb 的安装与配置"></a>mongodb 的安装与配置</h5><p>首先去 <a href="http://www.mongodb.org/downloads" target="_blank" rel="noopener">mongodb官网</a> 下载压缩包，或者点击下载<a href="https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.1.tgz" target="_blank" rel="noopener">mongodb-linux-x86_64-3.0.1.tgz</a>。</p><p>下载完成后，只需做两步工作：解压与配置环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; tar -xzvf mongodb-linux-x86_64-3.0.1.tgz/</span><br></pre></td></tr></table></figure></p><p>为了快速使用 mongodb 命令, 可以配置环境变量。编辑 ~/.profile 或 /etc/profile 文件， 将 mongodb/bin 路径加入即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; sudo vim /etc/profile</span><br></pre></td></tr></table></figure></p><p>在 /etc/profile 中添加以下行，注意把用户名（user1）和相应的文件目录名（mongodb-linux-x86_64-3.0.1）替换成自己系统中的名称：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/home/user1/mongodb-linux-x86_64-3.0.1/bin</span><br></pre></td></tr></table></figure></p><p>保存修改后，在终端运行以下命令使环境变量生效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; source /etc/profile</span><br></pre></td></tr></table></figure></p><h5 id="测试-mongodb-安装"><a href="#测试-mongodb-安装" class="headerlink" title="测试 mongodb 安装"></a>测试 mongodb 安装</h5><p>先在 /home/user1 下新建一个目录 data 存放 mongodb 数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/user1/data</span><br></pre></td></tr></table></figure></p><p>用以下命令启动 mongodb：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --dbpath /home/user1/data</span><br></pre></td></tr></table></figure></p><p>这时 mongod 已经启动，<strong>重新打开</strong>一个终端, 键入 mongo 进入交互程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&gt; mongo</span><br><span class="line">&gt; show dbs</span><br><span class="line">...数据库列表</span><br></pre></td></tr></table></figure></p><p>至此 mongodb 就安装完成。</p><h4 id="使-mongodb-和-leanote-在后台运行"><a href="#使-mongodb-和-leanote-在后台运行" class="headerlink" title="使 mongodb 和 leanote 在后台运行"></a>使 mongodb 和 leanote 在后台运行</h4><p>由于按照 github 上的 leanote 安装说明，mongodb 和 leanote 是会随着会话和终端的关闭而停止运行，现在的目的是使它们不受会话关闭的影响，在后台运行。</p><p>我们可以时使用 <code>nohup command &gt;/dev/null 2&gt;&amp;1 &amp;</code> 命令来使得 mongodb 和 leanote 在后台运行。</p><p>对于 mongodb ，我们还可以配置 config 文件，通过在启动 mongod 时指定配置文件来实现后台运行，配置文件 mongodb.conf 内容如下：（路径需要自己修改）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#数据库路径</span><br><span class="line">dbpath=/usr/local/mongodb/data</span><br><span class="line">#日志输出文件路径</span><br><span class="line">logpath=/usr/local/mongodb/logs/mongodb.log</span><br><span class="line">#错误日志采用追加模式</span><br><span class="line">logappend=true</span><br><span class="line">#启用日志文件，默认启用</span><br><span class="line">journal=true</span><br><span class="line">#这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false</span><br><span class="line">quiet=true</span><br><span class="line">#端口号 默认为27017</span><br><span class="line">port=27017</span><br><span class="line">#允许远程访问</span><br><span class="line">#bind_ip=0.0.0.0</span><br><span class="line">#开启子进程</span><br><span class="line">fork=true</span><br><span class="line">#开启认证，必选先添加用户</span><br><span class="line">auth=true</span><br></pre></td></tr></table></figure><p>此时在 mongodb.conf 同一目录下执行 <code>mongod --conf mongodb.conf</code> 即可在后台启动数据库，此时可以通过 mongo 来访问数据库。<br>需要注意的是，mongod 命令不会帮你创建文件夹，所以 data 以及 logs 等目录是需要创建好再填写的，否则会报错 <code>ERROR: child process failed, exited with error number 1</code> 。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>至此已经可以较为简便的实现 mongod 与 leanote 的后台运行，并且每次服务器重启后我们都可以通过两条命令来启动。本次实践新接触了一个非关系型数据库 mongod 以及一些 linux 命令，下面目标是可以通过编写 Shell 脚本来使得工作更加简化，例如实现开机自启等。</p><p>本文不是教程，是笔记，当然如果已经成功搭建了 leanote ，想要使其在后台运行，还是可以参考本文的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h4&gt;&lt;p&gt;Leanote 是一款类似于印象笔记的开源的笔记项目，具体介绍请访问 &lt;a href=&quot;https://github.com
      
    
    </summary>
    
      <category term="Linux" scheme="http://valenshi.top/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Liunx 使进程在后台运行的几种方法</title>
    <link href="http://valenshi.top/2020/02/14/nohup/"/>
    <id>http://valenshi.top/2020/02/14/nohup/</id>
    <published>2020-02-14T10:33:06.000Z</published>
    <updated>2020-02-14T10:34:00.022Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Liunx-使进程在后台运行的几种方法"><a href="#Liunx-使进程在后台运行的几种方法" class="headerlink" title="Liunx 使进程在后台运行的几种方法"></a>Liunx 使进程在后台运行的几种方法</h4><p>现在有如下两个目标：</p><ul><li>使进程让出前台终端，让我们可以继续通过终端与系统进行交互。</li><li>使进程不再受终端关闭的影响，即系统在终端关闭后不再向进程发送 SIGHUP 信号或即使发送了信号程序也不会退出。</li></ul><p>首先要明白什么是进程、进程组、会话、终端、作业等名词。</p><h5 id="为什么进程会被终止"><a href="#为什么进程会被终止" class="headerlink" title="为什么进程会被终止"></a>为什么进程会被终止</h5><p>用户注销或者网络断开时，SIGHUP 信号会被发送到会话所属的子进程，而 SIGHUP 的默认处理方式是终止收到该信号的进程。所以若程序中没有捕捉该信号，当终端关闭后，会话所属进程就会退出。</p><h5 id="利用-amp-符号"><a href="#利用-amp-符号" class="headerlink" title="利用 &amp; 符号"></a>利用 &amp; 符号</h5><p>将 &amp; 附在命令后面可以使进程在后台执行，不占用前台界面。它实际上是在会话中开启了一个后台作业，但是此时如果终端被关闭了，进程还是会退出，这是因为 &amp; 只有让进程退出前台终端的功能，无法让进程不受 SIGHUP 的影响。</p><h5 id="nohup-命令"><a href="#nohup-命令" class="headerlink" title="nohup 命令"></a>nohup 命令</h5><p>nohup 可以使得进程不受 SIGHUP 信号的影响，但是执行<code>nohup php test.php</code> 后会发现，进程还是会一直占用着前台终端，不过此时如果终端被关闭或连接断开，程序还是会继续执行。另外此时当前文件夹还会多出一个 nohup.out 文件。</p><p>这是因为 nohup 仅仅让进程不受 SIGHUP 信号影响，并不会让出前台，而且它还会在命令执行的目录下生成 nohup.out 用于存储进程输出。如果不需要输出，且不想创建 nohup.out 文件，可以将标准输出和标准错误重定向。</p><p>我们常将 &amp; 和 nohup 搭配一起使用，执行命令如下：<code>nohup command &gt;/dev/null 2&gt;&amp;1 &amp;</code> ，这样就可以既不占用前台，又不会受 SIGHUP 信号影响，同时也不会创建输出文件。</p><h5 id="setsid-命令"><a href="#setsid-命令" class="headerlink" title="setsid 命令"></a>setsid 命令</h5><p>setsid 是另一个让进程在后台执行的命令，它的作用是让进程打开一个新的会话并运行进程，使用方式为 setsid command。</p><p>前面的做法都是使得进程忽略 SIGHUP 信号的影响，而 setsid 则干脆让进程新打开一个会话并在其中运行，那么原会话终端状态就不会影响该进程了。不过 setsid 并没有为进程分配一个输出终端，所以进程还是会输出到当前终端上。</p><p>不过 setsid 在 shell 脚本中表现的会有不同，具体可另行查找资料。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>除了上述做法之外，还可以利用 screen ，tmux 等会话工具来实现进程的后台运行，这里不做介绍。<br>本文主要解决了如何使进程不受终端和会话的影响，通过忽视 SIGHUB 信号从而实现在后台运行，上述的每个命令用法可能并不仅仅如此，并没有展开介绍每个命令的所有用法。同时本文介绍也仅仅是所有方案中的一部分。</p><p>参考资料：<a href="http://www.sohu.com/a/306275405_760387" target="_blank" rel="noopener">让 Linux 进程在后台可靠运行的几种方法 </a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Liunx-使进程在后台运行的几种方法&quot;&gt;&lt;a href=&quot;#Liunx-使进程在后台运行的几种方法&quot; class=&quot;headerlink&quot; title=&quot;Liunx 使进程在后台运行的几种方法&quot;&gt;&lt;/a&gt;Liunx 使进程在后台运行的几种方法&lt;/h4&gt;&lt;p&gt;现在
      
    
    </summary>
    
      <category term="Linux" scheme="http://valenshi.top/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>USACO 2019 December Contest, Silver 题解</title>
    <link href="http://valenshi.top/2019/12/17/usaco2019de/"/>
    <id>http://valenshi.top/2019/12/17/usaco2019de/</id>
    <published>2019-12-17T12:07:25.000Z</published>
    <updated>2019-12-17T12:09:03.975Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-MooBuzz"><a href="#1-MooBuzz" class="headerlink" title="1.MooBuzz"></a>1.MooBuzz</h4><h5 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h5><p>Farmer John 的奶牛们最近成为了一个简单的数字游戏“FizzBuzz”的狂热玩家。这个游戏的规则很简单：奶牛们站成一圈，依次从一开始报数，每头奶牛在轮到她的时候报一个数。如果一头奶牛将要报的数字是 3 的倍数，她应当报“Fizz”来代替这个数。如果一头奶牛将要报的数字是 5 的倍数，她应当报“Buzz”来代替这个数。如果一头奶牛将要报的数字是 15 的倍数，她应当报“FizzBuzz”来代替这个数。于是这个游戏的开始部分的记录为：<br>1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16</p><p>由于词汇的匮乏，奶牛们玩的 FizzBuzz 中用“Moo”代替了 Fizz、Buzz、FizzBuzz。于是奶牛版的游戏的开始部分的记录为：</p><p>1, 2, Moo, 4, Moo, Moo, 7, 8, Moo, Moo, 11, Moo, 13, 14, Moo, 16</p><p>给定 N（1≤N≤1e9），请求出这个游戏中第 N 个被报的数。</p><h5 id="A-possible-solution"><a href="#A-possible-solution" class="headerlink" title="A possible solution"></a>A possible solution</h5><p>利用容斥原理+二分判断。我们假设 n 个数里共有 cnt 个被跳过的数，那么报的第 n 个数就是 n+cnt ，由于 n 和 cnt 都具有单调性，所以我们可以利用二分判定来解决。<br>其中容斥原理很容易想到，cnt 显然等于 n 内 3 的倍数 + 5 的倍数 +15的倍数，但是15 = 3 * 5，所以15不需要重复统计（已经在 3 的倍数中统计过了）。但是我们重复统计了 3 和 5 的公倍数（统计了 2 次），于是我们就要减去同时是 3 的倍数和 5 的倍数 的 个数即可得到cnt。<br>在O(1)时间内求出cnt后，我们就可以在O(logN)时间内用二分搜索解决此题。</p><h5 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">int</span> tn;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">ll a = n/<span class="number">3</span>, b = n/<span class="number">5</span>;</span><br><span class="line">ll c = n/<span class="number">15</span>;</span><br><span class="line">ll cnt = a + b - c;</span><br><span class="line"><span class="keyword">return</span> n-cnt &gt;= tn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"moobuzz.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"moobuzz.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; tn ;</span><br><span class="line">ll l = <span class="number">1</span>,r = INF;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">ll mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Meetings"><a href="#2-Meetings" class="headerlink" title="2.Meetings"></a>2.Meetings</h4><h5 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h5><p>有两个牛棚位于一维数轴上的点 0 和 L 处（1≤L≤1e9）。同时有 N 头奶牛（1≤N≤5e4）位于数轴上不同的位置（将牛棚和奶牛看作点）。每头奶牛 i 初始时位于某个位置 xi，并朝着正向或负向以一个单位每秒的速度移动，用一个等于 1 或 −1 的整数 di 表示。每头奶牛还拥有一个在范围 [1,1e3] 内的重量。所有奶牛始终以恒定的速度移动，直到以下事件之一发生：<br>如果奶牛 i 移动到了一个牛棚，则奶牛 i 停止移动。<br>当奶牛 i 和 j 占据了相同的点的时候，并且这一点不是一个牛棚，则发生了相遇。此时，奶牛 i 被赋予奶牛 j 先前的速度，反之亦然。注意奶牛可能在一个非整数点相遇。<br>令 T 等于停止移动的奶牛（由于到达两个牛棚之一）的重量之和至少等于所有奶牛的重量之和的一半的最早时刻。请求出在时刻 0…T（包括时刻T）之间发生的奶牛对相遇的总数。</p><h5 id="A-possible-solution-1"><a href="#A-possible-solution-1" class="headerlink" title="A possible solution"></a>A possible solution</h5><p>这道题与 Ants 那题类似。如果不考虑重量，那么我们可以忽略每头牛的个性，从整体来看，如果两头牛相遇可以看作他们“穿过”对方并继续前进；如果每头牛有不同的重量，那么它们就有了个性，不能再等价于“穿过”对方。<br>这个时候我们可以从两个角度来考虑：</p><ol><li>首先如果有 x 头牛回窝，那么一定是靠近端点的 x 头牛。原因很简单，这是一个一维的空间，前面的牛不回窝后面的就会被堵住过不去。所以每个端点回窝的重量顺序就确定了。</li><li>在 t 时刻内，一头牛只可能和与他迎面走来的 2 <em> t 距离内的牛相遇。这个时候我们不需要考虑重量，所以每个牛可以看作“穿过”相遇的对方继续前进，那么显然 t 时刻内这两头牛相向而行 2 </em> t 的距离。</li></ol><p>通过第一个推论我们可以求出 T （二分或者优先队列），通过第二个推论我们可以根据 T 来求出相遇的牛的总数。</p><h5 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,l;</span><br><span class="line">ll sum;</span><br><span class="line"><span class="keyword">int</span> w[N],px[N],d[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="comment">//t时刻到家的重量是否达到一半</span></span><br><span class="line"><span class="keyword">int</span> tw = <span class="number">0</span>, c1 = <span class="number">0</span>, c2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(d[i] == <span class="number">1</span> &amp;&amp; l - px[i] &lt;= t) c1++;</span><br><span class="line"><span class="keyword">if</span>(d[i] == <span class="number">-1</span> &amp;&amp; px[i] &lt;= t) c2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c2;i++) tw += w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt; n-c1;i--) tw += w[i];</span><br><span class="line"><span class="comment">//printf("%d %d %d %d %d\n",t,c1,c2,tw,sum);</span></span><br><span class="line"><span class="keyword">return</span> tw*<span class="number">2</span> &lt; sum;</span><br><span class="line">&#125;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>,r = tot;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid] &gt;= x) r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; " " &lt;&lt; l &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(ll t)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">//相遇次数</span></span><br><span class="line">tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(d[i] == <span class="number">-1</span>) a[++tot] = px[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(d[i] == <span class="number">1</span>) res += bsearch(px[i]+<span class="number">2</span>*t+<span class="number">1</span>) - bsearch(px[i]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> w,x,d;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; rhs) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt; rhs.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;nodes[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"meetings.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"meetings.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;l);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;nodes[i].w,&amp;nodes[i].x,&amp;nodes[i].d);</span><br><span class="line">sort(nodes+<span class="number">1</span>,nodes+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) w[i] = nodes[i].w,px[i] = nodes[i].x,d[i] = nodes[i].d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) sum += w[i];</span><br><span class="line"><span class="keyword">int</span> tl = <span class="number">0</span>,tr = l; </span><br><span class="line"><span class="keyword">while</span>(tl &lt;= tr)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = tl+tr&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) tl = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> tr = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; l &lt;&lt; endl;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,calc(tl));<span class="comment">//计算 l 秒内碰头次数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Milk-Visits"><a href="#3-Milk-Visits" class="headerlink" title="3.Milk Visits"></a>3.Milk Visits</h4><h5 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h5><p>Farmer John 计划建造 N（1≤N≤1e5）个农场，用 N−1 条道路连接，构成一棵树（也就是说，所有农场之间都互相可以到达，并且没有环）。每个农场有一头奶牛，品种为更赛牛或荷斯坦牛之一。<br>Farmer John 的 M 个朋友（1≤M≤1e5）经常前来拜访他。在朋友 i 拜访之时，Farmer John 会与他的朋友沿着从农场 Ai 到农场 Bi 之间的唯一路径行走（可能有 Ai=Bi）。除此之外，他们还可以品尝他们经过的路径上任意一头奶牛的牛奶。由于 Farmer John 的朋友们大多数也是农场主，他们对牛奶有着极强的偏好。他的有些朋友只喝更赛牛的牛奶，其余的只喝荷斯坦牛的牛奶。任何 Farmer John 的朋友只有在他们访问时能喝到他们偏好的牛奶才会高兴。</p><p>请求出每个朋友在拜访过后是否会高兴。</p><h5 id="A-possible-solution-2"><a href="#A-possible-solution-2" class="headerlink" title="A possible solution"></a>A possible solution</h5><p>一条道路只有 3 种情况，全是 H 牛，全是 G 牛或者两者兼有。那么如果节点 x 是 H 牛我们就令其w =  -1，如果是 G 牛就等于1。那么这一段路径上所有点的 w 相加，如果等于 d，就说明全是G牛；如果等于 -d，就说明全是 H 牛；否则就说明两者都有。<br>至于快速求两点间距离可以用倍增求LCA。</p><h5 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">char</span> ty[N];</span><br><span class="line"><span class="keyword">int</span> n,m,w[N];</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dis[N],anc[N][<span class="number">25</span>],dep[N],sum[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++) </span><br><span class="line">anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(dis[y] || y == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">dis[y] = dis[x] + z;</span><br><span class="line">anc[y][<span class="number">0</span>] = x;</span><br><span class="line">sum[y] = sum[x] + w[y];</span><br><span class="line">dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[x] &lt; dep[y]) swap(x,y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(dep[anc[x][i]] &gt;= dep[y]) x = anc[x][i];</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(anc[x][i] != anc[y][i])&#123;</span><br><span class="line">x = anc[x][i]; y = anc[y][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"milkvisits.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"milkvisits.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,ty+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line"><span class="keyword">if</span>(ty[i] == <span class="string">'G'</span>) w[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> w[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y,<span class="number">1</span>); addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">dep[<span class="number">0</span>] = <span class="number">-1</span>; dfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;x,&amp;y,s);</span><br><span class="line"><span class="keyword">int</span> fa = lca(x,y);</span><br><span class="line"><span class="keyword">int</span> d = dis[x]+dis[y] - <span class="number">2</span>*dis[fa] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sw = sum[x]+sum[y] - <span class="number">2</span>*sum[fa]+w[fa];</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'H'</span> &amp;&amp; sw != d) <span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'G'</span> &amp;&amp; sw != -d) <span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-MooBuzz&quot;&gt;&lt;a href=&quot;#1-MooBuzz&quot; class=&quot;headerlink&quot; title=&quot;1.MooBuzz&quot;&gt;&lt;/a&gt;1.MooBuzz&lt;/h4&gt;&lt;h5 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; c
      
    
    </summary>
    
    
      <category term="lca" scheme="http://valenshi.top/tags/lca/"/>
    
      <category term="树上倍增" scheme="http://valenshi.top/tags/%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/"/>
    
      <category term="二分搜索" scheme="http://valenshi.top/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Python之字符串处理与格式输出</title>
    <link href="http://valenshi.top/2019/12/08/python-str/"/>
    <id>http://valenshi.top/2019/12/08/python-str/</id>
    <published>2019-12-08T06:04:03.000Z</published>
    <updated>2019-12-08T06:06:12.096Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>大多数语言都有字符串（String）这一数据类型，在Python中String类型的关键字为 str ，其属于扁平序列、不可改变序列，因此对其的操作需要一些技巧。<br>本文将以方便算法竞赛的角度来整理Python中 str 类型的使用方法，分别从字符串操作与格式化输出两个角度来整理。</p><h4 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h4><h5 id="标准的序列操作"><a href="#标准的序列操作" class="headerlink" title="标准的序列操作"></a>标准的序列操作</h5><p>这里的序列类型就不单单是指字符串了，而是指包含字符串的一种类型。序列类型大体可分为容器序列与扁平序列。<br><strong>容器序列</strong>实际上放的是对象引用，因此可以存放不同类型的数据；<br><strong>扁平序列</strong>存放的是对象的值，是一段连续的内存空间，因此要求对象必须是相同的数据类型才行，如字符、数字、字节。字符串是扁平序列。</p><p>当然，按照<strong>是否可修改</strong>还可以分为可变序列与不可变序列，不可变序列有<code>tuple、str、bytes</code>；可变序列有<code>list、bytearray</code> 等。字符串是不可变序列。</p><p>以上序列都有一些通用的操作，如：索引、切片、加法乘法；当然对于不同的序列这些操作意义也不同。</p><p><strong>索引：</strong> 和类C语言一样，序列中的元素都是有序排列的，拥有自己的编号（从0开始），我们可以通过索引来得到对应位置上的元素。<br>索引也可以是负值，负索引代表从后向前数，如 -3 表示倒数第三个元素，以此类推。</p><p><strong>切片：</strong> Python中有着分片操作符[ : ]，[begin : end]将会返回子序列 [begin,end)，其中end位置上的元素取不到，所以end是个超尾。<br>切片的索引同样支持负值，负索引表示倒数第几个元素，需要注意的是起始下标应在终止下标之前，否则将会返回空。</p><p><strong>代码示例：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"abcdefg"</span></span><br><span class="line">print(s)</span><br><span class="line"><span class="comment">#索引</span></span><br><span class="line">print(s[<span class="number">2</span>])<span class="comment">#输出索引为2的元素 'c'</span></span><br><span class="line">print(s[<span class="number">-2</span>])<span class="comment">#输出倒数第2个元素 'f'</span></span><br><span class="line"><span class="comment">#切片</span></span><br><span class="line">print(s[<span class="number">2</span>:<span class="number">6</span>])<span class="comment">#输出[2,6)位置的子串 "cdef"</span></span><br><span class="line">print(s[<span class="number">-4</span>:<span class="number">-2</span>])<span class="comment">#输出[倒数第4个元素,倒数第2个元素)子串 "de"</span></span><br></pre></td></tr></table></figure></p><p>字符串的 ‘+’与 ‘ * ‘ 分别是拼接与复制，一试便知，不再赘述。</p><h5 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h5><p>前面说过，python中的str属于不可修改序列，即不可以通过索引赋值的方式来修改元素；也就是说 <code>s[2] = &#39;x&#39;</code> 这样的写法是不允许的。那么如果想修改怎么办呢？这里挑几种方便的写法整理：<br><strong>重新赋值：</strong> 具体思路是，通过将需要修改的目标位置用切片切出来，然后替换再拼接，具体代码如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"abcdefg"</span></span><br><span class="line">print(s)</span><br><span class="line">s = s[:<span class="number">4</span>] + <span class="string">"x"</span> + s[<span class="number">5</span>:]</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure></p><p><strong>使用replace函数：</strong> 可以通过调用字符串方法replace( s , t )将字符串内的所有子串 s 替换为 t 后返回。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"abcdefgabc"</span></span><br><span class="line">print(s)</span><br><span class="line"><span class="comment">#将abcdefabc替换为xxxdefxxx</span></span><br><span class="line">s2 = s.replace(<span class="string">"abc"</span>,<span class="string">"xxx"</span>)</span><br><span class="line">print(s2)</span><br></pre></td></tr></table></figure></p><p>还可以通过将字符串转化为列表后修改元素，再用 join 方法转回字符串来达成修改目的，具体选择哪种方法按需求来看。</p><h5 id="ASCII码与字符的转换"><a href="#ASCII码与字符的转换" class="headerlink" title="ASCII码与字符的转换"></a>ASCII码与字符的转换</h5><p>在一些情形下，尤其是算法竞赛中，快速实现字符转ASCII码是十分重要的，在Python中不能直接对字符用加法或减法来实现转换，而是要通过ord() 和 chr() 函数来实现转换：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(ord(<span class="string">'a'</span>))<span class="comment">#输出字符 a 的ASCII码</span></span><br><span class="line">print(chr(<span class="number">98</span>))<span class="comment">#输出ASCII码为 98 的字符</span></span><br></pre></td></tr></table></figure></p><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><p>对于字符串的输出可以通过调用print()来实现，但是在算法竞赛等一些情况下，这样是不够的，因为我们往往对输出的格式有着严格的要求。</p><h5 id="基本的转换说明符"><a href="#基本的转换说明符" class="headerlink" title="基本的转换说明符"></a>基本的转换说明符</h5><p>% 字符 标记转换说明符的开始，例如<code>print(&quot;Hello, %s &quot; % &quot;egg&quot;)            # Hello, egg</code> ，这段代码将字符串中的 %s 替换成了字符串 “egg” ；这就是字符串格式化操作符 % 的基本使用方式。<br>如果要在格式化字符串里包含%，那么必须使用%%，这样Python就不会将百分号误以为是转换说明符了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"There is %d people."</span> % <span class="number">32</span>) <span class="comment"># There is 32 people.</span></span><br><span class="line">print(<span class="string">"Hello%%, %s "</span> % <span class="string">"egg"</span>)<span class="comment"># Hello%, egg</span></span><br></pre></td></tr></table></figure></p><h5 id="字段宽度和精度"><a href="#字段宽度和精度" class="headerlink" title="字段宽度和精度"></a>字段宽度和精度</h5><p>指定宽度和精度同C语言类似，都是类似%.3f以及%5d<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"An egg is %.2f yuan"</span> % <span class="number">0.8</span>)        <span class="comment"># An egg is 0.80 yuan</span></span><br><span class="line">print(<span class="string">"An egg is %5d yuan"</span> % <span class="number">1</span>)<span class="comment"># An egg is     1 yuan</span></span><br></pre></td></tr></table></figure></p><h5 id="符号、对齐和用0填充"><a href="#符号、对齐和用0填充" class="headerlink" title="符号、对齐和用0填充"></a>符号、对齐和用0填充</h5><p>在字符宽度和精度值之前还可以放一个“标志”，该表示可以是<code>0 + -</code> </p><ul><li>如果是0则表示不足的位置用前导零填充</li><li>‘-‘ 表示左对齐数值</li><li>‘+’ 表示输出符号（不管是正数还是负数）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"An egg is %05d yuan"</span> % <span class="number">1</span>)<span class="comment"># An egg is 00001 yuan</span></span><br><span class="line">print(<span class="string">"An egg is %-5d yuan"</span> % <span class="number">1</span>)<span class="comment"># An egg is 1     yuan</span></span><br><span class="line">print(<span class="string">"An egg is %+d yuan"</span> % <span class="number">1</span>)<span class="comment">#An egg is +1 yuan</span></span><br></pre></td></tr></table></figure><h5 id="输出不止一个元素"><a href="#输出不止一个元素" class="headerlink" title="输出不止一个元素"></a>输出不止一个元素</h5><p>你可能注意到了上述例子都是只输出一个值，一个元素；在C语言中我们可以通过逗号来分隔需要输出的不同元素，那么在Python中如何办到呢？<br>在Python中，只有元组和字典可以格式化一个以上的值；如果用列表或者其它序列代替元组，那么序列会被解释为一个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用元组来输出一个以上的值</span></span><br><span class="line">print(<span class="string">"An egg is %d yuan,two eggs are %d yuan."</span>% (<span class="number">1</span>,<span class="number">2</span>)) </span><br><span class="line"><span class="comment"># An egg is 1 yuan,two eggs are 2 yuan.</span></span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>Magnus Lie Hetland，Python基础教程第二版·修定版，北京：人民邮电出版社，45-47</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;大多数语言都有字符串（String）这一数据类型，在Python中String类型的关键字为 str ，其属于扁平序列、不可改变序列，因此对
      
    
    </summary>
    
      <category term="Python学习笔记" scheme="http://valenshi.top/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python字符串" scheme="http://valenshi.top/tags/Python%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>2019CSP-J普及组复赛题解</title>
    <link href="http://valenshi.top/2019/11/26/2019CSP-J/"/>
    <id>http://valenshi.top/2019/11/26/2019CSP-J/</id>
    <published>2019-11-26T12:11:19.000Z</published>
    <updated>2019-11-26T12:13:00.868Z</updated>
    
    <content type="html"><![CDATA[<h4 id="A-数字游戏"><a href="#A-数字游戏" class="headerlink" title="A.数字游戏"></a>A.数字游戏</h4><p><strong>题意描述</strong><br>小 K 同学向小 P 同学发送了一个长度为 8 的 01 字符串来玩数字游戏，小 P 同学想 要知道字符串中究竟有多少个 1。<br> 注意：01 字符串为每一个字符是 0 或者 1 的字符串，如“101”（不含双引号）为一 个长度为 3 的 01 字符串。</p><p><strong>解题思路</strong><br>签到题。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;str[i];i++) <span class="keyword">if</span>(str[i] == <span class="string">'1'</span>) cnt++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="B-公车换乘"><a href="#B-公车换乘" class="headerlink" title="B.公车换乘"></a>B.公车换乘</h4><p><strong>题意描述</strong><br>著名旅游城市 B 市为了鼓励大家采用公共交通方式出行，推出了一种地铁换乘公交 车的优惠方案：在搭乘一次地铁后可以获得一张优惠票，有效期为 45 分钟，在有效期内可以 消耗这张优惠票，免费搭乘一次票价不超过地铁票价的公交车。在有效期内指 开始乘公交车的时间与开始乘地铁的时间之差小于等于 45 分钟，即：$t_{bus} - t_{subway} ≤ 45$。<br>搭乘地铁获得的优惠票可以累积，即可以连续搭乘若干次地铁后再连续使用优 惠票搭乘公交车。搭乘公交车时，如果可以使用优惠票一定会使用优惠票；如果有多张优惠票满 足条件，则优先消耗获得最早的优惠票。<br>现在你得到了小轩最近的公共交通出行记录，你能帮他算算他的花费吗？</p><p><strong>解题思路</strong><br>一道模拟题，显而易见需要按照时间升序，因为如果超过45分钟就无效了。基于此应该想到可以利用优先队列（或类似）的数据结构来维护，每次坐公交，在所有价值大于本次票价的优惠券中优先使用过期时间最早的（不用就过期了！），价值最低的优惠券。一旦票过期了，就删掉，但是如果票只是价值不够，那可能后面还会有用，所以还要压回去。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> ty;</span><br><span class="line">ll t,price;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; rhs) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t == rhs.t) <span class="keyword">return</span> price &gt; rhs.price;</span><br><span class="line"><span class="keyword">return</span> t &gt; rhs.t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;rd[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"><span class="built_in">stack</span>&lt;Node&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">sort(rd+<span class="number">1</span>,rd+<span class="number">1</span>+n);</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(!rd[i].ty)&#123;</span><br><span class="line">res += rd[i].price, q.push(rd[i]);</span><br><span class="line"><span class="keyword">continue</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">Node x = q.top(); q.pop();</span><br><span class="line"><span class="keyword">if</span>(rd[i].t - x.t &gt; <span class="number">45</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(x.price &lt; rd[i].price)&#123;</span><br><span class="line">s.push(x); <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) res += rd[i].price;</span><br><span class="line"><span class="keyword">while</span>(s.size()) q.push(s.top()), s.pop(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;rd[i].ty,&amp;rd[i].price,&amp;rd[i].t);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="C-纪念品"><a href="#C-纪念品" class="headerlink" title="C.纪念品"></a>C.纪念品</h4><p><strong>题意描述</strong><br>小伟突然获得一种超能力，他知道未来 T 天 N 种纪念品每天的价格。某个纪念品 的价格是指购买一个该纪念品所需的金币数量，以及卖出一个该纪念品换回的金币数量。<br> 每天，小伟可以进行以下两种交易<strong>无限次</strong>：<br>任选一个纪念品，若手上有足够金币，以当日价格购买该纪念品；卖出持有的任意一个纪念品，以当日价格换回金币。<br> 每天卖出纪念品换回的金币可以<strong>立即</strong>用于购买纪念品，当日购买的纪念品也可以<strong>当日卖出</strong>换回金币。当然，一直持有纪念品也是可以的。<br>T 天之后，小伟的超能力消失。因此他一定会在第 T 天卖出<strong>所有</strong>纪念品换回金币。<br>小伟现在有 M 枚金币，他想要在超能力消失后拥有尽可能多的金币。 </p><p><strong>解题思路</strong><br>本题思路可以根据数据范围来想。这是一道动态规划题。<br>刚开始想到的是建立一张全图，但是后来发现节点数量不是 N 而是 NT ，并且总价值也不一定只能走一条路。<br>后来发现可以用动态规划解决，首先设 f[x]: 第x天能够赚到最多多少钱。那么显然f[1] = m，并且 f 是递增的。重点在于状态转移，f[ i ] 肯定是由 f[ 1~i-1 ] 推出来的，因为单独一个 f[i-1] 无法表示所有状态。<br>假设当前处于状态 j （j &lt; i），那么将第 j 天物品的价格看作花费，第 i 天的物品价格看作价值，这就是一个完全背包问题，背包容量是当天的金币数 f[j] 。<br>于是我们两层循环O(T^2)来计算 f[i] ，而每次计算需要O(MN) 做完全背包，但是实际测试效率还行，可能是数据太弱了。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e2</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,m;</span><br><span class="line"><span class="keyword">int</span> val[N][N];</span><br><span class="line"><span class="keyword">int</span> f[N];<span class="comment">//第 x 天最多有多少钱</span></span><br><span class="line"><span class="keyword">int</span> tmp[M],mx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">f[<span class="number">1</span>] = m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> day = <span class="number">2</span>;day &lt;= t;day++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; day;i++)&#123;</span><br><span class="line"><span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span> tmp); mx = m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v = val[i][j]; v &lt;= f[i];v++)&#123;</span><br><span class="line">tmp[v] = max(tmp[v-val[i][j]]+val[day][j],tmp[v]);</span><br><span class="line">mx = max(mx,tmp[v]+f[i]-v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f[day] = max(f[day],mx);</span><br><span class="line">&#125;</span><br><span class="line">f[day] = max(f[day],f[day<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for(int i = 1;i &lt;= t;i++) printf("%d\n",f[i]);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[t]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;t,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= t;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val[i][j]);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="D-加工零件"><a href="#D-加工零件" class="headerlink" title="D.加工零件"></a>D.加工零件</h4><p><strong>题意描述</strong></p><p>凯凯的工厂正在有条不紊地生产一种神奇的零件，神奇的零件的生产过程自然也很 神奇。工厂里有 𝑛 位工人，工人们从 1∼𝑛编号。某些工人之间存在双向的零件传送带。保证每两名工人之间最多只存在一条传送带。<br>如果 𝑥 号工人想生产一个被加工到第 𝐿(𝐿&gt;1) 阶段的零件，则所有与 𝑥 号工人 有传送带直接相连的工人，都需要生产一个被加工到第 𝐿 −1 阶段的零件（但 𝑥 号工 人自己无需生产第 𝐿 −1 阶段的零件）。<br>如果 𝑥 号工人想生产一个被加工到第 1 阶段的零件，则所有与 𝑥 号工人有传送 带直接相连的工人，都需要为 𝑥 号工人提供一个原材料。<br>轩轩是 1 号工人。现在给出 𝑞 张工单，第 𝑖 张工单表示编号为 𝑎𝑖的工人想生产 一个第 𝐿𝑖阶段的零件。轩轩想知道对于每张工单，他是否需要给别人提供原材料。他知道聪明的你一定可以帮他计算出来！</p><p><strong>解题思路</strong><br>经过推导可以发现，如果 a 号节点到 1 号节点（以下只用编号简写）之间存在一条小于 L 的路径，且它们的差为偶数（包括0），那么 1 就要提供原材料。<br>但是问题在于 1 到 a 之间可能不止一条路径，而 L 也不一定是奇或者偶，于是我们需要保存 a 到 1 的<strong>最短奇路径</strong>与<strong>最短偶路径</strong>。<br>在图论中，如果边权为1，那么求奇偶最短路径的好方法就是用分层图来做，具体做法是建立双层图，如果从起点不在同一层，则路径一定是奇，否则一定为偶；这样做的好处是不用额外的辅助代码，只要在建图时多加两条边就行了。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[M],ver[M],nex[M] ,tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="keyword">int</span> dis[N],vis[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[a] &lt;= l &amp;&amp; !((dis[a]&amp;<span class="number">1</span>) ^ (l&amp;<span class="number">1</span>))) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(dis[a+n] &lt;= l &amp;&amp; !((dis[a+n]&amp;<span class="number">1</span>) ^ (l&amp;<span class="number">1</span>))) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">que.push(s);</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(que.size())&#123;</span><br><span class="line"><span class="keyword">int</span> x = que.front(); que.pop();</span><br><span class="line">vis[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(dis[y] &gt; dis[x]+z)&#123;</span><br><span class="line">dis[y] = dis[x]+z;</span><br><span class="line"><span class="keyword">if</span>(!vis[y]) que.push(y),vis[y] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = getInt(); m = getInt(); q = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">addEdge(x,y+n,<span class="number">1</span>); addEdge(y+n,x,<span class="number">1</span>);</span><br><span class="line">addEdge(x+n,y,<span class="number">1</span>); addEdge(y,x+n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">SPFA(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//for(int i = 1;i &lt;= n&lt;&lt;1;i++) cout &lt;&lt; dis[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,a,l;i &lt;= q;i++)&#123;</span><br><span class="line">a = getInt(); l = getInt();</span><br><span class="line"><span class="keyword">if</span>(solve(a,l)) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;A-数字游戏&quot;&gt;&lt;a href=&quot;#A-数字游戏&quot; class=&quot;headerlink&quot; title=&quot;A.数字游戏&quot;&gt;&lt;/a&gt;A.数字游戏&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;题意描述&lt;/strong&gt;&lt;br&gt;小 K 同学向小 P 同学发送了一个长度为 8 的 01 
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="http://valenshi.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="图论" scheme="http://valenshi.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="分层图" scheme="http://valenshi.top/tags/%E5%88%86%E5%B1%82%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>CodeForce#600（Div2）解题报告</title>
    <link href="http://valenshi.top/2019/11/24/cf600/"/>
    <id>http://valenshi.top/2019/11/24/cf600/</id>
    <published>2019-11-24T04:30:03.000Z</published>
    <updated>2019-11-24T04:36:10.475Z</updated>
    
    <content type="html"><![CDATA[<h4 id="A-Single-Push"><a href="#A-Single-Push" class="headerlink" title="A. Single Push"></a>A. Single Push</h4><p><strong>题意简述：</strong><br>给定两个序列 a 和 b，要求从序列 a 中选出连续的一段[l , r] ，对这段上的每个位置+k（k &gt;= 0），试问只操作一次能否使得序列 a 变为序列 b 。<br><strong>解题思路：</strong><br>由于只能操作一次，所以难度大大下降，因此只需要顺序判断 a 是否只有一个区间和 b 不同，且差值全部相同且为负。<br><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span> + c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = a[i]-b[i];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(a[i] &amp;&amp; a[i] != a[i<span class="number">-1</span>]) cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt &lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">t = getInt();</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">n = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) b[i] = getInt();</span><br><span class="line"><span class="keyword">if</span>(solve()) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="B-Silly-Mistake"><a href="#B-Silly-Mistake" class="headerlink" title="B. Silly Mistake"></a>B. Silly Mistake</h4><p><strong>题意简述：</strong><br>定义一个连续的序列是合法的，当且仅当：</p><ul><li>有一个正数，就有一个负数，例如有 5 ，就要有 -5；</li><li>负数之前必须有它的正数，即 5 只能在 -5 前面；</li><li>每个数对仅出现一次，即 5 ，-5，5，-5是不合格法的。</li></ul><p>给定一个序列 a，其中ai &lt;= 1e6，请问可以将序列a分为多少个合法的子序列，并输出每个子序列的长度，若不存在划分方法，则输出-1，否则输出任意满足条件的答案。</p><p><strong>解题思路：</strong><br>需要在O(N)时间内解决，就是模拟题，只需要每次遍历到一个数就判断当且序列是否合法就行了，若合法就划分，否则或退出输出-1，或继续加入元素。<br>需要注意若用前缀和作为判断条件可能会超 int，需要用longlong，另外对于每个条件分支一定要仔细划分，避免遗漏出错。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp;(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span>+ c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[N],d[N],tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line">__int64 sum[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) sum[i] = sum[i<span class="number">-1</span>] + a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,pre = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(num[a[i]] != <span class="number">0</span> || vis[a[i]] &gt; pre) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">num[a[i]]++; vis[a[i]] = i;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num[-a[i]] != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">num[-a[i]]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum[i] == <span class="number">0</span>) d[++tot] = i-pre,pre = i;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sum[i] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!tot || sum[n]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tot);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; tot;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,d[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d[tot]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line"><span class="comment">// freopen("out","w",stdout);</span></span><br><span class="line">n = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line"><span class="keyword">if</span>(!solve()) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="C-Sweets-Eating"><a href="#C-Sweets-Eating" class="headerlink" title="C. Sweets Eating"></a>C. Sweets Eating</h4><p><strong>题意简述：</strong><br>给定一个序列 a，给定 m ，对于 k（k从1到n） ，要求从序列 a 中挑出k个元素，分为若干组，每组最多有m个元素，使得第一组 <em> 1，第二组 </em> 2，依次类推，使得它们的总和最小。</p><p><strong>解题思路：</strong><br>首先对序列 a 排序，易得要想总和最小，应该选出最小的 k 个元素。<br>假设要求的是 f(k) ，那么需要解决的是如何才能快速的从 f(k) 转移到 f(k+1)，如果暴力转移，是 O(k) 复杂度，因为要加上每一组最小的元素放到高一组去。我们可以利用前缀和来优化，具体做法是开一个sum数组，sum[i] 记录 %m 为 i 的元素和，我们从小到大依次将 a 序列中的元素加入，就可以在O(1)转移。</p><p><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span> + c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line">ll sum[N],ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;k++)&#123;</span><br><span class="line">ans[k] = ans[k<span class="number">-1</span>] + sum[k%m] + a[k];</span><br><span class="line">sum[k%m] += a[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">printf</span>(<span class="string">"%I64d "</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line"><span class="comment">// freopen("out","w",stdout);</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="D-Harmonious-Graph"><a href="#D-Harmonious-Graph" class="headerlink" title="D. Harmonious Graph"></a>D. Harmonious Graph</h4><p><strong>题意简述</strong><br>一个有 N 个点的无向图，节点分别标号为1~N。要求如果图中存在 l —&gt; r 的路径，那么对于所有的 m (l &lt; m &lt; r)都满足 l —&gt; m 。给定一张无向图，试问最少添加多少条边才能使得其满足要求。</p><p><strong>解题思路</strong><br>思路不难想，因为只要求若(l , r)是连通的，那么对于 l 到 r 内的所有点都应（至多）延伸出一条线构成一个连通分量，易得一张图最多需要 N-2 条边；很容易想到用并查集来做，将相连通的点放在同一个集合，分配一个编号。然后记录每个集合（连通分量）最后一个点的位置 ed ，然后只需要从前往后依次遍历，若当前节点在另一个集合的范围内，则合并两个集合并将 ans++；若当前集合可以更新有边界，则更新。<br>思路是正确的，但是被卡了好多次，错了很多细节，首先就是求集合‘编号’需要调用Find()函数，而不是直接访问par[]数组，par[]数组只是一个辅助数组而已；然后还有就是通过Merge()函数后，集合的编号可能会改变，因此按照集合的编号来存有边界是不合理的，应该再转化为按照位置来存。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> par[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(par[x] == x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> par[x] = Find(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = Find(x), b = Find(y);</span><br><span class="line"><span class="keyword">if</span>(a == b) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(a &lt; b) swap(a,b);</span><br><span class="line">par[a] = b;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span>+c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> vis[N],ed[N],ls[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) par[i] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">Merge(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt; <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(!ed[Find(i)]) ed[Find(i)] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) ls[i] = ed[Find(i)];</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>,last = ls[x] ,ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt; last &amp;&amp; Merge(x,i)) ans++;</span><br><span class="line"><span class="keyword">if</span>(ls[i] &gt; last)&#123;</span><br><span class="line">last = ls[i]; x = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;A-Single-Push&quot;&gt;&lt;a href=&quot;#A-Single-Push&quot; class=&quot;headerlink&quot; title=&quot;A. Single Push&quot;&gt;&lt;/a&gt;A. Single Push&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;题意简述：&lt;/strong&gt;&lt;b
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="并查集" scheme="http://valenshi.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="前缀和" scheme="http://valenshi.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>STL之map容器速率测试</title>
    <link href="http://valenshi.top/2019/11/16/mapDemo/"/>
    <id>http://valenshi.top/2019/11/16/mapDemo/</id>
    <published>2019-11-16T03:46:09.000Z</published>
    <updated>2019-11-16T03:46:50.788Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>不止一次在使用 map 时被卡时限，map 是 c++ 的 STL 中一个常用且方便的容器，其是基于树来实现的，它的插入与查找效率实际上更接近O(log N )（N为插入的元素个数）。当然在 c++ 的 STL 中还有用哈希实现的无序关联容器，这里不做讨论。<br>在实际应用中，常常会有人把 map 时间复杂度看作O(1)，确实在大多数时候 map 表现是令人满意的，但在大量使用的时候，map却不尽人意。</p><p>我们将测试如下几种情形下使用 map 容器的效率（时间）：</p><ul><li>仅插入元素（元素类型为int）</li><li>插入以及查找（元素类型为int）<h4 id="测试环境准备"><a href="#测试环境准备" class="headerlink" title="测试环境准备"></a>测试环境准备</h4></li></ul><p>为了给定一个对照的标准，先给出如下数据：</p><ul><li>测试机空循环 1e6 次平均花费 0.0641 s</li><li>测试机读取 1e6 个int型数据（快读+从文件输入）平均花费 0.2142 s</li></ul><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><h5 id="仅插入元素"><a href="#仅插入元素" class="headerlink" title="仅插入元素"></a>仅插入元素</h5><p><strong>本机平均花费时间：</strong> 1.1015 s<br><strong>测试代码</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> gap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">mp[i*gap%P] = <span class="number">1</span>; gap += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="插入以及查找元素"><a href="#插入以及查找元素" class="headerlink" title="插入以及查找元素"></a>插入以及查找元素</h5><p><strong>本机平均花费时间：</strong> 1.238 s<br><strong>测试代码</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> gap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">mp[i*gap%P] = <span class="number">1</span>; gap += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(mp.count(i));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总体上测试结果是符合预期的，虽然 STL 容器已经很优化的，但是毕竟还是用树来实现的，达不到 O(1) 的时间复杂度，所以如果是对时限要求很高的话，最好还是采用手动写哈希表。<br>上述设计的实验有很多缺陷，如未对 long long转化、取模 以及其它多余的操作进行排除影响，另外本来还测试了char、string、set等类型的元素，但是要设计一个好的测试代码太麻烦了，就删了，总的结论来说就是 int 是所有测试的数据类型中最慢的一种（甚至慢于 set 和 string ，如果只考虑插入和查找）。<br>最终结论就是如果需要一个 O(1) 时间复杂度的插入和查找（int 类型的元素），那么就用哈希表。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;不止一次在使用 map 时被卡时限，map 是 c++ 的 STL 中一个常用且方便的容器，其是基于树来实现的，它的插入与查找效率实际上更接
      
    
    </summary>
    
    
      <category term="map" scheme="http://valenshi.top/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>最大流笔记</title>
    <link href="http://valenshi.top/2019/11/15/maxFlow/"/>
    <id>http://valenshi.top/2019/11/15/maxFlow/</id>
    <published>2019-11-15T05:19:48.000Z</published>
    <updated>2019-11-15T05:21:49.131Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>正如可以通过将道路交通图模型化为有向图来找到从一个城市到另一个城市之间的最短路，我们也可以将一个有向图看作一个“流网络”，并使用它来回答关于物料流动方面的问题。这种流网络可以用来建模很多实际问题，包括液体在管道中的流动、装配线上的部件的流动、电网中电流的流动和通信网络中信息的流动。<br>本文首先介绍网络流中的相关概念，然后给出最大流问题的一般解法思路，以及优化后的算法。我们应该将主要精力放在思维锻炼和题目分析上，而不要过于执着于那些经典算法的细节优化。本文中整理的算法在算法竞赛中已经够用。</p><h4 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h4><p><strong>流网络：</strong> 流网络 G = (V , E) 是一个有向图，图中每条边 (u , v) 都有一个非负的<strong>容量值c(u , v)</strong> 。而且，如果边集合 E 包含一条边(u , v) ，则图中不存在反向边(v , u)。</p><p><strong>源节点s和汇点t：</strong> 在流网络的所有节点中，我们分辨出两个特殊的节点，分别是源点s和汇点t；源点是所有路径的起点，而汇点是路径的终点。在某些情况下，源点和汇点需要人为指定。</p><p><strong>流网络 G 中的流：</strong> G中流的大小（值）用 f 表示，f(u , v)表示从点 u 到点 v 的流的大小。整张图的流是 $|f| = \sum_{v \epsilon V}f(s, v) - \sum_{v \epsilon V}f(v ,s)$（前后两个 v 含义不同），即从源点 s 流出的流量和，或称为流入汇点 t 的流量和。</p><p><strong>容量限制：</strong> 对于所有的节点$u, v \epsilon V$，要求$0 &lt;= f(u , v) &lt;= c(u , v)$<br><strong>流量守恒：</strong> 对于所有的节点 $u \epsilon V$ - { s , t }，要求流入 u 的流量等于流出 u 的流量，即：</p><script type="math/tex; mode=display">\sum_{v \epsilon V}f(v,u) = \sum_{v \epsilon V}f(u,v)</script><p>（前后两个 v 的含义不同，一个是入边的起点，一个是出边的终点）</p><p><strong>问题模型：</strong> 在最大流问题中，给定一个流网络G 、一个源节点s、一个汇点t，我们希望找到值最大的一个流。</p><h4 id="Edmonds-Karp算法"><a href="#Edmonds-Karp算法" class="headerlink" title="Edmonds-Karp算法"></a>Edmonds-Karp算法</h4><p>若一条从源点 s 到汇点 t 的路径上的各条边的剩余容量都大于 0，则称这条路径为一条增广路径。显然，可以让一股流沿着增广路径从 s 流到 t，使网络的流量增大。Edmonds-Karp算法思想就是不断用BFS寻找增广路，直至网络上不存在增广路为止。<br>该算法的时间复杂度为$O(nm^2)$。然而在实际运用中则远远达不到这个上界，效率较高，一般能够处理 $10^3 - 10^4$规模的网络。</p><p><strong>算法思路：</strong><br>这里介绍的是利用 bfs 寻找增广路的Edmonds-Karp增广路算法。在该算法中，我们不断的寻找增广路，并增加增广路上的流；重复这一步骤直至不存在增广路。<br>在每轮寻找增广路的过程中，Edmonds-Karp算法只考虑图中所有 f(x ,y) &lt; c(x, y)的边，用BFS找到任意一条从 s 到 t 的路径，同时计算出路径上各边的剩余容量的最小值 minf，则网络的流量就可以增加 minf。</p><p>需要注意的是，当一条边的流量 f(x ,y) &gt; 0时，根据斜对称性质，它的反向边流量 f(y ,x) &lt; 0，此时必定有 f(y , x) &lt; c(y ,x)。故Edmonds-Karp算法在BFS时除了原图的边集 E 外，还应考虑遍历 E 中每条边的反向边。<br>具体实现时，本文采用邻接表“成对存储”技巧（即’2’和’3’是一对，’4’和’5’是一对）。每条边只记录剩余容量 c-f 即可，当一条边 (x ,y) 流过大小为 e 的流时，令 (x ,y) 的容量减少 e，(y ,x) 的容量增加 e 。</p><p><strong>代码模板：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;<span class="comment">//最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e3</span>+<span class="number">10</span>;<span class="comment">//最大边数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;<span class="comment">//int范围内的无穷大</span></span><br><span class="line"><span class="keyword">int</span> head[N], edge[M], ver[M], nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;<span class="comment">// 共n个点,m条边,s是源点,t是汇点</span></span><br><span class="line"><span class="keyword">int</span> pre[N],incf[N];<span class="comment">//增广路上各边的最小剩余容量</span></span><br><span class="line"><span class="keyword">bool</span> vis[N];<span class="comment">//标记数组</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(s); vis[s] = <span class="literal">true</span>;</span><br><span class="line">incf[s] = INF;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(!z || vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">incf[y] = min(incf[x],z);</span><br><span class="line">pre[y] = i;<span class="comment">//记录前驱*边*</span></span><br><span class="line">q.push(y); vis[y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(y == t) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//找到一条增广路</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回最大流的值*/</span></span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(bfs())&#123;</span><br><span class="line"><span class="keyword">int</span> x = t;</span><br><span class="line"><span class="keyword">while</span>(x != s)&#123;</span><br><span class="line"><span class="keyword">int</span> i = pre[x];<span class="comment">//前驱 *边* </span></span><br><span class="line">edge[i] -= incf[t];</span><br><span class="line">edge[i^<span class="number">1</span>] += incf[t];</span><br><span class="line">x = ver[i^<span class="number">1</span>];<span class="comment">//前驱点 = 反向边的终点</span></span><br><span class="line">&#125;</span><br><span class="line">flow += incf[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addEdge(x,y,z); addEdge(y,x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,EK());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>算法正确性需要用到最小割来证明，详见《挑战程序设计竞赛第二版》P212。</p><h4 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h4><p> 在任意时刻，网络中所有节点以及剩余容量大于0的边构成的子图被称为残量网络。Edmonds-Karp每轮可能会遍历整个残量网络，但只找出 1 条增广路，还有进一步优化的空间。<br> 在宽度优先遍历时，我们可以计算出<strong>节点的层次d[x]</strong> ，它表示 s 到 x 最少需要经过的边数。在残量网络中，满足d[y] = d[x] + 1 的边(x ,y) 构成的子图被称为<strong>分层图</strong> 。分层图显然是一张有向无环图。</p><p> Dinic 算法不断重复以下步骤，直到残量网络中 s 不能到达 t：</p><ol><li>在残量网络上 BFS 求出节点的层次，构造分层图</li><li>在分层图上 DFS 寻找增广路，在回溯时实时更新剩余容量。另外，每个点可以流向多条出边，同时还加入了若干剪枝，详情参考代码示例。</li></ol><p>Dinic 算法的时间复杂度是$O(n^2m)$。实际运用中远远达不到这个上界，可以说是比较容易实现的效率最高的网络流算法之一，一般能够处理$10^4 - 10^5$规模的网络。特别地，Dinic算法求解二分图最大匹配的时间复杂度为$O(m\sqrt n)$，实际表现则更快。</p><p> <strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;<span class="comment">//int所能表示的最大范围的一半</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5</span>*N;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[M],ver[M],nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> d[N];<span class="comment">//记录节点的层次</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*利用bfs来求出节点的层次，构造分层图*/</span></span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="keyword">while</span>(q.size()) q.pop();</span><br><span class="line">q.push(s); d[s] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(q.size())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(!z || d[y]) <span class="keyword">continue</span>;</span><br><span class="line">q.push(y);</span><br><span class="line">d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(y == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 利用递归在分层图上找增广路,返回本次增广的流量 */</span></span><br><span class="line"><span class="keyword">if</span>(x == t) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> res = flow, k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(z &amp;&amp; d[y] == d[x]+<span class="number">1</span>)&#123;</span><br><span class="line">k = dinic(y,min(res,z));<span class="comment">//递归</span></span><br><span class="line"><span class="keyword">if</span>(!k) d[y] = <span class="number">0</span>;<span class="comment">//剪枝,去掉增广完毕的点</span></span><br><span class="line">edge[i] -= k; edge[i^<span class="number">1</span>] += k;</span><br><span class="line">res -= k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow - res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addEdge(x,y,z); addEdge(y,x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>,maxflow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(bfs())</span><br><span class="line"><span class="keyword">while</span>(flow = dinic(s,INF)) maxflow += flow;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,maxflow);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="ISAP算法"><a href="#ISAP算法" class="headerlink" title="ISAP算法"></a>ISAP算法</h4><p>ISAP算法没有正式的名称，首次出现于 Ahuja和Orlin的经典教材《Network Flows：Theory，Algorithms and Applications》中，作者称它是一种：改进版的SAP（Improved SAP，ISAP）“。</p><p>该算法基于这样一个事实：每次增广后，任意节点到汇点（在残量网络中）的最短距离都不会减小。这样，我们可以用一个函数d(x)来表示残量网络中节点 x 到汇点的距离的下界（在Dinic中是用数组 d[]），然后在增广过程中不断修正这个下界（而不是像Dinic 算法那样多次增广以后才重建层次图），则增广的时候和 Dinic 类似，只允许沿着 d(y) = d(x) + 1 的有向边 (x , y) 走。</p><p>严格的说，算法中的 d 函数是满足如下两个条件的非负函数，即 d(t) = 0；对于残量网络中的任意弧 (x ,y)，d(x) &lt;= d(y) + 1。不难证明，只要满足这两个条件，d(x) 就是 x~t 距离的下界。而且当 d(s) &gt;= n时，残量网络中不存在 s-t 路。</p><p><strong>算法思路</strong><br>和 Dinic 算法类似，找增广路的过程是从 s 开始沿着“允许弧”（即在残量网络中的，满足 d[x] = d[y] + 1 的弧 x —&gt; y）往前走（ISAP 算法中叫Advance）如果走不动了怎么办？在Dinic算法中，直接“往回走一步”即可，因为如果找不到增广路，会重新构造层次图；但在ISAP中，并没有一个“一次性修改所有距离标号”的过程，只能边增广边修改。具体来说，在从结点 x 往回走的时候，把 d(x) 修改为 min{d(y) | (x , y)  是残量网络中的弧 } + 1（ISAP算法叫 Retreat）即可。注意，如果残量网络中从 x 出发没有弧，则设 d(x) = n。<br>ISAP算法看上去不难理解，但是实现起来却有诸多细节。首先，我们需要使用一种“当<br>前弧”的数据结构加速 允许弧 的査找，其次，还需要一个 gap 数组维护每个距离标号<br>结点编号。当把一个结点的距离标号从 x 改成 y 的时候,把 gap[x] 减1,gap[y]加1,然后<br>检查 gap[x] 是否为0。如果是 0 的话,说明 s-t 不连通，算法终止。这就是所谓的 gap 优化。最后，初始距离标号可以统一设为 0 ，也可以用逆向BFS找，单次运行时效率相差不大，但如果是多次求解小规模网络流，加上BFS以后速度往往会有明显提升。</p><p>数据结构方面，只多了两个数组：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[N];        <span class="comment">//可增广路的上一条弧</span></span><br><span class="line"><span class="keyword">int</span> gap[N];       <span class="comment">//距离标号计数</span></span><br></pre></td></tr></table></figure></p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5</span>*N;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">/*以下6行是数组模拟邻接表部分*/</span></span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot;</span><br><span class="line"><span class="keyword">int</span> cur[N],dis[N],gap[N],pre[N];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gap[k]:k层有多少个节点</span></span><br><span class="line"><span class="comment">pre[x]:x点前一条边的编号</span></span><br><span class="line"><span class="comment">cur[]是临时数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y, edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;</span><br><span class="line"><span class="keyword">int</span> que[N],front,rear;<span class="comment">//手工模拟队列，节省部分时间</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">front = rear = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">dis[i] = <span class="number">-1</span>,cur[i] = head[i],gap[i]= <span class="number">0</span>;</span><br><span class="line">dis[t] = <span class="number">0</span>;  que[rear++] = t;</span><br><span class="line"><span class="keyword">while</span>(front != rear)&#123;</span><br><span class="line"><span class="keyword">int</span> x = que[front++];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(dis[y] == <span class="number">-1</span>) </span><br><span class="line">que[rear++] = y, dis[y] = dis[x] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ~dis[t];<span class="comment">//-1的补码是11111111,按位取反后是0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ISAP</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = s, ans = <span class="number">0</span>, i;<span class="comment">//时刻注意i不能被覆盖！！！</span></span><br><span class="line">bfs(n);<span class="comment">//一次bfs从汇点向前更新层次数组dis</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= n;i++) gap[dis[i]]++;</span><br><span class="line"><span class="keyword">while</span>(dis[s] &lt; n)&#123;</span><br><span class="line"><span class="keyword">if</span>(k == t)&#123;</span><br><span class="line"><span class="keyword">int</span> mi = INF, loc = t;</span><br><span class="line"><span class="keyword">while</span>(loc != s)&#123;</span><br><span class="line">mi = min(mi,edge[pre[loc]]);</span><br><span class="line">loc = ver[pre[loc]^<span class="number">1</span>];<span class="comment">//前一个顶点</span></span><br><span class="line">&#125;</span><br><span class="line">loc = t;</span><br><span class="line"><span class="keyword">while</span>(loc != s)&#123;</span><br><span class="line">edge[pre[loc]] -= mi;</span><br><span class="line">edge[pre[loc]^<span class="number">1</span>] += mi;</span><br><span class="line">loc = ver[pre[loc]^<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">ans += mi, k = s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = cur[k];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(z &amp;&amp; dis[k] == dis[y]+<span class="number">1</span>)&#123;</span><br><span class="line">pre[y] = cur[k] = i; k = y;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> m = n;</span><br><span class="line"><span class="keyword">for</span>(i = head[k];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(z &amp;&amp; dis[y] &lt; m) m = dis[y], cur[k] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(--gap[dis[k]] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">dis[k] = m+<span class="number">1</span>, ++gap[dis[k]];</span><br><span class="line"><span class="keyword">if</span>(k != s) k = ver[pre[k]^<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;s,&amp;t))&#123;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">0</span> ,<span class="keyword">sizeof</span> head); tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addEdge(x,y,z); addEdge(y,x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ISAP(n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>刘汝佳，算法竞赛入门经典训练指南，北京：清华大学出版社，2012，362-363.</li><li>李煜东，算法竞赛进阶指南，郑州：河南电子音像出版社，2017，410-415.</li><li>秋叶拓哉，挑战程序设计竞赛第2版，北京：人民邮电出版社，2013，209-215.</li><li>Thomas H.Cormen，算法导论（原书第3版），北京：机械工业出版社，2013，414-417.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;正如可以通过将道路交通图模型化为有向图来找到从一个城市到另一个城市之间的最短路，我们也可以将一个有向图看作一个“流网络”，并使用它来回答关于
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="图论" scheme="http://valenshi.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="最大流" scheme="http://valenshi.top/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>伙伴算法</title>
    <link href="http://valenshi.top/2019/11/13/buddy-system/"/>
    <id>http://valenshi.top/2019/11/13/buddy-system/</id>
    <published>2019-11-13T12:13:59.000Z</published>
    <updated>2019-11-13T12:16:54.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="伙伴系统（Buddy-System）"><a href="#伙伴系统（Buddy-System）" class="headerlink" title="伙伴系统（Buddy System）"></a>伙伴系统（Buddy System）</h4><p><strong>伙伴系统的特点</strong></p><ul><li>整个可分配的分区大小为 $2^u$。</li><li>需要的分区大小为 $2^{u-1} &lt; s &lt;= 2^u$时，把整个块分配给该进程。</li></ul><p><strong>分配分区的过程：</strong><br>如果 $s &lt;= 2^{i-1}$，则将大小为$2^i$的当前空闲分区划分为两个大小为$2^{i-1}$的空闲分区<br>重复划分过程，直至$2^{i-1} &lt; s &lt;= 2^i$，并把一个空闲分区分配给该进程。</p><h4 id="伙伴系统的实现"><a href="#伙伴系统的实现" class="headerlink" title="伙伴系统的实现"></a>伙伴系统的实现</h4><p><strong>数据结构：</strong></p><ul><li>空闲块按照大小和起始地址组成二维数组。</li><li>初始状态：只有一个大小为$2^u$的空闲块。</li></ul><p><strong>分配过程：</strong></p><ul><li>由大到小在空闲块数组中找到最小的可用空闲块。</li><li>如果空闲块过大，对可用的空闲块进行二等分，直到得到合适的可用的空闲块。</li></ul><p><strong>分配样例图示：</strong><br><img src="/2019/11/13/buddy-system/1.png" alt="1"></p><p><strong>释放过程：</strong></p><ul><li>把释放的空闲块放入空闲数组</li><li>合并满足合并条件的空闲块</li></ul><p><strong>合并条件：</strong></p><ul><li>大小相同，例如都是$2^i$</li><li>地址相邻</li><li>低地址空闲块起始地址为$2^{i+1}$的位数</li></ul><h4 id="伙伴算法的优缺点"><a href="#伙伴算法的优缺点" class="headerlink" title="伙伴算法的优缺点"></a>伙伴算法的优缺点</h4><p><strong>优点：</strong></p><ul><li>较好的解决外部碎片问题</li><li>当需要分配若干个内存页面时，用于DMA的内存页面必须连续，伙伴算法很好的满足了这个要求</li><li>只要请求的块不超过512个页面（2k），内核就尽量分配连续的页面。</li><li>针对大内存分配设计</li></ul><p><strong>缺点：</strong></p><ul><li>合并的要求过于严格，只能是满足伙伴关系的块才能合并</li><li>碎片问题：一个连续的内存中仅仅一个页面被占用，导致整个内存区都不具备合并条件</li><li>浪费问题：伙伴算法只能分配2的幂次方内存区，当需要的内存为$2^i+1$ K 时，例如需要 9K 时，就需要分配16K的内存空间，剩下的 7K 浪费了。</li><li>算法的效率问题：伙伴算法中涉及了比较多的计算还有链表和位图的操作，开销比较大，如果每次合并$2^n$大小的块为$2^{n+1}$的小，那么大小为$2^n$的块会减少，如果随后系统又需要$2^n$大小的块，就又要拆分，这样的立即合并和拆分过程无效率。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;伙伴系统（Buddy-System）&quot;&gt;&lt;a href=&quot;#伙伴系统（Buddy-System）&quot; class=&quot;headerlink&quot; title=&quot;伙伴系统（Buddy System）&quot;&gt;&lt;/a&gt;伙伴系统（Buddy System）&lt;/h4&gt;&lt;p&gt;&lt;stron
      
    
    </summary>
    
      <category term="计算机操作系统" scheme="http://valenshi.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="内存分配" scheme="http://valenshi.top/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下vim简单入门</title>
    <link href="http://valenshi.top/2019/10/26/vim-use/"/>
    <id>http://valenshi.top/2019/10/26/vim-use/</id>
    <published>2019-10-26T02:34:59.000Z</published>
    <updated>2019-10-26T02:36:02.627Z</updated>
    
    <content type="html"><![CDATA[<h4 id="安装vim"><a href="#安装vim" class="headerlink" title="安装vim"></a>安装vim</h4><p>在ubuntu的命令行下输入<code>sudo apt install vim</code> 以获得vim。如遇到报错，可复制报错信息去百度寻找对应解决策略。</p><h4 id="vim的使用"><a href="#vim的使用" class="headerlink" title="vim的使用"></a>vim的使用</h4><p>vim编辑器有三种：命令模式，末行模式，插入模式。</p><p>打开vim时默认的是<strong>命令模式</strong>，此状态下敲击键盘视为输入命令而非字符。若想进入<strong>插入模式</strong>，则要在命令模式下输入 i ，此时可以输入字符，编辑文本；输入完毕后，按ESC可退回到命令模式。<br>命令模式只有一些简单的命令，更多命令需要使用末行模式；在命令模式下输入” : “（不含引号）可进入末行模式，末行模式可以进行更多灵活的操作。</p><p>以上是三种模式的异同以及切换方法。</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>以下复制老师的笔记：</p><p><strong>模式切换</strong></p><ol><li>输入i进入插入模式</li><li>在插入模式中按ESC进入命令模式</li><li>在命令模式中输入 “ : “ 进入末行模式</li></ol><p><strong>保存：</strong></p><ol><li>命令模式中输入ZZ</li><li>在末行模式中输入:wq</li></ol><p><strong>编译：</strong></p><ol><li>g++ -o test test.cpp -Wall</li></ol><p><strong>定位：</strong></p><ol><li>:i 定位到第 i 行</li><li>:/x 定位到x第一次出现的行</li></ol><p><strong>删除行（命令模式下）：</strong></p><ol><li>dd删除当前行</li><li>d2d删除包含当前行的2行，向下的</li></ol><p><strong>撤回：</strong></p><ol><li>命令模式下输入 u</li></ol><p><strong>复制（命令模式下）：</strong></p><ol><li>yy，与dd功能相似</li><li>粘贴时按p</li></ol><h4 id="配置vim"><a href="#配置vim" class="headerlink" title="配置vim"></a>配置vim</h4><p>此时vim可以正常使用，但是界面有些不友好，没有行号，缩进也很难看，更没有自动补全等。<br>我们可以通过在末行模式中输入一些命令来使得界面以及操作更加友好，例如添加行号，设置缩进等，但是这样需要每次打开vim都要重新配置，所以为了方便起见，可以修改配置文件达到自动配置的目的。</p><p>首先通过 <code>cd ~</code> 进入用户根目录，然后<code>vim .vimrc</code> 新建一个隐藏文件<code>.vimrc</code>，并打开编辑；输入如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">set nu          //显示行号</span><br><span class="line">set ts=4        //制表符宽度</span><br><span class="line">set history=1000    </span><br><span class="line">set showmatch   //高亮显示匹配的括号</span><br><span class="line">set ruler       //显示尺寸</span><br><span class="line">set mouse=a     //启用鼠标选择</span><br><span class="line">set autoindent  //自动缩进</span><br><span class="line">set cindent     //自动缩进</span><br><span class="line">set nobackup    //禁止生成临时文件</span><br><span class="line">set smartindent //自动缩进</span><br><span class="line">set shiftwidth=4    //自动缩进的长度</span><br><span class="line">set expandtab   //tab变空格</span><br><span class="line"></span><br><span class="line">//以下是自动补全</span><br><span class="line">inoremap&#123; &#123;&#125;&lt;ESC&gt;i&lt;CR&gt;&lt;ESC&gt;O</span><br><span class="line">inoremap( ()&lt;ESC&gt;i</span><br><span class="line">inoremap[ []&lt;ESC&gt;i</span><br><span class="line">inoremap&apos; &apos;&apos;&lt;ESC&gt;i</span><br><span class="line">inoremap&quot; &quot;&quot;&lt;ESC&gt;i</span><br><span class="line"></span><br><span class="line">set encoding=utf-8</span><br><span class="line">set softtabstop=4</span><br><span class="line"></span><br><span class="line">//定义F6快捷编译运行，在命令模式下</span><br><span class="line">map &lt;F6&gt; :cal CR() &lt;CR&gt;</span><br><span class="line">func! CR()</span><br><span class="line">exec &quot;w&quot;</span><br><span class="line">exec &quot;!g++ % -o %&lt;&quot;</span><br><span class="line">exec &quot;! ./%&lt;&quot;</span><br><span class="line">endfunc</span><br></pre></td></tr></table></figure></p><p>输入完成后按ESC进入命令模式，再 :wq 保存退出即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;安装vim&quot;&gt;&lt;a href=&quot;#安装vim&quot; class=&quot;headerlink&quot; title=&quot;安装vim&quot;&gt;&lt;/a&gt;安装vim&lt;/h4&gt;&lt;p&gt;在ubuntu的命令行下输入&lt;code&gt;sudo apt install vim&lt;/code&gt; 以获得vim。如遇到
      
    
    </summary>
    
      <category term="Linux" scheme="http://valenshi.top/categories/Linux/"/>
    
    
      <category term="vim" scheme="http://valenshi.top/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>单调栈与单调队列</title>
    <link href="http://valenshi.top/2019/10/17/ddz/"/>
    <id>http://valenshi.top/2019/10/17/ddz/</id>
    <published>2019-10-17T05:42:19.000Z</published>
    <updated>2019-10-17T05:42:57.769Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>单调栈和单调队列都可以看作是一种对栈和队列的特殊用法，即要求栈或队列中的元素具有单调性，递增或递减。那么很显然这种数据结构就是基于栈和队列实现的，即它既保留了栈的先进后出（队列就是保留先进先出），又具有单调性。而我们在某些时候正需要其这种性质，我们在讲解了单调栈和单调队列的定义、特性、构造方法后，会各给出一道例题来体现它们的用法。</p><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><h5 id="单调栈的概念"><a href="#单调栈的概念" class="headerlink" title="单调栈的概念"></a>单调栈的概念</h5><p>单调栈是一种特殊的栈，栈内的所有元素都保持着单调性，即单调递增或单调递减。</p><h5 id="单调栈的性质"><a href="#单调栈的性质" class="headerlink" title="单调栈的性质"></a>单调栈的性质</h5><ul><li>单调性。若是单调递增栈，则从栈顶到栈底的元素是严格递增的。若是单调递减栈，则从栈顶到栈底的元素是严格递减的。</li><li>靠近栈底的元素先进栈，越靠后的元素越后进栈。</li></ul><p>单调栈和普通的栈一样，都只能在栈顶操作，压入或弹出。而我们需要通过一些约束来使得栈内元素具有单调性，从而构成单调栈。</p><h5 id="构造单调栈"><a href="#构造单调栈" class="headerlink" title="构造单调栈"></a>构造单调栈</h5><p>以单调递增栈为例：对于当前元素e，若e大于栈顶元素，则进栈，否则弹出栈顶元素，再次进行比较，重复直至栈顶元素小于e或栈为空为止，此时将e压入栈。<br>对于弹出的元素，我们并不需要重新压回，因为一般情况下它们都属于被“淘汰”的元素，后面压入的元素一般又“新鲜”又“美味”，即时间上和数值上都比其优秀。</p><h5 id="例题HDU1506"><a href="#例题HDU1506" class="headerlink" title="例题HDU1506"></a>例题HDU1506</h5><p>先思考一个问题，如果题目中的矩形的高度都是单调递增的，如何得到最优解？显然有一个贪心的策略，就是以每一个矩形的高度作为最终大矩形的高度，看最宽能是多少，然后统计最优解。<br>但如果进来的下一矩形比上一个低，它其实相当于限制了之前矩形的高度，那么之前矩形比这个矩形高出的高度在以后的统计中就没有丝毫用处了，如果我们在这个时候把以之前矩形的高度作为最终高度的答案统计掉，那么反正以后的统计和上一个矩形没有关系，还不如把他删除。<br>这样，我们实际上就得到了单调栈的模型，只需要维护一个单调栈，在维护单调性的弹出操作时统计宽度，更新答案即可在O(n) 时间内得到最优解。<br>为了方便把最后剩下的，以及单调递增的矩形也统计进去，我们假设a[n+1]的位置有一个高度为0的矩形，最后将它加入单调栈时他会将所有矩形都弹出，那么答案也就完成最后的更新了。</p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><p>见附录部分code-1</p><h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>单调队列的概念和单调栈类似，只是把先进后出改成先进先出就可以了。其具有先进先出的特性并且队列中元素具有单调性。<br>单调是一种思想，当我们解决问题的时候发现有许多冗杂无用的状态时，我们可以采用单调思想，用单调队列或类似于单调队列的方法去除冗杂状态，保存我们想要的状态。</p><h5 id="单调队列的性质"><a href="#单调队列的性质" class="headerlink" title="单调队列的性质"></a>单调队列的性质</h5><ul><li>单调队列的最优选择在队首。</li><li>队列元素具有单调性。</li><li>去除冗余状态（无用状态）。</li><li>维护区间最值。</li></ul><h5 id="单调队列的构造方法"><a href="#单调队列的构造方法" class="headerlink" title="单调队列的构造方法"></a>单调队列的构造方法</h5><ul><li>维护队首（对于上题就是如果队首已经是当前元素的m个之前，则队首就应该被删了,head++）</li><li>在队尾插入（每插入一个就要从队尾开始往前去除冗杂状态，保持单调性）</li></ul><p>假如对于序列A：a1,  a2 , … an 建立一个单调递减栈维护长度为m的字段最大值，那么对于当前元素e，若队首元素小于e，那么其位置上不占优势（要被踢出长度为m的字段），而且其数值上也不占优势（比新来的e要小），所以其就要被舍弃。重复这一操作，直至队首元素大于元素e，那么说明其还有用，就保留。<br>举个应用例子：</p><p>数列为：6 4 10 10 8 6 4 2 12 14<br>N=10,K=3;<br>那么我们构造一个长度为3的单调递减队列：<br>首先，那6和它的位置0放入队列中，我们用(6,0)表示，每一步插入元素时队列中的元素如下<br>插入6：(6,0);<br>插入4：(6,0),(4,1);<br>插入10：(10,2);<br>插入第二个10，保留后面那个：(10,3);<br>插入8：(10,3),(8,4);<br>插入6：(10,3),(8,4),(6,5);<br>插入4，之前的10已经超出范围所以排掉：(8,4),(6,5),(4,6);<br>插入2，同理：(6,5),(4,6),(2,7);<br>插入12：(12,8);<br>插入14：(14,9);<br>那么f(i)就是第i步时队列当中的首元素：6,6,10,10,10,10,8,6,12,14同理，最小值也可以用单调队列来做。</p><h5 id="例题Poj-2823"><a href="#例题Poj-2823" class="headerlink" title="例题Poj 2823"></a>例题Poj 2823</h5><p>给定一个数列，从左至右输出每个长度为m的数列段内的最小数和最大数。数列长度：$N&lt;=10^6，m&lt;=N$<br><strong>解题思路：</strong><br>我们知道，暴力枚举的过程中，有一个地方是重复比较了，就是在找当前的f(i)的时候，i的前面其它m-1个数在算f(i-1)的时候我们就比较过了。当你一个个往下找时，每一次都是少一个然后多一个，如果少的不是最大值，然后再问新加进来的，看起来很省时间对吧，那么如果少了的是最大值呢？第二个最大值是什么？？那么我们能不能保存上一次的结果呢？当然主要是i的前k-1个数中的最大值了。答案是可以，这就要用到单调队列。</p><h5 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h5><p>见附录部分code-2</p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><h5 id="code-1：-HDU1506"><a href="#code-1：-HDU1506" class="headerlink" title="code-1： HDU1506"></a>code-1： HDU1506</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],n,Stack[N],w[N];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="function">ll <span class="title">max</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(Stack,<span class="number">0</span>,<span class="keyword">sizeof</span> Stack);</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;ans = <span class="number">0</span>;a[n+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(Stack[top] &lt; a[i])&#123;</span><br><span class="line">Stack[++top] = a[i];</span><br><span class="line">w[top] = <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">ll sumw = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(Stack[top] &gt; a[i])&#123;</span><br><span class="line">sumw += w[top];</span><br><span class="line">ans = max(ans,sumw*Stack[top]);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line">Stack[++top] = a[i];w[top] = sumw + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="code-2-Poj2823"><a href="#code-2-Poj2823" class="headerlink" title="code-2 Poj2823"></a>code-2 Poj2823</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;v[<span class="number">1010000</span>]; <span class="comment">//x表示值，y表示位置 可以理解为下标</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1010000</span>],n,m,mx[<span class="number">1010000</span>],mn[<span class="number">1010000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,head=<span class="number">1</span>,tail=<span class="number">0</span>;<span class="comment">// 默认起始位置为1 因为插入是v[++tail]故初始化为0</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail &amp;&amp; v[tail].x&gt;=a[i]) tail--;</span><br><span class="line">        v[++tail].x=a[i],v[tail].y=i;</span><br><span class="line">                <span class="comment">// 根据题目 前m-1个先直接进入队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail &amp;&amp; v[tail].x&gt;=a[i]) tail--;</span><br><span class="line">        v[++tail].x=a[i],v[tail].y=i;</span><br><span class="line">        <span class="keyword">while</span>(v[head].y&lt;i-m+<span class="number">1</span>) head++;</span><br><span class="line">        mn[i-m+<span class="number">1</span>]=v[head].x;</span><br><span class="line">               <span class="comment">// 道理同上，当然了 要把已经超出范围的从head开始排出</span></span><br><span class="line">               <span class="comment">//  然后每个队首则是目前m个数的最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmax</span><span class="params">()</span> <span class="comment">//最大值同最小值的道理，只不过是维护的是递减队列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail &amp;&amp; v[tail].x&lt;=a[i]) tail--;</span><br><span class="line">        v[++tail].x=a[i],v[tail].y=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail &amp;&amp; v[tail].x&lt;=a[i]) tail--;</span><br><span class="line">        v[++tail].x=a[i],v[tail].y=i;</span><br><span class="line">        <span class="keyword">while</span>(v[head].y&lt;i-m+<span class="number">1</span>) head++;</span><br><span class="line">        mx[i-m+<span class="number">1</span>]=v[head].x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    getmin();</span><br><span class="line">    getmax();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n-m+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"%d"</span>,mn[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" %d"</span>,mn[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n-m+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"%d"</span>,mx[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" %d"</span>,mx[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;单调栈和单调队列都可以看作是一种对栈和队列的特殊用法，即要求栈或队列中的元素具有单调性，递增或递减。那么很显然这种数据结构就是基于栈和队列实
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="单调栈" scheme="http://valenshi.top/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
      <category term="单调队列" scheme="http://valenshi.top/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>后缀数组题集</title>
    <link href="http://valenshi.top/2019/10/17/lcp-problems/"/>
    <id>http://valenshi.top/2019/10/17/lcp-problems/</id>
    <published>2019-10-17T05:13:33.000Z</published>
    <updated>2019-10-17T05:19:45.526Z</updated>
    
    <content type="html"><![CDATA[<p>sa[i]：排名为i的后缀起始位置是多少。<br>rank[i]：从 i 位置起始的后缀在所有后缀中字典序排序后序号，与sa互逆。<br>lcp[i]：S[sa[i] ,…] 与 S[sa[i+1] , …]的最长公共前缀。</p><h4 id="Musical-Theme"><a href="#Musical-Theme" class="headerlink" title="Musical Theme"></a>Musical Theme</h4><p><a href="http://poj.org/problem?id=1743" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给n个数组成的串，求是否有多个“相似”且不重叠的子串的长度大于等于5，两个子串相似当且仅当长度相等且每一位的数字差都相等。</p><p><strong>解题思路</strong><br>本题题意有些难理解。就是利用后缀数组+高度数组解决最长不重复子串问题，解法很套路，就是二分+判断。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POJ1743</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sa[N],rk[N],lcp[N],tmp[N];</span><br><span class="line"><span class="keyword">int</span> len,k;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= len?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= len?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line">len = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; len?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+len,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]]+compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j + h &lt; len &amp;&amp; i + h &lt; len;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(lcp[<span class="number">1</span>] &gt;= x) pre = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!pre &amp;&amp; lcp[i] &gt;= x) pre = i;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= x)<span class="comment">//注意一下到底是i还是i-1</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(sa[pre] - sa[i]) &gt; x) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(a,sa);</span><br><span class="line">construct_lcp(a,sa,lcp);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = n;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(++r &lt; <span class="number">5</span>) r = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n)&#123;</span><br><span class="line"><span class="comment">//注意，该模板必须从下标0开始存！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) b[i] = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) a[i] = b[i]-b[i<span class="number">-1</span>]+<span class="number">100</span>;</span><br><span class="line">a[<span class="number">0</span>] = b[<span class="number">0</span>]+<span class="number">100</span>; solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Milk-Patterns"><a href="#Milk-Patterns" class="headerlink" title="Milk Patterns"></a>Milk Patterns</h4><p><a href="http://poj.org/problem?id=3261" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>求可重叠的，出现k次的最长重复子串。<br><strong>解题思路</strong><br>这个就是可重叠的最长重复子串了，要求求出最长的，重复出现k次以上的子串，通过题意以及样例观察可知，是允许子串重复的。解决方法和上题类似，也是后缀数组+二分。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POJ3261</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,a[N],kk;</span><br><span class="line"><span class="keyword">int</span> rk[N],sa[N],lcp[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//别把全局变量的k覆盖了！！！</span></span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= x) cnt++;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt &gt;= kk) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt &gt;= kk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(a,sa);</span><br><span class="line">construct_lcp(a,sa,lcp);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line"><span class="comment">//for(int i = 1;i &lt;= n;i++) printf("%d ",lcp[i]);</span></span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;kk) != EOF)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="不同子串的个数"><a href="#不同子串的个数" class="headerlink" title="不同子串的个数"></a>不同子串的个数</h4><p><a href="https://www.luogu.org/problem/P2408" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给定一个字符串，求其所有子串中，不同的子串数量。</p><p><strong>解题思路</strong><br>利用后缀数组+高度数组求解。已知高度数组lcp，那么首先可以知道第一个sa[1]有n - sa[1]个不同子串；而2~n，每个sa[i] 有 n - sa[i] - lcp[i-1] 个不同子串。累加即可，注意结果可能爆 int。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P2408不同子串的个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> sa[N],lcp[N],tmp[N],k,rk[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line">sum = n - sa[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">sum += n - sa[i] - lcp[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line">construct_lcp(str,sa,lcp);</span><br><span class="line">calc();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">freopen(<span class="string">"123.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"222.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Substring"><a href="#Substring" class="headerlink" title="Substring"></a>Substring</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5769" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给定一个字符串，求所有不同的，且包含<strong>字符x</strong>的子串数量。</p><p><strong>解题思路</strong><br>和上一题有些类似，但是我们需要确保每一个被统计的子串包含字符x。那么我们可以用一个数组pos[p]来记录 p 后面第一个字符 x 的位置，那么我们从头开始统计时，sa[1]有n - pos[ sa[1] ] 个合法子串，其它位置有 n - max(pos[ sa[i] ] , sa[i] + lcp[i])个合法子串，将它们累加起来即可。<br>这题选G++编译器就超时，选C++就可以通过，猜测可能和STL有关。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hdu5769,G++超时,C++AC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">char</span> str[N],lv[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> rk[N],sa[N],lcp[N],tmp[N],k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pos[N];<span class="comment">//pos[x]:x后面第一个lv出现的位置</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line">construct_lcp(str,sa,lcp);</span><br><span class="line">pos[n] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(str[i] == lv[<span class="number">0</span>]) pos[i] = i;</span><br><span class="line"><span class="keyword">else</span> pos[i] = pos[i+<span class="number">1</span>];</span><br><span class="line">sum = n - pos[sa[<span class="number">1</span>]];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">sum += n - max(pos[sa[i]],sa[i]+lcp[i<span class="number">-1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>,++idx,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">freopen(<span class="string">"123.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"222.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,lv,str);</span><br><span class="line">n = <span class="built_in">strlen</span>(str);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Life-Forms"><a href="#Life-Forms" class="headerlink" title="Life Forms"></a>Life Forms</h4><p><a href="http://poj.org/problem?id=3294" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给定n个字符串，请问它们之间出现次数超过一半的最长公共子串是什么？如果有多个，按字典序输出。</p><p><strong>解题思路</strong><br>利用后缀数组+高度数组求解。我们将n个字符串拼接中一个“母串”，中间用不同的字符间隔；然后对母串求高度数组lcp，我们依旧是用二分搜索判定长度p是否合法，每次判定从前向后用O(N)时间遍历统计一遍即可。当我们得到最长的合法长度 p 后，再利用类似的方法输出所有的子串。</p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> str,s;</span><br><span class="line"><span class="keyword">int</span> n,k,len;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> sa[N],rk[N],lcp[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line">    <span class="keyword">int</span> ri = i+k &lt;= len?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> rj = j+k &lt;= len?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="built_in">string</span> S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line">    len = S.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line">        sa[i] = i;</span><br><span class="line">        rk[i] = i &lt; len ? S[i]:<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//k一定不能设置成局部变量导致覆盖全局变量！！！</span></span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= len;k *= <span class="number">2</span>)&#123;</span><br><span class="line">        sort(sa,sa+len+<span class="number">1</span>,compare_sa);</span><br><span class="line">        tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++)</span><br><span class="line">            tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="built_in">string</span> S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line">    len = S.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line">        <span class="keyword">for</span>(;j+h &lt; len &amp;&amp; i+h &lt; len;h++)</span><br><span class="line">            <span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">        lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">110</span>],idx[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    vis[idx[sa[<span class="number">1</span>]]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &lt; p)&#123;</span><br><span class="line">            cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!vis[idx[sa[i]]]) cnt++,vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= n/<span class="number">2</span>+<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    vis[idx[sa[<span class="number">1</span>]]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= len+<span class="number">1</span>;i++)&#123;  <span class="comment">//lcp[len+1] = 0,作为结束标志</span></span><br><span class="line">        <span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &lt; p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt;= n/<span class="number">2</span>+<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = sa[i<span class="number">-1</span>];j &lt; sa[i<span class="number">-1</span>]+p;j++) <span class="built_in">cout</span> &lt;&lt; str[j];</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!vis[idx[sa[i]]]) cnt++,vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    construct_sa(str,sa);</span><br><span class="line">    construct_lcp(str,sa,lcp);</span><br><span class="line">    <span class="comment">/*sa[i]：存放排名第i的后缀的起始位置*/</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"?"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> print(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; str; <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">2</span>,tot = <span class="number">0</span>; str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s; str += s+<span class="keyword">char</span>(++cnt);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= s.length();j++) idx[tot++] = i;</span><br><span class="line">        &#125; </span><br><span class="line">        solve();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Maximum-repetition-substring"><a href="#Maximum-repetition-substring" class="headerlink" title="Maximum repetition substring"></a>Maximum repetition substring</h4><p><strong>题意简述</strong><br>求一个字符串中，重复次数最多的连续重复子串是什么（循环次数最多的循环子串）。要求输出字典序最小的。</p><p>例如：ccabababc中，连续循环次数最多的子串是ababab。</p><p><strong>解题思路</strong><br>这题我对照题解写了很久，思想勉强搞懂。<br>先说做法，是枚举长度len（从1到n），然后判断以 len 为循环长度的 连续循环次数 最多的 子串 长度 是多少；假设这个子串长度是 l ，那么它的连续循环次数就是 l/len。<br>我们考虑如何求子串长度 l 。如果有一个字符串的循环节长度为len，那么必然有s[1,n-len] = s[len , n]，因此，如果字符串 s[len, n] 与 s[ 2 <em> len, n] 的公共前缀长度为 lcp，那么 s[len ,n] 的循环节个数为lcp / len + 1（加上的一个是开头为计算在lcp内的循环节 ）。<br>因此我们只需要对s[0] , s[len] ,s[2 </em> len] … , 判断相差 len 的两个相邻后缀的 lcp，就可以计算该子串循环节个数。这是由于如果一个子串的循环节长度为 len，且循环至少两次，那么显然它会包含相邻的两个len，否则就构不成循环了。当然可能起点并不在len的倍数位置上，因此我们还需要向前拓展一下。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> cse = <span class="number">0</span>,n;</span><br><span class="line"><span class="keyword">int</span> k,rk[N],lcp[N],sa[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]]+compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>],Log[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = lcp[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)</span><br><span class="line">st[i][j] = min(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &gt; r) swap(l,r); r--;</span><br><span class="line"><span class="keyword">int</span> kk = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> min(st[l][kk],st[r-(<span class="number">1</span>&lt;&lt;kk)+<span class="number">1</span>][kk]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mxtc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> q[N],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i+len &lt; n;i += len)&#123;</span><br><span class="line"><span class="keyword">int</span> l = ask(rk[i],rk[i+len]);</span><br><span class="line"><span class="keyword">int</span> res = l/len+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> pre = i - (len-l%len);</span><br><span class="line"><span class="keyword">if</span>(pre &gt;= <span class="number">0</span> &amp;&amp; ask(rk[pre],rk[pre+len]) &gt;= len) res++;</span><br><span class="line"><span class="keyword">if</span>(mxtc &lt; res) mxtc = res,cnt = <span class="number">0</span>,q[++cnt] = len;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(mxtc == res &amp;&amp; len != q[cnt]) q[++cnt] = len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAns</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= cnt;j++)</span><br><span class="line"><span class="keyword">if</span>(ask(rk[sa[i]],rk[sa[i]+q[j]]) &gt;= q[j]*(mxtc<span class="number">-1</span>))&#123;</span><br><span class="line">str[sa[i]+q[j]*mxtc] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">puts</span>(str+sa[i]); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line">construct_lcp(str,sa,lcp);<span class="comment">//lcp[n]是恒等于0的</span></span><br><span class="line"><span class="comment">/*下一步求重复次数最多的连续重复子串*/</span></span><br><span class="line">st_init();</span><br><span class="line">mxtc = cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) calc(i); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: "</span>,++cse);</span><br><span class="line">printAns();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str) != EOF)&#123;</span><br><span class="line">n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span> &amp;&amp; str[<span class="number">0</span>] == <span class="string">'#'</span>) <span class="keyword">break</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Common-Substrings"><a href="#Common-Substrings" class="headerlink" title="Common Substrings"></a>Common Substrings</h4><p><a href="http://poj.org/problem?id=3415" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给定2个字符串A和B，以及一个整数k。目标是求出这两个字符串中公共子串的数量，例如A:xx , B:xx，k = 1，那么公共子串数量就是5。<br><strong>解题思路</strong><br>将A和B拼接在一起，中间用一个未出现过的字符间隔，新串S = A+’#’+B；然后对S求高度数组，利用高度数组来求解。<br>对于属于 B 的每一个后缀，统计它与所有属于 A 的后缀的 lcp（最长公共前缀），并统计lcp-m+1，这就是该后缀和 A 的公共子串数量。这样做的复杂度是O(N^2)。</p><p>我们可以利用单调栈来在 O(N) 时间内解决；我们从前向后遍历lcp数组，将属于A的后缀的 lcp 压入栈；由于两个字符串的后缀是取它们中间的最小值，所以我们应该维护单调递减栈，同时需要维护的是 sum，sum代表当前 A 中相同的子串数量，也就是说如果当前后缀属于 B ，则直接加上sum即可。</p><p>由于我们是顺序遍历的，只统计了A对B的贡献，再反过来统计一次B对A的贡献即可。<br><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> A[N],B[N];</span><br><span class="line"><span class="keyword">int</span> rk[N],tmp[N],lcp[N],sa[N],k;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = i+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j =sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> idx[N];<span class="comment">//初始化为0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ll h,cnt;</span><br><span class="line">&#125;Stack[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(A,sa);</span><br><span class="line">construct_lcp(A,sa,lcp);</span><br><span class="line">ll ans = <span class="number">0</span>,sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ll cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top &amp;&amp; Stack[top].h &gt;= lcp[i<span class="number">-1</span>])&#123;</span><br><span class="line">cnt += Stack[top].cnt;</span><br><span class="line">sum -= Stack[top].cnt * (Stack[top].h-m+<span class="number">1</span>);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= m)&#123;</span><br><span class="line">cnt += idx[sa[i<span class="number">-1</span>]] == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt) Stack[++top] = Node&#123;lcp[i<span class="number">-1</span>],cnt&#125;;</span><br><span class="line">sum += (lcp[i<span class="number">-1</span>]-m+<span class="number">1</span>)*cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(idx[sa[i]] == <span class="number">1</span>) ans += sum;</span><br><span class="line">&#125;</span><br><span class="line">top = <span class="number">0</span>; sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ll cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top &amp;&amp; Stack[top].h &gt;= lcp[i<span class="number">-1</span>])&#123;</span><br><span class="line">cnt += Stack[top].cnt;</span><br><span class="line">sum -= Stack[top].cnt * (Stack[top].h-m+<span class="number">1</span>);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= m)&#123;</span><br><span class="line">cnt += idx[sa[i<span class="number">-1</span>]] == <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt) Stack[++top] = Node&#123;lcp[i<span class="number">-1</span>],cnt&#125;;</span><br><span class="line">sum += (lcp[i<span class="number">-1</span>]-m+<span class="number">1</span>)*cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!idx[sa[i]]) ans += sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m) != EOF &amp;&amp; m)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,A);</span><br><span class="line"><span class="built_in">memset</span>(idx,<span class="number">0</span>,<span class="keyword">sizeof</span> idx);</span><br><span class="line">n = <span class="built_in">strlen</span>(A); </span><br><span class="line">idx[n] = <span class="number">2</span>; A[n++] = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) idx[i] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,A+n);</span><br><span class="line">n = <span class="built_in">strlen</span>(A);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;sa[i]：排名为i的后缀起始位置是多少。&lt;br&gt;rank[i]：从 i 位置起始的后缀在所有后缀中字典序排序后序号，与sa互逆。&lt;br&gt;lcp[i]：S[sa[i] ,…] 与 S[sa[i+1] , …]的最长公共前缀。&lt;/p&gt;
&lt;h4 id=&quot;Musical-Them
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="后缀数组" scheme="http://valenshi.top/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>后缀数组的常见应用</title>
    <link href="http://valenshi.top/2019/10/17/lcp-use/"/>
    <id>http://valenshi.top/2019/10/17/lcp-use/</id>
    <published>2019-10-17T05:13:32.000Z</published>
    <updated>2019-10-17T05:20:01.958Z</updated>
    
    <content type="html"><![CDATA[<h3 id="后缀数组的应用"><a href="#后缀数组的应用" class="headerlink" title="后缀数组的应用"></a>后缀数组的应用</h3><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>后缀数组是处理字符串相关问题的有力工具，后缀数组的题型与解法相对固定，因此对于本文中的几种题型要掌握解法与原理。本文假设读者已经掌握求后缀数组（sa）以及高度数组（lcp）的算法。<br>本文将介绍4类后缀数组的应用，分别是：</p><ul><li>最长公共前缀</li><li>单个字符串相关问题</li><li>两个字符串相关问题</li><li>多个字符串相关问题<h4 id="相关符号说明"><a href="#相关符号说明" class="headerlink" title="相关符号说明"></a>相关符号说明</h4>S 是原字符串。<br>suffix( i )表示字符串 S 从位置 i 开始的后缀。<br>sa( i )表示排名为第 i 的后缀的起始位置。<br>rk( i )表示 起始位置为 i 的后缀的排名。<br>lcp( i )表示排名为 i 的后缀与排名为 i+1 的后缀的最长公共前缀的长度。</li></ul><h4 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h4><p><strong>例1：</strong> 给定一个字符串，询问某两个后缀的最长公共前缀。<br><strong>解题思路：</strong><br>我们已经知道lcp[ i ]是排名为 i 的后缀与排名为 i+1 的后缀的最长公共前缀的长度，而我们又可以通过sa数组来得到任意俩个后缀的排名，因此对于给定的两个后缀，我们可以先求出它们的排名，分别设为 i 和 j （i &lt;= j），那么ans = min{ lcp[i] , lcp[i+1] , … , lcp[j - 1] }，也就相当于求RMQ问题，所以接下来的询问可以当做RMQ问题来采用合适的算法（例如st表）。</p><h4 id="单个字符串相关问题"><a href="#单个字符串相关问题" class="headerlink" title="单个字符串相关问题"></a>单个字符串相关问题</h4><p>这类问题的一个常用做法是先求后缀数组和lcp数组，然后利用lcp数组求解。</p><h5 id="重复子串问题"><a href="#重复子串问题" class="headerlink" title="重复子串问题"></a>重复子串问题</h5><p><strong>重复子串：</strong> 字符串R在字符串L中至少出现两次，则称 R 是 L 的重复子串。</p><p><strong>例2：可重叠最长重复子串</strong><br>给定一个字符串，求最长重复子串，这两个子串可以重叠。<br><strong>解题思路：</strong><br>求最长重复子串，等价于求两个后缀的最长公共前缀的最大值。于是我们只需要求出lcp数组中的最大值即可。由于任意两个后缀的最长公共前缀一定是lcp数组中某一段的最小值，那么这个值一定不大于lcp数组里的最大值。所以最长重复子串的长度就是lcp数组里的最大值。该做法时间复杂度为O(N)。</p><p><strong>例3：不可重叠最长重复子串</strong><br>给定一个字符串，求最长重复子串，这两个子串不能重叠。<br><strong>Musical Theme</strong><br><a href="http://poj.org/problem?id=1743" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给n个数组成的串，求是否有多个“相似”且不重叠的子串的长度大于等于5，两个子串相似当且仅当长度相等且每一位的数字差都相等。</p><p><strong>解题思路</strong><br>本题题意有些难理解。就是利用后缀数组+高度数组解决最长不重复子串问题，解法很套路，就是二分+判断。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POJ1743</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sa[N],rk[N],lcp[N],tmp[N];</span><br><span class="line"><span class="keyword">int</span> len,k;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= len?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= len?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line">len = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; len?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+len,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]]+compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j + h &lt; len &amp;&amp; i + h &lt; len;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(lcp[<span class="number">1</span>] &gt;= x) pre = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!pre &amp;&amp; lcp[i] &gt;= x) pre = i;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= x)<span class="comment">//注意一下到底是i还是i-1</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(sa[pre] - sa[i]) &gt; x) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(a,sa);</span><br><span class="line">construct_lcp(a,sa,lcp);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = n;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(++r &lt; <span class="number">5</span>) r = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n)&#123;</span><br><span class="line"><span class="comment">//注意，该模板必须从下标0开始存！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) b[i] = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) a[i] = b[i]-b[i<span class="number">-1</span>]+<span class="number">100</span>;</span><br><span class="line">a[<span class="number">0</span>] = b[<span class="number">0</span>]+<span class="number">100</span>; solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>例4：可重叠的k次最长重复子串POJ3261</strong><br><a href="http://poj.org/problem?id=3261" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>求可重叠的，出现k次的最长重复子串。<br><strong>解题思路</strong><br>这个就是可重叠的最长重复子串了，要求求出最长的，重复出现k次以上的子串，通过题意以及样例观察可知，是允许子串重复的。解决方法和上题类似，也是后缀数组+二分。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POJ3261</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,a[N],kk;</span><br><span class="line"><span class="keyword">int</span> rk[N],sa[N],lcp[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//别把全局变量的k覆盖了！！！</span></span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= x) cnt++;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt &gt;= kk) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt &gt;= kk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(a,sa);</span><br><span class="line">construct_lcp(a,sa,lcp);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line"><span class="comment">//for(int i = 1;i &lt;= n;i++) printf("%d ",lcp[i]);</span></span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;kk) != EOF)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="子串的个数"><a href="#子串的个数" class="headerlink" title="子串的个数"></a>子串的个数</h5><p><strong>例5：求不同子串的个数</strong><br><strong>题意简述</strong><br>给定一个字符串，求其所有子串中，不同的子串数量。<br><strong>解题思路</strong><br>利用后缀数组+高度数组求解。已知高度数组lcp，那么首先可以知道第一个sa[1]有n - sa[1]个不同子串；而2~n，每个sa[i] 有 n - sa[i] - lcp[i-1] 个不同子串。累加即可，注意结果可能爆 int。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P2408不同子串的个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> sa[N],lcp[N],tmp[N],k,rk[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line">sum = n - sa[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">sum += n - sa[i] - lcp[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line">construct_lcp(str,sa,lcp);</span><br><span class="line">calc();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">freopen(<span class="string">"123.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"222.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h5><p><strong>例6：求最长回文子串</strong></p><p>穷举每一位，然后计算以这个字符为中心的最长回文子串。注意这里要对长度分奇偶讨论。两种情况都可以转化为求一个后缀和一个反过来写的后缀的最长公共前缀。具体做法是：将整个字符反过来放在原字符串后面，中间用一个特殊字符隔开，这样就转化为了求新串的某两个后缀的最长公共前缀。</p><h5 id="连续重复子串"><a href="#连续重复子串" class="headerlink" title="连续重复子串"></a>连续重复子串</h5><p><strong>例7：重复次数最多的连续子串</strong><br><strong>Maximum repetition substring</strong><br><strong>题意简述</strong><br>求一个字符串中，重复次数最多的连续重复子串是什么（循环次数最多的循环子串）。要求输出字典序最小的。</p><p>例如：ccabababc中，连续循环次数最多的子串是ababab。</p><p><strong>解题思路</strong><br>这题我对照题解写了很久，思想勉强搞懂。<br>先说做法，是枚举长度len（从1到n），然后判断以 len 为循环长度的 连续循环次数 最多的 子串 长度 是多少；假设这个子串长度是 l ，那么它的连续循环次数就是 l/len。<br>我们考虑如何求子串长度 l 。如果有一个字符串的循环节长度为len，那么必然有s[1,n-len] = s[len , n]，因此，如果字符串 s[len, n] 与 s[ 2 <em> len, n] 的公共前缀长度为 lcp，那么 s[len ,n] 的循环节个数为lcp / len + 1（加上的一个是开头为计算在lcp内的循环节 ）。<br>因此我们只需要对s[0] , s[len] ,s[2 </em> len] … , 判断相差 len 的两个相邻后缀的 lcp，就可以计算该子串循环节个数。这是由于如果一个子串的循环节长度为 len，且循环至少两次，那么显然它会包含相邻的两个len，否则就构不成循环了。当然可能起点并不在len的倍数位置上，因此我们还需要向前拓展一下。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> cse = <span class="number">0</span>,n;</span><br><span class="line"><span class="keyword">int</span> k,rk[N],lcp[N],sa[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]]+compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>],Log[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = lcp[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)</span><br><span class="line">st[i][j] = min(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &gt; r) swap(l,r); r--;</span><br><span class="line"><span class="keyword">int</span> kk = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> min(st[l][kk],st[r-(<span class="number">1</span>&lt;&lt;kk)+<span class="number">1</span>][kk]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mxtc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> q[N],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i+len &lt; n;i += len)&#123;</span><br><span class="line"><span class="keyword">int</span> l = ask(rk[i],rk[i+len]);</span><br><span class="line"><span class="keyword">int</span> res = l/len+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> pre = i - (len-l%len);</span><br><span class="line"><span class="keyword">if</span>(pre &gt;= <span class="number">0</span> &amp;&amp; ask(rk[pre],rk[pre+len]) &gt;= len) res++;</span><br><span class="line"><span class="keyword">if</span>(mxtc &lt; res) mxtc = res,cnt = <span class="number">0</span>,q[++cnt] = len;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(mxtc == res &amp;&amp; len != q[cnt]) q[++cnt] = len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAns</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= cnt;j++)</span><br><span class="line"><span class="keyword">if</span>(ask(rk[sa[i]],rk[sa[i]+q[j]]) &gt;= q[j]*(mxtc<span class="number">-1</span>))&#123;</span><br><span class="line">str[sa[i]+q[j]*mxtc] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">puts</span>(str+sa[i]); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line">construct_lcp(str,sa,lcp);<span class="comment">//lcp[n]是恒等于0的</span></span><br><span class="line"><span class="comment">/*下一步求重复次数最多的连续重复子串*/</span></span><br><span class="line">st_init();</span><br><span class="line">mxtc = cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) calc(i); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: "</span>,++cse);</span><br><span class="line">printAns();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str) != EOF)&#123;</span><br><span class="line">n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span> &amp;&amp; str[<span class="number">0</span>] == <span class="string">'#'</span>) <span class="keyword">break</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="两个字符串相关问题"><a href="#两个字符串相关问题" class="headerlink" title="两个字符串相关问题"></a>两个字符串相关问题</h4><p>这类问题的一个常用做法是，先连接这两个字符串，然后求后缀数组和高度数组，再利用高度数组求解。</p><h5 id="公共子串"><a href="#公共子串" class="headerlink" title="公共子串"></a>公共子串</h5><p><strong>例8：公共子串的数量：Common Substrings</strong></p><p><strong>题意简述</strong><br>给定2个字符串A和B，以及一个整数k。目标是求出这两个字符串中公共子串的数量，例如A:xx , B:xx，k = 1，那么公共子串数量就是5。<br><strong>解题思路</strong><br>将A和B拼接在一起，中间用一个未出现过的字符间隔，新串S = A+’#’+B；然后对S求高度数组，利用高度数组来求解。<br>对于属于 B 的每一个后缀，统计它与所有属于 A 的后缀的 lcp（最长公共前缀），并统计lcp-m+1，这就是该后缀和 A 的公共子串数量。这样做的复杂度是O(N^2)。</p><p>我们可以利用单调栈来在 O(N) 时间内解决；我们从前向后遍历lcp数组，将属于A的后缀的 lcp 压入栈；由于两个字符串的后缀是取它们中间的最小值，所以我们应该维护单调递减栈，同时需要维护的是 sum，sum代表当前 A 中相同的子串数量，也就是说如果当前后缀属于 B ，则直接加上sum即可。</p><p>由于我们是顺序遍历的，只统计了A对B的贡献，再反过来统计一次B对A的贡献即可。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> A[N],B[N];</span><br><span class="line"><span class="keyword">int</span> rk[N],tmp[N],lcp[N],sa[N],k;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = i+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j =sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> idx[N];<span class="comment">//初始化为0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ll h,cnt;</span><br><span class="line">&#125;Stack[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(A,sa);</span><br><span class="line">construct_lcp(A,sa,lcp);</span><br><span class="line">ll ans = <span class="number">0</span>,sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ll cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top &amp;&amp; Stack[top].h &gt;= lcp[i<span class="number">-1</span>])&#123;</span><br><span class="line">cnt += Stack[top].cnt;</span><br><span class="line">sum -= Stack[top].cnt * (Stack[top].h-m+<span class="number">1</span>);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= m)&#123;</span><br><span class="line">cnt += idx[sa[i<span class="number">-1</span>]] == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt) Stack[++top] = Node&#123;lcp[i<span class="number">-1</span>],cnt&#125;;</span><br><span class="line">sum += (lcp[i<span class="number">-1</span>]-m+<span class="number">1</span>)*cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(idx[sa[i]] == <span class="number">1</span>) ans += sum;</span><br><span class="line">&#125;</span><br><span class="line">top = <span class="number">0</span>; sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ll cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top &amp;&amp; Stack[top].h &gt;= lcp[i<span class="number">-1</span>])&#123;</span><br><span class="line">cnt += Stack[top].cnt;</span><br><span class="line">sum -= Stack[top].cnt * (Stack[top].h-m+<span class="number">1</span>);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= m)&#123;</span><br><span class="line">cnt += idx[sa[i<span class="number">-1</span>]] == <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt) Stack[++top] = Node&#123;lcp[i<span class="number">-1</span>],cnt&#125;;</span><br><span class="line">sum += (lcp[i<span class="number">-1</span>]-m+<span class="number">1</span>)*cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!idx[sa[i]]) ans += sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m) != EOF &amp;&amp; m)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,A);</span><br><span class="line"><span class="built_in">memset</span>(idx,<span class="number">0</span>,<span class="keyword">sizeof</span> idx);</span><br><span class="line">n = <span class="built_in">strlen</span>(A); </span><br><span class="line">idx[n] = <span class="number">2</span>; A[n++] = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) idx[i] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,A+n);</span><br><span class="line">n = <span class="built_in">strlen</span>(A);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="多个字符串相关问题"><a href="#多个字符串相关问题" class="headerlink" title="多个字符串相关问题"></a>多个字符串相关问题</h4><p>这类问题的一个常用做法是，先将所有的字符串连接起来，然后求后缀数组和高度数组，再利用高度数组进行求解。中间可能还要利用二分答案。</p><p><strong>例9：不小于k个字符串中的最长子串。</strong></p><p><strong>Life Forms</strong><br><a href="http://poj.org/problem?id=3294" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给定n个字符串，请问它们之间出现次数超过一半的最长公共子串是什么？如果有多个，按字典序输出。</p><p><strong>解题思路</strong><br>利用后缀数组+高度数组求解。我们将n个字符串拼接中一个“母串”，中间用不同的字符间隔；然后对母串求高度数组lcp，我们依旧是用二分搜索判定长度p是否合法，每次判定从前向后用O(N)时间遍历统计一遍即可。当我们得到最长的合法长度 p 后，再利用类似的方法输出所有的子串。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> str,s;</span><br><span class="line"><span class="keyword">int</span> n,k,len;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> sa[N],rk[N],lcp[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line">    <span class="keyword">int</span> ri = i+k &lt;= len?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> rj = j+k &lt;= len?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="built_in">string</span> S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line">    len = S.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line">        sa[i] = i;</span><br><span class="line">        rk[i] = i &lt; len ? S[i]:<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//k一定不能设置成局部变量导致覆盖全局变量！！！</span></span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= len;k *= <span class="number">2</span>)&#123;</span><br><span class="line">        sort(sa,sa+len+<span class="number">1</span>,compare_sa);</span><br><span class="line">        tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++)</span><br><span class="line">            tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="built_in">string</span> S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line">    len = S.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line">        <span class="keyword">for</span>(;j+h &lt; len &amp;&amp; i+h &lt; len;h++)</span><br><span class="line">            <span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">        lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">110</span>],idx[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    vis[idx[sa[<span class="number">1</span>]]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &lt; p)&#123;</span><br><span class="line">            cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!vis[idx[sa[i]]]) cnt++,vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= n/<span class="number">2</span>+<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    vis[idx[sa[<span class="number">1</span>]]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= len+<span class="number">1</span>;i++)&#123;  <span class="comment">//lcp[len+1] = 0,作为结束标志</span></span><br><span class="line">        <span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &lt; p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt;= n/<span class="number">2</span>+<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = sa[i<span class="number">-1</span>];j &lt; sa[i<span class="number">-1</span>]+p;j++) <span class="built_in">cout</span> &lt;&lt; str[j];</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!vis[idx[sa[i]]]) cnt++,vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    construct_sa(str,sa);</span><br><span class="line">    construct_lcp(str,sa,lcp);</span><br><span class="line">    <span class="comment">/*sa[i]：存放排名第i的后缀的起始位置*/</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"?"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> print(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; str; <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">2</span>,tot = <span class="number">0</span>; str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s; str += s+<span class="keyword">char</span>(++cnt);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= s.length();j++) idx[tot++] = i;</span><br><span class="line">        &#125; </span><br><span class="line">        solve();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>罗穗骞，后缀数组——处理字符串的有利工具，2009.1</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;后缀数组的应用&quot;&gt;&lt;a href=&quot;#后缀数组的应用&quot; class=&quot;headerlink&quot; title=&quot;后缀数组的应用&quot;&gt;&lt;/a&gt;后缀数组的应用&lt;/h3&gt;&lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="后缀数组" scheme="http://valenshi.top/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>树链剖分题集</title>
    <link href="http://valenshi.top/2019/10/12/lct-problems/"/>
    <id>http://valenshi.top/2019/10/12/lct-problems/</id>
    <published>2019-10-12T06:30:05.000Z</published>
    <updated>2019-10-12T06:32:22.569Z</updated>
    
    <content type="html"><![CDATA[<p>树链剖分常用于处理静态树上操作，效率很高，写起来也就是固定的轻重边拆分+线段树，但是代码一般都是100行+，容易出错。<br>本题集中的树链剖分练习题，在解决思路上没什么难点，主要是如何设计线段树以及如何更新+询问，也就是说要想好怎么维护线段树，其它地方没什么太难的，但是代码长就容易出bug，多写写就好了。最后一题是线段树动态开点，这和可持久化权值线段树（动态主席树）一样的思想，只需要将普通的线段树给稍微修改一下即可。</p><h4 id="树的统计"><a href="#树的统计" class="headerlink" title="树的统计"></a>树的统计</h4><p><strong>题意简述</strong><br>原题来自：ZJOI 2008<br>一树上有 n 个节点，编号分别为 1 到 n，每个节点都有一个权值 w。我们将以下面的形式来要求你对这棵树完成一些操作：</p><p>1.CHANGE u t ：把节点 u 权值改为 t；</p><p>2.QMAX u v ：询问点 u 到点 v 路径上的节点的最大权值；</p><p>3.QSUM u v ：询问点 u 到点 v 路径上的节点的权值和。</p><p>注意：从点 u 到点 v 路径上的节点包括 u 和 v 本身。</p><p><strong>解题思路</strong><br>树链剖分+线段树上单点修改，区间查询，需要注意查询操作，利用到了LCA倍增思想，树链剖分中很多区间修改和查询操作都是这样完成的。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y, edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,q,a[N];</span><br><span class="line"><span class="comment">/*父亲,深度,子树大小,重儿子,重路径顶部节点,</span></span><br><span class="line"><span class="comment">    树中节点在线段树中下标,线段树中节点对应树中位置*/</span></span><br><span class="line"><span class="keyword">int</span> par[N],deep[N],size[N],son[N],top[N],seg[N],rev[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*利用深搜更新par,size,deep,son数组*/</span></span><br><span class="line">    vis[x] = <span class="literal">true</span>; size[x] = <span class="number">1</span>;</span><br><span class="line">    par[x] = fa; deep[x] = deep[fa]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(y == fa || vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y,x);</span><br><span class="line">        size[x] += size[y]; <span class="comment">//累加子树大小</span></span><br><span class="line">        <span class="keyword">if</span>(size[y] &gt; size[son[x]]) son[x] = y;<span class="comment">//求重儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x])&#123; <span class="comment">//先走重儿子,使得重路径在线段树中连续</span></span><br><span class="line">        seg[son[x]] = ++seg[<span class="number">0</span>];<span class="comment">//0位置用不到,利用来计数</span></span><br><span class="line">        top[son[x]] = top[x];</span><br><span class="line">        rev[seg[<span class="number">0</span>]] = son[x];</span><br><span class="line">        dfs2(son[x],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(top[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">/*若y没有被遍历过,即y不是x的重儿子或者父亲*/</span></span><br><span class="line">        seg[y] = ++seg[<span class="number">0</span>]; rev[seg[<span class="number">0</span>]] = y;</span><br><span class="line">        top[y] = y; dfs2(y,x);</span><br><span class="line">        <span class="comment">/*如果x--&gt;y是轻边,那么y就是其所在重路径顶部节点*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    ll mx, sum;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mx(x) t[x].mx</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    l(rt) = l, r(rt) = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        mx(rt) = sum(rt) = a[rev[l]]; <span class="comment">//线段树上l节点对应着树上rev[l]点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    BuildTree(rt*<span class="number">2</span>,l,mid); BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    mx(rt) = max(mx(rt&lt;&lt;<span class="number">1</span>),mx(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>) + sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preHandle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>); <span class="comment">//我们以1号节点为根</span></span><br><span class="line">    <span class="comment">/*根节点所在重路径的顶部节点也是根节点,赋初值*/</span></span><br><span class="line">    seg[<span class="number">0</span>] = seg[<span class="number">1</span>] = top[<span class="number">1</span>] = rev[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    BuildTree(<span class="number">1</span>,<span class="number">1</span>,seg[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">ll tmx,tsum;<span class="comment">//利用全局变量同时统计2个答案</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*将以rt为根的区间内属于[l,r]部分的和累加到tsum上,并更新tmx*/</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">        tsum += sum(rt); tmx = max(tmx,mx(rt));</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) query(rt&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*返回x与y之间路径上权值最大点的权值*/</span></span><br><span class="line">    <span class="keyword">int</span> fx = top[x] , fy = top[y];</span><br><span class="line">    <span class="keyword">while</span>(fx != fy)&#123;<span class="comment">//先将x和y条整到同一个重链上</span></span><br><span class="line">        <span class="keyword">if</span>(deep[fx] &lt; deep[fy]) swap(x,y),swap(fx,fy);</span><br><span class="line">        query(<span class="number">1</span>,seg[fx],seg[x]);</span><br><span class="line">        x = par[fx]; fx = top[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deep[x] &gt; deep[y]) swap(x,y);<span class="comment">//路径浅的编号小</span></span><br><span class="line">    query(<span class="number">1</span>,seg[x],seg[y]); <span class="comment">//再更新一次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*把线段树节点x的权值改为val*/</span></span><br><span class="line">    <span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">        mx(rt) = sum(rt) = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt) + r(rt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; mid) change(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,val);</span><br><span class="line">    <span class="keyword">else</span> change(rt&lt;&lt;<span class="number">1</span>,x,val);</span><br><span class="line">    mx(rt) = max(mx(rt&lt;&lt;<span class="number">1</span>),mx(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>) + sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">"123.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">"222.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        addEdge(x,y,<span class="number">1</span>); addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    preHandle();<span class="comment">//树链剖分预处理</span></span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= q;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>,op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'C'</span>) change(<span class="number">1</span>,seg[x],y);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmx = -INF; tsum = <span class="number">0</span>;</span><br><span class="line">            ask(x,y);<span class="comment">//同时更新最大值与路径和</span></span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">'M'</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,tmx);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,tsum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="「HAOI2015」树上操作"><a href="#「HAOI2015」树上操作" class="headerlink" title="「HAOI2015」树上操作"></a>「HAOI2015」树上操作</h4><p><strong>题意简述</strong><br>有一棵点数为 N 的树，以点 1 为根，且树有点权。然后有 M 个操作，分为三种：</p><p>1、把某个节点 x 的点权增加 a 。</p><p>2、把某个节点 x 为根的子树中所有点的点权都增加 a 。</p><p>3、询问某个节点 x 到根的路径中所有点的点权和。</p><p><strong>解题思路</strong><br>树链剖分+线段树上区间修改，区间查询。用到了线段树上的延迟标记，其实和普通线段树没啥区别，就是查询和修改时候要用LCA倍增思想将树上的链转化为线段树上的区间。只要理解了树上节点和线段树下标是通过seg[x] 和 rev[seg[x]]来转换的即可。</p><p>另外还需要明白线段树上重链的seg[]值是连续的，同一个子树上的所有节点下标也是连续的，这个结论可以通过观察dfs2的实现得到。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y,edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">        ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> deep[N],par[N],top[N],size[N],son[N],seg[N],rev[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>; par[x] = fa;</span><br><span class="line">    deep[x] = deep[fa]+<span class="number">1</span>; size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(vis[y] || y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y,x);</span><br><span class="line">        size[x] += size[y]; </span><br><span class="line">        <span class="keyword">if</span>(size[y] &gt; size[son[x]]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x])&#123;</span><br><span class="line">        seg[son[x]] = ++seg[<span class="number">0</span>];</span><br><span class="line">        rev[seg[<span class="number">0</span>]] = son[x];</span><br><span class="line">        top[son[x]] = top[x];</span><br><span class="line">        dfs2(son[x],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(top[y]) <span class="keyword">continue</span>;</span><br><span class="line">        seg[y] = ++seg[<span class="number">0</span>]; rev[seg[<span class="number">0</span>]] = y;</span><br><span class="line">        top[y] = y; dfs2(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    ll sum,add;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> add(x) t[x].add</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    l(rt) = l,r(rt) = r,add(rt) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        sum(rt) = a[rev[l]]; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    BuildTree(rt&lt;&lt;<span class="number">1</span>,l,mid); BuildTree(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>) + sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preHandle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    seg[<span class="number">0</span>] = seg[<span class="number">1</span>] = top[<span class="number">1</span>] = rev[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    BuildTree(<span class="number">1</span>,<span class="number">1</span>,seg[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!add(rt)) <span class="keyword">return</span>;</span><br><span class="line">    sum(rt&lt;&lt;<span class="number">1</span>) += (r(rt&lt;&lt;<span class="number">1</span>)-l(rt&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>)*add(rt);</span><br><span class="line">    sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) += (r(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)-l(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)+<span class="number">1</span>)*add(rt);</span><br><span class="line">    add(rt&lt;&lt;<span class="number">1</span>) += add(rt); add(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) += add(rt);</span><br><span class="line">    add(rt) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">        sum(rt) += (r(rt) - l(rt)+<span class="number">1</span>)*val;</span><br><span class="line">        add(rt) += val; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spread(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) Add(rt&lt;&lt;<span class="number">1</span>,l,r,val);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) Add(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,val);</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>)+sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> sum(rt);</span><br><span class="line">    spread(rt); ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt) + r(rt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res += query(rt&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res += query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*从节点x到根节点的路径和*/</span></span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        res += query(<span class="number">1</span>,seg[top[x]],seg[x]);</span><br><span class="line">        x = par[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = getInt(); m = getInt();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line">        x = getInt(); y = getInt();</span><br><span class="line">        addEdge(x,y,<span class="number">1</span>); addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    preHandle();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,op,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">        op = getInt();</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            x = getInt(); y = getInt();</span><br><span class="line">            Add(<span class="number">1</span>,seg[x],seg[x],y);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line">            x = getInt(); y = getInt();</span><br><span class="line">            Add(<span class="number">1</span>,seg[x],seg[x]+size[x]<span class="number">-1</span>,y);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            x = getInt(); <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="「NOI2015」软件包管理器"><a href="#「NOI2015」软件包管理器" class="headerlink" title="「NOI2015」软件包管理器"></a>「NOI2015」软件包管理器</h4><p><strong>题意简述</strong><br>Linux 用户和 OSX 用户一定对软件包管理器不会陌生。通过软件包管理器，你可以通过一行命令安装某一个软件包，然后软件包管理器会帮助你从软件源下载软件包，同时自动解决所有的依赖（即下载安装这个软件包的安装所依赖的其它软件包），完成所有的配置。Debian/Ubuntu 使用的 apt-get，Fedora/CentOS 使用的 yum，以及 OSX 下可用的 Homebrew 都是优秀的软件包管理器。</p><p>你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包 A 依赖软件包 B，那么安装软件包 A 以前，必须先安装软件包 B。同时，如果想要卸载软件包 B，则必须卸载软件包 A。现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除 0 号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而 0 号软件包不依赖任何一个软件包。依赖关系不存在环（若有m(m≥2) 个软件包A1,A2,A3,…,Am ，其中 A1 依赖 A2，A2依赖 A3 依赖 A4 ，……，Am−1 依赖 Am ，而 Am 依赖 A1 ，则称这 m 个软件包的依赖关系构成环），当然也不会有一个软件包依赖自己。</p><p>现在你要为你的软件包管理器写一个依赖解决程序。根据反馈，用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包），你的任务就是实现这个部分。注意，安装一个已安装的软件包，或卸载一个未安装的软件包，都不会改变任何软件包的安装状态，即在此情况下，改变安装状态的软件包数为 0。</p><p><strong>解题思路</strong><br>要画图理解题意，若A依赖B，则安装A之前要安装B，若卸载B要先卸载A。也就是说要安装A，就要确保A到根节点路径上软件都已安装；若卸载A，就要确保 A 的子树为空。</p><p>于是就是树上操作，若卸载一个软件 x ，就是查询它子树上已安装的软件个数（包括它自己），输出后再删除即可；若安装一个软件 x ，就是查询 x 到根节点路径上未安装的软件个数（包括它自己），输出后再安装。因为软件安装和卸载只是改变其状态（已安装：1，未安装：0），而不改变结构（彻底删除节点），所以可以用树链剖分+线段树解决。</p><p>但是需要注意的是，怎么把整棵子树都清零，怎么把到根节点的路径都置 1，显然要用延迟标记，但是延迟标记却不应该累加，那要怎么处理？<br>置 1 时延迟标记add = 1，置0时延迟标记add = -1，每一个节点如果延迟标记不为0，那么该节点为根的子树所有软件状态相同。我们下传延迟标记操作封装在spread函数内，可以参考如何实现延迟标记的更新。</p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y, edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> par[N],deep[N],size[N],son[N],top[N],seg[N],rev[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>; par[x] = fa;</span><br><span class="line">    deep[x] = deep[fa]+<span class="number">1</span>; size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y,x);</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">        <span class="keyword">if</span>(size[y] &gt; size[son[x]]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x])&#123;</span><br><span class="line">        seg[son[x]] = ++seg[<span class="number">0</span>];</span><br><span class="line">        rev[seg[<span class="number">0</span>]] = son[x];</span><br><span class="line">        top[son[x]] = top[x];</span><br><span class="line">        dfs2(son[x],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(top[y]) <span class="keyword">continue</span>;</span><br><span class="line">        seg[y] = ++seg[<span class="number">0</span>]; rev[seg[<span class="number">0</span>]] = y;</span><br><span class="line">        top[y] = y; dfs2(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,sum,add;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> add(x) t[x].add</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    l(rt) = l,r(rt) = r,add(rt) = sum(rt) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    BuildTree(rt&lt;&lt;<span class="number">1</span>,l,mid); BuildTree(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>) + sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preHandle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    seg[<span class="number">0</span>] = seg[<span class="number">1</span>] = top[<span class="number">1</span>] = rev[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    BuildTree(<span class="number">1</span>,<span class="number">1</span>,seg[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!add(rt)) <span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">if</span>(add(rt) == <span class="number">-1</span>)&#123;</span><br><span class="line">        sum(rt&lt;&lt;<span class="number">1</span>) = sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">        add(rt&lt;&lt;<span class="number">1</span>) = add(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = add(rt);</span><br><span class="line">        add(rt) = <span class="number">0</span>; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum(rt&lt;&lt;<span class="number">1</span>) = (r(rt&lt;&lt;<span class="number">1</span>)-l(rt&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>)*add(rt);</span><br><span class="line">    sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = (r(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)-l(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)+<span class="number">1</span>)*add(rt);</span><br><span class="line">    add(rt&lt;&lt;<span class="number">1</span>) = add(rt); add(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = add(rt);</span><br><span class="line">    add(rt) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(val == <span class="number">-1</span>) sum(rt) = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> sum(rt) = (r(rt) - l(rt)+<span class="number">1</span>);</span><br><span class="line">        add(rt) = val; </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spread(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) Add(rt&lt;&lt;<span class="number">1</span>,l,r,val);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) Add(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,val);</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>)+sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> sum(rt);</span><br><span class="line">    spread(rt); ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt) + r(rt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res += query(rt&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res += query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> query(<span class="number">1</span>,seg[x],seg[x]+size[x]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        res += query(<span class="number">1</span>,seg[top[x]],seg[x]);</span><br><span class="line">        x = par[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        Add(<span class="number">1</span>,seg[top[x]],seg[x],<span class="number">1</span>);</span><br><span class="line">        x = par[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        addEdge(x+<span class="number">1</span>,i+<span class="number">1</span>,<span class="number">1</span>); addEdge(i+<span class="number">1</span>,x+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    preHandle();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m); <span class="keyword">char</span> op[<span class="number">22</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>,op,&amp;x); x++;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'u'</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask1(x));</span><br><span class="line">            Add(<span class="number">1</span>,seg[x],seg[x]+size[x]<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,deep[x]-ask2(x));</span><br><span class="line">            Add2(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="染色"><a href="#染色" class="headerlink" title="染色"></a>染色</h4><p><strong>题意简述</strong><br>原题来自：SDOI 2011<br>给定一棵有 n 个节点的无根树和 m 个操作，操作共两类。<br>1、将节点 a 到节点 b 路径上的所有节点都染上颜色；<br>2、询问节点 a 到节点 b 路径上的颜色段数量，连续相同颜色的认为是同一段，例如 112221 由三段组成：11 、 222、1。</p><p>请你写一个程序依次完成操作。</p><p><strong>解题思路</strong><br>如果不是在树上，是在区间上，该如何操作？用线段树解决。线段树上每个节点有lc：左端点颜色，rc：右端点颜色，same：区间颜色是否唯一（1表示唯一，0表示不唯一），sum：区间内颜色段数量。<br>那么更新显然要用延迟标记，标记在same上，而合并操作需要考虑中间相接的端点颜色是否相同，若相同则颜色段数量要-1。于是区间上“染色”问题就可以用线段树解决了。</p><p>在树上显然类似，因为我们可以通过树链剖分来将树给转化为区间。唯一麻烦的地方就是端点颜色问题，在区间上，我们只需要判断左子树的右端点、右子树的左端点是否颜色相同即可，但是树上的路径是通过倍增来找的，显然需要记录每一条链的端点颜色，麻烦在于如何记录并判断。</p><p>树链剖分后节点越浅，其seg越小，于是需要判断颜色是否相同的是seg[fx]和 seg[par[fx]]，这是由于我们在倍增调整深度时候是自底向上的，自然要判断深度浅的节点。为了美观以及简便，设 getcol(x) 返回该节点的颜色。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[M],ver[M],nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y, edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> deep[N],seg[N],rev[N],top[N],son[N],size[N],par[N];</span><br><span class="line"><span class="keyword">int</span> vis[N],a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>; par[x] = fa;</span><br><span class="line">    deep[x] = deep[fa]+<span class="number">1</span>; size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(vis[y] || y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y,x);</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">        <span class="keyword">if</span>(size[y] &gt; size[son[x]]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x])&#123;</span><br><span class="line">        seg[son[x]] = ++seg[<span class="number">0</span>];</span><br><span class="line">        rev[seg[<span class="number">0</span>]] = son[x];</span><br><span class="line">        top[son[x]] = top[x];</span><br><span class="line">        dfs2(son[x],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(top[y]) <span class="keyword">continue</span>;</span><br><span class="line">        seg[y] = ++seg[<span class="number">0</span>]; rev[seg[<span class="number">0</span>]] = y;</span><br><span class="line">        top[y] = y; dfs2(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="comment">/*lc:区间左端点颜色,rc:区间右端点颜色,sum:区间内颜色段数*/</span></span><br><span class="line">    <span class="keyword">int</span> l,r,lc,rc,sum;</span><br><span class="line">    <span class="keyword">int</span> same;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) t[x].lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) t[x].rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> same(x) t[x].same</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Updata</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;<span class="comment">//更新节点rt的same、rc、lc和sum</span></span><br><span class="line">    same(rt) = same(rt&lt;&lt;<span class="number">1</span>) &amp;&amp; same(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) &amp;&amp; rc(rt&lt;&lt;<span class="number">1</span>) == lc(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>)+sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(rc(rt&lt;&lt;<span class="number">1</span>) == lc(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)) sum(rt)--;</span><br><span class="line">    lc(rt) = lc(rt&lt;&lt;<span class="number">1</span>); rc(rt) = rc(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    l(rt) = l,r(rt) = r,same(rt) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        lc(rt) = rc(rt) = a[rev[l]];</span><br><span class="line">        sum(rt) = <span class="number">1</span>; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    BuildTree(rt&lt;&lt;<span class="number">1</span>,l,mid); BuildTree(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    Updata(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preHandle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    seg[<span class="number">0</span>] = seg[<span class="number">1</span>] = rev[<span class="number">1</span>] = top[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    BuildTree(<span class="number">1</span>,<span class="number">1</span>,seg[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!same(rt)) <span class="keyword">return</span>;<span class="comment">//将懒惰标记下传，即对子树染相同颜色</span></span><br><span class="line">    sum(rt&lt;&lt;<span class="number">1</span>) = sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = <span class="number">1</span>;</span><br><span class="line">    lc(rt&lt;&lt;<span class="number">1</span>) = rc(rt&lt;&lt;<span class="number">1</span>) = lc(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = rc(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = lc(rt);</span><br><span class="line">    same(rt&lt;&lt;<span class="number">1</span>) = same(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = <span class="number">1</span>; same(rt) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">        sum(rt) = <span class="number">1</span>; lc(rt) = rc(rt) = col;</span><br><span class="line">        same(rt) = <span class="number">1</span>; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spread(rt);<span class="comment">//懒惰标记</span></span><br><span class="line">    <span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) modify(rt&lt;&lt;<span class="number">1</span>,l,r,col);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) modify(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,col);</span><br><span class="line">    Updata(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = top[x],fy = top[y];</span><br><span class="line">    <span class="keyword">while</span>(fx != fy)&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[fx] &lt; deep[fy]) swap(x,y),swap(fx,fy);</span><br><span class="line">        modify(<span class="number">1</span>,seg[fx],seg[x],z);</span><br><span class="line">        x = par[fx]; fx = top[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deep[x] &gt; deep[y]) swap(x,y);</span><br><span class="line">    modify(<span class="number">1</span>,seg[x],seg[y],z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> sum(rt);</span><br><span class="line">    spread(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span> ,res= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res += query(rt&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res += query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="comment">/*合并时中间颜色相同,要减去一段*/</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid &amp;&amp; mid &lt; r &amp;&amp; rc(rt&lt;&lt;<span class="number">1</span>) == lc(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)) res--;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getcol</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//这个函数太好用了，哭哭</span></span><br><span class="line">    <span class="keyword">if</span>(l(rt) == r(rt)) <span class="keyword">return</span> lc(rt);</span><br><span class="line">    spread(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="keyword">return</span> getcol(rt&lt;&lt;<span class="number">1</span>,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> getcol(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = top[x], fy = top[y], res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fx != fy)&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[fx] &lt; deep[fy]) swap(fx,fy),swap(x,y);</span><br><span class="line">        res += query(<span class="number">1</span>,seg[fx],seg[x]);</span><br><span class="line">        <span class="keyword">if</span>(getcol(<span class="number">1</span>,seg[fx]) == getcol(<span class="number">1</span>,seg[par[fx]])) res--;</span><br><span class="line">        x = par[fx]; fx = top[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deep[x] &gt; deep[y]) swap(x,y);</span><br><span class="line">    res += query(<span class="number">1</span>,seg[x],seg[y]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y); </span><br><span class="line">        addEdge(x,y,<span class="number">1</span>); addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    preHandle(); <span class="keyword">char</span> op[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x,y));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            change(x,y,z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="「SDOI2014」旅行"><a href="#「SDOI2014」旅行" class="headerlink" title="「SDOI2014」旅行"></a>「SDOI2014」旅行</h4><p><strong>题意简述</strong><br>S 国有 N 个城市，编号从 1 到 N。城市间用 N−1 条双向道路连接，满足从一个城市出发可以到达其它所有城市。每个城市信仰不同的宗教，如飞天面条神教、隐形独角兽教、绝地教都是常见的信仰。为了方便，我们用不同的正整数代表各种宗教，S 国境内总共有 C 种不同的宗教。<br>S 国的居民常常旅行。旅行时他们总会走最短路，并且为了避免麻烦，只在信仰和他们相同的城市留宿。当然旅程的终点也是信仰与他相同的城市。S 国政府为每个城市标定了不同的旅行评级，旅行者们常会记下途中（包括起点和终点）留宿过的城市的评级总和或最大值。<br>在 S 国的历史上常会发生以下几种事件：</p><p>1、CC x c：城市 x 的居民全体改信了 c 教；</p><p>2、CW x w：城市 x 的评级调整为 w；</p><p>3、QS x y：一位旅行者从城市 x 出发，到城市 y，并记下了途中留宿过的城市的评级总和；</p><p>4、QM x y：一位旅行者从城市 x 出发，到城市 y，并记下了途中留宿过的城市的评级最大值。<br>由于年代久远，旅行者记下的数字已经遗失了，但记录开始之前每座城市的信仰与评级，还有事件记录本身是完好的。请根据这些信息，还原旅行者记下的数字。</p><p>为了方便，我们认为事件之间的间隔足够长，以致在任意一次旅行中，所有城市的评级和信仰保持不变。<br><strong>解题思路</strong><br>如果没有信仰，那就是简单的树链剖分模板题，但这题多了个信仰，正常思路是开数组存放对应信仰的评级，但是显然不现实，从空间角度来看。<br>这题用到了动态开点，和可持久化线段树类似，只需要稍微改一下线段树模板即可。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y,edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> deep[N],par[N],size[N],top[N],seg[N],rev[N],son[N];</span><br><span class="line"><span class="keyword">int</span> vis[N],a[N],c[N];<span class="comment">//a:初始评级 c:初始信仰</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    deep[x] = deep[fa]+<span class="number">1</span>;par[x] = fa;</span><br><span class="line">    size[x] = <span class="number">1</span>;vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(vis[y] || y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y,x);</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">        <span class="keyword">if</span>(size[y] &gt; size[son[x]]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x])&#123;</span><br><span class="line">        seg[son[x]] = ++seg[<span class="number">0</span>];</span><br><span class="line">        rev[seg[<span class="number">0</span>]] = son[x];</span><br><span class="line">        top[son[x]] = top[x];</span><br><span class="line">        dfs2(son[x],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(top[y]) <span class="keyword">continue</span>;</span><br><span class="line">        seg[y] = ++seg[<span class="number">0</span>]; rev[seg[<span class="number">0</span>]] = y;</span><br><span class="line">        top[y] = y; dfs2(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls,rs;</span><br><span class="line">    ll mx,sum;</span><br><span class="line">    SegmentTree()&#123;</span><br><span class="line">        ls = rs = mx = sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(x) t[x].ls</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(x) t[x].rs</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mx(x) t[x].mx</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">&#125;t[N*<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> root[N],sz = <span class="number">1</span>;<span class="comment">//最多有多少个根节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preHandle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    seg[<span class="number">0</span>] = seg[<span class="number">1</span>] = rev[<span class="number">1</span>] = top[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> &amp;rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos,ll val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) rt = ++sz;</span><br><span class="line">    mx(rt) = max(mx(rt),val); sum(rt) += val;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>; <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid) Add(ls(rt),l,mid,pos,val);</span><br><span class="line">    <span class="keyword">else</span> Add(rs(rt),mid+<span class="number">1</span>,r,pos,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        sum(rt) = mx(rt) = <span class="number">0</span>; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid) Delete(ls(rt),l,mid,pos);</span><br><span class="line">    <span class="keyword">else</span> Delete(rs(rt),mid+<span class="number">1</span>,r,pos);</span><br><span class="line">    sum(rt) = sum(ls(rt)) + sum(rs(rt));</span><br><span class="line">    mx(rt) = max(mx(ls(rt)),mx(rs(rt)));</span><br><span class="line">&#125;</span><br><span class="line">ll mx,sum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="comment">//  printf("%d %d %d %d %d\n",rt,L,R,l,r);</span></span><br><span class="line">    <span class="keyword">if</span>(!rt) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= L &amp;&amp; R &lt;= r)&#123;</span><br><span class="line">      <span class="comment">//  printf("%d %d\n",mx(rt),sum(rt));</span></span><br><span class="line">        mx = max(mx,mx(rt)); sum += sum(rt); <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) query(ls(rt),L,mid,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) query(rs(rt),mid+<span class="number">1</span>,R,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*返回x到y路径上信仰rt的评级最大值以及总和*/</span></span><br><span class="line">    <span class="keyword">int</span> fx = top[x],fy = top[y];</span><br><span class="line">    <span class="keyword">while</span>(fx != fy)&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[fx] &lt; deep[fy]) swap(x,y),swap(fx,fy);</span><br><span class="line">        query(rt,<span class="number">1</span>,seg[<span class="number">0</span>],seg[fx],seg[x]);</span><br><span class="line">        x = par[fx]; fx = top[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deep[x] &gt; deep[y]) swap(x,y);</span><br><span class="line">    query(rt,<span class="number">1</span>,seg[<span class="number">0</span>],seg[x],seg[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,a+i,c+i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        addEdge(x,y,<span class="number">1</span>); addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    preHandle();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        Add(root[c[i]],<span class="number">1</span>,seg[<span class="number">0</span>],seg[i],a[i]);</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>,op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">'C'</span>)&#123;</span><br><span class="line">            Delete(root[c[x]],<span class="number">1</span>,seg[<span class="number">0</span>],seg[x]);</span><br><span class="line">            Add(root[c[x] = y],<span class="number">1</span>,seg[<span class="number">0</span>],seg[x],a[x]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">'W'</span>)&#123;</span><br><span class="line">            Delete(root[c[x]],<span class="number">1</span>,seg[<span class="number">0</span>],seg[x]);</span><br><span class="line">            Add(root[c[x]],<span class="number">1</span>,seg[<span class="number">0</span>],seg[x],a[x] = y);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mx = sum = <span class="number">0</span>;<span class="comment">//一起更新，少写代码，美滋滋</span></span><br><span class="line">            ask(root[c[x]],x,y);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">'S'</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,mx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;树链剖分常用于处理静态树上操作，效率很高，写起来也就是固定的轻重边拆分+线段树，但是代码一般都是100行+，容易出错。&lt;br&gt;本题集中的树链剖分练习题，在解决思路上没什么难点，主要是如何设计线段树以及如何更新+询问，也就是说要想好怎么维护线段树，其它地方没什么太难的，但是代
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树链剖分" scheme="http://valenshi.top/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>树链剖分笔记</title>
    <link href="http://valenshi.top/2019/10/10/lct/"/>
    <id>http://valenshi.top/2019/10/10/lct/</id>
    <published>2019-10-10T05:03:03.000Z</published>
    <updated>2019-10-10T07:58:48.913Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>树链剖分是用来维护静态树上路径信息的数据结构，静态即树的形态不能改变（增删点或者换根，改变了构造）。<br>其思想是将树上的路径分为重路径和轻边，然后为每个节点分配一个编号，重路径上节点的编号是连续的；接着对这些编号建立一棵线段树，这样就可以将重路径当作区间来维护了；利用了“每个点到根的路径上都有不超过O(logN)条轻边和O(logN)条重路径”结论来保证时间复杂度。</p><h4 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h4><p>树链剖分通常用于解决一类维护静态树上路径信息的问题，例如，给定一棵点带权的树，接下来每次操作会修改某条路径上所有点的权值（修改为同一个值或是加上同一个值等），以及询问某条路径上所有点的权值和。</p><p>当这棵树是一条链时，这个问题实际上就是一个序列上区间修改、区间询问的问题，可以用线段树等数据结构解决。</p><p>对于其他情况，由于树的形态是不变的，因此树链剖分的策略是将这些点按某种方式组织起来，剖分成若干条链，每条链就相当于一个序列。这样，操作的路径可以拆分为某几条链，也就是若干个完整序列或是某个序列上的一段区间，此时可利用线段树等处理序列上区间操作的数据结构解决问题。</p><p>树链剖分的核心是如何恰当的将树剖分为若干条链。当链的划分方式确定后，我们只要将它们看作是一个个序列，将所有序列按顺序拼接起来，每条链就成了一段区间，而序列上的区间问题是我们所熟悉和擅长的。</p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><h5 id="划分轻重边"><a href="#划分轻重边" class="headerlink" title="划分轻重边"></a>划分轻重边</h5><p>下面以点带权的树为例，结合路径权值修改、路径询问权值和问题，介绍常用的剖分方法，该方法是轻、重边剖分。<br>我们将树中的边分为两种：轻边 和 重边。如图1所示，图中红色的边是重边，其余的是轻边。<br><img src="/2019/10/10/lct/1.png" alt="1"><br>图1：节点数字代表子树大小（size）<br>我们可以以任意点为根，然后记size( u )为以u为根的子树的节点个数，令 v 为 u 所有儿子中 size 值最大的一个，则(u,v)是重边，v 称为 u 的重儿子。u 到其余儿子的边为轻边。</p><h5 id="轻重边的性质"><a href="#轻重边的性质" class="headerlink" title="轻重边的性质"></a>轻重边的性质</h5><p>轻重边有如下几个性质：</p><ol><li>如果(u , v)为轻边，则 size( v ) &lt;= size( u ) / 2。</li><li>从根到某一点v的路径上的轻边个数不多于O(logN)。</li><li>我们称某条路径为重路径（链），当且仅当它全部由重边组成（特殊地，一个点也算一条重路径）。那么对于每个点到根的路径上都有不超过O(logN)条轻边和O(logN)条重路径。</li></ol><p>同时我们也容易发现，一个点在且只在一条重路径上，而每条重路径一定是一条从根节点方向向叶节点方向延申的深度递增的路径（因为一个非叶节点有且只有一个重儿子）。</p><h5 id="如何处理树上的路径"><a href="#如何处理树上的路径" class="headerlink" title="如何处理树上的路径"></a>如何处理树上的路径</h5><p>对树进行轻、重边剖分后，操作所要处理的路径（u , v），我们可以分别处理u，v两个点到其最近公共祖先的路径。根据性质3，路径可以分解为最多O(logN)条的重路径和最多O(logN)的轻边，那么现在我们<strong>只考虑如何维护这两种对象。</strong></p><p>对于重路径，它们此时相当于一个序列，因此我们只需要用线段树维护。而对于轻边，我们可以直接跳过，访问下一条重路径，因为轻边的两端点一定在某两条重路径上。这两种操作的时间复杂度分别为$O(log^2N)$和O(logN)，因此总的时间复杂度为$O(log^2N)$。</p><h5 id="剖分方法"><a href="#剖分方法" class="headerlink" title="剖分方法"></a>剖分方法</h5><p>轻、重边剖分的过程可以用两次dfs实现，有时为了防止递归过深而导致栈溢出，也可以用bfs实现。<br><strong>剖分过程中主要计算如下7个值：</strong><br>par[x] : x在树中的父亲。<br>deep[x]：x在树中的深度。<br>size[x]：x的子树节点数（子树大小）。<br>son[x]：x的重儿子，即u-&gt;son[u]为重边。<br>top[x]：x所在重路径的顶部节点（深度最小）。<br>seg[x]：x所在线段树中的位置（下标）。<br>rev[x]：线段树中第x个位置对应的树中节点编号，即rev[seg[x] ] = x。</p><p>第一遍 dfs 时可以计算前 4 个值，第二遍 dfs 可以计算后 3 个值。而计算 seg 时，同一条重路径上的点需要按顺序排在连续的一段位置，也就是一段区间。</p><p>将一条路径(u ,v)拆分为若干条重路径的过程，实际上就是一个寻找最近公共祖先的过程。考虑“暴力”的做法，我们会选择u，v中深度较大的点向上走一步，直到u = v。现在有了重路径，由于我们记录了重路径的顶部节点top[x]，还记录了每个点在序列中的位置，因此我们不需要一步步走。假定top[u]和top[v]不同，那么它们的最近公共祖先可能在其中一条重路径上，也可能在其他的重路径上，因为LCA显然不可能在top深度较大的那条重路径上，所以我们先处理top深度较大的。假设u是深度较大的，则可以直接条到par[top[u]]处，且跳过的这一段，在线段树中是一段区间，若我们按照深度从小到大来存储点，则这段区间为：[seg[top[x]] , seg[x]]。当u，v的top相同时，说明它们走到了同一条重路径上，这时它们之间的路径也是序列上的一段区间，且u，v中深度较小的那点是原路径的LCA。</p><p>这样我们就可以将给出的任意路径拆分成若干条重路径，也就是若干个区间，并用线段树等数据结构处理操作。</p><h4 id="例题模板"><a href="#例题模板" class="headerlink" title="例题模板"></a>例题模板</h4><p>原题来自：ZJOI 2008</p><p>一树上有 n 个节点，编号分别为 1 到 n，每个节点都有一个权值 w。我们将以下面的形式来要求你对这棵树完成一些操作：<br>1.CHANGE u t ：把节点 u 权值改为 t；<br>2.QMAX u v ：询问点 u 到点 v 路径上的节点的最大权值；<br>3.QSUM u v ：询问点 u 到点 v 路径上的节点的权值和。<br>注意：从点 u 到点 v 路径上的节点包括 u 和 v 本身。</p><p>模板使用说明：</p><ul><li>将树拆分成若干条链，为树上每个点分配一个编号，同一条链上的编号连续，然后在这些编号上建立线段树维护。seg[x]是树上的节点x在线段树的下标，rev[y]是线段树下标为 y 节点在树中的编号。</li><li>树的节点编号要从1开始，不能从0。</li><li>子树在线段树中的下标是连续的，以 x 为根的子树起点下标是seg[x]，终点是seg[x]+size[x]-1。</li></ul><p><strong>代码模板</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y, edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,q,a[N];</span><br><span class="line"><span class="comment">/*父亲,深度,子树大小,重儿子,重路径顶部节点,</span></span><br><span class="line"><span class="comment">    树中节点在线段树中下标,线段树中节点对应树中位置*/</span></span><br><span class="line"><span class="keyword">int</span> par[N],deep[N],size[N],son[N],top[N],seg[N],rev[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*利用深搜更新par,size,deep,son数组*/</span></span><br><span class="line">    vis[x] = <span class="literal">true</span>; size[x] = <span class="number">1</span>;</span><br><span class="line">    par[x] = fa; deep[x] = deep[fa]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(y == fa || vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y,x);</span><br><span class="line">        size[x] += size[y]; <span class="comment">//累加子树大小</span></span><br><span class="line">        <span class="keyword">if</span>(size[y] &gt; size[son[x]]) son[x] = y;<span class="comment">//求重儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x])&#123; <span class="comment">//先走重儿子,使得重路径在线段树中连续</span></span><br><span class="line">        seg[son[x]] = ++seg[<span class="number">0</span>];<span class="comment">//0位置用不到,利用来计数</span></span><br><span class="line">        top[son[x]] = top[x];</span><br><span class="line">        rev[seg[<span class="number">0</span>]] = son[x];</span><br><span class="line">        dfs2(son[x],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(top[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">/*若y没有被遍历过,即y不是x的重儿子或者父亲*/</span></span><br><span class="line">        seg[y] = ++seg[<span class="number">0</span>]; rev[seg[<span class="number">0</span>]] = y;</span><br><span class="line">        top[y] = y; dfs2(y,x);</span><br><span class="line">        <span class="comment">/*如果x--&gt;y是轻边,那么y就是其所在重路径顶部节点*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    ll mx, sum;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mx(x) t[x].mx</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    l(rt) = l, r(rt) = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        mx(rt) = sum(rt) = a[rev[l]]; <span class="comment">//线段树上l节点对应着树上rev[l]点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    BuildTree(rt*<span class="number">2</span>,l,mid); BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    mx(rt) = max(mx(rt&lt;&lt;<span class="number">1</span>),mx(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>) + sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preHandle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>); <span class="comment">//我们以1号节点为根</span></span><br><span class="line">    <span class="comment">/*根节点所在重路径的顶部节点也是根节点,赋初值*/</span></span><br><span class="line">    seg[<span class="number">0</span>] = seg[<span class="number">1</span>] = top[<span class="number">1</span>] = rev[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    BuildTree(<span class="number">1</span>,<span class="number">1</span>,seg[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">ll tmx,tsum;<span class="comment">//利用全局变量同时统计2个答案</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*将以rt为根的区间内属于[l,r]部分的和累加到tsum上,并更新tmx*/</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">        tsum += sum(rt); tmx = max(tmx,mx(rt));</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) query(rt&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*返回x与y之间路径上权值最大点的权值*/</span></span><br><span class="line">    <span class="keyword">int</span> fx = top[x] , fy = top[y];</span><br><span class="line">    <span class="keyword">while</span>(fx != fy)&#123;<span class="comment">//先将x和y条整到同一个重链上</span></span><br><span class="line">        <span class="keyword">if</span>(deep[fx] &lt; deep[fy]) swap(x,y),swap(fx,fy);</span><br><span class="line">        query(<span class="number">1</span>,seg[fx],seg[x]);</span><br><span class="line">        x = par[fx]; fx = top[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deep[x] &gt; deep[y]) swap(x,y);<span class="comment">//路径浅的编号小</span></span><br><span class="line">    query(<span class="number">1</span>,seg[x],seg[y]); <span class="comment">//再更新一次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*把线段树节点x的权值改为val*/</span></span><br><span class="line">    <span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">        mx(rt) = sum(rt) = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt) + r(rt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; mid) change(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,val);</span><br><span class="line">    <span class="keyword">else</span> change(rt&lt;&lt;<span class="number">1</span>,x,val);</span><br><span class="line">    mx(rt) = max(mx(rt&lt;&lt;<span class="number">1</span>),mx(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>) + sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">"123.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">"222.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        addEdge(x,y,<span class="number">1</span>); addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    preHandle();<span class="comment">//树链剖分预处理</span></span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= q;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>,op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'C'</span>) change(<span class="number">1</span>,seg[x],y);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmx = -INF; tsum = <span class="number">0</span>;</span><br><span class="line">            ask(x,y);<span class="comment">//同时更新最大值与路径和</span></span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">'M'</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,tmx);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,tsum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;树链剖分是用来维护静态树上路径信息的数据结构，静态即树的形态不能改变（增删点或者换根，改变了构造）。&lt;br&gt;其思想是将树上的路径分为重路径和
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法模板" scheme="http://valenshi.top/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="树链剖分" scheme="http://valenshi.top/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>树上倍增LCA题集</title>
    <link href="http://valenshi.top/2019/10/09/lca-problems/"/>
    <id>http://valenshi.top/2019/10/09/lca-problems/</id>
    <published>2019-10-09T12:04:00.000Z</published>
    <updated>2019-10-09T12:16:10.691Z</updated>
    
    <content type="html"><![CDATA[<p>树上倍增法可以用于求LCA，当然在其它场合也有应用，在很多时候看似不是树形的问题，我们也可以通过转化成树形结构，然后在树中进行操作，这种操作可以是求二者之间的最近状态，或者是二者之间的距离，如最后一题。<br>另外关于树的题型，最好还是根据样例画图思考，往往可以比空想获得更多思路。</p><h4 id="点的距离"><a href="#点的距离" class="headerlink" title="点的距离"></a>点的距离</h4><p><strong>题意简述</strong><br>给定一棵 n 个点的树，Q 个询问，每次询问点 x 到点 y 两点之间的距离。<br><strong>解题思路</strong><br>模板题，用树上倍增法，初始化时间为O(NlogN)，查询时间O(logN)。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="comment">//anc[x][i]表示x往上走2^i步的祖先编号 </span></span><br><span class="line"><span class="keyword">int</span> anc[N][<span class="number">25</span>], deep[N],dis[N];</span><br><span class="line"><span class="keyword">int</span> root = <span class="number">1</span>;<span class="comment">//这棵树的根,无特殊说明可以为1 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++)</span><br><span class="line">anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i] , z = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dis[y] || y == root) <span class="keyword">continue</span>;</span><br><span class="line">deep[y] = deep[x]+<span class="number">1</span>;</span><br><span class="line">dis[y] = dis[x] + z;</span><br><span class="line">anc[y][<span class="number">0</span>] = x; dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[u] &lt; deep[v]) swap(u,v);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(deep[anc[u][i]] &gt;= deep[v]) u = anc[u][i];</span><br><span class="line"><span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(anc[u][i] != anc[v][i])&#123;</span><br><span class="line">u = anc[u][i]; v= anc[v][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">/*logN时间内返回x与y之间的距离,注意是否会爆int*/</span> </span><br><span class="line"><span class="keyword">return</span> dis[x] + dis[y] - <span class="number">2</span>*dis[Lca(x,y)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);<span class="comment">//双向边 </span></span><br><span class="line">&#125;</span><br><span class="line">deep[<span class="number">0</span>] = <span class="number">-1</span>; dfs(root);<span class="comment">//完成预处理 </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= q;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="暗的锁链"><a href="#暗的锁链" class="headerlink" title="暗的锁链*"></a>暗的锁链*</h4><p><strong>题意简述</strong><br>原题来自：POJ 3417</p><p>Dark 是一张无向图，图中有 N 个节点和两类边，一类边被称为主要边，而另一类被称为附加边。Dark 有 N–1 条主要边，并且 Dark 的任意两个节点之间都存在一条只由主要边构成的路径。另外，Dark 还有 M 条附加边。</p><p>你的任务是把 Dark 斩为不连通的两部分。一开始 Dark 的附加边都处于无敌状态，你只能选择一条主要边切断。一旦你切断了一条主要边，Dark 就会进入防御模式，主要边会变为无敌的而附加边可以被切断。但是你的能力只能再切断 Dark 的一条附加边。</p><p>现在你想要知道，一共有多少种方案可以击败 Dark。注意，就算你第一步切断主要边之后就已经把 Dark 斩为两截，你也需要切断一条附加边才算击败了 Dark。</p><p><strong>解题思路</strong><br>这是一道需要观察和转化题意的问题。<br>在树上如果有一条附加边，就形成了一个环，可知每个环内最多有一条附加边。如果一条主要边在环中，则称该主要边被<strong>覆盖</strong> ，它在几个环内，就被覆盖了几次。可知一个主要边最多被覆盖2次。<br>如果一条主要边被覆盖了 2 次，那么我们无论怎么切都切不断 Dark，因为切断了主要边后，还是一个环，而切断一个环需要切断两条边。如果一条主要边被覆盖了 1 次，那么我们切断该主要边后，再切断它的附加边即可，即只有一种方案。如果一条主要边被覆盖0次，那么我们切完该主要边后，可以任意切一条附加边，共 m 中方案（m 是附加边的条数）。综上所述，我们只需要求出每条主要边被附加边覆盖次数即可，我们设 f[x] 为 x 到其父节点的主要边被覆盖的次数。</p><p>我们可以利用<strong>树上差分</strong>来求 f 数组，树上差分的思想就不额外介绍了，具体做法是如果有一条附加边(x, y)，那么f[x]++ ,f[y]++，同时 f[ Lca(x, y) ] -= 2，这样当我们添加完附加边后，将 f 数组从叶子节点向上累加，即可更新完毕 f 数组。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x];head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,f[N];</span><br><span class="line"><span class="keyword">int</span> dis[N],deep[N],anc[N][<span class="number">24</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++) </span><br><span class="line">anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dis[y] || y == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">deep[y] = deep[x] + <span class="number">1</span>;</span><br><span class="line">dis[y] = dis[x] + z;</span><br><span class="line">anc[y][<span class="number">0</span>] = x; dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[x] &lt; deep[y]) swap(x,y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(deep[anc[x][i]] &gt;= deep[y]) x = anc[x][i];</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(anc[x][i] != anc[y][i])&#123;</span><br><span class="line">x = anc[x][i]; y = anc[y][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">f[x] += dfs2(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">f[x]++; f[y]++; f[Lca(x,y)] -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">dfs2(<span class="number">1</span>); <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(!f[i]) ans += m;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(f[i] == <span class="number">1</span>) ans++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="异象石"><a href="#异象石" class="headerlink" title="异象石*"></a>异象石*</h4><p><strong>题意简述</strong><br>原题来自：Contest Hunter Round #56</p><p>在 Adera 的异时空中有一张地图。这张地图上有 N 个点，有 N−1 条双向边把它们连通起来。起初地图上没有任何异象石，在接下来的 M 个时刻中，每个时刻会发生以下三种类型的事件之一：</p><p>地图的某个点上出现了异象石（已经出现的不会再次出现）；</p><p>地图某个点上的异象石被摧毁（不会摧毁没有异象石的点）；</p><p>向玩家询问使所有异象石所在的点连通的边集的总长度最小是多少。</p><p>请你作为玩家回答这些问题。下图是一个例子，灰色节点表示出现了异象石，加粗的边表示被选为连通异象石的边集。</p><p><strong>解题思路</strong><br>我也不太能理解这题的思路是怎么发现的。<br>很自然的想法就是求所有 k 个异象石两两之间的距离和，然后 / (k-1) 即为答案，但显然会超时。<br>正解是利用一个结论，该结论题解没给出证明，搞懂了再补上。<br>对这颗树先进行dfs遍历，给每个节点打上一个时间戳，设节点 x 的时间戳为 dfn[x]；设已存在的异象石中，dfn序是 x 前驱的节点编号为 pre，后继节点编号为 nex，那么在 x 处插入异象石后， ans += Dis(pre , x) + Dis(x, nex) - Dis(pre, nex)。<br>删除一个异象石同理，减去就好。<br>证明暂时没有，另外这个要做法记住，是用来求树上多个节点之间的最短总路径用的。</p><p>还要注意set的用法，如果set为空，那么begin() = end()，此时如果用指向end()的迭代器自增或自减都是不合法的。</p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x];head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,f[N];</span><br><span class="line"><span class="keyword">int</span> dis[N],deep[N],anc[N][<span class="number">24</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++) </span><br><span class="line">anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dis[y] || y == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">deep[y] = deep[x] + <span class="number">1</span>;</span><br><span class="line">dis[y] = dis[x] + z;</span><br><span class="line">anc[y][<span class="number">0</span>] = x; dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[x] &lt; deep[y]) swap(x,y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(deep[anc[x][i]] &gt;= deep[y]) x = anc[x][i];</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(anc[x][i] != anc[y][i])&#123;</span><br><span class="line">x = anc[x][i]; y = anc[y][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">f[x] += dfs2(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">f[x]++; f[y]++; f[Lca(x,y)] -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">dfs2(<span class="number">1</span>); <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(!f[i]) ans += m;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(f[i] == <span class="number">1</span>) ans++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树*"></a>次小生成树*</h4><p>这是阳哥哥负责的题型，我就不越界了。</p><h4 id="Dis"><a href="#Dis" class="headerlink" title="Dis"></a>Dis</h4><p><strong>题意简述</strong><br>给出 n 个点的一棵树，多次询问两点之间的最短距离。<br>注意：边是双向的。<br><strong>解题思路</strong><br>这个就是标准的模板题了，和第一题一样，注意一下细节即可。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],edge[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x];</span><br><span class="line">edge[tot] = z; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">int</span> anc[N][<span class="number">25</span>], deep[N],dis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++)</span><br><span class="line">anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i] , z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(dis[y] || y == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">deep[y] = deep[x]+<span class="number">1</span>;</span><br><span class="line">dis[y] = dis[x] + z;</span><br><span class="line">anc[y][<span class="number">0</span>] = x; dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[u] &lt; deep[v]) swap(u,v);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(deep[anc[u][i]] &gt;= deep[v]) u = anc[u][i];</span><br><span class="line"><span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(anc[u][i] != anc[v][i])&#123;</span><br><span class="line">u = anc[u][i]; v= anc[v][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> dis[x] + dis[y] - <span class="number">2</span>*dis[Lca(x,y)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addEdge(x,y,z); addEdge(y,x,z);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>);<span class="comment">//完成预处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= q;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="祖孙询问"><a href="#祖孙询问" class="headerlink" title="祖孙询问"></a>祖孙询问</h4><p><strong>题意简述</strong><br>已知一棵 n 个节点的有根树。有 m 个询问，每个询问给出了一对节点的编号 x 和 y，询问 x 与 y 的祖孙关系。<br><strong>解题思路</strong><br>简单的模板题，需要注意的是如果 x == y，那么是属于<strong>其它情况</strong>哦。<br>另外还需要注意一下，deep[0] = -1，否则会和根节点数值相等而出错。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> anc[N][<span class="number">25</span>], dis[N],deep[N];</span><br><span class="line"><span class="keyword">int</span> root;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++)</span><br><span class="line">anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(dis[y] || y == root) <span class="keyword">continue</span>;</span><br><span class="line">deep[y] = deep[x]+<span class="number">1</span>;</span><br><span class="line">dis[y] = dis[x] + <span class="number">1</span>;</span><br><span class="line">anc[y][<span class="number">0</span>] = x; dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[x] &lt; deep[y]) swap(x,y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(deep[anc[x][i]] &gt;= deep[y]) x = anc[x][i];</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(anc[x][i] != anc[y][i])&#123;</span><br><span class="line">x = anc[x][i]; y = anc[y][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">if</span>(y == <span class="number">-1</span>) root = x;</span><br><span class="line"><span class="keyword">else</span> addEdge(x,y,<span class="number">1</span>), addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 因为deep[root] = 0,如果deep[0] = 0,则会认为 0 号节点也是根 */</span></span><br><span class="line">deep[<span class="number">0</span>] = <span class="number">-1</span>; dfs(root);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">int</span> par = Lca(x,y);</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(par == x) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(par == y) <span class="built_in">puts</span>(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="聚会"><a href="#聚会" class="headerlink" title="聚会*"></a>聚会*</h4><p><strong>题意简述</strong><br>原题来自：AHOI 2008</p><p>Y 岛风景美丽宜人，气候温和，物产丰富。Y 岛上有 N 个城市，有 N−1 条城市间的道路连接着它们。每一条道路都连接某两个城市。幸运的是，小可可通过这些道路可以走遍 Y 岛的所有城市。神奇的是，乘车经过每条道路所需要的费用都是一样的。</p><p>小可可，小卡卡和小 YY 经常想聚会，每次聚会，他们都会选择一个城市，使得三个人到达这个城市的总费用最小。</p><p>由于他们计划中还会有很多次聚会，每次都选择一个地点是很烦人的事情，所以他们决定把这件事情交给你来完成。他们会提供给你地图以及若干次聚会前他们所处的位置，希望你为他们的每一次聚会选择一个合适的地点。</p><p><strong>解题思路</strong><br>在一棵树上求三个点 (x, y ,z) 之间的最短路径，我们求出dis[x, y] + dis[x , z] + dis[y , z]，画图就会发现每一段路径都被重复计算了 2 次，于是我们再将答案 / 2就得到了三个点之间的路径。<br>假设这个聚会点为 p ，那么显然 p 是三条路径的交汇点，否则路径和肯定不会是最短。下一步的目标就是求出这个交汇点的坐标。</p><p>如果我们以某个点为根，为每个节点更新深度deep（就像我们在求LCA时一样），那么显然 p 点就是 Lca[x, y] , Lca[x , z] , Lca[y , z] 三者中deep最大（最深）的点，这也可以通过画图观察出来，也很容易证明。</p><p>于是我们就可以利用树上倍增法求出Lca，在O(NlogN)时间内解决该题，但是常数不太优秀，极限数据还是会被卡掉，如果想满分需要用树链剖分，不过该思路已经可以通过一本通oj上的数据了。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y, edge[tot] = z;</span><br><span class="line">nex[tot] = head[x] , head[x] = tot;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) </span><br><span class="line">res = res*<span class="number">10</span>+c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> root = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> deep[N],anc[N][<span class="number">24</span>],dis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++)</span><br><span class="line">anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(dis[y] || y == root) <span class="keyword">continue</span>;</span><br><span class="line">deep[y] = deep[x] + <span class="number">1</span>;</span><br><span class="line">dis[y] = dis[x] + <span class="number">1</span>;</span><br><span class="line">anc[y][<span class="number">0</span>] = x; dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[x] &lt; deep[y]) swap(x,y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(deep[anc[x][i]] &gt;= deep[y]) x = anc[x][i];</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(anc[x][i] != anc[y][i])&#123;</span><br><span class="line">x = anc[x][i]; y = anc[y][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dis</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> dis[x] + dis[y] - <span class="number">2</span>*dis[Lca(x,y)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">print(x/<span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">addEdge(x,y,<span class="number">1</span>); addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">deep[<span class="number">0</span>] = <span class="number">-1</span>; dfs(root);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt(); z = getInt();</span><br><span class="line"><span class="keyword">int</span> par = Lca(x,y); </span><br><span class="line"><span class="keyword">int</span> p2 = Lca(x,z) , p3 = Lca(y,z);</span><br><span class="line"><span class="keyword">if</span>(deep[par] &lt; deep[p2]) par = p2;</span><br><span class="line"><span class="keyword">if</span>(deep[par] &lt; deep[p3]) par = p3;</span><br><span class="line"><span class="keyword">int</span> res = Dis(x,y) + Dis(x,z) + Dis(y,z) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">print(par); <span class="built_in">putchar</span>(<span class="string">' '</span>); print(res); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="跳跳棋"><a href="#跳跳棋" class="headerlink" title="跳跳棋**"></a>跳跳棋**</h4><p><strong>题意简述</strong><br>原题来自：BZOJ 2144</p><p>跳跳棋是在一条数轴上进行的。棋子只能摆在整点上。每个点不能摆超过一个棋子。我们用跳跳棋来做一个简单的游戏：棋盘上有三颗棋子，分别在 a,b,c 这三个位置。我们要通过最少的跳动把他们的位置移动成 x,y,z（注意：棋子是没有区别的）。</p><p>跳动的规则很简单，任意选一颗棋子，对一颗中轴棋子跳动。跳动后两颗棋子距离不变。一次只允许跳过一颗棋子。</p><p>写一个程序，首先判断是否可以完成任务。如果可以，输出最少需要的跳动次数。<br><img src="/2019/10/09/lca-problems/1.png" alt="1"><br><strong>解题思路</strong><br>这题有好几个难点，思路也不是那么容易想到。</p><p>首先比较容易想到的是，有哪些点是可以达到的；设a,b,c升序，l1 = b-a, l2 = c-b，那么(l1, l2)可以转移到 (l1, l2-l1) 和 (l1-l2 , l2)。<br>那么每次转移了多少长度，向哪个方向转移的我们都知道了，自然就可以得到点的转移。就比如 (l1 , l2)  —&gt; (l1 , l2 - l1) ，就对应着(a ,b ,c)—&gt;(b, 2b-a, c)。</p><p>既然我们知道点如何转移，那么问题就变成了判断 (a , b, c) 和 (x , y , z) 是否可以转移到同一个状态。</p><p>我们上面只讨论了两端节点向中间跳（对应着合法长度的相减，a跳到b、c中间，c跳到a、b中间），没考虑中间节点向两边跳（a关于c跳，或c关于a跳，或b关于a、c跳，对应着合法长度的相加），实际上两者都成立，比如(l1 , l2)—&gt;(l1, l1+l2)对应着(a ,b ,c) —&gt; (b , a , c) ，但是如果我们将其中两点之间的距离不断变大，会终止于正无穷，但如果不断缩小，就会终止于某一个非负整数；基于此我们只考虑“两边的点向中间跳”这种情况，这对应着开始介绍的两个减法转移。</p><p>到此就有些明朗了，每个状态看作一个节点，转移一次就看作向上走一步，最终一定会终止于某一个状态，这个状态就可以看作根节点；我们将(a ,b ,c) 与 (x, y , z)同时“向上”转移，如果它们终止于同一个状态，就说明它们可以互相抵达，否则则不能。</p><p>接下来就是要判断最小的步数，即(a ,b ,c) 到 (x , y , z) 的最少转移次数。这就相当于求二者的LCA，因为它们有共同的“根节点”，并且有着到根节点的唯一路径，所以可以将它们的转移看作一棵树，边权为1，求着两个状态之间的距离。</p><p>由于我们利用的是合法长度的转移来对应着点的状态的转移，即(l1, l2) —&gt; (l1 , l2-l1)或(l1-l2, l2)。这和更相减损术 gcd(a, b) = gcd(a, b-a) = gcd(a-b, a)相同，而欧几里得又告诉我们 gcd(a ,b) = gcd(b ,a%b)，于是本来 O(N) 的减法变成了 O(log N)的除法（取模）。</p><p>我们可以在O(logN)的时间内转移到任意一个父状态，但是我们不知道该向上转移几步才是最少步数，于是我们要先将二者的<strong>深度</strong>调到相同，然后同时向上走 k 步，这可以用倍增实现，也可以用二分搜索实现。求深度我们可以在求第一问时顺便求解，同时深度也是最长路径，用于二分。</p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>],b[<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line">Node()&#123;&#125;</span><br><span class="line">Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z):x(x),y(y),z(z)&#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> Node&amp; B) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(x == B.x &amp;&amp; y == B.y &amp;&amp; z == B.z);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> deep;</span><br><span class="line"><span class="function">Node <span class="title">jump</span><span class="params">(Node h, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回从位置h向上跳step步后的状态,顺便记录一下当前深度(距根距离)*/</span></span><br><span class="line">Node res = h;</span><br><span class="line"><span class="keyword">int</span> t1 = h.y-h.x, t2 = h.z - h.y;</span><br><span class="line"><span class="keyword">if</span>(t1 == t2) <span class="keyword">return</span> res; </span><br><span class="line"><span class="keyword">if</span>(t1 &lt; t2)&#123;</span><br><span class="line"><span class="keyword">int</span> t = min(step,(t2<span class="number">-1</span>)/t1);<span class="comment">//用除法优化 </span></span><br><span class="line">step -= t; deep += t;<span class="comment">//记录一下深度 </span></span><br><span class="line">res.y += t*t1; res.x += t*t1;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = min(step,(t1<span class="number">-1</span>)/t2);</span><br><span class="line">step -= t; deep += t;</span><br><span class="line">res.y -= t*t2; res.z -= t*t2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(step) <span class="keyword">return</span> jump(res,step);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,Node h1,Node h2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(jump(h1,x) != jump(h2,x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span>;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span>;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,b+i);</span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">4</span>); sort(b+<span class="number">1</span>,b+<span class="number">4</span>);</span><br><span class="line">Node h1(a[1],a[2],a[3]) , h2(b[1],b[2],b[3]);</span><br><span class="line">Node aa = jump(h1,INF); <span class="keyword">int</span> d1 = deep; deep = <span class="number">0</span>;</span><br><span class="line">Node bb = jump(h2,INF); <span class="keyword">int</span> d2 = deep; deep = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(aa != bb)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"NO"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line"><span class="comment">/*计算步数：先调整到同一深度,再二分一起跳*/</span></span><br><span class="line"><span class="keyword">if</span>(d1 &lt; d2) swap(d1,d2),swap(h1,h2);</span><br><span class="line">h1 = jump(h1,d1-d2);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = d1;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid,h1,h2)) r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="number">2</span>*l+d1-d2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;树上倍增法可以用于求LCA，当然在其它场合也有应用，在很多时候看似不是树形的问题，我们也可以通过转化成树形结构，然后在树中进行操作，这种操作可以是求二者之间的最近状态，或者是二者之间的距离，如最后一题。&lt;br&gt;另外关于树的题型，最好还是根据样例画图思考，往往可以比空想获得更
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="lca" scheme="http://valenshi.top/tags/lca/"/>
    
      <category term="树上倍增" scheme="http://valenshi.top/tags/%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树相关问题</title>
    <link href="http://valenshi.top/2019/10/09/MSTs/"/>
    <id>http://valenshi.top/2019/10/09/MSTs/</id>
    <published>2019-10-09T10:47:52.000Z</published>
    <updated>2019-10-09T10:48:57.678Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>在对最小生成树算法有一定理解后，我们对典型的最小生成树题型应该不难解决，但是对于由最小生成树模型变形而来的几种模型，我们仍需做一次总结与记录。<br>首先我们需要提出最小生成树几个性质，便于推导算法；然后我们将介绍6种最小生成树相关问题模型，并讨论一般解法与更优解法；其中有的解法显而易见，接受起来也很简单，但有的解法却需要从理论上逻辑严密的进行推导，构造算法并证明算法的正确性，这部分难度稍大。<br>这6个相关问题分别是：增量最小生成树，最小瓶颈生成树，最小瓶颈路，每对节点的最小瓶颈路，次小生成树，最小有向生成树。</p><h4 id="图论中的2个性质："><a href="#图论中的2个性质：" class="headerlink" title="图论中的2个性质："></a>图论中的2个性质：</h4><ul><li><strong>切割性质：</strong> 假定所有边权均不相同。设S为既非空集也非全集的V的子集，边e是满足一个端点在S内，另一个端点不在S内的所有边中权值最小的一个，则图G的所有生成树均包含e。</li><li><strong>回路性质：</strong> 假定所有边权值均不相同。设C是图G中任意回路，边e是C上权值最大的边，则图G的所有生成树均不包含e。</li></ul><p>在此不给出证明。</p><h4 id="增量最小生成树"><a href="#增量最小生成树" class="headerlink" title="增量最小生成树"></a>增量最小生成树</h4><p><strong>问题描述：</strong><br>从包含n个点的空图开始，依次加入m条带权边。每加入一条边，输出当前图中的最小生成树权值（如果当前图不连通，则输出无解）。<br><strong>解题思路：</strong><br>如果每次重新求完整的最小生成树问题，总时间复杂度高达O(m^2 log n)。根据回路的性质，可以得到如下改进算法：</p><blockquote><p>每次求出新的最小生成树后，把其它的边删除。由于每次只需计算一个n条边（原生成树有 n - 1条，新加入一条）的图的最小生成树，Kruskal算法的时间复杂度降为O(n log n)，总时间复杂度为O(nm log n)。</p></blockquote><p>这个算法可以进一步改进:</p><blockquote><p>加入一条边e = (u, v)之后，图中恰好包含一个环。根据回路性质，删除该回路上权值最大的边即可，因此只需在加边之前的MST上找到u到v的唯一路径上的权值最大的边，再和e比较，删除权值较大的一条。由于路径唯一，可以用DFS或BFS找到这条u到v的路径，总时间复杂度为O(nm)。</p></blockquote><h4 id="最小瓶颈生成树"><a href="#最小瓶颈生成树" class="headerlink" title="最小瓶颈生成树"></a>最小瓶颈生成树</h4><p><strong>问题描述：</strong><br>给出加权无向图，求一棵生成树，使得最大边权值尽量小。</p><p><strong>解题思路：</strong><br>由于只关心最大边权值，我们可以从一个空图开始，按照权值从小到大的顺序依次加入各条边，则图第一次连通时，该图的最小生成树就是原图的最小瓶颈生成树。可以发现，原图的最小生成树就是一棵最小瓶颈生成树（但不是每棵最小瓶颈生成树都是最小生成树）。</p><h4 id="最小瓶颈路"><a href="#最小瓶颈路" class="headerlink" title="最小瓶颈路"></a>最小瓶颈路</h4><p><strong>问题描述：</strong><br>给定加权无向图的两个节点u和v，求出从u到v的一条路径，使得路径上最长边尽量短。</p><p><strong>解题思路：</strong><br>这个问题可以用二分法+BFS解决，但我们有更好的算法。先求出这个图的最小生成树，则起点和终点在树上的唯一路径就是我们要找的路径，这条路径上的最长边就是问题的答案。</p><h4 id="每对结点间的最小瓶颈路"><a href="#每对结点间的最小瓶颈路" class="headerlink" title="每对结点间的最小瓶颈路"></a>每对结点间的最小瓶颈路</h4><p><strong>问题描述：</strong><br>给出加权无向图，求每两个节点u和v之间的最小瓶颈路的最大边长f(u,v)。</p><p><strong>解题思路：</strong></p><blockquote><p>先求最小生成树。接下来，用DFS把最小生成树变成有根树，同时计算f(u,v)，当新访问一个节点u时，考虑所有已经访问过的老节点x，更新f(x,u) = max(f(x,v) , w(u,v))，其中v是u的父节点。每个f(u,v)只需经过常数时间计算，因此是时间复杂度为O(n^2)。</p></blockquote><h4 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a>次小生成树</h4><p><strong>问题描述：</strong><br>把所有生成树按照权值之和从大到小的顺序排列，求排在第二位的生成树。注意，如果最小生成树不唯一，次小生成树的权值与最小生成树相同。</p><p><strong>解题思路：</strong> </p><blockquote><p>次小生成树不会与最小生成树完全相同，因此可以枚举最小生成树中不在次小生成树中出现的边。注意最小生成树只有n-1条边，所以只需枚举n-1次。每次在剩下的边里求一次最小生成树，则这n-1棵“缺一条边的图”的最小生成树中权最小的就是原图的次小生成树。</p></blockquote><p>还有一种更好的方法：</p><blockquote><p>枚举要加入哪条新边。在最小生成树上加一条边u-v之后，图上会出现一条回路，因此删除的边必须在最小生成树上u到v的路径上，且是这条路径上的最长边。可以证明，次小生成树一定可以由最小生成树加一条边再删一条边得到（称为边交换），因此只需按照“每对节点之间的最小瓶颈路”的方法求出每对节点u和v在最小生成树中唯一路径的最大边权maxcost[u][v]，则剩下的部分只需要O(m)时间（枚举所有m-n+1条边进行交换，每次花O(1)时间求出新生成树的权值）。总时间复杂度为O(n^2)。</p></blockquote><h4 id="最小有向生成树"><a href="#最小有向生成树" class="headerlink" title="最小有向生成树"></a>最小有向生成树</h4><p><strong>问题描述：</strong><br>给定一个有向带权图G和其中一个节点u，找出一个以u为根节点，权和最小的有向生成树。有向生成树（directed spanning tree）也叫树形图（arborescence），是指一个类似树的有向图，满足以下条件：</p><ul><li>恰好有一个入度为0的点，称为根节点</li><li>其它节点的入度均为1</li><li>可以从根节点到达其它所有节点</li></ul><p>不难发现，如果树形图的节点数为n，它的边数一定为n-1，且树形图中不存在有向环。</p><p><strong>解题思路：</strong><br>固定根的最小树形图可以用朱-刘算法解决。</p><blockquote><p>首先是预处理，删除自环并判断根节点是否可以到达其它所有节点。如果不是，输出无解并终止程序。<br>接下来是算法的主过程：<br>首先，给所有非根节点选择一条权最小的入边。如果选出来的n-1条边不构成圈，则可以证明这些边就形成了一个最小树形图，否则把每个圈各收缩成一个点，继续上述过程。<br>缩圈之后，圈上所有边都消失了，因此在最终答案里需要加上这些边权之和。但这样做有个问题：假设在算法的某次迭代中，把圈C收缩为人工节点v，则在下一次迭代中，给v选择的入弧将与在圈C中的入弧发生冲突。（假设X在圈中已经有了入弧Y-&gt;X）因此如果收缩之后又选了一个入弧Z-&gt;X，必须把弧Y-&gt;X从最小树形图中删除。这等价于把弧Z-&gt;X的权值减少了Y-&gt;X的权值。</p></blockquote><h5 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h5><ul><li>刘汝佳，算法竞赛入门经典训练指南，北京：清华大学出版社，2012，343-344</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;在对最小生成树算法有一定理解后，我们对典型的最小生成树题型应该不难解决，但是对于由最小生成树模型变形而来的几种模型，我们仍需做一次总结与记录。&lt;br&gt;首先我们需要提出最小生成树几个性质，便于推导算法；然后我们将介绍6种最小生成
      
    
    </summary>
    
      <category term="ACM学习笔记" scheme="http://valenshi.top/categories/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="http://valenshi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线段树题集</title>
    <link href="http://valenshi.top/2019/10/07/segmentTree-problems/"/>
    <id>http://valenshi.top/2019/10/07/segmentTree-problems/</id>
    <published>2019-10-07T09:47:28.000Z</published>
    <updated>2019-10-07T09:51:23.835Z</updated>
    
    <content type="html"><![CDATA[<h4 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h4><p><strong>题意简述</strong><br>给定一数列，规定有两种操作，一是修改某个元素，二是求区间的连续和。<br><strong>解题思路</strong><br>线段树单点修改，区间查询的模板。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll dat;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dat(x) t[x].dat</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*为区间[l,r]建立以rt为根节点的子树*/</span></span><br><span class="line">l(rt) = l, r(rt) = r,dat(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid);</span><br><span class="line">BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">dat(rt) += val; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt) + r(rt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= mid) Add(rt*<span class="number">2</span>,p,val);</span><br><span class="line"><span class="keyword">else</span> Add(rt*<span class="number">2</span>+<span class="number">1</span>,p,val);</span><br><span class="line">dat(rt) = dat(rt*<span class="number">2</span>) + dat(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(rt) == l &amp;&amp; r(rt) == r) <span class="keyword">return</span> dat(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt) + r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> ask(rt*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r &lt;= mid) <span class="keyword">return</span> ask(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> ask(rt*<span class="number">2</span>,l,mid)+ask(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,k,a,b;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;k,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">if</span>(k) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(<span class="number">1</span>,a,b));</span><br><span class="line"><span class="keyword">else</span> Add(<span class="number">1</span>,a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="A-Simple-Problem-with-Integers"><a href="#A-Simple-Problem-with-Integers" class="headerlink" title="A Simple Problem with Integers"></a>A Simple Problem with Integers</h4><p><strong>题意简述</strong><br>这是一道模板题。</p><p>给定数列 a[1],a[2],…,a[n]，你需要依次进行 q 个操作，操作有两类：</p><p>C l r x：给定 l,r,x，对于所有 i∈[l,r]，将 a[i] 加上 x（换言之，将 a[l],a[l+1],…,a[r] 分别加上 x）；</p><p>Q l r：给定 l,r，求 ∑ri=la[i] 的值（换言之，求 a[l]+a[l+1]+⋯+a[r] 的值）。<br><strong>解题思路</strong><br>这题也是POJ3468。可以用很多种方法解决，是个练手的模板题。线段树区间修改+区间查询，延迟标记的简单使用。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll sum,add;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(x) t[x].add</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">l(rt) = l, r(rt) = r;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum(rt) = a[l]; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid); BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将延迟标记向下传一层*/</span></span><br><span class="line"><span class="keyword">if</span>(!add(p)) <span class="keyword">return</span>;</span><br><span class="line">sum(p*<span class="number">2</span>) += (r(p*<span class="number">2</span>)-l(p*<span class="number">2</span>)+<span class="number">1</span>)*add(p);</span><br><span class="line">sum(p*<span class="number">2</span>+<span class="number">1</span>) += (r(p*<span class="number">2</span>+<span class="number">1</span>)-l(p*<span class="number">2</span>+<span class="number">1</span>)+<span class="number">1</span>)*add(p);</span><br><span class="line">add(p*<span class="number">2</span>) += add(p); add(p*<span class="number">2</span>+<span class="number">1</span>) += add(p);</span><br><span class="line">add(p) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="comment">/*[l,r]内所有位置上元素都+val*/</span> </span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">sum(rt) += (r(rt)-l(rt)+<span class="number">1</span>)*val;</span><br><span class="line">add(rt) += val; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">spread(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) change(rt*<span class="number">2</span>,l,r,val);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) change(rt*<span class="number">2</span>+<span class="number">1</span>,l,r,val);</span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*回答[l,r]区间和*/</span> </span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> sum(rt);</span><br><span class="line">spread(rt); ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) res += ask(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) res += ask(rt*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,l,r,x;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'C'</span>)&#123;</span><br><span class="line">l = getInt(); r = getInt(); x = getInt();</span><br><span class="line">change(<span class="number">1</span>,l,r,x);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">l = getInt(); r = getInt();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(<span class="number">1</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="最大数"><a href="#最大数" class="headerlink" title="最大数"></a>最大数</h4><p><strong>题意简述</strong><br>原题来自：JSOI 2008</p><p>给定一个正整数数列 a1,a2,a3,⋯,an ，每一个数都在 0∼p–1 之间。可以对这列数进行两种操作：</p><p>添加操作：向序列后添加一个数，序列长度变成 n+1；</p><p>询问操作：询问这个序列中最后 L 个数中最大的数是多少。</p><p>程序运行的最开始，整数序列为空。写一个程序，读入操作的序列，并输出询问操作的答案。<br><strong>解题思路</strong><br>因为最多有N个数，那么先根据[1 , N]建立线段树，提前把位置空出来就好了，now指针记录最后一个位置，每次把新加入的元素插入++now，而询问最后L个数的最大值，则用ask(now - L , now)来查询即可，其它的就是线段树上维护区间最大值。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll mx;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mx(x) t[x].mx</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">l(rt) = l, r(rt) = r, mx(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid); BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">mx(rt) = val; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &gt; mid) change(rt*<span class="number">2</span>+<span class="number">1</span>,p,val);</span><br><span class="line"><span class="keyword">else</span> change(rt*<span class="number">2</span>,p,val);</span><br><span class="line">mx(rt) = max(mx(rt*<span class="number">2</span>),mx(rt*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> mx(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt) + r(rt)&gt;&gt;<span class="number">1</span> , res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) res = ask(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) res = max(res,ask(rt*<span class="number">2</span>+<span class="number">1</span>,l,r));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m,p,ans,now;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;p);</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,N<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%d"</span>,op,&amp;x);</span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'A'</span>) change(<span class="number">1</span>,++now,(x*<span class="number">1l</span>l+ans)%p);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans = ask(<span class="number">1</span>,now-x+<span class="number">1</span>,now));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="花神游历各国"><a href="#花神游历各国" class="headerlink" title="花神游历各国*"></a>花神游历各国*</h4><p><strong>题意简述</strong><br>原题来自：BZOJ 3211</p><p>花神喜欢步行游历各国，顺便虐爆各地竞赛。花神有一条游览路线，它是线型的，也就是说，所有游历国家呈一条线的形状排列，花神对每个国家都有一个喜欢程度（当然花神并不一定喜欢所有国家）。</p><p>每一次旅行中，花神会选择一条旅游路线，它在那一串国家中是连续的一段，这次旅行带来的开心值是这些国家的喜欢度的总和，当然花神对这些国家的喜欢程序并不是恒定的，有时会突然对某些国家产生反感，使他对这些国家的喜欢度 δ 变为 $\sqrtδ$（可能是花神虐爆了那些国家的 OI，从而感到乏味）。</p><p>现在给出花神每次的旅行路线，以及开心度的变化，请求出花神每次旅行的开心值。</p><p><strong>解题思路</strong><br>我刚开始想的是如何把修改延迟，但是后来发现不太容易实现。很容易的发现的就是1e9开根10次后就是1了（当然还有下取整），所以题目范围内所有数最多开根10次就会变成1或0，也就是说我们可以记录每个点被修改了多少次，如果已经修改了10次以上，那么再修改也无意义了。<br>于是我们可以每次修改都修改到叶子节点（因为无法延迟或整段修改），同时记录每个节点被修改了多少次，如果一段区间修改次数最小的节点都修改了10次，那么这一段区间就都不用修改了；这就会大大降低时间复杂度，因为每一个节点最多被修改10次，O(10NlogN)。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,mi;</span><br><span class="line">ll sum;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mi(x) t[x].mi</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">l(rt) = l,r(rt) = r,mi(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum(rt) = a[l]; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid); BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(mi(rt) &gt; <span class="number">10</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">sum(rt) = a[l(rt)] = <span class="built_in">sqrt</span>(a[l(rt)]); </span><br><span class="line">mi(rt)++; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt) + r(rt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) change(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) change(rt*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">mi(rt) = min(mi(rt*<span class="number">2</span>),mi(rt*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> sum(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>; ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) res += ask(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) res += ask(rt*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,op,l,r;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;op,&amp;l,&amp;r);</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(<span class="number">1</span>,l,r));</span><br><span class="line"><span class="keyword">else</span> change(<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="维护序列"><a href="#维护序列" class="headerlink" title="维护序列*"></a>维护序列*</h4><p><strong>题意简述</strong><br>原题来自：AHOI 2009</p><p>老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。</p><p>有长为 n 的数列，不妨设为 a1,a2,⋯,an 。有如下三种操作形式：</p><p>把数列中的一段数全部乘一个值；</p><p>把数列中的一段数全部加一个值；</p><p>询问数列中的一段数的和，由于答案可能很大，你只需输出这个数模 P 的值。</p><p><strong>解题思路</strong><br>这个如果修改操作只有 2 或 1，那么就是一个区间修改-延迟标记的模板题，但是它把“乘”和“加”操作放在了一起，当然还是需要用延迟标记来做，add表示待加上的值，mul表示待乘的值。<br>有一个问题，就是我们在向下传递延迟标记时，是先传递加法呢，还是乘法呢？其实问题的根源不在这，而在于我们在做乘法时，对加法的延迟标记也要乘 val，即 add = add * val，因为满足结合律。搞完这点剩下就是写起来比较麻烦而已，没别的难点了</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll add,mul,sum;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x) t[x].mul</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(x) t[x].add</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,P;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">l(rt) = l, r(rt) = r, add(rt) = <span class="number">0</span>, mul(rt) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum(rt) = a[l]; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid); BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread_add</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将累加标记向下传一层*/</span></span><br><span class="line"><span class="keyword">if</span>(!add(p)) <span class="keyword">return</span>;</span><br><span class="line">sum(p*<span class="number">2</span>) = (sum(p*<span class="number">2</span>) + (r(p*<span class="number">2</span>) - l(p*<span class="number">2</span>)+<span class="number">1</span>)*add(p)%P)%P;</span><br><span class="line">sum(p*<span class="number">2</span>+<span class="number">1</span>) = (sum(p*<span class="number">2</span>+<span class="number">1</span>) + (r(p*<span class="number">2</span>+<span class="number">1</span>) - l(p*<span class="number">2</span>+<span class="number">1</span>)+<span class="number">1</span>)*add(p)%P)%P;</span><br><span class="line">add(p*<span class="number">2</span>) = (add(p*<span class="number">2</span>) + add(p))%P; </span><br><span class="line">add(p*<span class="number">2</span>+<span class="number">1</span>) = (add(p*<span class="number">2</span>+<span class="number">1</span>)+add(p))%P; </span><br><span class="line">add(p) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread_mul</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将累乘标记向下传一层,累乘标记对累加标记也有影响*/</span> </span><br><span class="line"><span class="keyword">if</span>(mul(p) == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">sum(p*<span class="number">2</span>) = sum(p*<span class="number">2</span>)*mul(p)%P;</span><br><span class="line">sum(p*<span class="number">2</span>+<span class="number">1</span>) = sum(p*<span class="number">2</span>+<span class="number">1</span>)*mul(p)%P;</span><br><span class="line">mul(p*<span class="number">2</span>) = mul(p*<span class="number">2</span>)*mul(p)%P;</span><br><span class="line">mul(p*<span class="number">2</span>+<span class="number">1</span>) = mul(p*<span class="number">2</span>+<span class="number">1</span>)*mul(p)%P;</span><br><span class="line"><span class="comment">/*更新add标记*/</span> </span><br><span class="line">add(p*<span class="number">2</span>) = add(p*<span class="number">2</span>)*mul(p)%P;</span><br><span class="line">add(p*<span class="number">2</span>+<span class="number">1</span>) = add(p*<span class="number">2</span>+<span class="number">1</span>)*mul(p)%P; </span><br><span class="line">mul(p) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">add(rt) = add(rt)*val%P;<span class="comment">//更新add标记！ </span></span><br><span class="line">sum(rt) = sum(rt)*val%P;</span><br><span class="line">mul(rt) = mul(rt)*val%P;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">spread_mul(rt);spread_add(rt); </span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) Mul(rt*<span class="number">2</span>,l,r,val);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) Mul(rt*<span class="number">2</span>+<span class="number">1</span>,l,r,val);</span><br><span class="line">sum(rt) = (sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>))%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">sum(rt) = (sum(rt) + (r(rt)-l(rt)+<span class="number">1</span>)*val % P)%P;</span><br><span class="line">add(rt) = (add(rt)+val)%P; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">spread_mul(rt); spread_add(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) Add(rt*<span class="number">2</span>,l,r,val);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) Add(rt*<span class="number">2</span>+<span class="number">1</span>,l,r,val);</span><br><span class="line">sum(rt) = (sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>))%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> sum(rt)%P;</span><br><span class="line">spread_mul(rt); spread_add(rt) ;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) res += ask(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) res += ask(rt*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> res%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;P);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,a+i), a[i] %= P;</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,op,t,g,c;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op);</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;t,&amp;g,&amp;c);</span><br><span class="line">Mul(<span class="number">1</span>,t,g,c);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;t,&amp;g,&amp;c);</span><br><span class="line">Add(<span class="number">1</span>,t,g,c);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t,&amp;g);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(<span class="number">1</span>,t,g));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;区间和&quot;&gt;&lt;a href=&quot;#区间和&quot; class=&quot;headerlink&quot; title=&quot;区间和&quot;&gt;&lt;/a&gt;区间和&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;题意简述&lt;/strong&gt;&lt;br&gt;给定一数列，规定有两种操作，一是修改某个元素，二是求区间的连续和。&lt;br&gt;&lt;str
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="线段树" scheme="http://valenshi.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>一维RMQ问题题集</title>
    <link href="http://valenshi.top/2019/10/07/st-problems/"/>
    <id>http://valenshi.top/2019/10/07/st-problems/</id>
    <published>2019-10-07T05:10:12.000Z</published>
    <updated>2019-10-07T05:13:59.758Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/index.php" target="_blank" rel="noopener">书本配套OJ</a><br><a href="http://www.mfstem.org/" target="_blank" rel="noopener">本校OJ</a></p><p>ST表使用说明：</p><ul><li>常用于离线问题，或当作辅助数据结构，查询时间非常优秀，O(1)</li><li>二维st表也很好实现，不过本题集中未涉及</li><li>st表内也可以维护的是下标而非值，在某些时候很有用</li></ul><h4 id="数列区间最大值"><a href="#数列区间最大值" class="headerlink" title="数列区间最大值"></a>数列区间最大值</h4><p><strong>题意简述</strong><br>输入一串数字，给你 M 个询问，每次询问就给你两个数字 X,Y，要求你说出 X 到 Y 这段区间内的最大数。<br><strong>解题思路</strong><br>st表模板题。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>] ,Log[N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'-'</span> &amp;&amp; (c &lt;<span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i]= Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)&#123;</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="最敏捷的机器人"><a href="#最敏捷的机器人" class="headerlink" title="最敏捷的机器人"></a>最敏捷的机器人</h4><p><strong>题意简述</strong><br>Wind 设计了很多机器人。但是它们都认为自己是最强的，于是，一场比赛开始了……</p><p>机器人们都想知道谁是最敏捷的，于是它们进行了如下一个比赛。首先，他们面前会有一排共 n 个数，它们比赛看谁能最先把每连续 k 个数中最大和最小值写下来，当然，这些机器人运算速度都很快，它们比赛的是谁写得快。</p><p>但是 Wind 也想知道答案，你能帮助他吗？<br><strong>解题思路</strong><br>st表模板题，不过还要维护一下最小值，多开一个数组即可。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>] ,Log[N], st2[N][<span class="number">22</span>];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'-'</span> &amp;&amp; (c &lt;<span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i]= Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st2[i][<span class="number">0</span>] = st[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)&#123;</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">st2[i][j] = min(st2[i][j<span class="number">-1</span>],st2[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> mx = max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"><span class="keyword">int</span> mi = min(st2[l][k],st2[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,mx,mi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n-m+<span class="number">1</span>;i++) ask(i,i+m<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="与众不同"><a href="#与众不同" class="headerlink" title="与众不同*"></a>与众不同*</h4><p><strong>题意简述</strong><br>A 是某公司的 CEO，每个月都会有员工把公司的盈利数据送给 A，A 是个与众不同的怪人，A 不注重盈利还是亏本，而是喜欢研究「完美序列」：一段连续的序列满足序列中的数互不相同。<br>A 想知道区间 [L,R] 之间最长的完美序列长度。</p><p><strong>解题思路</strong><br>我们可以通过标记数组在O(N)时间内求出每个位置“作为结束位置”时的最长完美序列长度，以及它的起点。<br>设last[ x ] 表示 x 上次出现的位置；bgn[ p ]表示以位置 p 为末尾的完美序列的起点位置；len[p] 表示以位置 p 为末尾的完美序列的长度。显然我们可以在一次遍历内更新完毕上述三个数组，O(N)。<br>那么对于任意区间[ L , R ]，其内的最长完美序列长度仅有 2 种可能，一种是终点在区间内，起点不在；另一种是起点和终点都在区间内。此时我们已经可以通过一次遍历来求答案了，但是复杂度最差O(N)，不可取。由于bgn[]是单调递增的，所以对于某个位置 pos，[ L , pos-1] 所有位置上的起点都小于 L，[pos , R]上所有位置上的起点都大于L，那么我们可以通过ST表维护 [pos ,R] 上的最大的 len 值，在O(1)时间内求出，那么答案就是max(pos-L , ask(pos , R) )。</p><p>我们可以通过二分搜索来查找 pos ,复杂度 O(log N)，根据len数组构造st表，O(NlogN)，总时间复杂度O( (N+M)logN )。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">1e6</span>;</span><br><span class="line"><span class="comment">/*last[x]为x上一次出现的位置;</span></span><br><span class="line"><span class="comment">bgn[p]为以位置p结尾的起点位置;len[p]为以p结尾的完美序列长度*/</span></span><br><span class="line"><span class="keyword">int</span> last[SZ],bgn[N],len[N];</span><br><span class="line"><span class="keyword">int</span> a[N],Log[N],st[N][<span class="number">22</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_st</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = len[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;<span class="number">1</span>&lt;&lt;j &lt;= n;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(bgn[mid] &gt;= x) r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">bgn[i] = max(bgn[i<span class="number">-1</span>],last[a[i]+B]+<span class="number">1</span>);<span class="comment">//起始位置必须合法 </span></span><br><span class="line">len[i] = i - bgn[i] + <span class="number">1</span>;</span><br><span class="line">last[a[i]+B] = i;</span><br><span class="line">&#125;</span><br><span class="line">init_st();<span class="comment">//建立len数组的st表 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,p,res;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);x++,y++; </span><br><span class="line">p = bsearch(x,y,x);<span class="comment">//找到[x,y]内第一个bgn大于等于x的位置 </span></span><br><span class="line"><span class="keyword">if</span>(p &lt;= y) res = max(p-x,ask(p,y));</span><br><span class="line"><span class="keyword">else</span> res = p-x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="天才的记忆"><a href="#天才的记忆" class="headerlink" title="天才的记忆"></a>天才的记忆</h4><p><strong>代码示例：</strong> 模板模板，题面和思路不说了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>] ,Log[N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'-'</span> &amp;&amp; (c &lt;<span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i]= Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)&#123;</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt();;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">init(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Balanced-Lineup"><a href="#Balanced-Lineup" class="headerlink" title="Balanced Lineup"></a>Balanced Lineup</h4><p><strong>代码示例：</strong> 和“敏捷的机器人”一样，都是要维护最大以及最小值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>] ,Log[N], st2[N][<span class="number">22</span>];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'-'</span> &amp;&amp; (c &lt;<span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i]= Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st2[i][<span class="number">0</span>] = st[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)&#123;</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">st2[i][j] = min(st2[i][j<span class="number">-1</span>],st2[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> mx = max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"><span class="keyword">int</span> mi = min(st2[l][k],st2[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mx-mi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">ask(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="选择客栈"><a href="#选择客栈" class="headerlink" title="选择客栈*"></a>选择客栈*</h4><p><strong>题意描述</strong><br>丽江河边有 n 家很有特色的客栈，客栈按照其位置顺序从 1 到 n 编号。</p><p>每家客栈都按照某一种色调进行装饰（总共 k 种，用整数 0 k−1 表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。</p><p>两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。</p><p>晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 p 。</p><p>他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 p 元的咖啡店小聚。</p><p><strong>解题思路</strong><br>没看正解是啥，我没用到st表，不过倒是用到了求RMQ的步骤。<br>共三个辅助数组，col[k] 表示当前第k种颜色客栈的数量；val[x]表示客栈x的最低消费；mip[x]表示 [x, n] 内第一个最低消费小于等于 p 元的客栈位置。<br>如果第一个人入住客栈x，第二个人能够入住的旅店的位置一定是大于等于mip[x]的，并且要颜色和 x 相同，即col[ a[i] ]种选择方案。所以我们只需要从前往后顺序遍历一遍并统计答案即可，复杂度O(N)。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> col[K];</span><br><span class="line"><span class="keyword">int</span> n,m,p;</span><br><span class="line"><span class="keyword">int</span> a[N],val[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'-'</span> &amp;&amp; (c &lt;<span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mip[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">mip[n+<span class="number">1</span>] = n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(val[i] &gt; p) mip[i] = mip[i+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> mip[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">1</span>; ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> now = mip[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = pre;j &lt; now;j++) col[a[j]]--;</span><br><span class="line"><span class="comment">//printf("%d %d %d\n",pre,now,col[a[i]]);</span></span><br><span class="line">ans += col[a[i]]; pre = now;</span><br><span class="line"><span class="keyword">if</span>(now == i) ans--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt(); p = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= n;i++)&#123;</span><br><span class="line">a[i] = getInt(); val[i] = getInt(); </span><br><span class="line">col[a[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://ybt.ssoier.cn:8088/index.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;书本配套OJ&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.mfstem.org/&quot; target=&quot;_blan
      
    
    </summary>
    
      <category term="ACM题解" scheme="http://valenshi.top/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="st表" scheme="http://valenshi.top/tags/st%E8%A1%A8/"/>
    
      <category term="RMQ问题" scheme="http://valenshi.top/tags/RMQ%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
</feed>
