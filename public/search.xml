<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Educational Codeforces Round 81 (Rated for Div. 2)</title>
      <link href="/2020/02/16/Edu-Cf81/"/>
      <url>/2020/02/16/Edu-Cf81/</url>
      
        <content type="html"><![CDATA[<h4 id="A-Display-The-Number"><a href="#A-Display-The-Number" class="headerlink" title="A. Display The Number"></a>A. Display The Number</h4><p><strong>题意简述</strong><br>众所周知 7 根数码管可以用于表示数字 0~9 ，现在给 n 根数码管，请问能表示的最大的数是多少？</p><p><strong>解题思路</strong><br>显然位数越大的数越大，相同位数时，高位大的数越大。那么最少用 2 根数码管能表示一个数字，即 1，所以我们尽量多的表示 1，可以表示 n/2 个1，如果 n 为奇数，那么剩下的 1 个数码管可以和最高位表示出 7，因此我们只需对 n 判奇偶即可。</p><p><strong>Code</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = n/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">string</span> ans = <span class="string">"1"</span>;</span><br><span class="line"><span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans = <span class="string">"7"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; cnt;i++) ans += <span class="string">"1"</span>;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; solve() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="B-Infinite-Prefixes"><a href="#B-Infinite-Prefixes" class="headerlink" title="B. Infinite Prefixes"></a>B. Infinite Prefixes</h4><p><strong>题意简述</strong><br>给定一个 01 串 s，定义串 t 是由若干个 s 组成，即 t = sssssss…。<br>对于 t 的前缀 pre，pre 中 <strong>cnt0 （字符 0 的数量） - cnt1（字符 1 的数量） = x</strong>，那么称 pre 是 t 的黄金前缀，请问给定整数 x 和字符串 s，t 共多少个黄金前缀？<br>注意：空串也是一个前缀！</p><p><strong>解题思路</strong><br>如果仅从题意来看的话应该就是构造性模拟题，但是前提是分类要正确，我刚开始就是分类过细导致漏掉某些情况。<br>我们可以利用前缀和思路，sum[i] 存放 s 串中以 i 为末尾的前缀 cnt0 - cnt1 的值。易得，若 x - sum[i] % sum[n] == 0，则说明我们可以在当前前缀前面添加若干个 s 串来使得其变为黄金前缀。但是如果 sum[n] &lt;= 0 那么就会出错，因为正数和负数取模结果是不一定的，所以当 sum[n] &lt;= 0 时需要单独处理。<br>上述做法只针对 x 是正数，若 x 是负数则把 s 串中 01 互换并把 x 取反即可。</p><p><strong>Code</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> pre[N];</span><br><span class="line"><span class="keyword">int</span> n,x;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;<span class="comment">//预处理将x转为正</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line"><span class="keyword">if</span>(str[i] == <span class="string">'1'</span>) str[i] = <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">else</span> str[i] = <span class="string">'1'</span>;</span><br><span class="line">x = -x;</span><br><span class="line">&#125; </span><br><span class="line">str = <span class="string">"#"</span> + str;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">//判断无穷解</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i] == <span class="string">'0'</span>) pre[i] = pre[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> pre[i] = pre[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(pre[i] == x) flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pre[n] == <span class="number">0</span> &amp;&amp; flag)&#123;<span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> ans = (!x)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(pre[n] &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>((x-pre[i]) &gt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>((pre[i]-x)%(-pre[n]) == <span class="number">0</span>) ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(x &gt;= pre[i] &amp;&amp; (x-pre[i])%pre[n] == <span class="number">0</span>) ans++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="C-Obtain-The-String"><a href="#C-Obtain-The-String" class="headerlink" title="C. Obtain The String"></a>C. Obtain The String</h4><p><strong>题意简述</strong><br>给定两个字符串 s 和 t，要求从 s 中选出若干个<strong>子序列</strong>，使得它们<strong>依次</strong>拼接后可以得到 t。<br>请问最少需要选几次子序列？（每次选定后 s 不变）</p><p><strong>解题思路</strong><br>理解题意后可以做出推论” 每次选取当前最长合法子序列一定是最优的“。<br>例如对于 s = “abcdef” , t = “adddecf”，那么第一次可选的有 “a” 和 “ad”，显而易见选 “ad” 更好，否则选了 “a” 之后第二次还是要选一次 “d”，多做了一次操作。<br>那么解题步骤可以总结为：nex[p , j] 记录 s 中位置 p 的下一个 j （j = a,b,c,d,…）所在的下标。于是我们可以遍历 t，刚开始 p = 0，然后 p = nex[p ,j]，当 p = -1时就说明当前子序列不能再拓展了。</p><p><strong>Code</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> f[N],nex[N][<span class="number">30</span>];</span><br><span class="line"><span class="built_in">string</span> s,t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*最少几次操作可以使得 z 变为 t */</span></span><br><span class="line">s = <span class="string">"#"</span> + s; t = <span class="string">"#"</span> + t;</span><br><span class="line"><span class="keyword">int</span> len = s.length();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">30</span>;i++) nex[len<span class="number">-1</span>][i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++) nex[i<span class="number">-1</span>][j] = nex[i][j];</span><br><span class="line">nex[i<span class="number">-1</span>][s[i]-<span class="string">'a'</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>; len = t.length();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,p = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">f[i] = f[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(~nex[p][t[i]-<span class="string">'a'</span>]) p = nex[p][t[i]-<span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">f[i]++, p = nex[<span class="number">0</span>][t[i]-<span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">-1</span>)&#123; <span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f[len<span class="number">-1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="D-Same-GCDs"><a href="#D-Same-GCDs" class="headerlink" title="D. Same GCDs"></a>D. Same GCDs</h4><p><strong>题意简述</strong><br>给定正整数 a 和 m，试求出 x 的个数，x 满足 0 &lt;= x &lt; m 且 gcd(a, m) = gcd(a+x, m) 。其中 1&lt;= a,m &lt;= 1e10。</p><p><strong>解题思路</strong><br>设 d = gcd(a, m)，易得 d|a , d|m , d|(a+x) , d|x 。<br>因而 x 满足：</p><ol><li>d|x</li><li>gcd( (x+a)/d , m/d ) = 1</li></ol><p>令 t = (x+a)/d，那么问题变为找到 t 的个数，使得 gcd(t , m/d) = 1，其中 a/d &lt;= t &lt;= (m+a)/d，化简得 0 &lt;= t &lt;= m/d。<br>即答案为 phi(m/d)。其中 phi(y) 为 y 的欧拉函数。</p><p><strong>Code</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line">ll a,m;</span><br><span class="line"><span class="function">ll <span class="title">Phi</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">ll res = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;<span class="number">1l</span>l*i*i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(n%i == <span class="number">0</span>) &#123;</span><br><span class="line">res -= res/i;</span><br><span class="line"><span class="keyword">while</span>(n%i == <span class="number">0</span>) n /= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n &gt; <span class="number">1</span>) res -= res/n;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%I64d%I64d"</span>,&amp;a,&amp;m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,Phi(m/gcd(a,m)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强连通分量题集</title>
      <link href="/2020/02/16/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E9%A2%98%E9%9B%86/"/>
      <url>/2020/02/16/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E9%A2%98%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/statusx.php?runidx=3239944" target="_blank" rel="noopener">一本通OJ</a><br><a href="http://www.mfstem.org/contest/17/problems" target="_blank" rel="noopener">灵动OJ</a></p><h4 id="A-受欢迎的牛-popular"><a href="#A-受欢迎的牛-popular" class="headerlink" title="A.受欢迎的牛(popular)"></a>A.受欢迎的牛(popular)</h4><p><strong>题意描述</strong><br>原题来自：USACO 2003 Fall</p><p>每一头牛的愿望就是变成一头最受欢迎的牛。现在有 N 头牛，给你 M 对整数 (A,B)，表示牛 A 认为牛 B 受欢迎。这种关系是具有传递性的，如果 A 认为 B 受欢迎，B 认为 C 受欢迎，那么牛 A 也认为牛 C 受欢迎。你的任务是求出有多少头牛被除自己之外的所有牛认为是受欢迎的。</p><p><strong>解题思路</strong><br>一头牛是受欢迎的，当且仅当其它所有牛都是它的粉丝。那么我们在这样一个有向图中，首先把强连通分量缩点，变成 DAG ，在新的图上，出度为 0 的点才有可能是受欢迎的。如果这样的点仅有一个，那么该点所代表的牛就都是受欢迎的，如果有不止一个，那么就不存在受欢迎的牛。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span>*N;</span><br><span class="line"><span class="comment">//建立有向图的同时建立它的反图</span></span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],edge[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> rhead[N],rver[M],rnex[M],redge[M],rtot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">rver[++rtot] = x,rnex[rtot] = rhead[y]; rhead[y] = rtot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* co[x]:节点x所属强连通的id,col则是用于计数</span></span><br><span class="line"><span class="comment">ts[x]:结束时间为x的节点编号,clk用于计数 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,cnt[N],deg[N];</span><br><span class="line"><span class="keyword">int</span> co[N],col,ts[N],clk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">co[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])</span><br><span class="line"><span class="keyword">if</span>(!co[ver[i]]) dfs(ver[i]);</span><br><span class="line">ts[++clk] = x;<span class="comment">//第 clk 个结束的是x</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rdfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">co[x] = col; ++cnt[col];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = rhead[x]; i ;i = rnex[i])</span><br><span class="line"><span class="keyword">if</span>(!co[rver[i]]) rdfs(rver[i],col);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Korasaju</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!co[i]) dfs(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) co[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i ;--i) </span><br><span class="line"><span class="keyword">if</span>(!co[ts[i]]) rdfs(ts[i],++col);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">Korasaju();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>;x &lt;= n;x++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])</span><br><span class="line"><span class="keyword">if</span>(co[x] != co[ver[i]]) deg[co[x]]++;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++)</span><br><span class="line"><span class="keyword">if</span>(!deg[i] &amp;&amp; ans)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"0"</span>); <span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!deg[i]) ans = cnt[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="B-最大半连通子图-semi"><a href="#B-最大半连通子图-semi" class="headerlink" title="B.最大半连通子图(semi)"></a>B.最大半连通子图(semi)</h4><p><strong>题意描述</strong><br>一个有向图 G=( V , E ) 称为半连通的 (Semi-Connected)，如果满足对于图中任意两点 u，v , 存在一条 u 到 v 的有向路径或者从 v 到 u 的有向路径。</p><p>若 G’=(V’,E’) 满足 V’属于 V， E’ 是 E 中所有跟 V’ 有关的边，则称 G’ 是 G 的一个导出子图。若 G’ 是 G 的导出子图，且 G’ 半连通，则称 G’ 为 G 的半连通子图。若 G’ 是 G 所有半连通子图中包含节点数最多的，则称 G’ 是 G 的最大半连通子图。</p><p>给定一个有向图 G，请求出 G 的最大半连通子图拥有的节点数 K，以及不同的最大半连通子图的数目 C。由于C可能比较大，仅要求输出 C 对 X 的余数。<br><strong>解题思路</strong><br>这道题首先要理解清楚半连通、半连通子图的概念，然后才能进行求解。这道题有两问，第一问求最大的半连通子图（节点数最多的），第二问求有多少种不同的最大半连通子图。</p><p>对于第一问可以通过先将原图缩点，变成一张 DAG，然后再用拓扑排序来寻找‘最长链’，这个最长链就是最大半连通子图，而在 topo 过程中我们还可以设置一个数组 f[i] 表示到节点 i 达到局部最长链的方案数。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> co[N],col,dfn[N],clk,low[N];</span><br><span class="line"><span class="keyword">int</span> n,m,X;</span><br><span class="line"><span class="keyword">int</span> Stack[N],top,cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;<span class="comment">//dfs序</span></span><br><span class="line">Stack[++top] = x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y]) Tarjan(y), low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!co[y]) low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[x] == low[x])</span><br><span class="line"><span class="keyword">for</span>(++col;Stack[top+<span class="number">1</span>] != x;top--)</span><br><span class="line">co[Stack[top]] = col,cnt[col]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[N]; <span class="comment">//到 x 距离最长时不同的方案数</span></span><br><span class="line"><span class="keyword">int</span> deg[N],dis[N]; </span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++) <span class="keyword">if</span>(!deg[i]) que.push(i),dis[i] = cnt[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++) f[i] = <span class="number">1</span>;<span class="comment">//这儿置1,但是下面要置0</span></span><br><span class="line"><span class="keyword">while</span>(que.size())&#123;</span><br><span class="line"><span class="keyword">int</span> x = que.front(); que.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i]; deg[y]--;</span><br><span class="line"><span class="keyword">if</span>(!deg[y]) que.push(y);</span><br><span class="line"><span class="keyword">if</span>(dis[y] &lt; dis[x] + cnt[y])</span><br><span class="line">dis[y] = dis[x]+cnt[y], f[y] = <span class="number">0</span>;<span class="comment">//要把 f[y] 置零</span></span><br><span class="line"><span class="keyword">if</span>(dis[y] == dis[x] + cnt[y])<span class="comment">//任何情况下都要从 x 上转移过来</span></span><br><span class="line">f[y] = (f[y]+f[x])%X;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pa[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line"><span class="comment">//建立新图</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>,tc = <span class="number">0</span>;x &lt;= n;x++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])</span><br><span class="line">pa[++tc].first = co[x],pa[tc].second = co[ver[i]];</span><br><span class="line">sort(pa+<span class="number">1</span>,pa+<span class="number">1</span>+m);</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head); tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x = pa[i].first, y = pa[i].second;</span><br><span class="line"><span class="keyword">int</span> xx = pa[i<span class="number">-1</span>].first, yy = pa[i<span class="number">-1</span>].second;</span><br><span class="line"><span class="keyword">if</span>(x != y &amp;&amp; (x != xx || y != yy))</span><br><span class="line">addEdge(x,y),deg[y]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建图后利用拓扑排序查找最长链以及不同个数</span></span><br><span class="line">topo();  <span class="keyword">int</span> mx = <span class="number">0</span>,ty = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++) mx = max(mx,dis[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++) <span class="keyword">if</span>(dis[i] == mx) ty = (ty+f[i])%X;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>,mx,ty);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;X);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y); addEdge(x,y);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="C-网络协议-net"><a href="#C-网络协议-net" class="headerlink" title="C.网络协议(net)"></a>C.网络协议(net)</h4><p><strong>题意描述</strong></p><p>出自 IOI 1996一些学校连接在一个计算机网络上。学校之间存在软件支援协议。每个学校都有它应支援的学校名单（学校 a 支援学校 b，并不表示学校 b 一定支援学校 a）。当某校获得一个新软件时，无论是直接得到还是网络得到，该校都应立即将这个软件通过网络传送给它应支援的学校。因此，一个新软件若想让所有连接在网络上的学校都能使用，只需将其提供给一些学校即可。</p><p><strong>任务a：</strong> 请编一个程序，根据学校间支援协议（各个学校的支援名单），计算最少需要将一个新软件直接提供给多少个学校，才能使软件通过网络被传送到所有学校；</p><p><strong>任务b：</strong> 如果允许在原有支援协议上添加新的支援关系。则总可以形成一个新的协议，使得此时只需将一个新软件提供给任何一个学校，其他所有学校就都可以通过网络获得该软件。编程计算最少需要添加几条新的支援关系。</p><p><strong>解题思路</strong><br>首先可以知道在一个强连通分量中，任意一个学校拥有资源，那么其它所有学校就都会拥有资源，所以我们可以通过先缩点，将原图变为 DAG 。在此之后可以通过计算入度为 0 的点的数目，这就是我们需要提供的学校数量。<br>第二问可以通过统计出度为 0 的点的数目，因此来统计至少需要添加多少条边才能使得 DAG 变为强连通图，当然要特判 DAG 仅有一个点的情况，此时无需添加额外的边。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> G[N][N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],co[N],col,clk;</span><br><span class="line"><span class="keyword">int</span> Stack[N],top;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line">Stack[++top] = x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!G[x][i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(!dfn[i]) Tarjan(i),low[x] = min(low[x],low[i]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!co[i]) low[x] = min(low[x],dfn[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[x] == dfn[x])</span><br><span class="line"><span class="keyword">for</span>(++col;Stack[top+<span class="number">1</span>] != x;--top)</span><br><span class="line">co[Stack[top]] = col;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> deg[N],deg2[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line"><span class="keyword">if</span>(G[i][j] &amp;&amp; co[i] != co[j]) deg[co[j]]++,deg2[co[i]]++;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>,res2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++) <span class="keyword">if</span>(!deg[i]) res++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++) <span class="keyword">if</span>(!deg2[i]) res2++;</span><br><span class="line">res2 = max(res,res2);</span><br><span class="line"><span class="keyword">if</span>(col == <span class="number">1</span>) res2 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,y;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; y;</span><br><span class="line"><span class="keyword">while</span>(y)</span><br><span class="line">G[i][y] = <span class="number">1</span>, <span class="built_in">cin</span> &gt;&gt; y;</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="D-消息的传递-message"><a href="#D-消息的传递-message" class="headerlink" title="D.消息的传递(message)"></a>D.消息的传递(message)</h4><p><strong>题意描述</strong><br>我们的郭嘉大大在曹操这过得逍遥自在，但是有一天曹操给了他一个任务，在建邺城内有N（&lt;=1000）个袁绍的奸细 将他们从 1 到 N 进行编号，同时他们之间存在一种传递关系，即若C[i, j] = 1，则奸细 i 能将消息直接传递给奸细 j。<br>现在，曹操要发布一个假消息，需要传达给所有奸细，而我们的郭嘉大大则需要传递给尽量少的奸细使所有的奸细都知道这一个消息，问我们至少要传给几个奸细？</p><p><strong>解题思路</strong><br>和上一题有些类似，只需要缩点后统计入度为 0 的点的数量即可。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1100</span>;</span><br><span class="line"><span class="keyword">int</span> G[N][N],dfn[N],low[N],clk,co[N],col;</span><br><span class="line"><span class="keyword">int</span> n,Stack[N],top;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line">Stack[++top] = x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!G[x][i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(!dfn[i]) Tarjan(i),low[x] = min(low[x],low[i]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!co[i]) low[x] = min(low[x],dfn[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[x] == dfn[x])</span><br><span class="line"><span class="keyword">for</span>(++col;Stack[top+<span class="number">1</span>] != x;top--)</span><br><span class="line">co[Stack[top]] = col;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> deg[N],ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;G[i][j]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line"><span class="keyword">if</span>(G[i][j] &amp;&amp; co[i] != co[j]) deg[co[j]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++) <span class="keyword">if</span>(!deg[i]) ans++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="E-间谍网络-spy"><a href="#E-间谍网络-spy" class="headerlink" title="E.间谍网络(spy)"></a>E.间谍网络(spy)</h4><p><strong>题意描述</strong><br>由于外国间谍的大量渗入，国家安全正处于高度的危机之中。如果A间谍手中掌握着关于B间谍的犯罪证据，则称A可以揭发B。有些间谍收受贿赂，只要给他们一定数量的美元，他们就愿意交出手中掌握的全部情报。所以，如果我们能够收买一些间谍的话，我们就可能控制间谍网中的每一分子。因为一旦我们逮捕了一个间谍，他手中掌握的情报都将归我们所有，这样就有可能逮捕新的间谍，掌握新的情报。</p><p>我们的反间谍机关提供了一份资料，包括所有已知的受贿的间谍，以及他们愿意收受的具体数额。同时我们还知道哪些间谍手中具体掌握了哪些间谍的资料。假设总共有n个间谍(n不超过3000)，每个间谍分别用1到3000的整数来标识。</p><p>请根据这份资料，判断我们是否有可能控制全部的间谍，如果可以，求出我们所需要支付的最少资金。否则，输出不能被控制的一个间谍。</p><p><strong>解题思路</strong><br>首先将原图强连通分量缩点，变为 DAG ，新点的权值为原图中强连通分量所有点权值的最小值；然后累加新图中入度为 0 的点的权值，如果有一个点入度为 0 且不受贿，那么就无解。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dfn[N],clk,co[N],col,low[N];</span><br><span class="line"><span class="keyword">int</span> Stack[N],top;</span><br><span class="line"><span class="keyword">int</span> w[N],n,m,p;</span><br><span class="line"><span class="keyword">int</span> spy[N],ct[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line">Stack[++top] = x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y]) Tarjan(y), low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!co[y]) low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[x] == low[x])</span><br><span class="line"><span class="keyword">for</span>(++col;Stack[top+<span class="number">1</span>] != x;top--)&#123;</span><br><span class="line">co[Stack[top]] = col;</span><br><span class="line"><span class="keyword">if</span>(w[Stack[top]] != INF) ct[col] = min(ct[col],w[Stack[top]]);</span><br><span class="line"><span class="keyword">else</span> spy[col] = min(spy[col],Stack[top]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> deg[N],ans,ans2 = INF;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>;x &lt;= n;x++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])</span><br><span class="line"><span class="keyword">if</span>(co[x] != co[ver[i]]) deg[co[ver[i]]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++)</span><br><span class="line"><span class="keyword">if</span>(!deg[i] &amp;&amp; ct[i] == INF)&#123;</span><br><span class="line">ans2 = min(ans2,spy[i]);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!deg[i]) ans += ct[i];</span><br><span class="line"><span class="keyword">if</span>(ans2 != INF) <span class="built_in">printf</span>(<span class="string">"NO\n%d\n"</span>,ans2);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"YES\n%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; N;i++) ct[i] = w[i] = spy[i] = INF;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n); <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= p;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y),w[x] = y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y),addEdge(x,y);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="F-抢掠计划-grab"><a href="#F-抢掠计划-grab" class="headerlink" title="F.抢掠计划(grab)"></a>F.抢掠计划(grab)</h4><p><strong>题意描述</strong></p><p>Siruseri 城中的道路都是单向的。不同的道路由路口连接。按照法律的规定， 在每个路口都设立了一个 Siruseri 银行的 ATM 取款机。<br>令人奇怪的是，Siruseri 的酒吧也都设在路口，虽然并不是每个路口都设有酒吧。<br>Banditji 计划实施 Siruseri 有史以来最惊天动地的 ATM 抢劫。他将从市中心出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆祝他的胜利。使用高超的黑客技术，他获知了每个 ATM 机中可以掠取的现金数额。<br>他希望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可以经过同一路口或道路任意多次。但只要他抢劫过某个ATM 机后，该ATM 机里面就不会再有钱了。</p><p><strong>解题思路</strong><br>对于一个强连通分量，我们只要经过它就可以将其中所有的钱都给取走，所以我们可以对强连通分量缩点，缩点后得到 DAG 。<br>对新图进行 SFPA 求从起点出发的单源最长路，然后再挑终点是酒吧的最长路即可。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,s,p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mon[N],w[N];</span><br><span class="line"><span class="keyword">bool</span> isBar[N],stop[N];</span><br><span class="line"><span class="keyword">int</span> dfn[N],clk,low[N],co[N],col;</span><br><span class="line"><span class="keyword">int</span> Stack[N],top;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line">Stack[++top] = x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y]) Tarjan(y),low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!co[y]) low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[x] == low[x])</span><br><span class="line"><span class="keyword">for</span>(++col;Stack[top+<span class="number">1</span>] != x;top--)&#123;</span><br><span class="line">co[Stack[top]] = col, w[col] += mon[Stack[top]];</span><br><span class="line">stop[col] |= isBar[Stack[top]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; edges[N];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N],vis[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">q.push(s); dis[s] = w[s];</span><br><span class="line"><span class="keyword">while</span>(q.size())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">vis[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(dis[y] &lt; dis[x] + w[y])&#123;</span><br><span class="line">dis[y] = dis[x] + w[y];</span><br><span class="line"><span class="keyword">if</span>(!vis[y]) q.push(y), vis[y] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>;x &lt;= n;x++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])</span><br><span class="line">edges[++cnt].first = co[x],edges[cnt].second = co[ver[i]];</span><br><span class="line">sort(edges+<span class="number">1</span>,edges+<span class="number">1</span>+cnt);</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head); tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x = edges[i].first, y = edges[i].second;</span><br><span class="line"><span class="keyword">int</span> xx = edges[i<span class="number">-1</span>].first, yy = edges[i<span class="number">-1</span>].second;</span><br><span class="line"><span class="keyword">if</span>(x != y &amp;&amp; (x != xx || y != yy)) addEdge(x,y);</span><br><span class="line">&#125;</span><br><span class="line">SPFA(co[s]);</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++) <span class="keyword">if</span>(stop[i]) ans = max(ans,dis[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y); addEdge(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,mon+i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;p);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= p;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x),isBar[x] = <span class="literal">true</span>;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="G-和平委员会-peace"><a href="#G-和平委员会-peace" class="headerlink" title="G.和平委员会(peace)"></a>G.和平委员会(peace)</h4><p><strong>题意描述</strong><br>原题来自：POI 2001</p><p>根据宪法，Byteland 民主共和国的公众和平委员会应该在国会中通过立法程序来创立。 不幸的是，由于某些党派代表之间的不和睦而使得这件事存在障碍。此委员会必须满足下列条件：</p><ul><li>每个党派都在委员会中恰有1个代表，如果2个代表彼此厌恶，则他们不能都属于委员会。</li><li>每个党在议会中有2个代表。代表从1编号到2n。 编号为 2i-1和 2i的代表属于第 i个党派。</li></ul><p>任务：写一程序读入党派的数量和关系不友好的代表对，计算决定建立和平委员会是否可能，若行，则列出委员会的成员表。</p><p><strong>解题思路</strong><br>这道题属于 2-SAT 问题，按照 2-SAT 问题的一般策略，对于两对党派(a, b) 、(x , y)，若 a 与 x 有矛盾，那么可以确定的是若 a 出席，则必定 y 出席，若 x 出席，则必定 b 出席。这对应着原命题与逆否命题，而其它命题虽然可能成立但并不能用“必须”修饰。<br>因此我们再利用 Tarjan 求强连通分量，即可解决2-SAT问题。</p><p>需要注意的是，边是有向的，也就是说添加的方向很重要，不可以随意添加。同时不能添加反向边，因为逆命题不一定成立。</p><p>由于 Tarjan 算法中不同连通块的颜色是按照拓扑排序来赋值的，也就是说颜色值越大的点越靠前（在拓扑排序中）；那么在本题中自然是优先选择同一个强连通分量的点，因此我们可以考虑优先输出颜色值大的点，这样我们就会按照拓扑排序的顺序挑选节点。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2</span>*<span class="number">8100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dfn[N],clk,co[N],col,low[N];</span><br><span class="line"><span class="keyword">int</span> Stack[N],top;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line">Stack[++top] = x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y]) Tarjan(y),low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!co[y]) low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[x] == low[x])</span><br><span class="line"><span class="keyword">for</span>(++col;Stack[top+<span class="number">1</span>] != x;top--)</span><br><span class="line">co[Stack[top]] = col;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i += <span class="number">2</span>) </span><br><span class="line"><span class="keyword">if</span>(co[i] == co[i+<span class="number">1</span>])&#123;<span class="built_in">puts</span>(<span class="string">"NIE"</span>); <span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i += <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span>(co[i] &lt; co[i+<span class="number">1</span>]) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i+<span class="number">1</span>);<span class="comment">//star</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m), n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">int</span> u = x%<span class="number">2</span> == <span class="number">0</span>?x<span class="number">-1</span>:x+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> v = y%<span class="number">2</span> == <span class="number">0</span>?y<span class="number">-1</span>:y+<span class="number">1</span>;</span><br><span class="line">addEdge(u,y); addEdge(v,x); <span class="comment">//star</span></span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强连通分量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树形动态规划题集</title>
      <link href="/2020/02/16/%E6%A0%91%E5%BD%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E9%9B%86/"/>
      <url>/2020/02/16/%E6%A0%91%E5%BD%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1579" target="_blank" rel="noopener">测试地址</a><br>部分题面可能复制有问题，图片没有复制，有疑惑见原题面。</p><h4 id="1575：【例-1】二叉苹果树"><a href="#1575：【例-1】二叉苹果树" class="headerlink" title="1575：【例 1】二叉苹果树"></a>1575：【例 1】二叉苹果树</h4><p><strong>问题描述</strong><br>有一棵二叉苹果树，如果数字有分叉，一定是分两叉，即没有只有一个儿子的节点。这棵树共 N 个节点，标号 1 至 N，树根编号一定为 1。</p><p>我们用一根树枝两端连接的节点编号描述一根树枝的位置。一棵有四根树枝的苹果树，因为树枝太多了，需要剪枝。但是一些树枝上长有苹果，给定需要保留的树枝数量，求最多能留住多少苹果。</p><p><strong>解题思路</strong><br>相当于从一棵二叉树上去掉一些子树，使得剩下 m 条边，目标是使得这 m 条边的总权值最大。剩 m 条边就相当于剩 m + 1 个点，我们转换成点来做。<br>设 f[i ,j] 表示节点 i 还剩 j 个点时最大总权值，目标状态是 f[1 , m+1] 。我们可以利用记忆化搜索，令 f[ i , j ] = MIN{ f[ ls , k] + f[rs , j - k -1] + w[ i ] }。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">440</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[M],nex[M],ver[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,f[N][N];</span><br><span class="line"><span class="keyword">int</span> ls[N],rs[N],w[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(ls[x]) rs[x] = y;</span><br><span class="line"><span class="keyword">else</span> ls[x] = y;</span><br><span class="line">w[y] = z;<span class="comment">//y 到其父亲的边权</span></span><br><span class="line">dfs(y,x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!ls[i] &amp;&amp; !rs[i]) <span class="keyword">return</span> w[i];</span><br><span class="line"><span class="keyword">if</span>(f[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> f[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= j<span class="number">-1</span>;k++)</span><br><span class="line">f[i][j] = max(f[i][j],DP(ls[i],k) + DP(rs[i],j-k<span class="number">-1</span>) + w[i]);</span><br><span class="line"><span class="keyword">return</span> f[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addEdge(x,y,z); addEdge(y,x,z);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,DP(<span class="number">1</span>,m+<span class="number">1</span>)); <span class="comment">//1号子树保留m+1个节点时最大值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1576：【例-2】选课"><a href="#1576：【例-2】选课" class="headerlink" title="1576：【例 2】选课 *"></a>1576：【例 2】选课 *</h4><p><strong>问题描述</strong><br>原题来自：CTSC 1997</p><p>大学实行学分制。每门课程都有一定的学分，学生只要选修了这门课并通过考核就能获得相应学分。学生最后的学分是他选修各门课的学分总和。</p><p>每个学生都要选择规定数量的课程。有些课程可以直接选修，有些课程需要一定的基础知识，必须在选了其他的一些课程基础上才能选修。例如《数据结构》必须在选修了《高级语言程序设计》后才能选修。我们称《高级语言程序设计》是《数据结构》的先修课。每门课的直接先修课最多只有一门。两门课也可能存在相同的先修课。为便于表述，每门课都有一个课号，课号依次为 1,2,3,⋯。</p><p>学生不可能学完大学开设的所有课程，因此必须在入学时选定自己要学的课程。每个学生可选课程的总数是给定的。请找出一种选课方案使得你能得到的学分最多，并满足先修课优先的原则。假定课程间不存在时间上的冲突。</p><p><strong>解题思路</strong><br>这题本质上是有树形依赖的分组背包问题。<br>首先用 0 号虚拟节点将森林合并为一棵树，注意 0 号节点不算一门课，没有学分也不消耗选课机会。<br>设 f[x , j] = 在以 x 为根的子树中选 j 门课能得到的最大学分。<br>那么显然 f[x , j] 就可以表示为“在以 x 为根的子树上选 j 门，在子树 y 上选 k 门”的最大值。即 f[x , j] = MAX{ f[x , j - k] + f[y , k]  }，因为用 x 的儿子对 f[x, j] 的更新无所谓先后顺序，所以上式可以成立。</p><p>除了 0 号节点以外， x 是必选的，所以回溯前要加上该门课的学分并消耗一次选课机会。<br><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">dfs(y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t = m;t &gt;= <span class="number">0</span>;t--)<span class="comment">//在子树 x 上选 t 门</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = t;j &gt;= <span class="number">0</span>;j--)<span class="comment">//在子树 y 选 j 门</span></span><br><span class="line">f[x][t] = max(f[x][t],f[x][t-j] + f[y][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x) <span class="keyword">for</span>(<span class="keyword">int</span> t = m;t &gt; <span class="number">0</span>;t--)<span class="comment">//如果不是 0 号节点,那么根节点是必选的</span></span><br><span class="line">f[x][t] = f[x][t<span class="number">-1</span>] + w[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f[<span class="number">0</span>][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,z;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;z); </span><br><span class="line">addEdge(x,i,z); w[i] = z;</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1577：【例-3】数字转换"><a href="#1577：【例-3】数字转换" class="headerlink" title="1577：【例 3】数字转换"></a>1577：【例 3】数字转换</h4><p><strong>问题描述</strong><br>如果一个数 x 的约数和 y （不包括他本身）比他本身小，那么 x 可以变成 y，y 也可以变成 x。例如 4 可以变为 3，1 可以变为 7。限定所有数字变换在不超过 n 的正整数范围内进行，求不断进行数字变换且不出现重复数字的最多变换步数。</p><p><strong>解题思路</strong><br>“约数和 y” 是指 x 的所有约数的累加的值是y。<br>从 1~n 挨个求出它们的约数和 y，然后由 y 向它们连线，最终构成一棵树。接下来就是求树上最长链问题，可以用两次 bfs 或者 dp 。</p><p><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getF</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>, i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">2</span>;i*i &lt; x;i++) <span class="keyword">if</span>(x%i == <span class="number">0</span>) res += i+x/i;</span><br><span class="line"><span class="keyword">if</span>(i*i == x) res += i;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,a[N];</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span> || y == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> leaf,mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(step &gt; mx) leaf = x,mx = step;</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">bfs(y,step+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x = getF(i);</span><br><span class="line"><span class="keyword">if</span>(x &gt; i) <span class="keyword">continue</span>;</span><br><span class="line">addEdge(x,i); addEdge(i,x);</span><br><span class="line">&#125;</span><br><span class="line">bfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">bfs(leaf,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1578：【例-4】战略游戏"><a href="#1578：【例-4】战略游戏" class="headerlink" title="1578：【例 4】战略游戏"></a>1578：【例 4】战略游戏</h4><p><strong>问题描述</strong><br>Bob 喜欢玩电脑游戏，特别是战略游戏。但是他经常无法找到快速玩过游戏的方法。现在他有个问题。</p><p>现在他有座古城堡，古城堡的路形成一棵树。他要在这棵树的节点上放置最少数目的士兵，使得这些士兵能够瞭望到所有的路。</p><p>注意：某个士兵在一个节点上时，与该节点相连的所有边都将能被瞭望到。</p><p>请你编一个程序，给定一棵树，帮 Bob 计算出他最少要放置的士兵数。</p><p><strong>解题思路</strong><br>这种题是“树的最大独立集”问题，也就是要求树上每一条边都至少有一个端点在集合内。这一类最值问题向来都是用动态规划解决的。<br>任何一个点的取舍都可以看作一个决策，而每个顶点为阶段，顶点取或不取为状态。设f[x , 0] = 第 x 个点不取时，以 x 为根的子树需要的最少士兵数目；f[ x,  1]表示取 x 点时，以 x 为根的子树需要的最少士兵数目。<br>如果 x 不取，那么它的所有子节点都一定要取；如果取 x，那么其字节点可取可不取。<br>所以状态转移方程为 $f[x , 0] = \sum f[y ,1]$，$f[x , 1] = \sum MIN(f[y , 0] , f[y ,1] ) + 1$</p><p><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,f[N][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>; f[x][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];~i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i]; </span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">dfs(y); </span><br><span class="line">f[x][<span class="number">0</span>] += f[y][<span class="number">1</span>];</span><br><span class="line">f[x][<span class="number">1</span>] += min(f[y][<span class="number">0</span>],f[y][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,k;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= k;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;y); </span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,min(f[<span class="number">1</span>][<span class="number">0</span>],f[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1579：-【例-5】皇宫看守"><a href="#1579：-【例-5】皇宫看守" class="headerlink" title="1579： 【例 5】皇宫看守 *"></a>1579： 【例 5】皇宫看守 *</h4><p><strong>问题描述</strong><br>太平王世子事件后，陆小凤成了皇上特聘的御前一品侍卫。</p><p>皇宫以午门为起点，直到后宫嫔妃们的寝宫，呈一棵树的形状，某些宫殿间可以互相望见。大内保卫森严，三步一岗，五步一哨，每个宫殿都要有人全天候看守，在不同的宫殿安排看守所需的费用不同。</p><p>可是陆小凤手上的经费不足，无论如何也没法在每个宫殿都安置留守侍卫。</p><p>帮助陆小凤布置侍卫，在看守全部宫殿的前提下，使得花费的经费最少。</p><p><strong>解题思路</strong><br>这题和上一题不同，上一次是每条边必须有一个端点被选，而这题是要求每个点的所有边中至少有一个边被选。换成点来说，就是与其相连的所有点（或其本身）中至少有一个被选。<br>那么我们就不能再“要么选 x ，要么选 x 的所有儿子”了；对于当前位置 x，我们可以分别从：</p><ul><li>x 的父亲被选了</li><li>x 的儿子有一个被选了</li><li>x 自己被选了</li></ul><p>三种情况来计算。我们设 f[x ,0|1|2 ]分别对应上述三种情况。对于当前节点 x ，我们既要考虑它的父亲，还要考虑它的儿子们，所以我们转移的时候既要加上它爹也要计算它儿子和孙子。具体状态设计和方程见代码吧，其中 d 是用来挑选一个费用最小的儿子。</p><p><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,w[N];</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>; f[x][<span class="number">2</span>] = w[x];</span><br><span class="line"><span class="keyword">int</span> d = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = w[x];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">dfs(y);</span><br><span class="line">f[x][<span class="number">0</span>] += min(f[y][<span class="number">1</span>],f[y][<span class="number">2</span>]);</span><br><span class="line">f[x][<span class="number">1</span>] += min(f[y][<span class="number">1</span>],f[y][<span class="number">2</span>]); </span><br><span class="line">f[x][<span class="number">2</span>] += min(f[y][<span class="number">0</span>],min(f[y][<span class="number">1</span>],f[y][<span class="number">2</span>]));</span><br><span class="line">d = min(d,f[y][<span class="number">2</span>] - min(f[y][<span class="number">1</span>],f[y][<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br><span class="line">f[x][<span class="number">1</span>] += d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,k,y;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x); <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;w[x],&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= k;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,min(f[<span class="number">1</span>][<span class="number">1</span>],f[<span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1580：加分二叉树"><a href="#1580：加分二叉树" class="headerlink" title="1580：加分二叉树"></a>1580：加分二叉树</h4><p><strong>题意描述</strong><br>原题来自：NOIP 2003</p><p>设一个 n 个节点的二叉树 tree 的中序遍历为 (1,2,3,⋯,n)，其中数字 1,2,3,⋯,n 为节点编号。每个节点都有一个分数（均为正整数），记第 i 个节点的分数为 di ，tree 及它的每个子树都有一个加分，任一棵子树 subtree（也包含 tree 本身）的加分计算方法如下：</p><p>记 subtree 的左子树加分为 l，右子树加分为 r，subtree 的根的分数为 a，则 subtree 的加分为：l×r+a</p><p>若某个子树为空，规定其加分为 1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。</p><p>试求一棵符合中序遍历为 (1,2,3,⋯,n) 且加分最高的二叉树 tree。</p><p>要求输出：</p><p>1、tree 的最高加分；</p><p>2、tree 的前序遍历。</p><p><strong>解题思路</strong><br>假设 f[i , j] 为中序遍历中 i 到 j 节点构成的子树最大得分是多少。那么显然就可以用类似区间 DP 的方法来解决，让跨度从小到大，起点也是从小到大，然后枚举中间节点即可。</p><p>但是输出前序遍历却不能直接用简洁的递归输出，而是需要加一行特判来处理边界情况。</p><p><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n,path[N][N];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll f[N][N],a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i == j || i+<span class="number">1</span> == j)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line"><span class="keyword">if</span>(i != j) <span class="built_in">printf</span>(<span class="string">"%d "</span>,j);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,path[i][j]);</span><br><span class="line">print(i,path[i][j]<span class="number">-1</span>); print(path[i][j]+<span class="number">1</span>,j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) f[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) path[i][i] = i,f[i][i] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>;l &lt;= n;l++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n-l;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = i+l;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i;k &lt;= j;k++)</span><br><span class="line"><span class="keyword">if</span>(f[i][j] &lt; f[i][k<span class="number">-1</span>]*f[k+<span class="number">1</span>][j] + a[k])&#123;</span><br><span class="line">f[i][j] = f[i][k<span class="number">-1</span>]*f[k+<span class="number">1</span>][j] + a[k];</span><br><span class="line">path[i][j] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[<span class="number">1</span>][n]);</span><br><span class="line">print(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1581：旅游规划"><a href="#1581：旅游规划" class="headerlink" title="1581：旅游规划"></a>1581：旅游规划</h4><p><strong>题意描述</strong><br>W 市的交通规划出现了重大问题，市政府下定决心在全市各大交通路口安排疏导员来疏导密集的车流。但由于人员不足，W 市市长决定只在最需要安排人员的路口安排人员。</p><p>具体来说，W 市的交通网络十分简单，由 n 个交叉路口和 n−1 条街道构成，交叉路口路口编号依次为 0,1,⋯,n−1 。任意一条街道连接两个交叉路口，且任意两个交叉路口间都存在一条路径互相连接。</p><p>经过长期调查，结果显示，如果一个交叉路口位于 W 市交通网最长路径上，那么这个路口必定拥挤不堪。所谓最长路径，定义为某条路径 p=(v1,v2,v3,⋯,vk)，路径经过的路口各不相同，且城市中不存在长度大于 k 的路径，因此最长路径可能不唯一。因此 Ｗ 市市长想知道哪些路口位于城市交通网的最长路径上。</p><p><strong>解题思路</strong><br>这道题就是求最长链上的节点，而最长链可能不止一条，所以就成了找出所有最长链上的所有节点，并按照升序输出。<br>我们知道两次 bfs 可以找到最长链的长度以及起点和终点，但是两次 bfs 却无法找到所有的最长链起点和终点。<br>我们可以通过 3 次 bfs 来找到所有的最长链以及其终点。首先通过第一遍 bfs 找到某一个叶子节点，然后第二次 bfs 找到所有以该叶子为起点的最长链，第三次 bfs 以其上次找到的某一条最长链的终点为起点，找到剩余的所有最长链。</p><p>由于树形结构上每一个节点都只有一个父亲，所以用 par 数组存放节点的父亲，这样就可以从终点找到该链上的所有节点。</p><p><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,par[N],leaf,mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(mx &lt; step)&#123;</span><br><span class="line">mx = step,leaf = x;</span><br><span class="line"><span class="keyword">while</span>(q.size()) q.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mx == step) q.push(x);</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">par[y] = x;</span><br><span class="line">bfs(y,step+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans[M], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">bfs(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//求最远叶子</span></span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">bfs(leaf,<span class="number">0</span>);<span class="comment">//从leaf出发的所有最远叶子</span></span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="built_in">memset</span>(par,<span class="number">0</span>,<span class="keyword">sizeof</span> par);</span><br><span class="line">bfs(leaf,<span class="number">0</span>);<span class="comment">//再求一边最远叶子,防止对称遗漏</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(q.size())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">ans[++cnt] = x;</span><br><span class="line"><span class="keyword">while</span>(par[x]) x = ans[++cnt] = par[x];</span><br><span class="line">&#125;</span><br><span class="line">sort(ans+<span class="number">1</span>,ans+<span class="number">1</span>+cnt);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++)</span><br><span class="line"><span class="keyword">if</span>(ans[i] != ans[i<span class="number">-1</span>]) <span class="built_in">cout</span> &lt;&lt; ans[i]<span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y); x++,y++;</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1582：周年纪念晚会"><a href="#1582：周年纪念晚会" class="headerlink" title="1582：周年纪念晚会"></a>1582：周年纪念晚会</h4><p><strong>题意描述</strong><br>Ural 州立大学的校长正在筹备学校的 8080 周年纪念聚会。由于学校的职员有不同的职务级别，可以构成一棵以校长为根的人事关系树。每个资源都有一个唯一的整数编号，从 1 到 N 编号，且对应一个参加聚会所获得的欢乐度。为使每个职员都感到快乐，校长设法使每个职员和其直接上司不会同时参加聚会。</p><p>你的任务是设计一份参加聚会者的名单，使总欢乐度最高。<br><strong>解题思路</strong><br>这题就是“没有上司的舞会”那一题，解法就相当于求森林中每棵树的最大点独立集，我们设 f[x ,0] 表示 x 不去时最大快乐值，f[x , 1] 表示 x 去时最大快乐值。<br>显然 x 要是不去那么 y 去或不去都可以，x 如果去那么所有的 y 都不能去，所以状态转移方程就很好想了，详见代码。</p><p><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> hp[N], n, x, y;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">2</span>],vis[N], ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">dfs(y);</span><br><span class="line">f[x][<span class="number">1</span>] = max(f[x][<span class="number">1</span>],f[y][<span class="number">0</span>]);</span><br><span class="line">f[x][<span class="number">0</span>] += max(f[y][<span class="number">0</span>],f[y][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">f[x][<span class="number">1</span>] += hp[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,hp+i);</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y) &amp;&amp; (x || y))&#123;</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">dfs(i); ans += max(f[i][<span class="number">1</span>],f[i][<span class="number">0</span>]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1583：叶子的染色"><a href="#1583：叶子的染色" class="headerlink" title="1583：叶子的染色"></a>1583：叶子的染色</h4><p><strong>题意描述</strong><br>原题来自：CQOI 2009</p><p>给一棵有 m 个节点的无根树，你可以选择一个度数大于 1 的节点作为根，然后给一些节点（根、内部节点、叶子均可）着以黑色或白色。你的着色方案应保证根节点到各叶子节点的简单路径上都包含一个有色节点，哪怕是叶子本身。</p><p>对于每个叶子节点 u，定义 cu 为从根节点到 u 的简单路径上最后一个有色节点的颜色。给出每个 cu  的值，设计着色方案使得着色节点的个数尽量少。</p><p><strong>解题思路</strong><br>题意非常绕，理解起来要花时间，另外题面描述的还丢三落四。<br>大意就是说有一棵树，我们要求从树根到每一个叶子节点的路径上的最后一个节点的颜色是指定的，我们给出所有指定的颜色 c[leaf] ；显然如果一棵子树的所有叶子节点都指定黑色，那么只需要给根节点染一个黑色就可以了（当然也可以给每个叶子节点都染黑色，但是不是最优解），我们题意就是求类似这样的最优解。</p><p>那么我们可以设 f[x , 0] 表示 x 染黑色时的最优解，f[x , 1] 表示 x 染白色时，以 x 为根的子树最少需要染几次色。</p><p>如果 x 是叶子节点，且要求染黑色，那么显然以 x 为根的子树最少需要染一次色，f[ x , 0] = 1，f[x , 1] = INF。</p><p>如果 x 不是叶子节点，那么显然 f[x, 0] += max{ f[y , 0] - 1 , f[y , 1] }，代表的实际含义是“如果 x 染黑色，那么就从 y 染黑色或 y 染白色中选一个最优解转移，显然如果 y 是黑色那么就可以少染一次（画图看）”</p><p><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x];head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,co[N],f[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>; f[x][<span class="number">0</span>] = f[x][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x &lt;= m) f[x][co[x]] = <span class="number">1</span>,f[x][co[x]^<span class="number">1</span>] = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; "--&gt;" &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">dfs(y);</span><br><span class="line">f[x][<span class="number">0</span>] += min(f[y][<span class="number">0</span>]<span class="number">-1</span>,f[y][<span class="number">1</span>]);</span><br><span class="line">f[x][<span class="number">1</span>] += min(f[y][<span class="number">1</span>]<span class="number">-1</span>,f[y][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">memset</span>(co,<span class="number">-1</span>,<span class="keyword">sizeof</span> co);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,co+i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">dfs(m+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; min(f[m+<span class="number">1</span>][<span class="number">0</span>],f[m+<span class="number">1</span>][<span class="number">1</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1584：骑士"><a href="#1584：骑士" class="headerlink" title="1584：骑士 **"></a>1584：骑士 **</h4><p><strong>题意描述</strong><br>原题来自：ZJOI 2008</p><p>Z 国的骑士团是一个很有势力的组织，帮会中聚集了来自各地的精英。他们劫富济贫，惩恶扬善，受到了社会各界的赞扬。</p><p>可是，最近发生了一件很可怕的事情：邪恶的 Y 国发起了一场针对 Z 国的侵略战争。战火绵延五百里，在和平环境中安逸了数百年的 Z 国又怎能抵挡得住 Y 国的军队。于是人们把所有希望都寄托在了骑士团身上，就像期待有一个真龙天子的降生，带领正义打败邪恶。</p><p>骑士团是肯定具备打败邪恶势力的能力的，但是骑士们互相之间往往有一些矛盾。每个骑士有且仅有一个他自己最厌恶的骑士（当然不是他自己），他是绝对不会与最厌恶的人一同出征的。</p><p>战火绵延，人们生灵涂炭，组织起一个骑士军团加入战斗刻不容缓！国王交给你了一个艰巨的任务：从所有骑士中选出一个骑士军团，使得军内没有矛盾的两人，即不存在一个骑士与他最痛恨的人一同被选入骑士团的情况，并且使这支骑士军团最富有战斗力。</p><p>为描述战斗力，我们将骑士按照 1 至 N 编号，给每位骑士估计一个战斗力，一个军团的战斗力为所有骑士的战斗力之和。</p><p><strong>解题思路</strong><br>本来看起来和“没有上司的舞会”很类似，但是这题会有环，有环的情况下如果还用原来的解法就有可能出错，所以需要处理一下。</p><p>解决这类问题的方法一般有两种，一种是基环树 DP，另一种是两次树形 DP。这里采用的是俩次树形 DP，首先用一次 dfs 找到当前子树的环上的一条边 edge，然后对这两条边的顶点为根分别做一次 DP，最终答案为 max( f[x, 0] , f[ y, 0] )，如果当前子树没有环（有重边），则正常 DP 即可，最终累加答案并输出。<br>这题对时限要求有点紧，在 bzoj 是可以过的，但是在一本通上过不了，在本校的 oj 也过不了。</p><p><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[N],f[N][<span class="number">2</span>] , ans = <span class="number">0</span>,mx;</span><br><span class="line"><span class="keyword">int</span> n,vis[N],edge ;</span><br><span class="line"><span class="keyword">int</span> Stack[N],top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>; Stack[++top] = x;</span><br><span class="line">f[x][<span class="number">1</span>] = a[x]; f[x][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">DP(y);</span><br><span class="line">f[x][<span class="number">0</span>] += max(f[y][<span class="number">0</span>],f[y][<span class="number">1</span>]);</span><br><span class="line">f[x][<span class="number">1</span>] += f[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> inStack[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;<span class="comment">//找到环上一边</span></span><br><span class="line">inStack[x] = <span class="literal">true</span>;<span class="comment">//正在遍历</span></span><br><span class="line"><span class="keyword">if</span>(edge) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(inStack[y]) edge = i;</span><br><span class="line"><span class="keyword">else</span> dfs(y,x);</span><br><span class="line">&#125;</span><br><span class="line">inStack[x] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span> + c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &gt; <span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,y;i &lt;= n;i++)&#123;</span><br><span class="line">a[i] = getInt(); y = getInt();</span><br><span class="line">addEdge(i,y); addEdge(y,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">top = edge = <span class="number">0</span>; dfs(i,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(!edge)&#123;</span><br><span class="line">DP(i); ans += max(f[i][<span class="number">0</span>],f[i][<span class="number">1</span>]);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">DP(ver[edge]); mx = f[ver[edge]][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">while</span>(top) vis[Stack[top--]] = <span class="literal">false</span>;</span><br><span class="line">DP(ver[edge^<span class="number">1</span>]); mx = max(f[ver[edge^<span class="number">1</span>]][<span class="number">0</span>],mx);</span><br><span class="line">ans += mx;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">print(ans);<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四边形不等式应用</title>
      <link href="/2020/02/16/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E5%BA%94%E7%94%A8/"/>
      <url>/2020/02/16/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="动态规划加速原理之四边形不等式"><a href="#动态规划加速原理之四边形不等式" class="headerlink" title="动态规划加速原理之四边形不等式"></a>动态规划加速原理之四边形不等式</h4><p>动态规划的四边形不等式优化是对特定形式的状态转移方程进行优化的一种方法，该方法可以将复杂度由 $O(n^3)$ 优化到 $O(n^2)$。</p><p>设我们有状态转移方程</p><script type="math/tex; mode=display">m(i ,j) =\left\{\begin{array}{rcl}min \{  m(i , k - 1) + m(k , j) + w(i , j) \} & & {i< j}\\0 & & i = j\\INF & & i > j\end{array} \right.</script><p><strong>w 满足区间包含的单调性：</strong><br>如果对于 i &lt;= i’ &lt; j &lt;= j’ 都有 w(i’ , j ) &lt;= w(i ,j’) ，那么称函数 w 满足关于区间包含的单调性。</p><p><strong>w 满足四边形不等式：</strong><br>如果对于 i &lt;= i’ &lt; j &lt;= j’ 都有 w(i , j ) + w(i’ , j’) &lt;= w(i ‘ , j ) + w( i , j’ )，我们称 w 满足四边形不等式。</p><p><strong>m 满足四边形不等式：</strong><br>如果 w 满足区间包含的单调性，同时又满足四边形不等式，那么 m 函数也满足四边形不等式。</p><p><strong>m 满足四边形不等式的应用：</strong><br>定义 s( i , j ) 为函数 m(i , j) 对应的决策变量的最大值。如果 m(i ,j) 满足四边形不等式，那么 s(i , j) 单调。<br>原状态转移方程可表示为：</p><script type="math/tex; mode=display">m(i ,j) = {  m(i , k - 1) + m(k , j) + w(i , j) }</script><p>其中 $s(i, j - 1) &lt;= k &lt;= s(i+1 , j)$ 。如此变将第三层枚举数量减少，时间复杂度优化到了 $O(n^2)$。</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><h5 id="例1：石子合并"><a href="#例1：石子合并" class="headerlink" title="例1：石子合并"></a>例1：石子合并</h5><p><strong>题意描述</strong><br>共 n 堆石子围成一圈，每次可以选定相邻两堆合并成一堆，得分为合并后的新堆的石子数量，请问将这 n 堆石子合并成一堆的最小值是多少？</p><h5 id="例2：HDU3480-Division"><a href="#例2：HDU3480-Division" class="headerlink" title="例2：HDU3480 Division"></a>例2：HDU3480 Division</h5><p><strong>题意简述</strong><br>给定 n 个元素，请将这 n 个元素分为 m 个集合，每个集合的得分为该集合内的（最大值-最小值）^2。请问最少得分是多少。</p><p><strong>解题思路</strong><br>因为我们可以任选元素放入子集，所以元素的顺序没有规定。我们将元素按照大小排序，这样选中连续的 k 个一定是所有大小为 k 的子集中得分最少的。可以通过反证法来证明，将这 k 个元素中的任一个替换都会使得得分增加。<br>可以用动态规划来解决，设 f[i ,j] 表示将前 j 个元素分为 j 个集合最少得分。那么 f[ i , j ] = min{ f[k , j-1] + w(k+1 , i) }，其中 w 为计算集合得分的函数，1 &lt;= k &lt; i。</p><p>这样做的时间复杂度为 O(N^3)，由于本题数据过大，因此会超时，可以考虑是否能用四边形不等式优化。</p><p><strong>判断是否能用四边形不等式优化</strong><br>假设 a &lt;= b &lt; c &lt;= d；由于序列是顺序排序，所以元素大小和下标成正比，因此用下标代替元素。</p><p>考虑 w( b , c) &lt; w(a , d)是否成立：显然由于元素是递增的，所以 $(d - a)^2 &gt; (c - b)^2$，即满足区间包含的单调性。<br>考虑w(a , c) + w(b , d) &lt;= w(a , d) + w(b , c)是否成立：<br>即 $(c-a)^2 + (d-b)^2 &lt;= (d-a)^2 + (c-b)^2$ 是否成立；<br>化简后即 $ac + bd &gt; ad + bc$ 是否成立；<br>即 b(d-c) &gt;= a(d-c) 是否成立；<br>由于 d &gt; c，b &gt; a，所以 上式成立，原式得证。</p><p>综上所述 w 函数既满足区间包含单调性又满足四边形不等式，所以可以用四边形不等式优化。</p><p><strong>利用 s 数组进行四边形不等式优化</strong></p><p>我们知道四边形不等式的优化主要在于减少了中间状态的枚举，我们设 s[i , j] 为 f[i ,j] 取最小值时的中间变量 k。<br>那么我们状态转移方程就可以变成 f[ i , j ] = min{ f[k , j-1] + w(k+1 , i) }，其中 s[i ,j-1] &lt;= k &lt; s[i+1 ,j] 。<br>初始化而言，f[i ,1] = w(i ,1)，即把前 i 个元素分为一个子集；s[i , 1] = 1，即前 i 个元素分为一个子集时起点为 1 。<br>因为集合的划分个数要从小到大，所以集合个数 j 就从 2 开始，放在最外层；第二层因为要用到 s[i+1 ,j] ，所以 i 要从后向前遍历更新；中间就是利用 s 数组进行四边形不等式优化了。</p><p>在用 s 数组替换原始范围时，一定要注意范围，尤其是边界范围是否一致，同时要注意 s 数组的加入是否会影响更新顺序。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ll;</span><br><span class="line">ll a[N],f[N][M];</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,m,s[N][M];</span><br><span class="line"><span class="function">ll <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">w</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a[r]-a[l])*(a[r]-a[l]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/* 计算并返回答案 */</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line"><span class="built_in">std</span>::sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) f[i][<span class="number">1</span>] = w(<span class="number">1</span>,i), s[i][<span class="number">1</span>] = <span class="number">1</span>,s[n+<span class="number">1</span>][i] = n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j &lt;= m;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= j;i--)&#123;</span><br><span class="line">f[i][j] = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = s[i][j<span class="number">-1</span>];k &lt;= s[i+<span class="number">1</span>][j];k++)</span><br><span class="line"><span class="keyword">if</span>(f[i][j] &gt;= f[k][j<span class="number">-1</span>] + w(k+<span class="number">1</span>,i))&#123;</span><br><span class="line">f[i][j] = f[k][j<span class="number">-1</span>] + w(k+<span class="number">1</span>,i);</span><br><span class="line">s[i][j] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> f[n][m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">1</span>;c &lt;= t;c++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,c,solve());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>动态规划加速原理之四边形不等式，赵爽</li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>割点和桥题集</title>
      <link href="/2020/02/16/%E5%89%B2%E7%82%B9%E5%92%8C%E6%A1%A5%E9%A2%98%E9%9B%86/"/>
      <url>/2020/02/16/%E5%89%B2%E7%82%B9%E5%92%8C%E6%A1%A5%E9%A2%98%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h4 id="分离的路径-rpaths"><a href="#分离的路径-rpaths" class="headerlink" title="分离的路径(rpaths)"></a>分离的路径(rpaths)</h4><p><strong>题意描述</strong><br>为了从 F个草场中的一个走到另一个，贝茜和她的同伴们不得不路过一些她们讨厌的可怕的树。<br>奶牛们已经厌倦了被迫走某一条路，所以她们想建一些新路，使每一对草场之间都会至少有两条相互分离的路径，这样她们就有多一些选择。<br>每对草场之间已经有至少一条路径，给出所有 R条双向路的描述，每条路连接了两个不同的草场，请计算最少的新建道路的数量。<br>路径由若干道路首尾相连而成，两条路径相互分离，是指两条路径没有一条重合的道路，但是两条分离的路径上可以有一些相同的草场。<br>对于同一对草场之间，可能已经有两条不同的道路，你也可以在它们之间再建一条道路，作为另一条不同的道路。</p><p><strong>解题思路</strong><br>本题就是希望能添加最少的边，使得原图变为边双连通图。<br>易得，在边双连通图中添加边是不会改变桥的数量的。所以我们可以先把边双连通分量缩点。缩点后的图只有点和桥，假设叶子节点的个数为 leaf 个，那么我们只需要添加 (leaf + 1) / 2 条边即可使其变为点双连通分量。（当然只有一个节点的图无需添加）</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dfn[N],clk,low[N],co[N],col;</span><br><span class="line"><span class="keyword">int</span> Stack[N],top,deg[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 对双连通分量进行染色、缩点 */</span></span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line">Stack[++top] = x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">Tarjan(y,i); </span><br><span class="line">low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="comment">//if(low[y] &gt; dfn[x]) bridge[i] = bridge[i^1] = true;</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>((i^<span class="number">1</span>) != e) low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[x] == low[x]) </span><br><span class="line"><span class="keyword">for</span>(++col;Stack[top+<span class="number">1</span>] != x;--top)</span><br><span class="line">co[Stack[top]] = col;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">Tarjan(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>;x &lt;= n;x++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i]; vis[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(!vis[i^<span class="number">1</span>] &amp;&amp; co[x] != co[y]) deg[co[x]]++,deg[co[y]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> leaf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++) <span class="keyword">if</span>(deg[i] == <span class="number">1</span>) leaf++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,leaf+<span class="number">1</span>&gt;&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y), addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="矿场搭建-mine"><a href="#矿场搭建-mine" class="headerlink" title="矿场搭建(mine)"></a>矿场搭建(mine)</h4><p><strong>题意描述</strong><br>煤矿工地可以看成是由隧道连接挖煤点组成的无向图。为安全起见，希望在工地发生事故时所有挖煤点的工人都能有一条出路逃到救援出口处。于是矿主决定在某些挖煤点设立救援出口，使得无论哪一个挖煤点坍塌之后，其他挖煤点的工人都有一条道路通向救援出口。<br>请写一个程序，用来计算至少需要设置几个救援出口，以及不同最少救援出口的设置方案总数。</p><p><strong>解题思路</strong><br>我们首先要画图来讨论不同情况下需要的出口个数，显而易见，出口个数是和割点相关的。</p><ul><li>如果原图是一个双连通分量，那么只需要添加 2 个出口，方案数按照组合原理共 sz * (sz-1) /2 种。</li><li>如果原图被 1 个割点分割成 2 个点双连通分量，那么每个双连通分量都需要一个出口，且这个出口不能放在割点上。</li><li>如果原图被 2 个割点分割成 3 个点双连通分量，那么中间的双连通分量（有两个割点的）不需要出口，其它两个点双连通分量只需要 1 个出口。出口不能放在割点上。</li><li>如果原图被多个割点分割成多个点双连通分量，与第三种情况类似。</li></ul><p>因此我们只需要统计出每个点双连通分量的节点数目（包括割点），以及每个点双连通分量中割点个数，即可统计出口数量以及方案数。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">550</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],vdcc,clk;</span><br><span class="line"><span class="keyword">int</span> Stack[N],top;</span><br><span class="line"><span class="keyword">bool</span> ct[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cuts[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line">Stack[++top] = x;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;<span class="comment">//用于统计子树个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">Tarjan(y,rt);</span><br><span class="line">low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">if</span>(low[y] &gt;= dfn[x])&#123;</span><br><span class="line"><span class="keyword">if</span>(++tot &gt; <span class="number">1</span> || x != rt) ct[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(++vdcc;Stack[top+<span class="number">1</span>] != y;top--)<span class="comment">//将 x 留在栈内</span></span><br><span class="line">cuts[vdcc].push_back(Stack[top]);</span><br><span class="line">cuts[vdcc].push_back(x);<span class="comment">//手动将 x 添加到连通分量中</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,st,ca = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = st;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i,i);</span><br><span class="line">ull ans1 = <span class="number">0</span>,ans2 = <span class="number">1</span>, sz, tot;</span><br><span class="line"><span class="keyword">if</span>(vdcc == <span class="number">1</span>)&#123;<span class="comment">//仅有一个连通分量，需要设置两个出口，方案数按组合原理计算</span></span><br><span class="line">sz = cuts[<span class="number">1</span>].size();</span><br><span class="line">ans1 = <span class="number">2</span>, ans2 = sz*(sz<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= vdcc;i++)&#123;</span><br><span class="line">tot = <span class="number">0</span>; sz = cuts[i].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; sz;j++) tot += ct[cuts[i][j]];<span class="comment">//统计割点个数</span></span><br><span class="line"><span class="keyword">if</span>(tot == <span class="number">1</span>) ++ ans1, ans2 *= sz<span class="number">-1</span>;<span class="comment">//只有一个割点时</span></span><br><span class="line"><span class="comment">//若有多个割点，那么该连通分量不需要设置出口，因为它可以去别的连通分量的出口</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: %llu %llu\n"</span>,ca,ans1,ans2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m) &amp;&amp; m != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; N;i++)</span><br><span class="line">head[i] = low[i] = dfn[i] = ct[i] = Stack[i] = <span class="number">0</span>,cuts[i].clear();</span><br><span class="line">tot = <span class="number">1</span>, top = vdcc = clk = <span class="number">0</span>; </span><br><span class="line">ca++; n = <span class="number">0</span>, st = N;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">n = max(n,max(x,y));</span><br><span class="line">st = min(st,min(x,y));</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="嗅探器-sniffer"><a href="#嗅探器-sniffer" class="headerlink" title="嗅探器(sniffer)"></a>嗅探器(sniffer)</h4><p><strong>题意描述</strong><br>某军搞信息对抗实战演习，红军成功地侵入了蓝军的内部网络，蓝军共有两个信息中心，红军计划在某台中间服务器上安装一个嗅探器，从而能够侦听到两个信息中心互相交换的所有信息，但是蓝军的网络相当的庞大，数据包从一个信息中心传到另一个信息中心可以不止有一条通路。<br>现在需要你尽快地解决这个问题，应该把嗅探器安装在哪个中间服务器上才能保证所有的数据包都能被捕获？</p><p><strong>解题思路</strong><br>在一个连通图中找到一个编号最小的节点，去掉该节点可以分隔 a 和 b 。那么这个节点肯定是割点，但是无向图中可能有多个割点，而且也不是每个割点都能分隔 a 和 b。所以这个割点必须在 a 和 b 之间，且能分隔 a 和 b。<br>利用 Tarjan 性质，如果我们以 a 为根开始执行，那么割点 y 必须满足dfn[y] &lt; dfn[b]（保证 y 在 b 前面，在 a 和 b 之间） 且 low[b] &gt;= dfn[a] （保证 a 和 b 中仅有一个割点）<br>由于题意要求是在某台中间服务器，所以还需要判断割点不能等于 a 或 b 。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x];head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],clk;</span><br><span class="line"><span class="keyword">int</span> ans = INF;</span><br><span class="line"><span class="keyword">int</span> n,a,b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="comment">// 标记出所有割点</span></span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">Tarjan(y,rt);</span><br><span class="line">low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">if</span>(low[y] &gt;= dfn[x])</span><br><span class="line"><span class="keyword">if</span>(dfn[y] &lt;= dfn[b] &amp;&amp; low[b] &gt;= dfn[a] &amp;&amp; x != a &amp;&amp; x != b)</span><br><span class="line">ans = min(ans,x);</span><br><span class="line">&#125;<span class="keyword">else</span> low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y) &amp;&amp; (x || y))</span><br><span class="line">addEdge(x,y), addEdge(y,x);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">Tarjan(a,a);</span><br><span class="line"><span class="keyword">if</span>(ans != INF) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No solution"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="旅游航道-route"><a href="#旅游航道-route" class="headerlink" title="旅游航道(route)"></a>旅游航道(route)</h4><p><strong>题意描述</strong><br>SGOI 旅游局在 SG-III 星团开设了旅游业务，每天有数以万计的地球人来这里观光，包括联合国秘书长，各国总统和 SGOI 总局局长等。<br>旅游线路四通八达，每天都有众多的载客太空飞船在星团的星球之间来往穿梭，他们保证了任意两个星球之间总是可以通过航道到达。但是，最近由于财政出现了困难，一些太空飞船也过于古老，又没有足够的资金购买新产品，所有只好取消一些航道。<br>如果某一条航道的删除使得一些星球不能到达，那么这条航道是不能删除的，称之为「主要航道」。<br>SGOI 旅游局局长希望知道主要航道的数目，但是航道较多，他不能手工计算，于是，他委托你写一个程序，计算主要航道数目。<br><strong>解题思路</strong><br>题意就是要求统计出桥的数量。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],clk;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">Tarjan(y,i);</span><br><span class="line">low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">if</span>(low[y] &gt; dfn[x]) ans++;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>((i^<span class="number">1</span>) != e) low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">Tarjan(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m) &amp;&amp; (n||m))&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) head[i] = dfn[i] = low[i] = <span class="number">0</span>;</span><br><span class="line">tot = <span class="number">1</span>; ans = clk = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="电力-power"><a href="#电力-power" class="headerlink" title="电力(power)"></a>电力(power)</h4><p><strong>题意描述</strong><br>求一个图删除一个点之后，联通块最多有多少。</p><p><strong>解题思路</strong><br>因为图不一定是连通的，所以我们要知道连通块的数量。如果图中存在割点，那么选择子树最多的那个割点删除，如果不存在割点，就优先删除某一个连通块中的一个节点，注意如果所有连通块都只有一个点，那么只能删掉一个连通块了。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],clk,vdcc;</span><br><span class="line"><span class="keyword">int</span> ct[N],Stack[N],top,num[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line">Stack[++top] = x;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">Tarjan(y,rt);</span><br><span class="line">low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">if</span>(low[y] &gt;= dfn[x])&#123;</span><br><span class="line"><span class="keyword">if</span>(++tot &gt; <span class="number">1</span> || x != rt) ct[x]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[x] == low[x])</span><br><span class="line"><span class="keyword">for</span>(++vdcc;Stack[top+<span class="number">1</span>] != x;top--)</span><br><span class="line">num[vdcc]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i,i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) ans = max(ct[i],ans);</span><br><span class="line"><span class="keyword">if</span>(ans)&#123; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans+vdcc); <span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= vdcc;i++) </span><br><span class="line"><span class="keyword">if</span>(num[i] &gt; <span class="number">1</span>)&#123;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,vdcc); <span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,vdcc<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m) &amp;&amp; (n||m))&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">num[i] = ct[i] = head[i] = dfn[i] = low[i] = <span class="number">0</span>;</span><br><span class="line">vdcc = clk = <span class="number">0</span>; tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y); x++,y++;</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Blockade"><a href="#Blockade" class="headerlink" title="Blockade"></a>Blockade</h4><p><strong>题意描述</strong><br>Byteotia 城市有 n个城镇，m条双向道路。每条道路连接两个不同的城镇，没有重复的道路，所有城镇连通。输出 n个数，代表如果把第 i个点去掉，将有多少对点不能互通。</p><p><strong>解题思路</strong><br>首先要用long long，中间变量也要用。<br>对于一个节点 x，如果删除它，那么：</p><ul><li>u 和其它所有节点不连通，且其它所有节点到 u 也不连通；</li><li>它的子树上的节点（不包括 u ）和其它所有节点不连通；</li><li>所有非 u 子树上的节点和 u 子树上的点不连通。</li></ul><p>只需要把上述分类情况累加起来即可得到答案，本题难点在于分类，要做到不遗漏、不重叠。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll ans[N];</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],clk;</span><br><span class="line"><span class="keyword">int</span> tmp[N],sz[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>; sz[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">Tarjan(y,rt);</span><br><span class="line">sz[x] += sz[y];</span><br><span class="line">low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">if</span>(low[y] &gt;= dfn[x])</span><br><span class="line"><span class="keyword">if</span>(++cnt &gt; <span class="number">1</span> || x != rt)&#123;</span><br><span class="line">ans[x] += (ll)(n-sz[y]<span class="number">-1</span>)*sz[y];</span><br><span class="line">tmp[x] += sz[y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line">ans[x] += (ll)tmp[x]*(n-tmp[x]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i,i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[i] + (n<span class="number">-1</span>)*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 割点和桥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无向图的割点和桥</title>
      <link href="/2020/02/16/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%89%B2%E7%82%B9%E5%92%8C%E6%A1%A5/"/>
      <url>/2020/02/16/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%89%B2%E7%82%B9%E5%92%8C%E6%A1%A5/</url>
      
        <content type="html"><![CDATA[<p>两个割点之间的边不一定是割边，割边的两个端点不一定是割点。<br>边双连通分量一定是点双连通分量，点双连通分量不一定是边双连通分量。</p><h4 id="Tarjan算法求割点"><a href="#Tarjan算法求割点" class="headerlink" title="Tarjan算法求割点"></a>Tarjan算法求割点</h4><p><strong>判定条件</strong><br>一个顶点 u 是割点，当且仅当满足以下两个条件之一：</p><ul><li>u 为树根，且 u 有多于一个子树。因为如果只有一棵子树，去掉树根节点后肯定不会出现多颗子树，因此不可能为割点；而无向图 DFS 搜索树中不存在横叉边（从某一个节点指向搜索树中另一子树中某节点的边），所以若有多颗子树，这些子树间不会有边相连，因此 u 肯定是割点。</li><li>u 不为树根，且满足存在（u，v）为树枝边（即 u 为 v 在搜素树中的父亲），并使得 dfn[u] &lt;= low[v] 。因为删去 u 后 v 以及 v 的子树都不能到达 u 的祖先。</li></ul><p><strong>代码实现</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line">Stack[++top] = x;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;<span class="comment">//用于统计子树个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">Tarjan(y,rt);</span><br><span class="line">low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">if</span>(low[y] &gt;= dfn[x])&#123;</span><br><span class="line"><span class="keyword">if</span>(++tot &gt; <span class="number">1</span> || x != rt) ct[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(++vdcc;Stack[top+<span class="number">1</span>] != y;top--)<span class="comment">//将 x 留在栈内</span></span><br><span class="line">cuts[vdcc].push_back(Stack[top]);</span><br><span class="line">cuts[vdcc].push_back(x);<span class="comment">//手动将 x 添加到连通分量中</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Tarjan算法求割边"><a href="#Tarjan算法求割边" class="headerlink" title="Tarjan算法求割边"></a>Tarjan算法求割边</h4><p><strong>判断桥</strong><br>一条无向边（u，v）是桥，当且仅当（u，v）为树枝边，且满足 dfn[u] &lt; low[v] 。因为 v 要想到达 u 的父亲必须经过（u，v）这条边，所以删去这条边后图不连通。</p><p><strong>代码实现</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++clk;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">Tarjan(y,i); </span><br><span class="line">low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">if</span>(low[y] &gt; dfn[x]) bridge[i] = bridge[i^<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>((i^<span class="number">1</span>) != e) low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="求双连通分量"><a href="#求双连通分量" class="headerlink" title="求双连通分量"></a>求双连通分量</h4><p>对于<strong>点双连通分量</strong>，在求割点的过程中就可以顺便求出。利用栈来存储当且双连通分量，当每遇到一个割点时就从栈中将当前的双连通分量弹出，可以染色（不能染割点）或放入 vector 数组中（可以包括割点）。需要注意一个割点可能属于多个双连通分量，因此割点不应弹出栈。代码同‘Tarjan算法求割点’。</p><p>对于<strong>边双连通分量</strong>，求法更为简单。只需要在求出所有的桥后，把桥边删除，原图就变成了多个连通块，每个连通块就是一个边双连通分量。桥不属于任何一个边双连通分量，其余的边和每个顶点都属于且只属于一个边双连通分量，可以用并查集实现。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>对于 Tarjan 算法，我们不仅仅要会利用其求强连通分量、割点或桥，还要明白其原理，对其做灵活的变化以使用更多的题型。例如 dfn 记录的是节点的时间戳，而 low 记录节点以或子树，以及和它们相邻的所有节点的最小时间戳；那么通过对比 dfn 值可以得知两个节点在搜索树中的位置关系，通过比对 low 值可以得知搜索树是否可以到达父亲节点等。</p><p>同时还需要注意 Tarjan 算法求割点的时候，对于树根节点，我们只有第二次得知其有双连通分量子树时才标记树根为割点，但实际上此时其属于两个双连通分量的割点，所以如果要保存双连通分量中的节点时要做些改变。对于一些同树根有关系的题目也要额外注意。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>董永建，信息学竞赛一本通提高篇，福州：福建教育出版社，2018.6，179-183</li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 割点和桥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间类动态规划题集</title>
      <link href="/2020/02/16/%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E9%9B%86/"/>
      <url>/2020/02/16/%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1574" target="_blank" rel="noopener">测试地址</a><br>本文题面皆是复制网页，如果有格式问题参考原题面。</p><h4 id="1569：【-例-1】石子合并"><a href="#1569：【-例-1】石子合并" class="headerlink" title="1569：【 例 1】石子合并"></a>1569：【 例 1】石子合并</h4><p><strong>题意描述</strong><br>将 n 堆石子绕圆形操场排放，现要将石子有序地合并成一堆。规定每次只能选相邻的两堆合并成新的一堆，并将新的一堆的石子数记做该次合并的得分。<br>请编写一个程序，读入堆数 n 及每堆的石子数，并进行如下计算：</p><p>1、选择一种合并石子的方案，使得做 n−1 次合并得分总和最大。</p><p>2、选择一种合并石子的方案，使得做 n−1 次合并得分总和最小。</p><p><strong>解题思路</strong><br>算是典型例题吧，环形上的 DP ，可以拆分成一维区间类的 DP ，具体做法是拼接两倍的区间长度，然后在这长度为 2n 的区间上进行动态规划。<br>具体到这题，可以采用‘跨度+起点+中转点’三层循环来解决。由于起点最多只能到n，跨度最多只能到 n-1 ，设 f[ i ，j ] = 将第 i 堆到 j 堆合并的最大得分，那么初始状态f[i ,i] = 0，目标状态为 MAX{ f[i ,i+n-1] }。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">440</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],sum[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N],g[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n&lt;&lt;<span class="number">1</span>;i++) g[i][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i+n] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n&lt;&lt;<span class="number">1</span>;i++) sum[i] = sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>;len &lt; n;len++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span>*n-len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = i+len;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i;k &lt; j;k++)&#123;</span><br><span class="line">f[i][j] = max(f[i][j],f[i][k]+f[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">g[i][j] = min(g[i][j],g[i][k]+g[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span>,mi = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">mx = max(mx,f[i][i+n<span class="number">-1</span>]),mi = min(g[i][i+n<span class="number">-1</span>],mi);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>,mi,mx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1570：【例-2】能量项链"><a href="#1570：【例-2】能量项链" class="headerlink" title="1570：【例 2】能量项链"></a>1570：【例 2】能量项链</h4><p><strong>题意描述</strong><br>原题来自：NOIP 2006</p><p>在 Mars 星球上，每个 Mars 人都随身佩带着一串能量项链。在项链上有 N 颗能量珠。能量珠是一颗有头标记和尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记必定等于后一颗珠子的头标记。因为只有这样，通过吸盘——Mars 人吸收能量的器官的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可被吸盘吸收的能量。如果一颗能量珠头标记为 m，尾标记为 r，后一颗能量珠头标记为 r，尾标记为 n，则聚合后释放出 m×r×n Mars单位的能量，新珠子头标记为 m，尾标记为 n。</p><p>当需要时，Mars 人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不一样的。请设计一个聚合顺序使得一串珠子聚合后释放出的总能量最大。</p><p>例如，设 N=4，四颗珠子头标记与尾标记分别为 (2,3),(3,5),(5,10),(10,2)。我们用记号 ⨂ 表示两颗珠子的聚合操作，(j⨂k) 表示 j,k 两颗珠子聚合后释放出的能量，则4,1两颗珠子聚合后所释放的能量为(4⨂1)=10×2×3=60，这一串项链可以得到最优值的一个聚合顺序所释放出的总能量为(((4⨂1)⨂2)⨂3)=10×2×3+10×3×5+10×5×10=710<br>现在给你一串项链，项链上有 n 颗珠子，相邻两颗珠子可以合并成一个，合并同时会放出一定的能量，不同珠子合并放出能量不相同，请问按怎样的次序合并才能使得释放的能量最多？</p><p><strong>解题思路</strong><br>解决思路和状态设计和上一题类似，唯一不同的地方在于本题最终一棵珠子也要首尾合并，等同于起点被计算了两次，所以跨度就可以达到 n 而非 n-1 ，其它完全等同于上一题。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (ll)a[i]*a[j]*a[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span>*n<span class="number">-2</span>;i++) f[i][i+<span class="number">2</span>] = Mul(i,i+<span class="number">1</span>,i+<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>;l &lt;= n;l++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span>*n-l;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = i+l;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i+<span class="number">1</span>;k &lt; j;k++)</span><br><span class="line">f[i][j] = max(f[i][j],f[i][k]+f[k][j]+Mul(i,j,k));</span><br><span class="line">&#125;</span><br><span class="line">ll mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) mx = max(mx,f[i][i+n]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,mx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i+n] = a[i];</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1571：【例-3】凸多边形的划分"><a href="#1571：【例-3】凸多边形的划分" class="headerlink" title="1571：【例 3】凸多边形的划分"></a>1571：【例 3】凸多边形的划分</h4><p><strong>题意描述</strong><br>给定一个具有 N 个顶点的凸多边形，将顶点从 1 至 N 标号，每个顶点的权值都是一个正整数。将这个凸多边形划分成 N−2 个互不相交的三角形，试求这些三角形顶点的权值乘积和至少为多少。</p><p><strong>解题思路</strong><br>首先要注意 1e9 <em> 1e9 </em> 1e9 = 1e27，爆longlong，我用了__int128，但不是所有 oj 都支持 int128 的，如果不支持还是要用高精度或 java 等方法。</p><p>将凸多边形拆分成一条链，并复制一份拼接在后面，我们就在这 2n 区间上 DP。<br>设 f[i ,j] = 从点 i 到 j 所构成的凸多边形中，割成三角形最少得分。<br>那么初始状态 f[i ,i+1] = 0，其它都是 INF（根据转移方程反推出来的！！！）<br>目标状态就是 f[i, i+n-1]。<br>状态转移方程就是 f[i ,j] = max{ f[i ,k] + f[k ,j] + Mul(i, j, k) }，其中 k 为 i 到 j 之间的点，Mul() 计算三个点的乘积。<br>也就是枚举三角形的顶点而已，把图形化为区间就容易想多了，不要老想着三角形。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int128 ll;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e30</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a[N],f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span> </span>&#123; <span class="keyword">return</span> a[i]*a[j]*a[k]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &gt; <span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n&lt;&lt;<span class="number">1</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n&lt;&lt;<span class="number">1</span>;j++) f[i][j] = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n&lt;&lt;<span class="number">1</span>;i++) f[i][i+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>;l &lt; n;l++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">2</span>*n-l;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = i+l;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i+<span class="number">1</span>;k &lt; j;k++)</span><br><span class="line">f[i][j] = min(f[i][j],f[i][k]+f[k][j]+Mul(i,j,k));</span><br><span class="line">&#125;</span><br><span class="line">ll mi = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) mi = min(mi,f[i][i+n<span class="number">-1</span>]);</span><br><span class="line">print(mi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,a+i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i+n] = a[i];</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1572：括号配对"><a href="#1572：括号配对" class="headerlink" title="1572：括号配对"></a>1572：括号配对</h4><p><strong>题意描述</strong><br>Hecy 又接了个新任务：BE 处理。BE 中有一类被称为 GBE。</p><p>以下是 GBE 的定义：</p><p>空表达式是 GBE<br>如果表达式 A 是 GBE，则 [A] 与 (A) 都是 GBE<br>如果 A 与 B 都是 GBE，那么 AB 是 GBE。</p><p><strong>解题思路</strong><br>设 f[i ,j] = 序列 i 到 j 需要补充多少括号；<br>初始值 f[i ,i] = 1；<br>目标为 f[1 , n]；<br>转移方程为 f[i, j] = f[i, k] + f[k+1 ,j]，k 为 i 和 j 中间位置；如果 s[i] == s[j] 那么 f[i , j] = f[i-1 , j-1]。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i] == <span class="string">'('</span> &amp;&amp; str[j] == <span class="string">')'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(str[i] == <span class="string">'['</span> &amp;&amp; str[j] == <span class="string">']'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>); str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(str) - <span class="number">1</span>;<span class="comment">// strlen()为字符个数+1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) f[i][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>;l &lt; n;l++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n-l;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = i+l; f[i][j] = INF;<span class="comment">//必须在这赋值 , 否则覆盖了f[2][1] = 0.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i;k &lt; j;k++)&#123;</span><br><span class="line">f[i][j] = min(f[i][j],f[i][k]+f[k+<span class="number">1</span>][j]);</span><br><span class="line"><span class="keyword">if</span>(check(i,j)) f[i][j] = min(f[i][j],f[i+<span class="number">1</span>][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[<span class="number">1</span>][n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1573：分离与合体"><a href="#1573：分离与合体" class="headerlink" title="1573：分离与合体"></a>1573：分离与合体</h4><p><strong>题意描述</strong><br>经过在机房里数日的切磋，LYD 从杜神牛那里学会了分离与合体，出关前，杜神牛给了他一个测试……</p><p>杜神牛造了 n 个区域，他们紧邻着排成一行，编号 1..n。在每个区域里都放着一把 OI 界的金钥匙，每一把都有一定的价值，LYD 当然想得到他们了。然而杜神牛规定 LYD 不能一下子把他们全部拿走，而是每次只可以拿一把。为了尽快得到所有金钥匙，LYD 自然就用上了刚学的分离与合体特技。</p><p>一开始 LYD 可以选择 1..n−1 中的任何一个区域进入，我们不妨把这个区域记为 k。进入后 LYD 会在 k 区域发生分离，从而分离成两个小 LYD。分离完成的同时会有一面墙在 k 区域和 k+1 区域间升起，从而把 1..k 和 k+1..n 阻断成两个独立的区间，并在各自区间内任选除区间末尾之外（即从 1..k−1 和 k+1..n−1中选取）的任意一个区域再次发生分离，这样就有了四个小小 LYD……重复以上所叙述的分离，直到每个小 LYD 发现自己所在的区间只剩下了一个区域，那么他们就可以抱起自己梦寐以求的 OI 金钥匙。</p><p>但是 LYD 不能就分成这么多个个体存在于世界上，这些小 LYD 还会再合体，合体的小 LYD 所在区间中间的墙会消失。合体会获得 ((合并后所在区间左右端区域里金钥匙价值之和)×(之前分离的时候所在区域的金钥匙价值))。</p><p>例如，LYD 曾在 1..3 区间中的 2 号区域分离成为 1..2 和 3..3 两个区间，合并时获得的价值就是 (( 1 号金钥匙价值 +3 号金钥匙价值)×( 2 号金钥匙价值))。</p><p>LYD 请你编程求出最终可以获得的最大总价值，并按照分离阶段从前到后，区域从左到右的顺序，输出发生分离区域编号。若有多种方案，选择分离区域尽量靠左的方案（也可以理解为输出字典序最小的）。</p><p>例如先打印一分为二的区域，然后从左到右打印二分为四的分离区域，然后是四分为八的……</p><p><strong>解题思路</strong><br>题意理解耗时间。<br>大意就是选取区间一点区间划分为左右部分，合并时得分为划分前（左端点+右端点） * 选取点的权值。<br>我们还是按照老办法，用跨度来 DP 就可以得到最大得分。<br>关于路径输出，因为本题中区间划分是同时进行的，就是说如果存在多段区间都可划分，那么它们是可以同时划分的，而题意又要求按照划分的先后和区域的左右输出，也就是说要先判断该节点是属于第几次划分的，由于我们 path 数组存放了区间的划分点，那么我们不断递归，递归树第 k 层就对应着第 k 次划分，而左右顺序取决于我们的递归顺序；因此我们可以通过传入变量 step 代表当前递归树的层数，num 代表当前要输出的是第几步划分出的区域，当 step = num 就说明满足条件。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">330</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[N],n,f[N][N];</span><br><span class="line"><span class="keyword">int</span> path[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> step,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt;= j) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(step == num) <span class="built_in">printf</span>(<span class="string">"%d "</span>,path[i][j]);</span><br><span class="line">print(i,path[i][j],step+<span class="number">1</span>,num); print(path[i][j]+<span class="number">1</span>,j,step+<span class="number">1</span>,num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>;l &lt; n;l++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n-l;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = i+l;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i;k &lt; j;k++)</span><br><span class="line"><span class="keyword">if</span>(f[i][j] &lt; f[i][k] + f[k+<span class="number">1</span>][j] + (a[i]+a[j])*a[k])&#123;</span><br><span class="line">f[i][j] = f[i][k] + f[k+<span class="number">1</span>][j] + (a[i]+a[j])*a[k];</span><br><span class="line">path[i][j] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll mx = f[<span class="number">1</span>][n];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,mx);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) print(<span class="number">1</span>,n,<span class="number">1</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1574：矩阵取数游戏"><a href="#1574：矩阵取数游戏" class="headerlink" title="1574：矩阵取数游戏"></a>1574：矩阵取数游戏</h4><p><strong>题意描述</strong><br>原题来自：NOIP 2007</p><p>帅帅经常和同学玩一个矩阵取数游戏：对于给定的 n×m 的矩阵，矩阵中每个元素 aij 均为非负整数。游戏规则如下：</p><p>1、每次取数时必须从每行各取走一个元素，共 n 个，m 次取完所有元素。</p><p>2、每次取走的各个元素只能是该元素所在行行首或行尾。</p><p>3、每次取数都有一个的分值，为每行取数得分之和，每行取数得分==被取走元素值×2i ，其中 i 表示第 i 次取数，从 1 开始计数。</p><p>4、游戏结束时，总得分为 m 次取数得分之和。</p><p>帅帅想让你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。<br><strong>解题思路</strong><br>要用大整数，或者int128.<br>注意，1&lt;&lt;40 是不行的！！！要对数字 1 强制类型转换！！！<br>由于每行可以单独计算，最后再累加，因此我们设 f[i ,j] = 当前行中从 i 到 j 的最大得分。<br>状态转移方程看代码。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int128 ll;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line">ll f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &gt; <span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = m;j &gt;= i;j--)&#123;</span><br><span class="line">ll b = (ll)<span class="number">1</span>&lt;&lt;(m-j+i<span class="number">-1</span>);</span><br><span class="line">f[i][j] = max(f[i<span class="number">-1</span>][j] + (ll)a[i<span class="number">-1</span>]*b,f[i][j+<span class="number">1</span>] + (ll)a[j+<span class="number">1</span>]*b);</span><br><span class="line">&#125;</span><br><span class="line">ll mx = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) mx = max(mx,f[i][i] + (ll)a[i]*((ll)<span class="number">1</span>&lt;&lt;m));</span><br><span class="line"><span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">ans += solve();</span><br><span class="line">&#125;</span><br><span class="line">print(ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长链剖分</title>
      <link href="/2020/02/16/dsu/"/>
      <url>/2020/02/16/dsu/</url>
      
        <content type="html"><![CDATA[<h4 id="长链剖分"><a href="#长链剖分" class="headerlink" title="长链剖分"></a>长链剖分</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>长链剖分属于树链剖分的一种，可以把维护子树中只与深度有关的信息做到线性时间。</p><p>一般的树链剖分是指剖分轻重链，其依据子节点的个数进行剖分，可以使得我们可以在任意一个点向上跳跃不超过 log 次就能到达根节点，从而可以高效维护两点之间的链的信息。</p><p>而长链剖分则是依据子树的深度进行剖分，深度最大的作为重儿子，这样原树就可以被分成若干条互不重复的链，并且保证了重链尽量长。因此长链剖分可以维护树中和深度有关的信息。</p><h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><p>在长链剖分中，我们常用如下几个数组：</p><blockquote><p>par[x] : x 在树中的父亲。<br>deep[x]：x 在树中的深度。<br>len[x]：x 为根的子树最大深度。<br>son[x]：x 的重儿子，即u-&gt;son[u]为重边。<br>top[x]：x 所在重路径的顶部节点（深度最小）。</p></blockquote><p>这些数组可以通过一次 dfs 来更新。通过定义可知，如果 top[x] = x，那么 x 就是一条长（重）链的起点，此时 len[x] 就是该链的长度（节点数目）。</p><p>更新代码可以这样来写：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line">dfs(ver[i]);</span><br><span class="line"><span class="keyword">if</span>(len[son[x]] &lt; len[ver[i]]) son[x] = ver[i];</span><br><span class="line">&#125;</span><br><span class="line">len[x] = len[son[x]]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;<span class="comment">//也可以不更新top数组，在此直接压入q1</span></span><br><span class="line"><span class="keyword">if</span>(ver[i] == son[x]) top[son[x]] = top[x];</span><br><span class="line"><span class="keyword">else</span> top[ver[i]] = ver[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码是基于邻接表存储‘单向边构成的有根树’，如果是无根树则需加个标记位来防止重复访问。</p><h5 id="长链剖分的性质"><a href="#长链剖分的性质" class="headerlink" title="长链剖分的性质"></a>长链剖分的性质</h5><p><strong>性质一：</strong> 所有的链的长度之和是 O（N）级别</p><blockquote><p>证明：所有点在且仅在一条长（重）链之中，永远只会被计算一次，所以总长度与 N 成正比</p></blockquote><p><strong>性质二：</strong> 从任意一个点向上跳跃的次数最多 $\sqrt N$ 次。</p><blockquote><p>证明：按照定义，节点 y 的父亲 x 所在的重链的长度一定是不小于 y 所在的重链的，我们知道所有重链的长度之和是 O(N)级别，所以最坏情况就是 1+2+3+…+$\sqrt n$<br>，所以最多跳 $\sqrt N$次</p></blockquote><h4 id="例题应用"><a href="#例题应用" class="headerlink" title="例题应用"></a>例题应用</h4><h5 id="BAPC2019-A-Appeal-to-the-Audience"><a href="#BAPC2019-A-Appeal-to-the-Audience" class="headerlink" title="BAPC2019 A.Appeal to the Audience"></a>BAPC2019 A.Appeal to the Audience</h5><p><strong>题意简述</strong><br>给定一棵有 k 个叶子节点的二叉树，所有非叶子节点的值等于其左右儿子的最大值，现在给定 k 个整数，求把它们分配在 k 个叶子上，使得整颗树的总权值最大（总权值 = 除根节点外所有节点的权值和）</p><p><strong>解题思路</strong><br>要想使得总和最大，就要使最大值被计算的次数最多。要想某个数被计算的多，就要使得它经过尽量多的节点。于是我们的目标就是找到 k 条从长到短的链，这些链互不重合，且一端是叶子节点。</p><p>可以通过长链剖分来将这棵树分为 k 条互不相交的长链，然后按照长度分配元素（长度越大，分配给它的元素值越大）。</p><p><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">/* 邻接表代码 */</span></span><br><span class="line"><span class="keyword">int</span> head[N],nex[M],ver[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 快读代码 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &gt; <span class="string">'9'</span> || c &lt; <span class="string">'0'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len[N],son[N],top[N];</span><br><span class="line"><span class="comment">//依次为当前子树最大深度、重儿子编号、当前链顶节点编号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line">dfs(ver[i]);</span><br><span class="line"><span class="keyword">if</span>(len[son[x]] &lt; len[ver[i]]) son[x] = ver[i];</span><br><span class="line">&#125;</span><br><span class="line">len[x] = len[son[x]]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;<span class="comment">//也可以不更新top数组，在此直接压入q1</span></span><br><span class="line"><span class="keyword">if</span>(ver[i] == son[x]) top[son[x]] = top[x];</span><br><span class="line"><span class="keyword">else</span> top[ver[i]] = ver[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,k,a[N];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line">priority_queue&lt;ll&gt; q1,q2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">top[<span class="number">1</span>] = <span class="number">1</span>; dfs(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) </span><br><span class="line"><span class="keyword">if</span>(top[i] == i) q1.push(len[i]);</span><br><span class="line">q1.push(len[<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span>(q1.size())&#123;</span><br><span class="line">ans += <span class="number">1l</span>l * q1.top() * q2.top();</span><br><span class="line">q1.pop(); q2.pop();</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = getInt(); k = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= k;i++) x = getInt(),q2.push(x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,y;i &lt;= n;i++) y = getInt(), addEdge(y+<span class="number">1</span>,i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Dominant-Indices"><a href="#Dominant-Indices" class="headerlink" title="Dominant Indices"></a>Dominant Indices</h5><p><a href="http://codeforces.com/problemset/problem/1009/F" target="_blank" rel="noopener">测试地址</a></p><p><strong>题意简述</strong><br>给定一颗编号为 1~n 的有根树，根节点编号为 1 。设 $d_{x,i}$ 表示以 x 为根的子树中，距 x 为 i 的节点的数目。求出对于每个节点 x，使 $d_{x,i}$ 最大的 i ，若有多种可能，则输出最小的 i。</p><p><strong>解题思路</strong><br>这道题刚开始以为就是 dfs，但是 dfs 中转移的时间太高了。看题解是用指针数组（* f[N]）来实现 O(1) 时间复杂度内转移的，其效率是由指针的赋值很快保证的，其正确性是由 f[x] = f[son[x] ] + 1 来保证的，即</p><blockquote><p>若 tmp[x, j] 表示距离 x 为 j 的节点数目，那么显然tmp[x, j] = tmp[son[x] , j-1]，其中 1 &lt;= j &lt;= n， 所以直接将 tmp[son[x] ] + 1 赋值给 tmp[ x ] 即可。<br>而我们这里用 dfs 从下往上更新，所以更新到 x 时， son[x] 已经计算完成，它的数据就没必要特意保存，所以即使用指针会修改原数据也无所谓。</p></blockquote><p>不过虽然转移的效率很高，但是回溯的过程中还需要合并，如果我们对每个子树都暴力合并的话，时间复杂度还是很高（主要是因为我们每次只能利用指针 O(1) 转移一次，所以要选最长的转移才最划算），所以我们可以用长链剖分，先将当前子树 x 所有的值合并到 x 所在在重链（长链）上，这样每次合并的次数等于短链的长度，然后只要通过 O(1) 转移长链即可。这样等同于每个点都合并了一次，所以总的时间复杂度为 O(N) 。</p><p><strong>代码示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span> + c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,len[N],son[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(ver[i] == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs(ver[i],x);</span><br><span class="line"><span class="keyword">if</span>(len[son[x]] &lt; len[ver[i]]) son[x] = ver[i];</span><br><span class="line">&#125;</span><br><span class="line">len[x] = len[son[x]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans[N],*f[N],tmp[N],*idx = tmp;</span><br><span class="line"><span class="comment">//f 数组是指针数组，可以利用偏移量实现 O(1) 转移,而 idx 代表当前在 tmp 数组的起点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">f[x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(son[x]) f[son[x]] = f[x]+<span class="number">1</span>, DP(son[x],x), ans[x] = ans[son[x]]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(y == fa || y == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">f[y] = idx; idx += len[y]; DP(y,x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= len[y];j++)&#123;</span><br><span class="line">f[x][j] += f[y][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>((j &lt; ans[x] &amp;&amp; f[x][j] &gt;= f[x][ans[x]]) || (j &gt; ans[x] &amp;&amp; f[x][j] &gt; f[x][ans[x]]))</span><br><span class="line">ans[x] = j;<span class="comment">//这里的判断句要保证取f[x][ans[x]]是最大值,且ans[x]尽量小</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f[x][ans[x]] == <span class="number">1</span>) ans[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>); </span><br><span class="line">f[<span class="number">1</span>] = idx; idx += len[<span class="number">1</span>];</span><br><span class="line">DP(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.cnblogs.com/zhoushuyu/p/9468669.html" target="_blank" rel="noopener">租酥雨的博客</a></li><li><a href="https://www.cnblogs.com/cjyyb/p/9479258.html" target="_blank" rel="noopener">yyb的博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leanote与mongodb布置总结</title>
      <link href="/2020/02/14/leanote/"/>
      <url>/2020/02/14/leanote/</url>
      
        <content type="html"><![CDATA[<h4 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h4><p>Leanote 是一款类似于印象笔记的开源的笔记项目，具体介绍请访问 <a href="https://github.com/leanote/leanote" target="_blank" rel="noopener">Github</a> 该项目。</p><p>在 Github 上该项目有着详细的中文版的介绍以及安装步骤，但是由于 Linux 不熟练，我还是遇到了如下问题：</p><ol><li>虽然根据说明可以成功部署并运行，但是一旦断开会话或关闭终端，mongodb 与 leanote 都会停止工作。</li><li>如何用 fork 命令使得 mongodb 在后台运行。</li><li>如何使用 nohup 命令使得 run.sh 脚本在后台运行。</li><li>如何编写一个 shell 脚本来实现开机自启、一键启动、停止。</li></ol><p>本文主要目的是总结在 Linux 环境下工作的经验，详细记录刚掌握的知识点。</p><h4 id="mongodb-与非关系型数据库"><a href="#mongodb-与非关系型数据库" class="headerlink" title="mongodb 与非关系型数据库"></a>mongodb 与非关系型数据库</h4><p>mongodb 是非关系型数据库的一种，与 MySql 等关系型数据库相比，它的特点有：</p><ol><li>高并发，读写能力强</li><li>弱化数据结构一致性，使用更加灵活</li><li>有良好的拓展性（mysql 等很难横向拓展）</li><li>通用性差 , 没有 sql 语句那样通用的语句             </li><li>操作灵活导致容易出错和混乱             </li><li>没有外键关联等复杂的操作</li></ol><p>总的来说，关系型数据库（mysql）适合存储结构化数据，例如：用户账号、地址等信息；而非关系型数据库适合存储非结构化的数据，例如：文章、评论等。更加具体的区别与用法不做展开。</p><p>总的来说，mongodb 上手轻松，使用简单，而本文用到的指令仅仅三四个。</p><h5 id="mongodb-的安装与配置"><a href="#mongodb-的安装与配置" class="headerlink" title="mongodb 的安装与配置"></a>mongodb 的安装与配置</h5><p>首先去 <a href="http://www.mongodb.org/downloads" target="_blank" rel="noopener">mongodb官网</a> 下载压缩包，或者点击下载<a href="https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.1.tgz" target="_blank" rel="noopener">mongodb-linux-x86_64-3.0.1.tgz</a>。</p><p>下载完成后，只需做两步工作：解压与配置环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; tar -xzvf mongodb-linux-x86_64-3.0.1.tgz/</span><br></pre></td></tr></table></figure></p><p>为了快速使用 mongodb 命令, 可以配置环境变量。编辑 ~/.profile 或 /etc/profile 文件， 将 mongodb/bin 路径加入即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; sudo vim /etc/profile</span><br></pre></td></tr></table></figure></p><p>在 /etc/profile 中添加以下行，注意把用户名（user1）和相应的文件目录名（mongodb-linux-x86_64-3.0.1）替换成自己系统中的名称：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/home/user1/mongodb-linux-x86_64-3.0.1/bin</span><br></pre></td></tr></table></figure></p><p>保存修改后，在终端运行以下命令使环境变量生效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; source /etc/profile</span><br></pre></td></tr></table></figure></p><h5 id="测试-mongodb-安装"><a href="#测试-mongodb-安装" class="headerlink" title="测试 mongodb 安装"></a>测试 mongodb 安装</h5><p>先在 /home/user1 下新建一个目录 data 存放 mongodb 数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/user1/data</span><br></pre></td></tr></table></figure></p><p>用以下命令启动 mongodb：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --dbpath /home/user1/data</span><br></pre></td></tr></table></figure></p><p>这时 mongod 已经启动，<strong>重新打开</strong>一个终端, 键入 mongo 进入交互程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&gt; mongo</span><br><span class="line">&gt; show dbs</span><br><span class="line">...数据库列表</span><br></pre></td></tr></table></figure></p><p>至此 mongodb 就安装完成。</p><h4 id="使-mongodb-和-leanote-在后台运行"><a href="#使-mongodb-和-leanote-在后台运行" class="headerlink" title="使 mongodb 和 leanote 在后台运行"></a>使 mongodb 和 leanote 在后台运行</h4><p>由于按照 github 上的 leanote 安装说明，mongodb 和 leanote 是会随着会话和终端的关闭而停止运行，现在的目的是使它们不受会话关闭的影响，在后台运行。</p><p>我们可以时使用 <code>nohup command &gt;/dev/null 2&gt;&amp;1 &amp;</code> 命令来使得 mongodb 和 leanote 在后台运行。</p><p>对于 mongodb ，我们还可以配置 config 文件，通过在启动 mongod 时指定配置文件来实现后台运行，配置文件 mongodb.conf 内容如下：（路径需要自己修改）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#数据库路径</span><br><span class="line">dbpath=/usr/local/mongodb/data</span><br><span class="line">#日志输出文件路径</span><br><span class="line">logpath=/usr/local/mongodb/logs/mongodb.log</span><br><span class="line">#错误日志采用追加模式</span><br><span class="line">logappend=true</span><br><span class="line">#启用日志文件，默认启用</span><br><span class="line">journal=true</span><br><span class="line">#这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false</span><br><span class="line">quiet=true</span><br><span class="line">#端口号 默认为27017</span><br><span class="line">port=27017</span><br><span class="line">#允许远程访问</span><br><span class="line">#bind_ip=0.0.0.0</span><br><span class="line">#开启子进程</span><br><span class="line">fork=true</span><br><span class="line">#开启认证，必选先添加用户</span><br><span class="line">auth=true</span><br></pre></td></tr></table></figure><p>此时在 mongodb.conf 同一目录下执行 <code>mongod --conf mongodb.conf</code> 即可在后台启动数据库，此时可以通过 mongo 来访问数据库。<br>需要注意的是，mongod 命令不会帮你创建文件夹，所以 data 以及 logs 等目录是需要创建好再填写的，否则会报错 <code>ERROR: child process failed, exited with error number 1</code> 。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>至此已经可以较为简便的实现 mongod 与 leanote 的后台运行，并且每次服务器重启后我们都可以通过两条命令来启动。本次实践新接触了一个非关系型数据库 mongod 以及一些 linux 命令，下面目标是可以通过编写 Shell 脚本来使得工作更加简化，例如实现开机自启等。</p><p>本文不是教程，是笔记，当然如果已经成功搭建了 leanote ，想要使其在后台运行，还是可以参考本文的。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Liunx 使进程在后台运行的几种方法</title>
      <link href="/2020/02/14/nohup/"/>
      <url>/2020/02/14/nohup/</url>
      
        <content type="html"><![CDATA[<h4 id="Liunx-使进程在后台运行的几种方法"><a href="#Liunx-使进程在后台运行的几种方法" class="headerlink" title="Liunx 使进程在后台运行的几种方法"></a>Liunx 使进程在后台运行的几种方法</h4><p>现在有如下两个目标：</p><ul><li>使进程让出前台终端，让我们可以继续通过终端与系统进行交互。</li><li>使进程不再受终端关闭的影响，即系统在终端关闭后不再向进程发送 SIGHUP 信号或即使发送了信号程序也不会退出。</li></ul><p>首先要明白什么是进程、进程组、会话、终端、作业等名词。</p><h5 id="为什么进程会被终止"><a href="#为什么进程会被终止" class="headerlink" title="为什么进程会被终止"></a>为什么进程会被终止</h5><p>用户注销或者网络断开时，SIGHUP 信号会被发送到会话所属的子进程，而 SIGHUP 的默认处理方式是终止收到该信号的进程。所以若程序中没有捕捉该信号，当终端关闭后，会话所属进程就会退出。</p><h5 id="利用-amp-符号"><a href="#利用-amp-符号" class="headerlink" title="利用 &amp; 符号"></a>利用 &amp; 符号</h5><p>将 &amp; 附在命令后面可以使进程在后台执行，不占用前台界面。它实际上是在会话中开启了一个后台作业，但是此时如果终端被关闭了，进程还是会退出，这是因为 &amp; 只有让进程退出前台终端的功能，无法让进程不受 SIGHUP 的影响。</p><h5 id="nohup-命令"><a href="#nohup-命令" class="headerlink" title="nohup 命令"></a>nohup 命令</h5><p>nohup 可以使得进程不受 SIGHUP 信号的影响，但是执行<code>nohup php test.php</code> 后会发现，进程还是会一直占用着前台终端，不过此时如果终端被关闭或连接断开，程序还是会继续执行。另外此时当前文件夹还会多出一个 nohup.out 文件。</p><p>这是因为 nohup 仅仅让进程不受 SIGHUP 信号影响，并不会让出前台，而且它还会在命令执行的目录下生成 nohup.out 用于存储进程输出。如果不需要输出，且不想创建 nohup.out 文件，可以将标准输出和标准错误重定向。</p><p>我们常将 &amp; 和 nohup 搭配一起使用，执行命令如下：<code>nohup command &gt;/dev/null 2&gt;&amp;1 &amp;</code> ，这样就可以既不占用前台，又不会受 SIGHUP 信号影响，同时也不会创建输出文件。</p><h5 id="setsid-命令"><a href="#setsid-命令" class="headerlink" title="setsid 命令"></a>setsid 命令</h5><p>setsid 是另一个让进程在后台执行的命令，它的作用是让进程打开一个新的会话并运行进程，使用方式为 setsid command。</p><p>前面的做法都是使得进程忽略 SIGHUP 信号的影响，而 setsid 则干脆让进程新打开一个会话并在其中运行，那么原会话终端状态就不会影响该进程了。不过 setsid 并没有为进程分配一个输出终端，所以进程还是会输出到当前终端上。</p><p>不过 setsid 在 shell 脚本中表现的会有不同，具体可另行查找资料。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>除了上述做法之外，还可以利用 screen ，tmux 等会话工具来实现进程的后台运行，这里不做介绍。<br>本文主要解决了如何使进程不受终端和会话的影响，通过忽视 SIGHUB 信号从而实现在后台运行，上述的每个命令用法可能并不仅仅如此，并没有展开介绍每个命令的所有用法。同时本文介绍也仅仅是所有方案中的一部分。</p><p>参考资料：<a href="http://www.sohu.com/a/306275405_760387" target="_blank" rel="noopener">让 Linux 进程在后台可靠运行的几种方法 </a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>USACO 2019 December Contest, Silver 题解</title>
      <link href="/2019/12/17/usaco2019de/"/>
      <url>/2019/12/17/usaco2019de/</url>
      
        <content type="html"><![CDATA[<h4 id="1-MooBuzz"><a href="#1-MooBuzz" class="headerlink" title="1.MooBuzz"></a>1.MooBuzz</h4><h5 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h5><p>Farmer John 的奶牛们最近成为了一个简单的数字游戏“FizzBuzz”的狂热玩家。这个游戏的规则很简单：奶牛们站成一圈，依次从一开始报数，每头奶牛在轮到她的时候报一个数。如果一头奶牛将要报的数字是 3 的倍数，她应当报“Fizz”来代替这个数。如果一头奶牛将要报的数字是 5 的倍数，她应当报“Buzz”来代替这个数。如果一头奶牛将要报的数字是 15 的倍数，她应当报“FizzBuzz”来代替这个数。于是这个游戏的开始部分的记录为：<br>1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16</p><p>由于词汇的匮乏，奶牛们玩的 FizzBuzz 中用“Moo”代替了 Fizz、Buzz、FizzBuzz。于是奶牛版的游戏的开始部分的记录为：</p><p>1, 2, Moo, 4, Moo, Moo, 7, 8, Moo, Moo, 11, Moo, 13, 14, Moo, 16</p><p>给定 N（1≤N≤1e9），请求出这个游戏中第 N 个被报的数。</p><h5 id="A-possible-solution"><a href="#A-possible-solution" class="headerlink" title="A possible solution"></a>A possible solution</h5><p>利用容斥原理+二分判断。我们假设 n 个数里共有 cnt 个被跳过的数，那么报的第 n 个数就是 n+cnt ，由于 n 和 cnt 都具有单调性，所以我们可以利用二分判定来解决。<br>其中容斥原理很容易想到，cnt 显然等于 n 内 3 的倍数 + 5 的倍数 +15的倍数，但是15 = 3 * 5，所以15不需要重复统计（已经在 3 的倍数中统计过了）。但是我们重复统计了 3 和 5 的公倍数（统计了 2 次），于是我们就要减去同时是 3 的倍数和 5 的倍数 的 个数即可得到cnt。<br>在O(1)时间内求出cnt后，我们就可以在O(logN)时间内用二分搜索解决此题。</p><h5 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">int</span> tn;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">ll a = n/<span class="number">3</span>, b = n/<span class="number">5</span>;</span><br><span class="line">ll c = n/<span class="number">15</span>;</span><br><span class="line">ll cnt = a + b - c;</span><br><span class="line"><span class="keyword">return</span> n-cnt &gt;= tn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"moobuzz.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"moobuzz.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; tn ;</span><br><span class="line">ll l = <span class="number">1</span>,r = INF;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">ll mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Meetings"><a href="#2-Meetings" class="headerlink" title="2.Meetings"></a>2.Meetings</h4><h5 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h5><p>有两个牛棚位于一维数轴上的点 0 和 L 处（1≤L≤1e9）。同时有 N 头奶牛（1≤N≤5e4）位于数轴上不同的位置（将牛棚和奶牛看作点）。每头奶牛 i 初始时位于某个位置 xi，并朝着正向或负向以一个单位每秒的速度移动，用一个等于 1 或 −1 的整数 di 表示。每头奶牛还拥有一个在范围 [1,1e3] 内的重量。所有奶牛始终以恒定的速度移动，直到以下事件之一发生：<br>如果奶牛 i 移动到了一个牛棚，则奶牛 i 停止移动。<br>当奶牛 i 和 j 占据了相同的点的时候，并且这一点不是一个牛棚，则发生了相遇。此时，奶牛 i 被赋予奶牛 j 先前的速度，反之亦然。注意奶牛可能在一个非整数点相遇。<br>令 T 等于停止移动的奶牛（由于到达两个牛棚之一）的重量之和至少等于所有奶牛的重量之和的一半的最早时刻。请求出在时刻 0…T（包括时刻T）之间发生的奶牛对相遇的总数。</p><h5 id="A-possible-solution-1"><a href="#A-possible-solution-1" class="headerlink" title="A possible solution"></a>A possible solution</h5><p>这道题与 Ants 那题类似。如果不考虑重量，那么我们可以忽略每头牛的个性，从整体来看，如果两头牛相遇可以看作他们“穿过”对方并继续前进；如果每头牛有不同的重量，那么它们就有了个性，不能再等价于“穿过”对方。<br>这个时候我们可以从两个角度来考虑：</p><ol><li>首先如果有 x 头牛回窝，那么一定是靠近端点的 x 头牛。原因很简单，这是一个一维的空间，前面的牛不回窝后面的就会被堵住过不去。所以每个端点回窝的重量顺序就确定了。</li><li>在 t 时刻内，一头牛只可能和与他迎面走来的 2 <em> t 距离内的牛相遇。这个时候我们不需要考虑重量，所以每个牛可以看作“穿过”相遇的对方继续前进，那么显然 t 时刻内这两头牛相向而行 2 </em> t 的距离。</li></ol><p>通过第一个推论我们可以求出 T （二分或者优先队列），通过第二个推论我们可以根据 T 来求出相遇的牛的总数。</p><h5 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,l;</span><br><span class="line">ll sum;</span><br><span class="line"><span class="keyword">int</span> w[N],px[N],d[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="comment">//t时刻到家的重量是否达到一半</span></span><br><span class="line"><span class="keyword">int</span> tw = <span class="number">0</span>, c1 = <span class="number">0</span>, c2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(d[i] == <span class="number">1</span> &amp;&amp; l - px[i] &lt;= t) c1++;</span><br><span class="line"><span class="keyword">if</span>(d[i] == <span class="number">-1</span> &amp;&amp; px[i] &lt;= t) c2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c2;i++) tw += w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt; n-c1;i--) tw += w[i];</span><br><span class="line"><span class="comment">//printf("%d %d %d %d %d\n",t,c1,c2,tw,sum);</span></span><br><span class="line"><span class="keyword">return</span> tw*<span class="number">2</span> &lt; sum;</span><br><span class="line">&#125;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>,r = tot;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid] &gt;= x) r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; " " &lt;&lt; l &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(ll t)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">//相遇次数</span></span><br><span class="line">tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(d[i] == <span class="number">-1</span>) a[++tot] = px[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(d[i] == <span class="number">1</span>) res += bsearch(px[i]+<span class="number">2</span>*t+<span class="number">1</span>) - bsearch(px[i]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> w,x,d;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; rhs) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt; rhs.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;nodes[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"meetings.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"meetings.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;l);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;nodes[i].w,&amp;nodes[i].x,&amp;nodes[i].d);</span><br><span class="line">sort(nodes+<span class="number">1</span>,nodes+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) w[i] = nodes[i].w,px[i] = nodes[i].x,d[i] = nodes[i].d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) sum += w[i];</span><br><span class="line"><span class="keyword">int</span> tl = <span class="number">0</span>,tr = l; </span><br><span class="line"><span class="keyword">while</span>(tl &lt;= tr)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = tl+tr&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) tl = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> tr = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; l &lt;&lt; endl;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,calc(tl));<span class="comment">//计算 l 秒内碰头次数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Milk-Visits"><a href="#3-Milk-Visits" class="headerlink" title="3.Milk Visits"></a>3.Milk Visits</h4><h5 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h5><p>Farmer John 计划建造 N（1≤N≤1e5）个农场，用 N−1 条道路连接，构成一棵树（也就是说，所有农场之间都互相可以到达，并且没有环）。每个农场有一头奶牛，品种为更赛牛或荷斯坦牛之一。<br>Farmer John 的 M 个朋友（1≤M≤1e5）经常前来拜访他。在朋友 i 拜访之时，Farmer John 会与他的朋友沿着从农场 Ai 到农场 Bi 之间的唯一路径行走（可能有 Ai=Bi）。除此之外，他们还可以品尝他们经过的路径上任意一头奶牛的牛奶。由于 Farmer John 的朋友们大多数也是农场主，他们对牛奶有着极强的偏好。他的有些朋友只喝更赛牛的牛奶，其余的只喝荷斯坦牛的牛奶。任何 Farmer John 的朋友只有在他们访问时能喝到他们偏好的牛奶才会高兴。</p><p>请求出每个朋友在拜访过后是否会高兴。</p><h5 id="A-possible-solution-2"><a href="#A-possible-solution-2" class="headerlink" title="A possible solution"></a>A possible solution</h5><p>一条道路只有 3 种情况，全是 H 牛，全是 G 牛或者两者兼有。那么如果节点 x 是 H 牛我们就令其w =  -1，如果是 G 牛就等于1。那么这一段路径上所有点的 w 相加，如果等于 d，就说明全是G牛；如果等于 -d，就说明全是 H 牛；否则就说明两者都有。<br>至于快速求两点间距离可以用倍增求LCA。</p><h5 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">char</span> ty[N];</span><br><span class="line"><span class="keyword">int</span> n,m,w[N];</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dis[N],anc[N][<span class="number">25</span>],dep[N],sum[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++) </span><br><span class="line">anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(dis[y] || y == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">dis[y] = dis[x] + z;</span><br><span class="line">anc[y][<span class="number">0</span>] = x;</span><br><span class="line">sum[y] = sum[x] + w[y];</span><br><span class="line">dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[x] &lt; dep[y]) swap(x,y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(dep[anc[x][i]] &gt;= dep[y]) x = anc[x][i];</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(anc[x][i] != anc[y][i])&#123;</span><br><span class="line">x = anc[x][i]; y = anc[y][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"milkvisits.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"milkvisits.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,ty+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line"><span class="keyword">if</span>(ty[i] == <span class="string">'G'</span>) w[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> w[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y,<span class="number">1</span>); addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">dep[<span class="number">0</span>] = <span class="number">-1</span>; dfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;x,&amp;y,s);</span><br><span class="line"><span class="keyword">int</span> fa = lca(x,y);</span><br><span class="line"><span class="keyword">int</span> d = dis[x]+dis[y] - <span class="number">2</span>*dis[fa] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sw = sum[x]+sum[y] - <span class="number">2</span>*sum[fa]+w[fa];</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'H'</span> &amp;&amp; sw != d) <span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'G'</span> &amp;&amp; sw != -d) <span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> lca </tag>
            
            <tag> 树上倍增 </tag>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之字符串处理与格式输出</title>
      <link href="/2019/12/08/python-str/"/>
      <url>/2019/12/08/python-str/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>大多数语言都有字符串（String）这一数据类型，在Python中String类型的关键字为 str ，其属于扁平序列、不可改变序列，因此对其的操作需要一些技巧。<br>本文将以方便算法竞赛的角度来整理Python中 str 类型的使用方法，分别从字符串操作与格式化输出两个角度来整理。</p><h4 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h4><h5 id="标准的序列操作"><a href="#标准的序列操作" class="headerlink" title="标准的序列操作"></a>标准的序列操作</h5><p>这里的序列类型就不单单是指字符串了，而是指包含字符串的一种类型。序列类型大体可分为容器序列与扁平序列。<br><strong>容器序列</strong>实际上放的是对象引用，因此可以存放不同类型的数据；<br><strong>扁平序列</strong>存放的是对象的值，是一段连续的内存空间，因此要求对象必须是相同的数据类型才行，如字符、数字、字节。字符串是扁平序列。</p><p>当然，按照<strong>是否可修改</strong>还可以分为可变序列与不可变序列，不可变序列有<code>tuple、str、bytes</code>；可变序列有<code>list、bytearray</code> 等。字符串是不可变序列。</p><p>以上序列都有一些通用的操作，如：索引、切片、加法乘法；当然对于不同的序列这些操作意义也不同。</p><p><strong>索引：</strong> 和类C语言一样，序列中的元素都是有序排列的，拥有自己的编号（从0开始），我们可以通过索引来得到对应位置上的元素。<br>索引也可以是负值，负索引代表从后向前数，如 -3 表示倒数第三个元素，以此类推。</p><p><strong>切片：</strong> Python中有着分片操作符[ : ]，[begin : end]将会返回子序列 [begin,end)，其中end位置上的元素取不到，所以end是个超尾。<br>切片的索引同样支持负值，负索引表示倒数第几个元素，需要注意的是起始下标应在终止下标之前，否则将会返回空。</p><p><strong>代码示例：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"abcdefg"</span></span><br><span class="line">print(s)</span><br><span class="line"><span class="comment">#索引</span></span><br><span class="line">print(s[<span class="number">2</span>])<span class="comment">#输出索引为2的元素 'c'</span></span><br><span class="line">print(s[<span class="number">-2</span>])<span class="comment">#输出倒数第2个元素 'f'</span></span><br><span class="line"><span class="comment">#切片</span></span><br><span class="line">print(s[<span class="number">2</span>:<span class="number">6</span>])<span class="comment">#输出[2,6)位置的子串 "cdef"</span></span><br><span class="line">print(s[<span class="number">-4</span>:<span class="number">-2</span>])<span class="comment">#输出[倒数第4个元素,倒数第2个元素)子串 "de"</span></span><br></pre></td></tr></table></figure></p><p>字符串的 ‘+’与 ‘ * ‘ 分别是拼接与复制，一试便知，不再赘述。</p><h5 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h5><p>前面说过，python中的str属于不可修改序列，即不可以通过索引赋值的方式来修改元素；也就是说 <code>s[2] = &#39;x&#39;</code> 这样的写法是不允许的。那么如果想修改怎么办呢？这里挑几种方便的写法整理：<br><strong>重新赋值：</strong> 具体思路是，通过将需要修改的目标位置用切片切出来，然后替换再拼接，具体代码如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"abcdefg"</span></span><br><span class="line">print(s)</span><br><span class="line">s = s[:<span class="number">4</span>] + <span class="string">"x"</span> + s[<span class="number">5</span>:]</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure></p><p><strong>使用replace函数：</strong> 可以通过调用字符串方法replace( s , t )将字符串内的所有子串 s 替换为 t 后返回。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"abcdefgabc"</span></span><br><span class="line">print(s)</span><br><span class="line"><span class="comment">#将abcdefabc替换为xxxdefxxx</span></span><br><span class="line">s2 = s.replace(<span class="string">"abc"</span>,<span class="string">"xxx"</span>)</span><br><span class="line">print(s2)</span><br></pre></td></tr></table></figure></p><p>还可以通过将字符串转化为列表后修改元素，再用 join 方法转回字符串来达成修改目的，具体选择哪种方法按需求来看。</p><h5 id="ASCII码与字符的转换"><a href="#ASCII码与字符的转换" class="headerlink" title="ASCII码与字符的转换"></a>ASCII码与字符的转换</h5><p>在一些情形下，尤其是算法竞赛中，快速实现字符转ASCII码是十分重要的，在Python中不能直接对字符用加法或减法来实现转换，而是要通过ord() 和 chr() 函数来实现转换：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(ord(<span class="string">'a'</span>))<span class="comment">#输出字符 a 的ASCII码</span></span><br><span class="line">print(chr(<span class="number">98</span>))<span class="comment">#输出ASCII码为 98 的字符</span></span><br></pre></td></tr></table></figure></p><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><p>对于字符串的输出可以通过调用print()来实现，但是在算法竞赛等一些情况下，这样是不够的，因为我们往往对输出的格式有着严格的要求。</p><h5 id="基本的转换说明符"><a href="#基本的转换说明符" class="headerlink" title="基本的转换说明符"></a>基本的转换说明符</h5><p>% 字符 标记转换说明符的开始，例如<code>print(&quot;Hello, %s &quot; % &quot;egg&quot;)            # Hello, egg</code> ，这段代码将字符串中的 %s 替换成了字符串 “egg” ；这就是字符串格式化操作符 % 的基本使用方式。<br>如果要在格式化字符串里包含%，那么必须使用%%，这样Python就不会将百分号误以为是转换说明符了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"There is %d people."</span> % <span class="number">32</span>) <span class="comment"># There is 32 people.</span></span><br><span class="line">print(<span class="string">"Hello%%, %s "</span> % <span class="string">"egg"</span>)<span class="comment"># Hello%, egg</span></span><br></pre></td></tr></table></figure></p><h5 id="字段宽度和精度"><a href="#字段宽度和精度" class="headerlink" title="字段宽度和精度"></a>字段宽度和精度</h5><p>指定宽度和精度同C语言类似，都是类似%.3f以及%5d<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"An egg is %.2f yuan"</span> % <span class="number">0.8</span>)        <span class="comment"># An egg is 0.80 yuan</span></span><br><span class="line">print(<span class="string">"An egg is %5d yuan"</span> % <span class="number">1</span>)<span class="comment"># An egg is     1 yuan</span></span><br></pre></td></tr></table></figure></p><h5 id="符号、对齐和用0填充"><a href="#符号、对齐和用0填充" class="headerlink" title="符号、对齐和用0填充"></a>符号、对齐和用0填充</h5><p>在字符宽度和精度值之前还可以放一个“标志”，该表示可以是<code>0 + -</code> </p><ul><li>如果是0则表示不足的位置用前导零填充</li><li>‘-‘ 表示左对齐数值</li><li>‘+’ 表示输出符号（不管是正数还是负数）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"An egg is %05d yuan"</span> % <span class="number">1</span>)<span class="comment"># An egg is 00001 yuan</span></span><br><span class="line">print(<span class="string">"An egg is %-5d yuan"</span> % <span class="number">1</span>)<span class="comment"># An egg is 1     yuan</span></span><br><span class="line">print(<span class="string">"An egg is %+d yuan"</span> % <span class="number">1</span>)<span class="comment">#An egg is +1 yuan</span></span><br></pre></td></tr></table></figure><h5 id="输出不止一个元素"><a href="#输出不止一个元素" class="headerlink" title="输出不止一个元素"></a>输出不止一个元素</h5><p>你可能注意到了上述例子都是只输出一个值，一个元素；在C语言中我们可以通过逗号来分隔需要输出的不同元素，那么在Python中如何办到呢？<br>在Python中，只有元组和字典可以格式化一个以上的值；如果用列表或者其它序列代替元组，那么序列会被解释为一个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用元组来输出一个以上的值</span></span><br><span class="line">print(<span class="string">"An egg is %d yuan,two eggs are %d yuan."</span>% (<span class="number">1</span>,<span class="number">2</span>)) </span><br><span class="line"><span class="comment"># An egg is 1 yuan,two eggs are 2 yuan.</span></span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>Magnus Lie Hetland，Python基础教程第二版·修定版，北京：人民邮电出版社，45-47</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019CSP-J普及组复赛题解</title>
      <link href="/2019/11/26/2019CSP-J/"/>
      <url>/2019/11/26/2019CSP-J/</url>
      
        <content type="html"><![CDATA[<h4 id="A-数字游戏"><a href="#A-数字游戏" class="headerlink" title="A.数字游戏"></a>A.数字游戏</h4><p><strong>题意描述</strong><br>小 K 同学向小 P 同学发送了一个长度为 8 的 01 字符串来玩数字游戏，小 P 同学想 要知道字符串中究竟有多少个 1。<br> 注意：01 字符串为每一个字符是 0 或者 1 的字符串，如“101”（不含双引号）为一 个长度为 3 的 01 字符串。</p><p><strong>解题思路</strong><br>签到题。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;str[i];i++) <span class="keyword">if</span>(str[i] == <span class="string">'1'</span>) cnt++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="B-公车换乘"><a href="#B-公车换乘" class="headerlink" title="B.公车换乘"></a>B.公车换乘</h4><p><strong>题意描述</strong><br>著名旅游城市 B 市为了鼓励大家采用公共交通方式出行，推出了一种地铁换乘公交 车的优惠方案：在搭乘一次地铁后可以获得一张优惠票，有效期为 45 分钟，在有效期内可以 消耗这张优惠票，免费搭乘一次票价不超过地铁票价的公交车。在有效期内指 开始乘公交车的时间与开始乘地铁的时间之差小于等于 45 分钟，即：$t_{bus} - t_{subway} ≤ 45$。<br>搭乘地铁获得的优惠票可以累积，即可以连续搭乘若干次地铁后再连续使用优 惠票搭乘公交车。搭乘公交车时，如果可以使用优惠票一定会使用优惠票；如果有多张优惠票满 足条件，则优先消耗获得最早的优惠票。<br>现在你得到了小轩最近的公共交通出行记录，你能帮他算算他的花费吗？</p><p><strong>解题思路</strong><br>一道模拟题，显而易见需要按照时间升序，因为如果超过45分钟就无效了。基于此应该想到可以利用优先队列（或类似）的数据结构来维护，每次坐公交，在所有价值大于本次票价的优惠券中优先使用过期时间最早的（不用就过期了！），价值最低的优惠券。一旦票过期了，就删掉，但是如果票只是价值不够，那可能后面还会有用，所以还要压回去。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> ty;</span><br><span class="line">ll t,price;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; rhs) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t == rhs.t) <span class="keyword">return</span> price &gt; rhs.price;</span><br><span class="line"><span class="keyword">return</span> t &gt; rhs.t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;rd[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"><span class="built_in">stack</span>&lt;Node&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">sort(rd+<span class="number">1</span>,rd+<span class="number">1</span>+n);</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(!rd[i].ty)&#123;</span><br><span class="line">res += rd[i].price, q.push(rd[i]);</span><br><span class="line"><span class="keyword">continue</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">Node x = q.top(); q.pop();</span><br><span class="line"><span class="keyword">if</span>(rd[i].t - x.t &gt; <span class="number">45</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(x.price &lt; rd[i].price)&#123;</span><br><span class="line">s.push(x); <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) res += rd[i].price;</span><br><span class="line"><span class="keyword">while</span>(s.size()) q.push(s.top()), s.pop(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;rd[i].ty,&amp;rd[i].price,&amp;rd[i].t);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="C-纪念品"><a href="#C-纪念品" class="headerlink" title="C.纪念品"></a>C.纪念品</h4><p><strong>题意描述</strong><br>小伟突然获得一种超能力，他知道未来 T 天 N 种纪念品每天的价格。某个纪念品 的价格是指购买一个该纪念品所需的金币数量，以及卖出一个该纪念品换回的金币数量。<br> 每天，小伟可以进行以下两种交易<strong>无限次</strong>：<br>任选一个纪念品，若手上有足够金币，以当日价格购买该纪念品；卖出持有的任意一个纪念品，以当日价格换回金币。<br> 每天卖出纪念品换回的金币可以<strong>立即</strong>用于购买纪念品，当日购买的纪念品也可以<strong>当日卖出</strong>换回金币。当然，一直持有纪念品也是可以的。<br>T 天之后，小伟的超能力消失。因此他一定会在第 T 天卖出<strong>所有</strong>纪念品换回金币。<br>小伟现在有 M 枚金币，他想要在超能力消失后拥有尽可能多的金币。 </p><p><strong>解题思路</strong><br>本题思路可以根据数据范围来想。这是一道动态规划题。<br>刚开始想到的是建立一张全图，但是后来发现节点数量不是 N 而是 NT ，并且总价值也不一定只能走一条路。<br>后来发现可以用动态规划解决，首先设 f[x]: 第x天能够赚到最多多少钱。那么显然f[1] = m，并且 f 是递增的。重点在于状态转移，f[ i ] 肯定是由 f[ 1~i-1 ] 推出来的，因为单独一个 f[i-1] 无法表示所有状态。<br>假设当前处于状态 j （j &lt; i），那么将第 j 天物品的价格看作花费，第 i 天的物品价格看作价值，这就是一个完全背包问题，背包容量是当天的金币数 f[j] 。<br>于是我们两层循环O(T^2)来计算 f[i] ，而每次计算需要O(MN) 做完全背包，但是实际测试效率还行，可能是数据太弱了。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e2</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,m;</span><br><span class="line"><span class="keyword">int</span> val[N][N];</span><br><span class="line"><span class="keyword">int</span> f[N];<span class="comment">//第 x 天最多有多少钱</span></span><br><span class="line"><span class="keyword">int</span> tmp[M],mx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">f[<span class="number">1</span>] = m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> day = <span class="number">2</span>;day &lt;= t;day++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; day;i++)&#123;</span><br><span class="line"><span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span> tmp); mx = m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v = val[i][j]; v &lt;= f[i];v++)&#123;</span><br><span class="line">tmp[v] = max(tmp[v-val[i][j]]+val[day][j],tmp[v]);</span><br><span class="line">mx = max(mx,tmp[v]+f[i]-v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f[day] = max(f[day],mx);</span><br><span class="line">&#125;</span><br><span class="line">f[day] = max(f[day],f[day<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for(int i = 1;i &lt;= t;i++) printf("%d\n",f[i]);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[t]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;t,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= t;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val[i][j]);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="D-加工零件"><a href="#D-加工零件" class="headerlink" title="D.加工零件"></a>D.加工零件</h4><p><strong>题意描述</strong></p><p>凯凯的工厂正在有条不紊地生产一种神奇的零件，神奇的零件的生产过程自然也很 神奇。工厂里有 𝑛 位工人，工人们从 1∼𝑛编号。某些工人之间存在双向的零件传送带。保证每两名工人之间最多只存在一条传送带。<br>如果 𝑥 号工人想生产一个被加工到第 𝐿(𝐿&gt;1) 阶段的零件，则所有与 𝑥 号工人 有传送带直接相连的工人，都需要生产一个被加工到第 𝐿 −1 阶段的零件（但 𝑥 号工 人自己无需生产第 𝐿 −1 阶段的零件）。<br>如果 𝑥 号工人想生产一个被加工到第 1 阶段的零件，则所有与 𝑥 号工人有传送 带直接相连的工人，都需要为 𝑥 号工人提供一个原材料。<br>轩轩是 1 号工人。现在给出 𝑞 张工单，第 𝑖 张工单表示编号为 𝑎𝑖的工人想生产 一个第 𝐿𝑖阶段的零件。轩轩想知道对于每张工单，他是否需要给别人提供原材料。他知道聪明的你一定可以帮他计算出来！</p><p><strong>解题思路</strong><br>经过推导可以发现，如果 a 号节点到 1 号节点（以下只用编号简写）之间存在一条小于 L 的路径，且它们的差为偶数（包括0），那么 1 就要提供原材料。<br>但是问题在于 1 到 a 之间可能不止一条路径，而 L 也不一定是奇或者偶，于是我们需要保存 a 到 1 的<strong>最短奇路径</strong>与<strong>最短偶路径</strong>。<br>在图论中，如果边权为1，那么求奇偶最短路径的好方法就是用分层图来做，具体做法是建立双层图，如果从起点不在同一层，则路径一定是奇，否则一定为偶；这样做的好处是不用额外的辅助代码，只要在建图时多加两条边就行了。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[M],ver[M],nex[M] ,tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="keyword">int</span> dis[N],vis[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[a] &lt;= l &amp;&amp; !((dis[a]&amp;<span class="number">1</span>) ^ (l&amp;<span class="number">1</span>))) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(dis[a+n] &lt;= l &amp;&amp; !((dis[a+n]&amp;<span class="number">1</span>) ^ (l&amp;<span class="number">1</span>))) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">que.push(s);</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(que.size())&#123;</span><br><span class="line"><span class="keyword">int</span> x = que.front(); que.pop();</span><br><span class="line">vis[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(dis[y] &gt; dis[x]+z)&#123;</span><br><span class="line">dis[y] = dis[x]+z;</span><br><span class="line"><span class="keyword">if</span>(!vis[y]) que.push(y),vis[y] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = getInt(); m = getInt(); q = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">addEdge(x,y+n,<span class="number">1</span>); addEdge(y+n,x,<span class="number">1</span>);</span><br><span class="line">addEdge(x+n,y,<span class="number">1</span>); addEdge(y,x+n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">SPFA(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//for(int i = 1;i &lt;= n&lt;&lt;1;i++) cout &lt;&lt; dis[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,a,l;i &lt;= q;i++)&#123;</span><br><span class="line">a = getInt(); l = getInt();</span><br><span class="line"><span class="keyword">if</span>(solve(a,l)) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 分层图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeForce#600（Div2）解题报告</title>
      <link href="/2019/11/24/cf600/"/>
      <url>/2019/11/24/cf600/</url>
      
        <content type="html"><![CDATA[<h4 id="A-Single-Push"><a href="#A-Single-Push" class="headerlink" title="A. Single Push"></a>A. Single Push</h4><p><strong>题意简述：</strong><br>给定两个序列 a 和 b，要求从序列 a 中选出连续的一段[l , r] ，对这段上的每个位置+k（k &gt;= 0），试问只操作一次能否使得序列 a 变为序列 b 。<br><strong>解题思路：</strong><br>由于只能操作一次，所以难度大大下降，因此只需要顺序判断 a 是否只有一个区间和 b 不同，且差值全部相同且为负。<br><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span> + c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = a[i]-b[i];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(a[i] &amp;&amp; a[i] != a[i<span class="number">-1</span>]) cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt &lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">t = getInt();</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">n = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) b[i] = getInt();</span><br><span class="line"><span class="keyword">if</span>(solve()) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="B-Silly-Mistake"><a href="#B-Silly-Mistake" class="headerlink" title="B. Silly Mistake"></a>B. Silly Mistake</h4><p><strong>题意简述：</strong><br>定义一个连续的序列是合法的，当且仅当：</p><ul><li>有一个正数，就有一个负数，例如有 5 ，就要有 -5；</li><li>负数之前必须有它的正数，即 5 只能在 -5 前面；</li><li>每个数对仅出现一次，即 5 ，-5，5，-5是不合格法的。</li></ul><p>给定一个序列 a，其中ai &lt;= 1e6，请问可以将序列a分为多少个合法的子序列，并输出每个子序列的长度，若不存在划分方法，则输出-1，否则输出任意满足条件的答案。</p><p><strong>解题思路：</strong><br>需要在O(N)时间内解决，就是模拟题，只需要每次遍历到一个数就判断当且序列是否合法就行了，若合法就划分，否则或退出输出-1，或继续加入元素。<br>需要注意若用前缀和作为判断条件可能会超 int，需要用longlong，另外对于每个条件分支一定要仔细划分，避免遗漏出错。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp;(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span>+ c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[N],d[N],tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line">__int64 sum[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) sum[i] = sum[i<span class="number">-1</span>] + a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,pre = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(num[a[i]] != <span class="number">0</span> || vis[a[i]] &gt; pre) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">num[a[i]]++; vis[a[i]] = i;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num[-a[i]] != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">num[-a[i]]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum[i] == <span class="number">0</span>) d[++tot] = i-pre,pre = i;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sum[i] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!tot || sum[n]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tot);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; tot;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,d[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d[tot]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line"><span class="comment">// freopen("out","w",stdout);</span></span><br><span class="line">n = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line"><span class="keyword">if</span>(!solve()) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="C-Sweets-Eating"><a href="#C-Sweets-Eating" class="headerlink" title="C. Sweets Eating"></a>C. Sweets Eating</h4><p><strong>题意简述：</strong><br>给定一个序列 a，给定 m ，对于 k（k从1到n） ，要求从序列 a 中挑出k个元素，分为若干组，每组最多有m个元素，使得第一组 <em> 1，第二组 </em> 2，依次类推，使得它们的总和最小。</p><p><strong>解题思路：</strong><br>首先对序列 a 排序，易得要想总和最小，应该选出最小的 k 个元素。<br>假设要求的是 f(k) ，那么需要解决的是如何才能快速的从 f(k) 转移到 f(k+1)，如果暴力转移，是 O(k) 复杂度，因为要加上每一组最小的元素放到高一组去。我们可以利用前缀和来优化，具体做法是开一个sum数组，sum[i] 记录 %m 为 i 的元素和，我们从小到大依次将 a 序列中的元素加入，就可以在O(1)转移。</p><p><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span> + c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line">ll sum[N],ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;k++)&#123;</span><br><span class="line">ans[k] = ans[k<span class="number">-1</span>] + sum[k%m] + a[k];</span><br><span class="line">sum[k%m] += a[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">printf</span>(<span class="string">"%I64d "</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line"><span class="comment">// freopen("out","w",stdout);</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="D-Harmonious-Graph"><a href="#D-Harmonious-Graph" class="headerlink" title="D. Harmonious Graph"></a>D. Harmonious Graph</h4><p><strong>题意简述</strong><br>一个有 N 个点的无向图，节点分别标号为1~N。要求如果图中存在 l —&gt; r 的路径，那么对于所有的 m (l &lt; m &lt; r)都满足 l —&gt; m 。给定一张无向图，试问最少添加多少条边才能使得其满足要求。</p><p><strong>解题思路</strong><br>思路不难想，因为只要求若(l , r)是连通的，那么对于 l 到 r 内的所有点都应（至多）延伸出一条线构成一个连通分量，易得一张图最多需要 N-2 条边；很容易想到用并查集来做，将相连通的点放在同一个集合，分配一个编号。然后记录每个集合（连通分量）最后一个点的位置 ed ，然后只需要从前往后依次遍历，若当前节点在另一个集合的范围内，则合并两个集合并将 ans++；若当前集合可以更新有边界，则更新。<br>思路是正确的，但是被卡了好多次，错了很多细节，首先就是求集合‘编号’需要调用Find()函数，而不是直接访问par[]数组，par[]数组只是一个辅助数组而已；然后还有就是通过Merge()函数后，集合的编号可能会改变，因此按照集合的编号来存有边界是不合理的，应该再转化为按照位置来存。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> par[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(par[x] == x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> par[x] = Find(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = Find(x), b = Find(y);</span><br><span class="line"><span class="keyword">if</span>(a == b) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(a &lt; b) swap(a,b);</span><br><span class="line">par[a] = b;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res*<span class="number">10</span>+c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> vis[N],ed[N],ls[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) par[i] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">Merge(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt; <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(!ed[Find(i)]) ed[Find(i)] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) ls[i] = ed[Find(i)];</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>,last = ls[x] ,ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt; last &amp;&amp; Merge(x,i)) ans++;</span><br><span class="line"><span class="keyword">if</span>(ls[i] &gt; last)&#123;</span><br><span class="line">last = ls[i]; x = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL之map容器速率测试</title>
      <link href="/2019/11/16/mapDemo/"/>
      <url>/2019/11/16/mapDemo/</url>
      
        <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>不止一次在使用 map 时被卡时限，map 是 c++ 的 STL 中一个常用且方便的容器，其是基于树来实现的，它的插入与查找效率实际上更接近O(log N )（N为插入的元素个数）。当然在 c++ 的 STL 中还有用哈希实现的无序关联容器，这里不做讨论。<br>在实际应用中，常常会有人把 map 时间复杂度看作O(1)，确实在大多数时候 map 表现是令人满意的，但在大量使用的时候，map却不尽人意。</p><p>我们将测试如下几种情形下使用 map 容器的效率（时间）：</p><ul><li>仅插入元素（元素类型为int）</li><li>插入以及查找（元素类型为int）<h4 id="测试环境准备"><a href="#测试环境准备" class="headerlink" title="测试环境准备"></a>测试环境准备</h4></li></ul><p>为了给定一个对照的标准，先给出如下数据：</p><ul><li>测试机空循环 1e6 次平均花费 0.0641 s</li><li>测试机读取 1e6 个int型数据（快读+从文件输入）平均花费 0.2142 s</li></ul><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><h5 id="仅插入元素"><a href="#仅插入元素" class="headerlink" title="仅插入元素"></a>仅插入元素</h5><p><strong>本机平均花费时间：</strong> 1.1015 s<br><strong>测试代码</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> gap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">mp[i*gap%P] = <span class="number">1</span>; gap += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="插入以及查找元素"><a href="#插入以及查找元素" class="headerlink" title="插入以及查找元素"></a>插入以及查找元素</h5><p><strong>本机平均花费时间：</strong> 1.238 s<br><strong>测试代码</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> gap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">mp[i*gap%P] = <span class="number">1</span>; gap += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(mp.count(i));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总体上测试结果是符合预期的，虽然 STL 容器已经很优化的，但是毕竟还是用树来实现的，达不到 O(1) 的时间复杂度，所以如果是对时限要求很高的话，最好还是采用手动写哈希表。<br>上述设计的实验有很多缺陷，如未对 long long转化、取模 以及其它多余的操作进行排除影响，另外本来还测试了char、string、set等类型的元素，但是要设计一个好的测试代码太麻烦了，就删了，总的结论来说就是 int 是所有测试的数据类型中最慢的一种（甚至慢于 set 和 string ，如果只考虑插入和查找）。<br>最终结论就是如果需要一个 O(1) 时间复杂度的插入和查找（int 类型的元素），那么就用哈希表。</p>]]></content>
      
      
      
        <tags>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大流笔记</title>
      <link href="/2019/11/15/maxFlow/"/>
      <url>/2019/11/15/maxFlow/</url>
      
        <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>正如可以通过将道路交通图模型化为有向图来找到从一个城市到另一个城市之间的最短路，我们也可以将一个有向图看作一个“流网络”，并使用它来回答关于物料流动方面的问题。这种流网络可以用来建模很多实际问题，包括液体在管道中的流动、装配线上的部件的流动、电网中电流的流动和通信网络中信息的流动。<br>本文首先介绍网络流中的相关概念，然后给出最大流问题的一般解法思路，以及优化后的算法。我们应该将主要精力放在思维锻炼和题目分析上，而不要过于执着于那些经典算法的细节优化。本文中整理的算法在算法竞赛中已经够用。</p><h4 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h4><p><strong>流网络：</strong> 流网络 G = (V , E) 是一个有向图，图中每条边 (u , v) 都有一个非负的<strong>容量值c(u , v)</strong> 。而且，如果边集合 E 包含一条边(u , v) ，则图中不存在反向边(v , u)。</p><p><strong>源节点s和汇点t：</strong> 在流网络的所有节点中，我们分辨出两个特殊的节点，分别是源点s和汇点t；源点是所有路径的起点，而汇点是路径的终点。在某些情况下，源点和汇点需要人为指定。</p><p><strong>流网络 G 中的流：</strong> G中流的大小（值）用 f 表示，f(u , v)表示从点 u 到点 v 的流的大小。整张图的流是 $|f| = \sum_{v \epsilon V}f(s, v) - \sum_{v \epsilon V}f(v ,s)$（前后两个 v 含义不同），即从源点 s 流出的流量和，或称为流入汇点 t 的流量和。</p><p><strong>容量限制：</strong> 对于所有的节点$u, v \epsilon V$，要求$0 &lt;= f(u , v) &lt;= c(u , v)$<br><strong>流量守恒：</strong> 对于所有的节点 $u \epsilon V$ - { s , t }，要求流入 u 的流量等于流出 u 的流量，即：</p><script type="math/tex; mode=display">\sum_{v \epsilon V}f(v,u) = \sum_{v \epsilon V}f(u,v)</script><p>（前后两个 v 的含义不同，一个是入边的起点，一个是出边的终点）</p><p><strong>问题模型：</strong> 在最大流问题中，给定一个流网络G 、一个源节点s、一个汇点t，我们希望找到值最大的一个流。</p><h4 id="Edmonds-Karp算法"><a href="#Edmonds-Karp算法" class="headerlink" title="Edmonds-Karp算法"></a>Edmonds-Karp算法</h4><p>若一条从源点 s 到汇点 t 的路径上的各条边的剩余容量都大于 0，则称这条路径为一条增广路径。显然，可以让一股流沿着增广路径从 s 流到 t，使网络的流量增大。Edmonds-Karp算法思想就是不断用BFS寻找增广路，直至网络上不存在增广路为止。<br>该算法的时间复杂度为$O(nm^2)$。然而在实际运用中则远远达不到这个上界，效率较高，一般能够处理 $10^3 - 10^4$规模的网络。</p><p><strong>算法思路：</strong><br>这里介绍的是利用 bfs 寻找增广路的Edmonds-Karp增广路算法。在该算法中，我们不断的寻找增广路，并增加增广路上的流；重复这一步骤直至不存在增广路。<br>在每轮寻找增广路的过程中，Edmonds-Karp算法只考虑图中所有 f(x ,y) &lt; c(x, y)的边，用BFS找到任意一条从 s 到 t 的路径，同时计算出路径上各边的剩余容量的最小值 minf，则网络的流量就可以增加 minf。</p><p>需要注意的是，当一条边的流量 f(x ,y) &gt; 0时，根据斜对称性质，它的反向边流量 f(y ,x) &lt; 0，此时必定有 f(y , x) &lt; c(y ,x)。故Edmonds-Karp算法在BFS时除了原图的边集 E 外，还应考虑遍历 E 中每条边的反向边。<br>具体实现时，本文采用邻接表“成对存储”技巧（即’2’和’3’是一对，’4’和’5’是一对）。每条边只记录剩余容量 c-f 即可，当一条边 (x ,y) 流过大小为 e 的流时，令 (x ,y) 的容量减少 e，(y ,x) 的容量增加 e 。</p><p><strong>代码模板：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;<span class="comment">//最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e3</span>+<span class="number">10</span>;<span class="comment">//最大边数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;<span class="comment">//int范围内的无穷大</span></span><br><span class="line"><span class="keyword">int</span> head[N], edge[M], ver[M], nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;<span class="comment">// 共n个点,m条边,s是源点,t是汇点</span></span><br><span class="line"><span class="keyword">int</span> pre[N],incf[N];<span class="comment">//增广路上各边的最小剩余容量</span></span><br><span class="line"><span class="keyword">bool</span> vis[N];<span class="comment">//标记数组</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(s); vis[s] = <span class="literal">true</span>;</span><br><span class="line">incf[s] = INF;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(!z || vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">incf[y] = min(incf[x],z);</span><br><span class="line">pre[y] = i;<span class="comment">//记录前驱*边*</span></span><br><span class="line">q.push(y); vis[y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(y == t) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//找到一条增广路</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回最大流的值*/</span></span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(bfs())&#123;</span><br><span class="line"><span class="keyword">int</span> x = t;</span><br><span class="line"><span class="keyword">while</span>(x != s)&#123;</span><br><span class="line"><span class="keyword">int</span> i = pre[x];<span class="comment">//前驱 *边* </span></span><br><span class="line">edge[i] -= incf[t];</span><br><span class="line">edge[i^<span class="number">1</span>] += incf[t];</span><br><span class="line">x = ver[i^<span class="number">1</span>];<span class="comment">//前驱点 = 反向边的终点</span></span><br><span class="line">&#125;</span><br><span class="line">flow += incf[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addEdge(x,y,z); addEdge(y,x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,EK());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>算法正确性需要用到最小割来证明，详见《挑战程序设计竞赛第二版》P212。</p><h4 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h4><p> 在任意时刻，网络中所有节点以及剩余容量大于0的边构成的子图被称为残量网络。Edmonds-Karp每轮可能会遍历整个残量网络，但只找出 1 条增广路，还有进一步优化的空间。<br> 在宽度优先遍历时，我们可以计算出<strong>节点的层次d[x]</strong> ，它表示 s 到 x 最少需要经过的边数。在残量网络中，满足d[y] = d[x] + 1 的边(x ,y) 构成的子图被称为<strong>分层图</strong> 。分层图显然是一张有向无环图。</p><p> Dinic 算法不断重复以下步骤，直到残量网络中 s 不能到达 t：</p><ol><li>在残量网络上 BFS 求出节点的层次，构造分层图</li><li>在分层图上 DFS 寻找增广路，在回溯时实时更新剩余容量。另外，每个点可以流向多条出边，同时还加入了若干剪枝，详情参考代码示例。</li></ol><p>Dinic 算法的时间复杂度是$O(n^2m)$。实际运用中远远达不到这个上界，可以说是比较容易实现的效率最高的网络流算法之一，一般能够处理$10^4 - 10^5$规模的网络。特别地，Dinic算法求解二分图最大匹配的时间复杂度为$O(m\sqrt n)$，实际表现则更快。</p><p> <strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;<span class="comment">//int所能表示的最大范围的一半</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5</span>*N;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[M],ver[M],nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> d[N];<span class="comment">//记录节点的层次</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*利用bfs来求出节点的层次，构造分层图*/</span></span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="keyword">while</span>(q.size()) q.pop();</span><br><span class="line">q.push(s); d[s] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(q.size())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(!z || d[y]) <span class="keyword">continue</span>;</span><br><span class="line">q.push(y);</span><br><span class="line">d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(y == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 利用递归在分层图上找增广路,返回本次增广的流量 */</span></span><br><span class="line"><span class="keyword">if</span>(x == t) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> res = flow, k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(z &amp;&amp; d[y] == d[x]+<span class="number">1</span>)&#123;</span><br><span class="line">k = dinic(y,min(res,z));<span class="comment">//递归</span></span><br><span class="line"><span class="keyword">if</span>(!k) d[y] = <span class="number">0</span>;<span class="comment">//剪枝,去掉增广完毕的点</span></span><br><span class="line">edge[i] -= k; edge[i^<span class="number">1</span>] += k;</span><br><span class="line">res -= k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow - res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addEdge(x,y,z); addEdge(y,x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>,maxflow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(bfs())</span><br><span class="line"><span class="keyword">while</span>(flow = dinic(s,INF)) maxflow += flow;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,maxflow);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="ISAP算法"><a href="#ISAP算法" class="headerlink" title="ISAP算法"></a>ISAP算法</h4><p>ISAP算法没有正式的名称，首次出现于 Ahuja和Orlin的经典教材《Network Flows：Theory，Algorithms and Applications》中，作者称它是一种：改进版的SAP（Improved SAP，ISAP）“。</p><p>该算法基于这样一个事实：每次增广后，任意节点到汇点（在残量网络中）的最短距离都不会减小。这样，我们可以用一个函数d(x)来表示残量网络中节点 x 到汇点的距离的下界（在Dinic中是用数组 d[]），然后在增广过程中不断修正这个下界（而不是像Dinic 算法那样多次增广以后才重建层次图），则增广的时候和 Dinic 类似，只允许沿着 d(y) = d(x) + 1 的有向边 (x , y) 走。</p><p>严格的说，算法中的 d 函数是满足如下两个条件的非负函数，即 d(t) = 0；对于残量网络中的任意弧 (x ,y)，d(x) &lt;= d(y) + 1。不难证明，只要满足这两个条件，d(x) 就是 x~t 距离的下界。而且当 d(s) &gt;= n时，残量网络中不存在 s-t 路。</p><p><strong>算法思路</strong><br>和 Dinic 算法类似，找增广路的过程是从 s 开始沿着“允许弧”（即在残量网络中的，满足 d[x] = d[y] + 1 的弧 x —&gt; y）往前走（ISAP 算法中叫Advance）如果走不动了怎么办？在Dinic算法中，直接“往回走一步”即可，因为如果找不到增广路，会重新构造层次图；但在ISAP中，并没有一个“一次性修改所有距离标号”的过程，只能边增广边修改。具体来说，在从结点 x 往回走的时候，把 d(x) 修改为 min{d(y) | (x , y)  是残量网络中的弧 } + 1（ISAP算法叫 Retreat）即可。注意，如果残量网络中从 x 出发没有弧，则设 d(x) = n。<br>ISAP算法看上去不难理解，但是实现起来却有诸多细节。首先，我们需要使用一种“当<br>前弧”的数据结构加速 允许弧 的査找，其次，还需要一个 gap 数组维护每个距离标号<br>结点编号。当把一个结点的距离标号从 x 改成 y 的时候,把 gap[x] 减1,gap[y]加1,然后<br>检查 gap[x] 是否为0。如果是 0 的话,说明 s-t 不连通，算法终止。这就是所谓的 gap 优化。最后，初始距离标号可以统一设为 0 ，也可以用逆向BFS找，单次运行时效率相差不大，但如果是多次求解小规模网络流，加上BFS以后速度往往会有明显提升。</p><p>数据结构方面，只多了两个数组：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[N];        <span class="comment">//可增广路的上一条弧</span></span><br><span class="line"><span class="keyword">int</span> gap[N];       <span class="comment">//距离标号计数</span></span><br></pre></td></tr></table></figure></p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5</span>*N;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">/*以下6行是数组模拟邻接表部分*/</span></span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot;</span><br><span class="line"><span class="keyword">int</span> cur[N],dis[N],gap[N],pre[N];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gap[k]:k层有多少个节点</span></span><br><span class="line"><span class="comment">pre[x]:x点前一条边的编号</span></span><br><span class="line"><span class="comment">cur[]是临时数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y, edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;</span><br><span class="line"><span class="keyword">int</span> que[N],front,rear;<span class="comment">//手工模拟队列，节省部分时间</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">front = rear = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">dis[i] = <span class="number">-1</span>,cur[i] = head[i],gap[i]= <span class="number">0</span>;</span><br><span class="line">dis[t] = <span class="number">0</span>;  que[rear++] = t;</span><br><span class="line"><span class="keyword">while</span>(front != rear)&#123;</span><br><span class="line"><span class="keyword">int</span> x = que[front++];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(dis[y] == <span class="number">-1</span>) </span><br><span class="line">que[rear++] = y, dis[y] = dis[x] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ~dis[t];<span class="comment">//-1的补码是11111111,按位取反后是0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ISAP</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = s, ans = <span class="number">0</span>, i;<span class="comment">//时刻注意i不能被覆盖！！！</span></span><br><span class="line">bfs(n);<span class="comment">//一次bfs从汇点向前更新层次数组dis</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= n;i++) gap[dis[i]]++;</span><br><span class="line"><span class="keyword">while</span>(dis[s] &lt; n)&#123;</span><br><span class="line"><span class="keyword">if</span>(k == t)&#123;</span><br><span class="line"><span class="keyword">int</span> mi = INF, loc = t;</span><br><span class="line"><span class="keyword">while</span>(loc != s)&#123;</span><br><span class="line">mi = min(mi,edge[pre[loc]]);</span><br><span class="line">loc = ver[pre[loc]^<span class="number">1</span>];<span class="comment">//前一个顶点</span></span><br><span class="line">&#125;</span><br><span class="line">loc = t;</span><br><span class="line"><span class="keyword">while</span>(loc != s)&#123;</span><br><span class="line">edge[pre[loc]] -= mi;</span><br><span class="line">edge[pre[loc]^<span class="number">1</span>] += mi;</span><br><span class="line">loc = ver[pre[loc]^<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">ans += mi, k = s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = cur[k];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(z &amp;&amp; dis[k] == dis[y]+<span class="number">1</span>)&#123;</span><br><span class="line">pre[y] = cur[k] = i; k = y;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> m = n;</span><br><span class="line"><span class="keyword">for</span>(i = head[k];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(z &amp;&amp; dis[y] &lt; m) m = dis[y], cur[k] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(--gap[dis[k]] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">dis[k] = m+<span class="number">1</span>, ++gap[dis[k]];</span><br><span class="line"><span class="keyword">if</span>(k != s) k = ver[pre[k]^<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;s,&amp;t))&#123;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">0</span> ,<span class="keyword">sizeof</span> head); tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addEdge(x,y,z); addEdge(y,x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ISAP(n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>刘汝佳，算法竞赛入门经典训练指南，北京：清华大学出版社，2012，362-363.</li><li>李煜东，算法竞赛进阶指南，郑州：河南电子音像出版社，2017，410-415.</li><li>秋叶拓哉，挑战程序设计竞赛第2版，北京：人民邮电出版社，2013，209-215.</li><li>Thomas H.Cormen，算法导论（原书第3版），北京：机械工业出版社，2013，414-417.</li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 最大流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伙伴算法</title>
      <link href="/2019/11/13/buddy-system/"/>
      <url>/2019/11/13/buddy-system/</url>
      
        <content type="html"><![CDATA[<h4 id="伙伴系统（Buddy-System）"><a href="#伙伴系统（Buddy-System）" class="headerlink" title="伙伴系统（Buddy System）"></a>伙伴系统（Buddy System）</h4><p><strong>伙伴系统的特点</strong></p><ul><li>整个可分配的分区大小为 $2^u$。</li><li>需要的分区大小为 $2^{u-1} &lt; s &lt;= 2^u$时，把整个块分配给该进程。</li></ul><p><strong>分配分区的过程：</strong><br>如果 $s &lt;= 2^{i-1}$，则将大小为$2^i$的当前空闲分区划分为两个大小为$2^{i-1}$的空闲分区<br>重复划分过程，直至$2^{i-1} &lt; s &lt;= 2^i$，并把一个空闲分区分配给该进程。</p><h4 id="伙伴系统的实现"><a href="#伙伴系统的实现" class="headerlink" title="伙伴系统的实现"></a>伙伴系统的实现</h4><p><strong>数据结构：</strong></p><ul><li>空闲块按照大小和起始地址组成二维数组。</li><li>初始状态：只有一个大小为$2^u$的空闲块。</li></ul><p><strong>分配过程：</strong></p><ul><li>由大到小在空闲块数组中找到最小的可用空闲块。</li><li>如果空闲块过大，对可用的空闲块进行二等分，直到得到合适的可用的空闲块。</li></ul><p><strong>分配样例图示：</strong><br><img src="/2019/11/13/buddy-system/1.png" alt="1"></p><p><strong>释放过程：</strong></p><ul><li>把释放的空闲块放入空闲数组</li><li>合并满足合并条件的空闲块</li></ul><p><strong>合并条件：</strong></p><ul><li>大小相同，例如都是$2^i$</li><li>地址相邻</li><li>低地址空闲块起始地址为$2^{i+1}$的位数</li></ul><h4 id="伙伴算法的优缺点"><a href="#伙伴算法的优缺点" class="headerlink" title="伙伴算法的优缺点"></a>伙伴算法的优缺点</h4><p><strong>优点：</strong></p><ul><li>较好的解决外部碎片问题</li><li>当需要分配若干个内存页面时，用于DMA的内存页面必须连续，伙伴算法很好的满足了这个要求</li><li>只要请求的块不超过512个页面（2k），内核就尽量分配连续的页面。</li><li>针对大内存分配设计</li></ul><p><strong>缺点：</strong></p><ul><li>合并的要求过于严格，只能是满足伙伴关系的块才能合并</li><li>碎片问题：一个连续的内存中仅仅一个页面被占用，导致整个内存区都不具备合并条件</li><li>浪费问题：伙伴算法只能分配2的幂次方内存区，当需要的内存为$2^i+1$ K 时，例如需要 9K 时，就需要分配16K的内存空间，剩下的 7K 浪费了。</li><li>算法的效率问题：伙伴算法中涉及了比较多的计算还有链表和位图的操作，开销比较大，如果每次合并$2^n$大小的块为$2^{n+1}$的小，那么大小为$2^n$的块会减少，如果随后系统又需要$2^n$大小的块，就又要拆分，这样的立即合并和拆分过程无效率。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存分配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下vim简单入门</title>
      <link href="/2019/10/26/vim-use/"/>
      <url>/2019/10/26/vim-use/</url>
      
        <content type="html"><![CDATA[<h4 id="安装vim"><a href="#安装vim" class="headerlink" title="安装vim"></a>安装vim</h4><p>在ubuntu的命令行下输入<code>sudo apt install vim</code> 以获得vim。如遇到报错，可复制报错信息去百度寻找对应解决策略。</p><h4 id="vim的使用"><a href="#vim的使用" class="headerlink" title="vim的使用"></a>vim的使用</h4><p>vim编辑器有三种：命令模式，末行模式，插入模式。</p><p>打开vim时默认的是<strong>命令模式</strong>，此状态下敲击键盘视为输入命令而非字符。若想进入<strong>插入模式</strong>，则要在命令模式下输入 i ，此时可以输入字符，编辑文本；输入完毕后，按ESC可退回到命令模式。<br>命令模式只有一些简单的命令，更多命令需要使用末行模式；在命令模式下输入” : “（不含引号）可进入末行模式，末行模式可以进行更多灵活的操作。</p><p>以上是三种模式的异同以及切换方法。</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>以下复制老师的笔记：</p><p><strong>模式切换</strong></p><ol><li>输入i进入插入模式</li><li>在插入模式中按ESC进入命令模式</li><li>在命令模式中输入 “ : “ 进入末行模式</li></ol><p><strong>保存：</strong></p><ol><li>命令模式中输入ZZ</li><li>在末行模式中输入:wq</li></ol><p><strong>编译：</strong></p><ol><li>g++ -o test test.cpp -Wall</li></ol><p><strong>定位：</strong></p><ol><li>:i 定位到第 i 行</li><li>:/x 定位到x第一次出现的行</li></ol><p><strong>删除行（命令模式下）：</strong></p><ol><li>dd删除当前行</li><li>d2d删除包含当前行的2行，向下的</li></ol><p><strong>撤回：</strong></p><ol><li>命令模式下输入 u</li></ol><p><strong>复制（命令模式下）：</strong></p><ol><li>yy，与dd功能相似</li><li>粘贴时按p</li></ol><h4 id="配置vim"><a href="#配置vim" class="headerlink" title="配置vim"></a>配置vim</h4><p>此时vim可以正常使用，但是界面有些不友好，没有行号，缩进也很难看，更没有自动补全等。<br>我们可以通过在末行模式中输入一些命令来使得界面以及操作更加友好，例如添加行号，设置缩进等，但是这样需要每次打开vim都要重新配置，所以为了方便起见，可以修改配置文件达到自动配置的目的。</p><p>首先通过 <code>cd ~</code> 进入用户根目录，然后<code>vim .vimrc</code> 新建一个隐藏文件<code>.vimrc</code>，并打开编辑；输入如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">set nu          //显示行号</span><br><span class="line">set ts=4        //制表符宽度</span><br><span class="line">set history=1000    </span><br><span class="line">set showmatch   //高亮显示匹配的括号</span><br><span class="line">set ruler       //显示尺寸</span><br><span class="line">set mouse=a     //启用鼠标选择</span><br><span class="line">set autoindent  //自动缩进</span><br><span class="line">set cindent     //自动缩进</span><br><span class="line">set nobackup    //禁止生成临时文件</span><br><span class="line">set smartindent //自动缩进</span><br><span class="line">set shiftwidth=4    //自动缩进的长度</span><br><span class="line">set expandtab   //tab变空格</span><br><span class="line"></span><br><span class="line">//以下是自动补全</span><br><span class="line">inoremap&#123; &#123;&#125;&lt;ESC&gt;i&lt;CR&gt;&lt;ESC&gt;O</span><br><span class="line">inoremap( ()&lt;ESC&gt;i</span><br><span class="line">inoremap[ []&lt;ESC&gt;i</span><br><span class="line">inoremap&apos; &apos;&apos;&lt;ESC&gt;i</span><br><span class="line">inoremap&quot; &quot;&quot;&lt;ESC&gt;i</span><br><span class="line"></span><br><span class="line">set encoding=utf-8</span><br><span class="line">set softtabstop=4</span><br><span class="line"></span><br><span class="line">//定义F6快捷编译运行，在命令模式下</span><br><span class="line">map &lt;F6&gt; :cal CR() &lt;CR&gt;</span><br><span class="line">func! CR()</span><br><span class="line">exec &quot;w&quot;</span><br><span class="line">exec &quot;!g++ % -o %&lt;&quot;</span><br><span class="line">exec &quot;! ./%&lt;&quot;</span><br><span class="line">endfunc</span><br></pre></td></tr></table></figure></p><p>输入完成后按ESC进入命令模式，再 :wq 保存退出即可。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈与单调队列</title>
      <link href="/2019/10/17/ddz/"/>
      <url>/2019/10/17/ddz/</url>
      
        <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>单调栈和单调队列都可以看作是一种对栈和队列的特殊用法，即要求栈或队列中的元素具有单调性，递增或递减。那么很显然这种数据结构就是基于栈和队列实现的，即它既保留了栈的先进后出（队列就是保留先进先出），又具有单调性。而我们在某些时候正需要其这种性质，我们在讲解了单调栈和单调队列的定义、特性、构造方法后，会各给出一道例题来体现它们的用法。</p><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><h5 id="单调栈的概念"><a href="#单调栈的概念" class="headerlink" title="单调栈的概念"></a>单调栈的概念</h5><p>单调栈是一种特殊的栈，栈内的所有元素都保持着单调性，即单调递增或单调递减。</p><h5 id="单调栈的性质"><a href="#单调栈的性质" class="headerlink" title="单调栈的性质"></a>单调栈的性质</h5><ul><li>单调性。若是单调递增栈，则从栈顶到栈底的元素是严格递增的。若是单调递减栈，则从栈顶到栈底的元素是严格递减的。</li><li>靠近栈底的元素先进栈，越靠后的元素越后进栈。</li></ul><p>单调栈和普通的栈一样，都只能在栈顶操作，压入或弹出。而我们需要通过一些约束来使得栈内元素具有单调性，从而构成单调栈。</p><h5 id="构造单调栈"><a href="#构造单调栈" class="headerlink" title="构造单调栈"></a>构造单调栈</h5><p>以单调递增栈为例：对于当前元素e，若e大于栈顶元素，则进栈，否则弹出栈顶元素，再次进行比较，重复直至栈顶元素小于e或栈为空为止，此时将e压入栈。<br>对于弹出的元素，我们并不需要重新压回，因为一般情况下它们都属于被“淘汰”的元素，后面压入的元素一般又“新鲜”又“美味”，即时间上和数值上都比其优秀。</p><h5 id="例题HDU1506"><a href="#例题HDU1506" class="headerlink" title="例题HDU1506"></a>例题HDU1506</h5><p>先思考一个问题，如果题目中的矩形的高度都是单调递增的，如何得到最优解？显然有一个贪心的策略，就是以每一个矩形的高度作为最终大矩形的高度，看最宽能是多少，然后统计最优解。<br>但如果进来的下一矩形比上一个低，它其实相当于限制了之前矩形的高度，那么之前矩形比这个矩形高出的高度在以后的统计中就没有丝毫用处了，如果我们在这个时候把以之前矩形的高度作为最终高度的答案统计掉，那么反正以后的统计和上一个矩形没有关系，还不如把他删除。<br>这样，我们实际上就得到了单调栈的模型，只需要维护一个单调栈，在维护单调性的弹出操作时统计宽度，更新答案即可在O(n) 时间内得到最优解。<br>为了方便把最后剩下的，以及单调递增的矩形也统计进去，我们假设a[n+1]的位置有一个高度为0的矩形，最后将它加入单调栈时他会将所有矩形都弹出，那么答案也就完成最后的更新了。</p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><p>见附录部分code-1</p><h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>单调队列的概念和单调栈类似，只是把先进后出改成先进先出就可以了。其具有先进先出的特性并且队列中元素具有单调性。<br>单调是一种思想，当我们解决问题的时候发现有许多冗杂无用的状态时，我们可以采用单调思想，用单调队列或类似于单调队列的方法去除冗杂状态，保存我们想要的状态。</p><h5 id="单调队列的性质"><a href="#单调队列的性质" class="headerlink" title="单调队列的性质"></a>单调队列的性质</h5><ul><li>单调队列的最优选择在队首。</li><li>队列元素具有单调性。</li><li>去除冗余状态（无用状态）。</li><li>维护区间最值。</li></ul><h5 id="单调队列的构造方法"><a href="#单调队列的构造方法" class="headerlink" title="单调队列的构造方法"></a>单调队列的构造方法</h5><ul><li>维护队首（对于上题就是如果队首已经是当前元素的m个之前，则队首就应该被删了,head++）</li><li>在队尾插入（每插入一个就要从队尾开始往前去除冗杂状态，保持单调性）</li></ul><p>假如对于序列A：a1,  a2 , … an 建立一个单调递减栈维护长度为m的字段最大值，那么对于当前元素e，若队首元素小于e，那么其位置上不占优势（要被踢出长度为m的字段），而且其数值上也不占优势（比新来的e要小），所以其就要被舍弃。重复这一操作，直至队首元素大于元素e，那么说明其还有用，就保留。<br>举个应用例子：</p><p>数列为：6 4 10 10 8 6 4 2 12 14<br>N=10,K=3;<br>那么我们构造一个长度为3的单调递减队列：<br>首先，那6和它的位置0放入队列中，我们用(6,0)表示，每一步插入元素时队列中的元素如下<br>插入6：(6,0);<br>插入4：(6,0),(4,1);<br>插入10：(10,2);<br>插入第二个10，保留后面那个：(10,3);<br>插入8：(10,3),(8,4);<br>插入6：(10,3),(8,4),(6,5);<br>插入4，之前的10已经超出范围所以排掉：(8,4),(6,5),(4,6);<br>插入2，同理：(6,5),(4,6),(2,7);<br>插入12：(12,8);<br>插入14：(14,9);<br>那么f(i)就是第i步时队列当中的首元素：6,6,10,10,10,10,8,6,12,14同理，最小值也可以用单调队列来做。</p><h5 id="例题Poj-2823"><a href="#例题Poj-2823" class="headerlink" title="例题Poj 2823"></a>例题Poj 2823</h5><p>给定一个数列，从左至右输出每个长度为m的数列段内的最小数和最大数。数列长度：$N&lt;=10^6，m&lt;=N$<br><strong>解题思路：</strong><br>我们知道，暴力枚举的过程中，有一个地方是重复比较了，就是在找当前的f(i)的时候，i的前面其它m-1个数在算f(i-1)的时候我们就比较过了。当你一个个往下找时，每一次都是少一个然后多一个，如果少的不是最大值，然后再问新加进来的，看起来很省时间对吧，那么如果少了的是最大值呢？第二个最大值是什么？？那么我们能不能保存上一次的结果呢？当然主要是i的前k-1个数中的最大值了。答案是可以，这就要用到单调队列。</p><h5 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h5><p>见附录部分code-2</p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><h5 id="code-1：-HDU1506"><a href="#code-1：-HDU1506" class="headerlink" title="code-1： HDU1506"></a>code-1： HDU1506</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],n,Stack[N],w[N];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="function">ll <span class="title">max</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(Stack,<span class="number">0</span>,<span class="keyword">sizeof</span> Stack);</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;ans = <span class="number">0</span>;a[n+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(Stack[top] &lt; a[i])&#123;</span><br><span class="line">Stack[++top] = a[i];</span><br><span class="line">w[top] = <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">ll sumw = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(Stack[top] &gt; a[i])&#123;</span><br><span class="line">sumw += w[top];</span><br><span class="line">ans = max(ans,sumw*Stack[top]);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line">Stack[++top] = a[i];w[top] = sumw + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="code-2-Poj2823"><a href="#code-2-Poj2823" class="headerlink" title="code-2 Poj2823"></a>code-2 Poj2823</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;v[<span class="number">1010000</span>]; <span class="comment">//x表示值，y表示位置 可以理解为下标</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1010000</span>],n,m,mx[<span class="number">1010000</span>],mn[<span class="number">1010000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,head=<span class="number">1</span>,tail=<span class="number">0</span>;<span class="comment">// 默认起始位置为1 因为插入是v[++tail]故初始化为0</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail &amp;&amp; v[tail].x&gt;=a[i]) tail--;</span><br><span class="line">        v[++tail].x=a[i],v[tail].y=i;</span><br><span class="line">                <span class="comment">// 根据题目 前m-1个先直接进入队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail &amp;&amp; v[tail].x&gt;=a[i]) tail--;</span><br><span class="line">        v[++tail].x=a[i],v[tail].y=i;</span><br><span class="line">        <span class="keyword">while</span>(v[head].y&lt;i-m+<span class="number">1</span>) head++;</span><br><span class="line">        mn[i-m+<span class="number">1</span>]=v[head].x;</span><br><span class="line">               <span class="comment">// 道理同上，当然了 要把已经超出范围的从head开始排出</span></span><br><span class="line">               <span class="comment">//  然后每个队首则是目前m个数的最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmax</span><span class="params">()</span> <span class="comment">//最大值同最小值的道理，只不过是维护的是递减队列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail &amp;&amp; v[tail].x&lt;=a[i]) tail--;</span><br><span class="line">        v[++tail].x=a[i],v[tail].y=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail &amp;&amp; v[tail].x&lt;=a[i]) tail--;</span><br><span class="line">        v[++tail].x=a[i],v[tail].y=i;</span><br><span class="line">        <span class="keyword">while</span>(v[head].y&lt;i-m+<span class="number">1</span>) head++;</span><br><span class="line">        mx[i-m+<span class="number">1</span>]=v[head].x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    getmin();</span><br><span class="line">    getmax();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n-m+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"%d"</span>,mn[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" %d"</span>,mn[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n-m+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"%d"</span>,mx[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" %d"</span>,mx[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀数组题集</title>
      <link href="/2019/10/17/lcp-problems/"/>
      <url>/2019/10/17/lcp-problems/</url>
      
        <content type="html"><![CDATA[<p>sa[i]：排名为i的后缀起始位置是多少。<br>rank[i]：从 i 位置起始的后缀在所有后缀中字典序排序后序号，与sa互逆。<br>lcp[i]：S[sa[i] ,…] 与 S[sa[i+1] , …]的最长公共前缀。</p><h4 id="Musical-Theme"><a href="#Musical-Theme" class="headerlink" title="Musical Theme"></a>Musical Theme</h4><p><a href="http://poj.org/problem?id=1743" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给n个数组成的串，求是否有多个“相似”且不重叠的子串的长度大于等于5，两个子串相似当且仅当长度相等且每一位的数字差都相等。</p><p><strong>解题思路</strong><br>本题题意有些难理解。就是利用后缀数组+高度数组解决最长不重复子串问题，解法很套路，就是二分+判断。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POJ1743</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sa[N],rk[N],lcp[N],tmp[N];</span><br><span class="line"><span class="keyword">int</span> len,k;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= len?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= len?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line">len = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; len?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+len,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]]+compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j + h &lt; len &amp;&amp; i + h &lt; len;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(lcp[<span class="number">1</span>] &gt;= x) pre = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!pre &amp;&amp; lcp[i] &gt;= x) pre = i;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= x)<span class="comment">//注意一下到底是i还是i-1</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(sa[pre] - sa[i]) &gt; x) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(a,sa);</span><br><span class="line">construct_lcp(a,sa,lcp);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = n;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(++r &lt; <span class="number">5</span>) r = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n)&#123;</span><br><span class="line"><span class="comment">//注意，该模板必须从下标0开始存！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) b[i] = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) a[i] = b[i]-b[i<span class="number">-1</span>]+<span class="number">100</span>;</span><br><span class="line">a[<span class="number">0</span>] = b[<span class="number">0</span>]+<span class="number">100</span>; solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Milk-Patterns"><a href="#Milk-Patterns" class="headerlink" title="Milk Patterns"></a>Milk Patterns</h4><p><a href="http://poj.org/problem?id=3261" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>求可重叠的，出现k次的最长重复子串。<br><strong>解题思路</strong><br>这个就是可重叠的最长重复子串了，要求求出最长的，重复出现k次以上的子串，通过题意以及样例观察可知，是允许子串重复的。解决方法和上题类似，也是后缀数组+二分。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POJ3261</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,a[N],kk;</span><br><span class="line"><span class="keyword">int</span> rk[N],sa[N],lcp[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//别把全局变量的k覆盖了！！！</span></span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= x) cnt++;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt &gt;= kk) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt &gt;= kk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(a,sa);</span><br><span class="line">construct_lcp(a,sa,lcp);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line"><span class="comment">//for(int i = 1;i &lt;= n;i++) printf("%d ",lcp[i]);</span></span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;kk) != EOF)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="不同子串的个数"><a href="#不同子串的个数" class="headerlink" title="不同子串的个数"></a>不同子串的个数</h4><p><a href="https://www.luogu.org/problem/P2408" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给定一个字符串，求其所有子串中，不同的子串数量。</p><p><strong>解题思路</strong><br>利用后缀数组+高度数组求解。已知高度数组lcp，那么首先可以知道第一个sa[1]有n - sa[1]个不同子串；而2~n，每个sa[i] 有 n - sa[i] - lcp[i-1] 个不同子串。累加即可，注意结果可能爆 int。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P2408不同子串的个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> sa[N],lcp[N],tmp[N],k,rk[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line">sum = n - sa[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">sum += n - sa[i] - lcp[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line">construct_lcp(str,sa,lcp);</span><br><span class="line">calc();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">freopen(<span class="string">"123.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"222.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Substring"><a href="#Substring" class="headerlink" title="Substring"></a>Substring</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5769" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给定一个字符串，求所有不同的，且包含<strong>字符x</strong>的子串数量。</p><p><strong>解题思路</strong><br>和上一题有些类似，但是我们需要确保每一个被统计的子串包含字符x。那么我们可以用一个数组pos[p]来记录 p 后面第一个字符 x 的位置，那么我们从头开始统计时，sa[1]有n - pos[ sa[1] ] 个合法子串，其它位置有 n - max(pos[ sa[i] ] , sa[i] + lcp[i])个合法子串，将它们累加起来即可。<br>这题选G++编译器就超时，选C++就可以通过，猜测可能和STL有关。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hdu5769,G++超时,C++AC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">char</span> str[N],lv[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> rk[N],sa[N],lcp[N],tmp[N],k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pos[N];<span class="comment">//pos[x]:x后面第一个lv出现的位置</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line">construct_lcp(str,sa,lcp);</span><br><span class="line">pos[n] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(str[i] == lv[<span class="number">0</span>]) pos[i] = i;</span><br><span class="line"><span class="keyword">else</span> pos[i] = pos[i+<span class="number">1</span>];</span><br><span class="line">sum = n - pos[sa[<span class="number">1</span>]];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">sum += n - max(pos[sa[i]],sa[i]+lcp[i<span class="number">-1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>,++idx,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">freopen(<span class="string">"123.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"222.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,lv,str);</span><br><span class="line">n = <span class="built_in">strlen</span>(str);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Life-Forms"><a href="#Life-Forms" class="headerlink" title="Life Forms"></a>Life Forms</h4><p><a href="http://poj.org/problem?id=3294" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给定n个字符串，请问它们之间出现次数超过一半的最长公共子串是什么？如果有多个，按字典序输出。</p><p><strong>解题思路</strong><br>利用后缀数组+高度数组求解。我们将n个字符串拼接中一个“母串”，中间用不同的字符间隔；然后对母串求高度数组lcp，我们依旧是用二分搜索判定长度p是否合法，每次判定从前向后用O(N)时间遍历统计一遍即可。当我们得到最长的合法长度 p 后，再利用类似的方法输出所有的子串。</p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> str,s;</span><br><span class="line"><span class="keyword">int</span> n,k,len;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> sa[N],rk[N],lcp[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line">    <span class="keyword">int</span> ri = i+k &lt;= len?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> rj = j+k &lt;= len?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="built_in">string</span> S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line">    len = S.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line">        sa[i] = i;</span><br><span class="line">        rk[i] = i &lt; len ? S[i]:<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//k一定不能设置成局部变量导致覆盖全局变量！！！</span></span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= len;k *= <span class="number">2</span>)&#123;</span><br><span class="line">        sort(sa,sa+len+<span class="number">1</span>,compare_sa);</span><br><span class="line">        tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++)</span><br><span class="line">            tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="built_in">string</span> S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line">    len = S.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line">        <span class="keyword">for</span>(;j+h &lt; len &amp;&amp; i+h &lt; len;h++)</span><br><span class="line">            <span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">        lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">110</span>],idx[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    vis[idx[sa[<span class="number">1</span>]]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &lt; p)&#123;</span><br><span class="line">            cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!vis[idx[sa[i]]]) cnt++,vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= n/<span class="number">2</span>+<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    vis[idx[sa[<span class="number">1</span>]]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= len+<span class="number">1</span>;i++)&#123;  <span class="comment">//lcp[len+1] = 0,作为结束标志</span></span><br><span class="line">        <span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &lt; p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt;= n/<span class="number">2</span>+<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = sa[i<span class="number">-1</span>];j &lt; sa[i<span class="number">-1</span>]+p;j++) <span class="built_in">cout</span> &lt;&lt; str[j];</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!vis[idx[sa[i]]]) cnt++,vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    construct_sa(str,sa);</span><br><span class="line">    construct_lcp(str,sa,lcp);</span><br><span class="line">    <span class="comment">/*sa[i]：存放排名第i的后缀的起始位置*/</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"?"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> print(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; str; <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">2</span>,tot = <span class="number">0</span>; str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s; str += s+<span class="keyword">char</span>(++cnt);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= s.length();j++) idx[tot++] = i;</span><br><span class="line">        &#125; </span><br><span class="line">        solve();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Maximum-repetition-substring"><a href="#Maximum-repetition-substring" class="headerlink" title="Maximum repetition substring"></a>Maximum repetition substring</h4><p><strong>题意简述</strong><br>求一个字符串中，重复次数最多的连续重复子串是什么（循环次数最多的循环子串）。要求输出字典序最小的。</p><p>例如：ccabababc中，连续循环次数最多的子串是ababab。</p><p><strong>解题思路</strong><br>这题我对照题解写了很久，思想勉强搞懂。<br>先说做法，是枚举长度len（从1到n），然后判断以 len 为循环长度的 连续循环次数 最多的 子串 长度 是多少；假设这个子串长度是 l ，那么它的连续循环次数就是 l/len。<br>我们考虑如何求子串长度 l 。如果有一个字符串的循环节长度为len，那么必然有s[1,n-len] = s[len , n]，因此，如果字符串 s[len, n] 与 s[ 2 <em> len, n] 的公共前缀长度为 lcp，那么 s[len ,n] 的循环节个数为lcp / len + 1（加上的一个是开头为计算在lcp内的循环节 ）。<br>因此我们只需要对s[0] , s[len] ,s[2 </em> len] … , 判断相差 len 的两个相邻后缀的 lcp，就可以计算该子串循环节个数。这是由于如果一个子串的循环节长度为 len，且循环至少两次，那么显然它会包含相邻的两个len，否则就构不成循环了。当然可能起点并不在len的倍数位置上，因此我们还需要向前拓展一下。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> cse = <span class="number">0</span>,n;</span><br><span class="line"><span class="keyword">int</span> k,rk[N],lcp[N],sa[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]]+compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>],Log[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = lcp[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)</span><br><span class="line">st[i][j] = min(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &gt; r) swap(l,r); r--;</span><br><span class="line"><span class="keyword">int</span> kk = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> min(st[l][kk],st[r-(<span class="number">1</span>&lt;&lt;kk)+<span class="number">1</span>][kk]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mxtc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> q[N],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i+len &lt; n;i += len)&#123;</span><br><span class="line"><span class="keyword">int</span> l = ask(rk[i],rk[i+len]);</span><br><span class="line"><span class="keyword">int</span> res = l/len+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> pre = i - (len-l%len);</span><br><span class="line"><span class="keyword">if</span>(pre &gt;= <span class="number">0</span> &amp;&amp; ask(rk[pre],rk[pre+len]) &gt;= len) res++;</span><br><span class="line"><span class="keyword">if</span>(mxtc &lt; res) mxtc = res,cnt = <span class="number">0</span>,q[++cnt] = len;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(mxtc == res &amp;&amp; len != q[cnt]) q[++cnt] = len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAns</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= cnt;j++)</span><br><span class="line"><span class="keyword">if</span>(ask(rk[sa[i]],rk[sa[i]+q[j]]) &gt;= q[j]*(mxtc<span class="number">-1</span>))&#123;</span><br><span class="line">str[sa[i]+q[j]*mxtc] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">puts</span>(str+sa[i]); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line">construct_lcp(str,sa,lcp);<span class="comment">//lcp[n]是恒等于0的</span></span><br><span class="line"><span class="comment">/*下一步求重复次数最多的连续重复子串*/</span></span><br><span class="line">st_init();</span><br><span class="line">mxtc = cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) calc(i); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: "</span>,++cse);</span><br><span class="line">printAns();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str) != EOF)&#123;</span><br><span class="line">n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span> &amp;&amp; str[<span class="number">0</span>] == <span class="string">'#'</span>) <span class="keyword">break</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Common-Substrings"><a href="#Common-Substrings" class="headerlink" title="Common Substrings"></a>Common Substrings</h4><p><a href="http://poj.org/problem?id=3415" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给定2个字符串A和B，以及一个整数k。目标是求出这两个字符串中公共子串的数量，例如A:xx , B:xx，k = 1，那么公共子串数量就是5。<br><strong>解题思路</strong><br>将A和B拼接在一起，中间用一个未出现过的字符间隔，新串S = A+’#’+B；然后对S求高度数组，利用高度数组来求解。<br>对于属于 B 的每一个后缀，统计它与所有属于 A 的后缀的 lcp（最长公共前缀），并统计lcp-m+1，这就是该后缀和 A 的公共子串数量。这样做的复杂度是O(N^2)。</p><p>我们可以利用单调栈来在 O(N) 时间内解决；我们从前向后遍历lcp数组，将属于A的后缀的 lcp 压入栈；由于两个字符串的后缀是取它们中间的最小值，所以我们应该维护单调递减栈，同时需要维护的是 sum，sum代表当前 A 中相同的子串数量，也就是说如果当前后缀属于 B ，则直接加上sum即可。</p><p>由于我们是顺序遍历的，只统计了A对B的贡献，再反过来统计一次B对A的贡献即可。<br><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> A[N],B[N];</span><br><span class="line"><span class="keyword">int</span> rk[N],tmp[N],lcp[N],sa[N],k;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = i+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j =sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> idx[N];<span class="comment">//初始化为0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ll h,cnt;</span><br><span class="line">&#125;Stack[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(A,sa);</span><br><span class="line">construct_lcp(A,sa,lcp);</span><br><span class="line">ll ans = <span class="number">0</span>,sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ll cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top &amp;&amp; Stack[top].h &gt;= lcp[i<span class="number">-1</span>])&#123;</span><br><span class="line">cnt += Stack[top].cnt;</span><br><span class="line">sum -= Stack[top].cnt * (Stack[top].h-m+<span class="number">1</span>);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= m)&#123;</span><br><span class="line">cnt += idx[sa[i<span class="number">-1</span>]] == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt) Stack[++top] = Node&#123;lcp[i<span class="number">-1</span>],cnt&#125;;</span><br><span class="line">sum += (lcp[i<span class="number">-1</span>]-m+<span class="number">1</span>)*cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(idx[sa[i]] == <span class="number">1</span>) ans += sum;</span><br><span class="line">&#125;</span><br><span class="line">top = <span class="number">0</span>; sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ll cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top &amp;&amp; Stack[top].h &gt;= lcp[i<span class="number">-1</span>])&#123;</span><br><span class="line">cnt += Stack[top].cnt;</span><br><span class="line">sum -= Stack[top].cnt * (Stack[top].h-m+<span class="number">1</span>);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= m)&#123;</span><br><span class="line">cnt += idx[sa[i<span class="number">-1</span>]] == <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt) Stack[++top] = Node&#123;lcp[i<span class="number">-1</span>],cnt&#125;;</span><br><span class="line">sum += (lcp[i<span class="number">-1</span>]-m+<span class="number">1</span>)*cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!idx[sa[i]]) ans += sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m) != EOF &amp;&amp; m)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,A);</span><br><span class="line"><span class="built_in">memset</span>(idx,<span class="number">0</span>,<span class="keyword">sizeof</span> idx);</span><br><span class="line">n = <span class="built_in">strlen</span>(A); </span><br><span class="line">idx[n] = <span class="number">2</span>; A[n++] = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) idx[i] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,A+n);</span><br><span class="line">n = <span class="built_in">strlen</span>(A);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀数组的常见应用</title>
      <link href="/2019/10/17/lcp-use/"/>
      <url>/2019/10/17/lcp-use/</url>
      
        <content type="html"><![CDATA[<h3 id="后缀数组的应用"><a href="#后缀数组的应用" class="headerlink" title="后缀数组的应用"></a>后缀数组的应用</h3><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>后缀数组是处理字符串相关问题的有力工具，后缀数组的题型与解法相对固定，因此对于本文中的几种题型要掌握解法与原理。本文假设读者已经掌握求后缀数组（sa）以及高度数组（lcp）的算法。<br>本文将介绍4类后缀数组的应用，分别是：</p><ul><li>最长公共前缀</li><li>单个字符串相关问题</li><li>两个字符串相关问题</li><li>多个字符串相关问题<h4 id="相关符号说明"><a href="#相关符号说明" class="headerlink" title="相关符号说明"></a>相关符号说明</h4>S 是原字符串。<br>suffix( i )表示字符串 S 从位置 i 开始的后缀。<br>sa( i )表示排名为第 i 的后缀的起始位置。<br>rk( i )表示 起始位置为 i 的后缀的排名。<br>lcp( i )表示排名为 i 的后缀与排名为 i+1 的后缀的最长公共前缀的长度。</li></ul><h4 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h4><p><strong>例1：</strong> 给定一个字符串，询问某两个后缀的最长公共前缀。<br><strong>解题思路：</strong><br>我们已经知道lcp[ i ]是排名为 i 的后缀与排名为 i+1 的后缀的最长公共前缀的长度，而我们又可以通过sa数组来得到任意俩个后缀的排名，因此对于给定的两个后缀，我们可以先求出它们的排名，分别设为 i 和 j （i &lt;= j），那么ans = min{ lcp[i] , lcp[i+1] , … , lcp[j - 1] }，也就相当于求RMQ问题，所以接下来的询问可以当做RMQ问题来采用合适的算法（例如st表）。</p><h4 id="单个字符串相关问题"><a href="#单个字符串相关问题" class="headerlink" title="单个字符串相关问题"></a>单个字符串相关问题</h4><p>这类问题的一个常用做法是先求后缀数组和lcp数组，然后利用lcp数组求解。</p><h5 id="重复子串问题"><a href="#重复子串问题" class="headerlink" title="重复子串问题"></a>重复子串问题</h5><p><strong>重复子串：</strong> 字符串R在字符串L中至少出现两次，则称 R 是 L 的重复子串。</p><p><strong>例2：可重叠最长重复子串</strong><br>给定一个字符串，求最长重复子串，这两个子串可以重叠。<br><strong>解题思路：</strong><br>求最长重复子串，等价于求两个后缀的最长公共前缀的最大值。于是我们只需要求出lcp数组中的最大值即可。由于任意两个后缀的最长公共前缀一定是lcp数组中某一段的最小值，那么这个值一定不大于lcp数组里的最大值。所以最长重复子串的长度就是lcp数组里的最大值。该做法时间复杂度为O(N)。</p><p><strong>例3：不可重叠最长重复子串</strong><br>给定一个字符串，求最长重复子串，这两个子串不能重叠。<br><strong>Musical Theme</strong><br><a href="http://poj.org/problem?id=1743" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给n个数组成的串，求是否有多个“相似”且不重叠的子串的长度大于等于5，两个子串相似当且仅当长度相等且每一位的数字差都相等。</p><p><strong>解题思路</strong><br>本题题意有些难理解。就是利用后缀数组+高度数组解决最长不重复子串问题，解法很套路，就是二分+判断。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POJ1743</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sa[N],rk[N],lcp[N],tmp[N];</span><br><span class="line"><span class="keyword">int</span> len,k;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= len?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= len?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line">len = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; len?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+len,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]]+compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j + h &lt; len &amp;&amp; i + h &lt; len;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(lcp[<span class="number">1</span>] &gt;= x) pre = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!pre &amp;&amp; lcp[i] &gt;= x) pre = i;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= x)<span class="comment">//注意一下到底是i还是i-1</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(sa[pre] - sa[i]) &gt; x) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(a,sa);</span><br><span class="line">construct_lcp(a,sa,lcp);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = n;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(++r &lt; <span class="number">5</span>) r = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n)&#123;</span><br><span class="line"><span class="comment">//注意，该模板必须从下标0开始存！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) b[i] = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) a[i] = b[i]-b[i<span class="number">-1</span>]+<span class="number">100</span>;</span><br><span class="line">a[<span class="number">0</span>] = b[<span class="number">0</span>]+<span class="number">100</span>; solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>例4：可重叠的k次最长重复子串POJ3261</strong><br><a href="http://poj.org/problem?id=3261" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>求可重叠的，出现k次的最长重复子串。<br><strong>解题思路</strong><br>这个就是可重叠的最长重复子串了，要求求出最长的，重复出现k次以上的子串，通过题意以及样例观察可知，是允许子串重复的。解决方法和上题类似，也是后缀数组+二分。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POJ3261</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,a[N],kk;</span><br><span class="line"><span class="keyword">int</span> rk[N],sa[N],lcp[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//别把全局变量的k覆盖了！！！</span></span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= x) cnt++;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt &gt;= kk) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt &gt;= kk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(a,sa);</span><br><span class="line">construct_lcp(a,sa,lcp);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line"><span class="comment">//for(int i = 1;i &lt;= n;i++) printf("%d ",lcp[i]);</span></span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;kk) != EOF)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="子串的个数"><a href="#子串的个数" class="headerlink" title="子串的个数"></a>子串的个数</h5><p><strong>例5：求不同子串的个数</strong><br><strong>题意简述</strong><br>给定一个字符串，求其所有子串中，不同的子串数量。<br><strong>解题思路</strong><br>利用后缀数组+高度数组求解。已知高度数组lcp，那么首先可以知道第一个sa[1]有n - sa[1]个不同子串；而2~n，每个sa[i] 有 n - sa[i] - lcp[i-1] 个不同子串。累加即可，注意结果可能爆 int。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P2408不同子串的个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> sa[N],lcp[N],tmp[N],k,rk[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line">sum = n - sa[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">sum += n - sa[i] - lcp[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line">construct_lcp(str,sa,lcp);</span><br><span class="line">calc();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">freopen(<span class="string">"123.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"222.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h5><p><strong>例6：求最长回文子串</strong></p><p>穷举每一位，然后计算以这个字符为中心的最长回文子串。注意这里要对长度分奇偶讨论。两种情况都可以转化为求一个后缀和一个反过来写的后缀的最长公共前缀。具体做法是：将整个字符反过来放在原字符串后面，中间用一个特殊字符隔开，这样就转化为了求新串的某两个后缀的最长公共前缀。</p><h5 id="连续重复子串"><a href="#连续重复子串" class="headerlink" title="连续重复子串"></a>连续重复子串</h5><p><strong>例7：重复次数最多的连续子串</strong><br><strong>Maximum repetition substring</strong><br><strong>题意简述</strong><br>求一个字符串中，重复次数最多的连续重复子串是什么（循环次数最多的循环子串）。要求输出字典序最小的。</p><p>例如：ccabababc中，连续循环次数最多的子串是ababab。</p><p><strong>解题思路</strong><br>这题我对照题解写了很久，思想勉强搞懂。<br>先说做法，是枚举长度len（从1到n），然后判断以 len 为循环长度的 连续循环次数 最多的 子串 长度 是多少；假设这个子串长度是 l ，那么它的连续循环次数就是 l/len。<br>我们考虑如何求子串长度 l 。如果有一个字符串的循环节长度为len，那么必然有s[1,n-len] = s[len , n]，因此，如果字符串 s[len, n] 与 s[ 2 <em> len, n] 的公共前缀长度为 lcp，那么 s[len ,n] 的循环节个数为lcp / len + 1（加上的一个是开头为计算在lcp内的循环节 ）。<br>因此我们只需要对s[0] , s[len] ,s[2 </em> len] … , 判断相差 len 的两个相邻后缀的 lcp，就可以计算该子串循环节个数。这是由于如果一个子串的循环节长度为 len，且循环至少两次，那么显然它会包含相邻的两个len，否则就构不成循环了。当然可能起点并不在len的倍数位置上，因此我们还需要向前拓展一下。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> cse = <span class="number">0</span>,n;</span><br><span class="line"><span class="keyword">int</span> k,rk[N],lcp[N],sa[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]]+compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>],Log[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = lcp[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)</span><br><span class="line">st[i][j] = min(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &gt; r) swap(l,r); r--;</span><br><span class="line"><span class="keyword">int</span> kk = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> min(st[l][kk],st[r-(<span class="number">1</span>&lt;&lt;kk)+<span class="number">1</span>][kk]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mxtc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> q[N],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i+len &lt; n;i += len)&#123;</span><br><span class="line"><span class="keyword">int</span> l = ask(rk[i],rk[i+len]);</span><br><span class="line"><span class="keyword">int</span> res = l/len+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> pre = i - (len-l%len);</span><br><span class="line"><span class="keyword">if</span>(pre &gt;= <span class="number">0</span> &amp;&amp; ask(rk[pre],rk[pre+len]) &gt;= len) res++;</span><br><span class="line"><span class="keyword">if</span>(mxtc &lt; res) mxtc = res,cnt = <span class="number">0</span>,q[++cnt] = len;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(mxtc == res &amp;&amp; len != q[cnt]) q[++cnt] = len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAns</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= cnt;j++)</span><br><span class="line"><span class="keyword">if</span>(ask(rk[sa[i]],rk[sa[i]+q[j]]) &gt;= q[j]*(mxtc<span class="number">-1</span>))&#123;</span><br><span class="line">str[sa[i]+q[j]*mxtc] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">puts</span>(str+sa[i]); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line">construct_lcp(str,sa,lcp);<span class="comment">//lcp[n]是恒等于0的</span></span><br><span class="line"><span class="comment">/*下一步求重复次数最多的连续重复子串*/</span></span><br><span class="line">st_init();</span><br><span class="line">mxtc = cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) calc(i); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: "</span>,++cse);</span><br><span class="line">printAns();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str) != EOF)&#123;</span><br><span class="line">n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span> &amp;&amp; str[<span class="number">0</span>] == <span class="string">'#'</span>) <span class="keyword">break</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="两个字符串相关问题"><a href="#两个字符串相关问题" class="headerlink" title="两个字符串相关问题"></a>两个字符串相关问题</h4><p>这类问题的一个常用做法是，先连接这两个字符串，然后求后缀数组和高度数组，再利用高度数组求解。</p><h5 id="公共子串"><a href="#公共子串" class="headerlink" title="公共子串"></a>公共子串</h5><p><strong>例8：公共子串的数量：Common Substrings</strong></p><p><strong>题意简述</strong><br>给定2个字符串A和B，以及一个整数k。目标是求出这两个字符串中公共子串的数量，例如A:xx , B:xx，k = 1，那么公共子串数量就是5。<br><strong>解题思路</strong><br>将A和B拼接在一起，中间用一个未出现过的字符间隔，新串S = A+’#’+B；然后对S求高度数组，利用高度数组来求解。<br>对于属于 B 的每一个后缀，统计它与所有属于 A 的后缀的 lcp（最长公共前缀），并统计lcp-m+1，这就是该后缀和 A 的公共子串数量。这样做的复杂度是O(N^2)。</p><p>我们可以利用单调栈来在 O(N) 时间内解决；我们从前向后遍历lcp数组，将属于A的后缀的 lcp 压入栈；由于两个字符串的后缀是取它们中间的最小值，所以我们应该维护单调递减栈，同时需要维护的是 sum，sum代表当前 A 中相同的子串数量，也就是说如果当前后缀属于 B ，则直接加上sum即可。</p><p>由于我们是顺序遍历的，只统计了A对B的贡献，再反过来统计一次B对A的贡献即可。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> A[N],B[N];</span><br><span class="line"><span class="keyword">int</span> rk[N],tmp[N],lcp[N],sa[N],k;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = i+k &lt;= n?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rk[i] = i &lt; n?S[i]:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+<span class="number">1</span>+n,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j =sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j+h &lt; n &amp;&amp; i+h &lt; n;h++)</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> idx[N];<span class="comment">//初始化为0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ll h,cnt;</span><br><span class="line">&#125;Stack[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">construct_sa(A,sa);</span><br><span class="line">construct_lcp(A,sa,lcp);</span><br><span class="line">ll ans = <span class="number">0</span>,sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ll cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top &amp;&amp; Stack[top].h &gt;= lcp[i<span class="number">-1</span>])&#123;</span><br><span class="line">cnt += Stack[top].cnt;</span><br><span class="line">sum -= Stack[top].cnt * (Stack[top].h-m+<span class="number">1</span>);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= m)&#123;</span><br><span class="line">cnt += idx[sa[i<span class="number">-1</span>]] == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt) Stack[++top] = Node&#123;lcp[i<span class="number">-1</span>],cnt&#125;;</span><br><span class="line">sum += (lcp[i<span class="number">-1</span>]-m+<span class="number">1</span>)*cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(idx[sa[i]] == <span class="number">1</span>) ans += sum;</span><br><span class="line">&#125;</span><br><span class="line">top = <span class="number">0</span>; sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ll cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top &amp;&amp; Stack[top].h &gt;= lcp[i<span class="number">-1</span>])&#123;</span><br><span class="line">cnt += Stack[top].cnt;</span><br><span class="line">sum -= Stack[top].cnt * (Stack[top].h-m+<span class="number">1</span>);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &gt;= m)&#123;</span><br><span class="line">cnt += idx[sa[i<span class="number">-1</span>]] == <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt) Stack[++top] = Node&#123;lcp[i<span class="number">-1</span>],cnt&#125;;</span><br><span class="line">sum += (lcp[i<span class="number">-1</span>]-m+<span class="number">1</span>)*cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!idx[sa[i]]) ans += sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m) != EOF &amp;&amp; m)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,A);</span><br><span class="line"><span class="built_in">memset</span>(idx,<span class="number">0</span>,<span class="keyword">sizeof</span> idx);</span><br><span class="line">n = <span class="built_in">strlen</span>(A); </span><br><span class="line">idx[n] = <span class="number">2</span>; A[n++] = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) idx[i] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,A+n);</span><br><span class="line">n = <span class="built_in">strlen</span>(A);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="多个字符串相关问题"><a href="#多个字符串相关问题" class="headerlink" title="多个字符串相关问题"></a>多个字符串相关问题</h4><p>这类问题的一个常用做法是，先将所有的字符串连接起来，然后求后缀数组和高度数组，再利用高度数组进行求解。中间可能还要利用二分答案。</p><p><strong>例9：不小于k个字符串中的最长子串。</strong></p><p><strong>Life Forms</strong><br><a href="http://poj.org/problem?id=3294" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述</strong><br>给定n个字符串，请问它们之间出现次数超过一半的最长公共子串是什么？如果有多个，按字典序输出。</p><p><strong>解题思路</strong><br>利用后缀数组+高度数组求解。我们将n个字符串拼接中一个“母串”，中间用不同的字符间隔；然后对母串求高度数组lcp，我们依旧是用二分搜索判定长度p是否合法，每次判定从前向后用O(N)时间遍历统计一遍即可。当我们得到最长的合法长度 p 后，再利用类似的方法输出所有的子串。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> str,s;</span><br><span class="line"><span class="keyword">int</span> n,k,len;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> sa[N],rk[N],lcp[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line">    <span class="keyword">int</span> ri = i+k &lt;= len?rk[i+k]:<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> rj = j+k &lt;= len?rk[j+k]:<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="built_in">string</span> S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line">    len = S.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line">        sa[i] = i;</span><br><span class="line">        rk[i] = i &lt; len ? S[i]:<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//k一定不能设置成局部变量导致覆盖全局变量！！！</span></span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= len;k *= <span class="number">2</span>)&#123;</span><br><span class="line">        sort(sa,sa+len+<span class="number">1</span>,compare_sa);</span><br><span class="line">        tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++)</span><br><span class="line">            tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + compare_sa(sa[i<span class="number">-1</span>],sa[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="built_in">string</span> S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line">    len = S.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>; lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = sa[rk[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line">        <span class="keyword">for</span>(;j+h &lt; len &amp;&amp; i+h &lt; len;h++)</span><br><span class="line">            <span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">        lcp[rk[i]<span class="number">-1</span>] = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">110</span>],idx[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    vis[idx[sa[<span class="number">1</span>]]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &lt; p)&#123;</span><br><span class="line">            cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!vis[idx[sa[i]]]) cnt++,vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= n/<span class="number">2</span>+<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    vis[idx[sa[<span class="number">1</span>]]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= len+<span class="number">1</span>;i++)&#123;  <span class="comment">//lcp[len+1] = 0,作为结束标志</span></span><br><span class="line">        <span class="keyword">if</span>(lcp[i<span class="number">-1</span>] &lt; p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt;= n/<span class="number">2</span>+<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = sa[i<span class="number">-1</span>];j &lt; sa[i<span class="number">-1</span>]+p;j++) <span class="built_in">cout</span> &lt;&lt; str[j];</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt = <span class="number">1</span>; <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!vis[idx[sa[i]]]) cnt++,vis[idx[sa[i]]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    construct_sa(str,sa);</span><br><span class="line">    construct_lcp(str,sa,lcp);</span><br><span class="line">    <span class="comment">/*sa[i]：存放排名第i的后缀的起始位置*/</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"?"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> print(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; str; <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">2</span>,tot = <span class="number">0</span>; str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s; str += s+<span class="keyword">char</span>(++cnt);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= s.length();j++) idx[tot++] = i;</span><br><span class="line">        &#125; </span><br><span class="line">        solve();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>罗穗骞，后缀数组——处理字符串的有利工具，2009.1</li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树链剖分题集</title>
      <link href="/2019/10/12/lct-problems/"/>
      <url>/2019/10/12/lct-problems/</url>
      
        <content type="html"><![CDATA[<p>树链剖分常用于处理静态树上操作，效率很高，写起来也就是固定的轻重边拆分+线段树，但是代码一般都是100行+，容易出错。<br>本题集中的树链剖分练习题，在解决思路上没什么难点，主要是如何设计线段树以及如何更新+询问，也就是说要想好怎么维护线段树，其它地方没什么太难的，但是代码长就容易出bug，多写写就好了。最后一题是线段树动态开点，这和可持久化权值线段树（动态主席树）一样的思想，只需要将普通的线段树给稍微修改一下即可。</p><h4 id="树的统计"><a href="#树的统计" class="headerlink" title="树的统计"></a>树的统计</h4><p><strong>题意简述</strong><br>原题来自：ZJOI 2008<br>一树上有 n 个节点，编号分别为 1 到 n，每个节点都有一个权值 w。我们将以下面的形式来要求你对这棵树完成一些操作：</p><p>1.CHANGE u t ：把节点 u 权值改为 t；</p><p>2.QMAX u v ：询问点 u 到点 v 路径上的节点的最大权值；</p><p>3.QSUM u v ：询问点 u 到点 v 路径上的节点的权值和。</p><p>注意：从点 u 到点 v 路径上的节点包括 u 和 v 本身。</p><p><strong>解题思路</strong><br>树链剖分+线段树上单点修改，区间查询，需要注意查询操作，利用到了LCA倍增思想，树链剖分中很多区间修改和查询操作都是这样完成的。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y, edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,q,a[N];</span><br><span class="line"><span class="comment">/*父亲,深度,子树大小,重儿子,重路径顶部节点,</span></span><br><span class="line"><span class="comment">    树中节点在线段树中下标,线段树中节点对应树中位置*/</span></span><br><span class="line"><span class="keyword">int</span> par[N],deep[N],size[N],son[N],top[N],seg[N],rev[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*利用深搜更新par,size,deep,son数组*/</span></span><br><span class="line">    vis[x] = <span class="literal">true</span>; size[x] = <span class="number">1</span>;</span><br><span class="line">    par[x] = fa; deep[x] = deep[fa]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(y == fa || vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y,x);</span><br><span class="line">        size[x] += size[y]; <span class="comment">//累加子树大小</span></span><br><span class="line">        <span class="keyword">if</span>(size[y] &gt; size[son[x]]) son[x] = y;<span class="comment">//求重儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x])&#123; <span class="comment">//先走重儿子,使得重路径在线段树中连续</span></span><br><span class="line">        seg[son[x]] = ++seg[<span class="number">0</span>];<span class="comment">//0位置用不到,利用来计数</span></span><br><span class="line">        top[son[x]] = top[x];</span><br><span class="line">        rev[seg[<span class="number">0</span>]] = son[x];</span><br><span class="line">        dfs2(son[x],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(top[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">/*若y没有被遍历过,即y不是x的重儿子或者父亲*/</span></span><br><span class="line">        seg[y] = ++seg[<span class="number">0</span>]; rev[seg[<span class="number">0</span>]] = y;</span><br><span class="line">        top[y] = y; dfs2(y,x);</span><br><span class="line">        <span class="comment">/*如果x--&gt;y是轻边,那么y就是其所在重路径顶部节点*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    ll mx, sum;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mx(x) t[x].mx</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    l(rt) = l, r(rt) = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        mx(rt) = sum(rt) = a[rev[l]]; <span class="comment">//线段树上l节点对应着树上rev[l]点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    BuildTree(rt*<span class="number">2</span>,l,mid); BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    mx(rt) = max(mx(rt&lt;&lt;<span class="number">1</span>),mx(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>) + sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preHandle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>); <span class="comment">//我们以1号节点为根</span></span><br><span class="line">    <span class="comment">/*根节点所在重路径的顶部节点也是根节点,赋初值*/</span></span><br><span class="line">    seg[<span class="number">0</span>] = seg[<span class="number">1</span>] = top[<span class="number">1</span>] = rev[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    BuildTree(<span class="number">1</span>,<span class="number">1</span>,seg[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">ll tmx,tsum;<span class="comment">//利用全局变量同时统计2个答案</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*将以rt为根的区间内属于[l,r]部分的和累加到tsum上,并更新tmx*/</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">        tsum += sum(rt); tmx = max(tmx,mx(rt));</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) query(rt&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*返回x与y之间路径上权值最大点的权值*/</span></span><br><span class="line">    <span class="keyword">int</span> fx = top[x] , fy = top[y];</span><br><span class="line">    <span class="keyword">while</span>(fx != fy)&#123;<span class="comment">//先将x和y条整到同一个重链上</span></span><br><span class="line">        <span class="keyword">if</span>(deep[fx] &lt; deep[fy]) swap(x,y),swap(fx,fy);</span><br><span class="line">        query(<span class="number">1</span>,seg[fx],seg[x]);</span><br><span class="line">        x = par[fx]; fx = top[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deep[x] &gt; deep[y]) swap(x,y);<span class="comment">//路径浅的编号小</span></span><br><span class="line">    query(<span class="number">1</span>,seg[x],seg[y]); <span class="comment">//再更新一次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*把线段树节点x的权值改为val*/</span></span><br><span class="line">    <span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">        mx(rt) = sum(rt) = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt) + r(rt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; mid) change(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,val);</span><br><span class="line">    <span class="keyword">else</span> change(rt&lt;&lt;<span class="number">1</span>,x,val);</span><br><span class="line">    mx(rt) = max(mx(rt&lt;&lt;<span class="number">1</span>),mx(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>) + sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">"123.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">"222.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        addEdge(x,y,<span class="number">1</span>); addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    preHandle();<span class="comment">//树链剖分预处理</span></span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= q;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>,op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'C'</span>) change(<span class="number">1</span>,seg[x],y);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmx = -INF; tsum = <span class="number">0</span>;</span><br><span class="line">            ask(x,y);<span class="comment">//同时更新最大值与路径和</span></span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">'M'</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,tmx);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,tsum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="「HAOI2015」树上操作"><a href="#「HAOI2015」树上操作" class="headerlink" title="「HAOI2015」树上操作"></a>「HAOI2015」树上操作</h4><p><strong>题意简述</strong><br>有一棵点数为 N 的树，以点 1 为根，且树有点权。然后有 M 个操作，分为三种：</p><p>1、把某个节点 x 的点权增加 a 。</p><p>2、把某个节点 x 为根的子树中所有点的点权都增加 a 。</p><p>3、询问某个节点 x 到根的路径中所有点的点权和。</p><p><strong>解题思路</strong><br>树链剖分+线段树上区间修改，区间查询。用到了线段树上的延迟标记，其实和普通线段树没啥区别，就是查询和修改时候要用LCA倍增思想将树上的链转化为线段树上的区间。只要理解了树上节点和线段树下标是通过seg[x] 和 rev[seg[x]]来转换的即可。</p><p>另外还需要明白线段树上重链的seg[]值是连续的，同一个子树上的所有节点下标也是连续的，这个结论可以通过观察dfs2的实现得到。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y,edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">        ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> deep[N],par[N],top[N],size[N],son[N],seg[N],rev[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>; par[x] = fa;</span><br><span class="line">    deep[x] = deep[fa]+<span class="number">1</span>; size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(vis[y] || y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y,x);</span><br><span class="line">        size[x] += size[y]; </span><br><span class="line">        <span class="keyword">if</span>(size[y] &gt; size[son[x]]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x])&#123;</span><br><span class="line">        seg[son[x]] = ++seg[<span class="number">0</span>];</span><br><span class="line">        rev[seg[<span class="number">0</span>]] = son[x];</span><br><span class="line">        top[son[x]] = top[x];</span><br><span class="line">        dfs2(son[x],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(top[y]) <span class="keyword">continue</span>;</span><br><span class="line">        seg[y] = ++seg[<span class="number">0</span>]; rev[seg[<span class="number">0</span>]] = y;</span><br><span class="line">        top[y] = y; dfs2(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    ll sum,add;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> add(x) t[x].add</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    l(rt) = l,r(rt) = r,add(rt) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        sum(rt) = a[rev[l]]; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    BuildTree(rt&lt;&lt;<span class="number">1</span>,l,mid); BuildTree(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>) + sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preHandle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    seg[<span class="number">0</span>] = seg[<span class="number">1</span>] = top[<span class="number">1</span>] = rev[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    BuildTree(<span class="number">1</span>,<span class="number">1</span>,seg[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!add(rt)) <span class="keyword">return</span>;</span><br><span class="line">    sum(rt&lt;&lt;<span class="number">1</span>) += (r(rt&lt;&lt;<span class="number">1</span>)-l(rt&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>)*add(rt);</span><br><span class="line">    sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) += (r(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)-l(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)+<span class="number">1</span>)*add(rt);</span><br><span class="line">    add(rt&lt;&lt;<span class="number">1</span>) += add(rt); add(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) += add(rt);</span><br><span class="line">    add(rt) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">        sum(rt) += (r(rt) - l(rt)+<span class="number">1</span>)*val;</span><br><span class="line">        add(rt) += val; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spread(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) Add(rt&lt;&lt;<span class="number">1</span>,l,r,val);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) Add(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,val);</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>)+sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> sum(rt);</span><br><span class="line">    spread(rt); ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt) + r(rt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res += query(rt&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res += query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*从节点x到根节点的路径和*/</span></span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        res += query(<span class="number">1</span>,seg[top[x]],seg[x]);</span><br><span class="line">        x = par[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = getInt(); m = getInt();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line">        x = getInt(); y = getInt();</span><br><span class="line">        addEdge(x,y,<span class="number">1</span>); addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    preHandle();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,op,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">        op = getInt();</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            x = getInt(); y = getInt();</span><br><span class="line">            Add(<span class="number">1</span>,seg[x],seg[x],y);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line">            x = getInt(); y = getInt();</span><br><span class="line">            Add(<span class="number">1</span>,seg[x],seg[x]+size[x]<span class="number">-1</span>,y);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            x = getInt(); <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="「NOI2015」软件包管理器"><a href="#「NOI2015」软件包管理器" class="headerlink" title="「NOI2015」软件包管理器"></a>「NOI2015」软件包管理器</h4><p><strong>题意简述</strong><br>Linux 用户和 OSX 用户一定对软件包管理器不会陌生。通过软件包管理器，你可以通过一行命令安装某一个软件包，然后软件包管理器会帮助你从软件源下载软件包，同时自动解决所有的依赖（即下载安装这个软件包的安装所依赖的其它软件包），完成所有的配置。Debian/Ubuntu 使用的 apt-get，Fedora/CentOS 使用的 yum，以及 OSX 下可用的 Homebrew 都是优秀的软件包管理器。</p><p>你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包 A 依赖软件包 B，那么安装软件包 A 以前，必须先安装软件包 B。同时，如果想要卸载软件包 B，则必须卸载软件包 A。现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除 0 号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而 0 号软件包不依赖任何一个软件包。依赖关系不存在环（若有m(m≥2) 个软件包A1,A2,A3,…,Am ，其中 A1 依赖 A2，A2依赖 A3 依赖 A4 ，……，Am−1 依赖 Am ，而 Am 依赖 A1 ，则称这 m 个软件包的依赖关系构成环），当然也不会有一个软件包依赖自己。</p><p>现在你要为你的软件包管理器写一个依赖解决程序。根据反馈，用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包），你的任务就是实现这个部分。注意，安装一个已安装的软件包，或卸载一个未安装的软件包，都不会改变任何软件包的安装状态，即在此情况下，改变安装状态的软件包数为 0。</p><p><strong>解题思路</strong><br>要画图理解题意，若A依赖B，则安装A之前要安装B，若卸载B要先卸载A。也就是说要安装A，就要确保A到根节点路径上软件都已安装；若卸载A，就要确保 A 的子树为空。</p><p>于是就是树上操作，若卸载一个软件 x ，就是查询它子树上已安装的软件个数（包括它自己），输出后再删除即可；若安装一个软件 x ，就是查询 x 到根节点路径上未安装的软件个数（包括它自己），输出后再安装。因为软件安装和卸载只是改变其状态（已安装：1，未安装：0），而不改变结构（彻底删除节点），所以可以用树链剖分+线段树解决。</p><p>但是需要注意的是，怎么把整棵子树都清零，怎么把到根节点的路径都置 1，显然要用延迟标记，但是延迟标记却不应该累加，那要怎么处理？<br>置 1 时延迟标记add = 1，置0时延迟标记add = -1，每一个节点如果延迟标记不为0，那么该节点为根的子树所有软件状态相同。我们下传延迟标记操作封装在spread函数内，可以参考如何实现延迟标记的更新。</p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y, edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> par[N],deep[N],size[N],son[N],top[N],seg[N],rev[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>; par[x] = fa;</span><br><span class="line">    deep[x] = deep[fa]+<span class="number">1</span>; size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y,x);</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">        <span class="keyword">if</span>(size[y] &gt; size[son[x]]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x])&#123;</span><br><span class="line">        seg[son[x]] = ++seg[<span class="number">0</span>];</span><br><span class="line">        rev[seg[<span class="number">0</span>]] = son[x];</span><br><span class="line">        top[son[x]] = top[x];</span><br><span class="line">        dfs2(son[x],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(top[y]) <span class="keyword">continue</span>;</span><br><span class="line">        seg[y] = ++seg[<span class="number">0</span>]; rev[seg[<span class="number">0</span>]] = y;</span><br><span class="line">        top[y] = y; dfs2(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,sum,add;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> add(x) t[x].add</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    l(rt) = l,r(rt) = r,add(rt) = sum(rt) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    BuildTree(rt&lt;&lt;<span class="number">1</span>,l,mid); BuildTree(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>) + sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preHandle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    seg[<span class="number">0</span>] = seg[<span class="number">1</span>] = top[<span class="number">1</span>] = rev[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    BuildTree(<span class="number">1</span>,<span class="number">1</span>,seg[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!add(rt)) <span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">if</span>(add(rt) == <span class="number">-1</span>)&#123;</span><br><span class="line">        sum(rt&lt;&lt;<span class="number">1</span>) = sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">        add(rt&lt;&lt;<span class="number">1</span>) = add(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = add(rt);</span><br><span class="line">        add(rt) = <span class="number">0</span>; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum(rt&lt;&lt;<span class="number">1</span>) = (r(rt&lt;&lt;<span class="number">1</span>)-l(rt&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>)*add(rt);</span><br><span class="line">    sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = (r(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)-l(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)+<span class="number">1</span>)*add(rt);</span><br><span class="line">    add(rt&lt;&lt;<span class="number">1</span>) = add(rt); add(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = add(rt);</span><br><span class="line">    add(rt) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(val == <span class="number">-1</span>) sum(rt) = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> sum(rt) = (r(rt) - l(rt)+<span class="number">1</span>);</span><br><span class="line">        add(rt) = val; </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spread(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) Add(rt&lt;&lt;<span class="number">1</span>,l,r,val);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) Add(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,val);</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>)+sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> sum(rt);</span><br><span class="line">    spread(rt); ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt) + r(rt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res += query(rt&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res += query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> query(<span class="number">1</span>,seg[x],seg[x]+size[x]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        res += query(<span class="number">1</span>,seg[top[x]],seg[x]);</span><br><span class="line">        x = par[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        Add(<span class="number">1</span>,seg[top[x]],seg[x],<span class="number">1</span>);</span><br><span class="line">        x = par[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        addEdge(x+<span class="number">1</span>,i+<span class="number">1</span>,<span class="number">1</span>); addEdge(i+<span class="number">1</span>,x+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    preHandle();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m); <span class="keyword">char</span> op[<span class="number">22</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>,op,&amp;x); x++;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'u'</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask1(x));</span><br><span class="line">            Add(<span class="number">1</span>,seg[x],seg[x]+size[x]<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,deep[x]-ask2(x));</span><br><span class="line">            Add2(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="染色"><a href="#染色" class="headerlink" title="染色"></a>染色</h4><p><strong>题意简述</strong><br>原题来自：SDOI 2011<br>给定一棵有 n 个节点的无根树和 m 个操作，操作共两类。<br>1、将节点 a 到节点 b 路径上的所有节点都染上颜色；<br>2、询问节点 a 到节点 b 路径上的颜色段数量，连续相同颜色的认为是同一段，例如 112221 由三段组成：11 、 222、1。</p><p>请你写一个程序依次完成操作。</p><p><strong>解题思路</strong><br>如果不是在树上，是在区间上，该如何操作？用线段树解决。线段树上每个节点有lc：左端点颜色，rc：右端点颜色，same：区间颜色是否唯一（1表示唯一，0表示不唯一），sum：区间内颜色段数量。<br>那么更新显然要用延迟标记，标记在same上，而合并操作需要考虑中间相接的端点颜色是否相同，若相同则颜色段数量要-1。于是区间上“染色”问题就可以用线段树解决了。</p><p>在树上显然类似，因为我们可以通过树链剖分来将树给转化为区间。唯一麻烦的地方就是端点颜色问题，在区间上，我们只需要判断左子树的右端点、右子树的左端点是否颜色相同即可，但是树上的路径是通过倍增来找的，显然需要记录每一条链的端点颜色，麻烦在于如何记录并判断。</p><p>树链剖分后节点越浅，其seg越小，于是需要判断颜色是否相同的是seg[fx]和 seg[par[fx]]，这是由于我们在倍增调整深度时候是自底向上的，自然要判断深度浅的节点。为了美观以及简便，设 getcol(x) 返回该节点的颜色。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[M],ver[M],nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y, edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> deep[N],seg[N],rev[N],top[N],son[N],size[N],par[N];</span><br><span class="line"><span class="keyword">int</span> vis[N],a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>; par[x] = fa;</span><br><span class="line">    deep[x] = deep[fa]+<span class="number">1</span>; size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(vis[y] || y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y,x);</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">        <span class="keyword">if</span>(size[y] &gt; size[son[x]]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x])&#123;</span><br><span class="line">        seg[son[x]] = ++seg[<span class="number">0</span>];</span><br><span class="line">        rev[seg[<span class="number">0</span>]] = son[x];</span><br><span class="line">        top[son[x]] = top[x];</span><br><span class="line">        dfs2(son[x],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(top[y]) <span class="keyword">continue</span>;</span><br><span class="line">        seg[y] = ++seg[<span class="number">0</span>]; rev[seg[<span class="number">0</span>]] = y;</span><br><span class="line">        top[y] = y; dfs2(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="comment">/*lc:区间左端点颜色,rc:区间右端点颜色,sum:区间内颜色段数*/</span></span><br><span class="line">    <span class="keyword">int</span> l,r,lc,rc,sum;</span><br><span class="line">    <span class="keyword">int</span> same;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) t[x].lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) t[x].rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> same(x) t[x].same</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Updata</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;<span class="comment">//更新节点rt的same、rc、lc和sum</span></span><br><span class="line">    same(rt) = same(rt&lt;&lt;<span class="number">1</span>) &amp;&amp; same(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) &amp;&amp; rc(rt&lt;&lt;<span class="number">1</span>) == lc(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>)+sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(rc(rt&lt;&lt;<span class="number">1</span>) == lc(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)) sum(rt)--;</span><br><span class="line">    lc(rt) = lc(rt&lt;&lt;<span class="number">1</span>); rc(rt) = rc(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    l(rt) = l,r(rt) = r,same(rt) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        lc(rt) = rc(rt) = a[rev[l]];</span><br><span class="line">        sum(rt) = <span class="number">1</span>; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    BuildTree(rt&lt;&lt;<span class="number">1</span>,l,mid); BuildTree(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    Updata(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preHandle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    seg[<span class="number">0</span>] = seg[<span class="number">1</span>] = rev[<span class="number">1</span>] = top[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    BuildTree(<span class="number">1</span>,<span class="number">1</span>,seg[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!same(rt)) <span class="keyword">return</span>;<span class="comment">//将懒惰标记下传，即对子树染相同颜色</span></span><br><span class="line">    sum(rt&lt;&lt;<span class="number">1</span>) = sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = <span class="number">1</span>;</span><br><span class="line">    lc(rt&lt;&lt;<span class="number">1</span>) = rc(rt&lt;&lt;<span class="number">1</span>) = lc(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = rc(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = lc(rt);</span><br><span class="line">    same(rt&lt;&lt;<span class="number">1</span>) = same(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) = <span class="number">1</span>; same(rt) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">        sum(rt) = <span class="number">1</span>; lc(rt) = rc(rt) = col;</span><br><span class="line">        same(rt) = <span class="number">1</span>; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spread(rt);<span class="comment">//懒惰标记</span></span><br><span class="line">    <span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) modify(rt&lt;&lt;<span class="number">1</span>,l,r,col);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) modify(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,col);</span><br><span class="line">    Updata(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = top[x],fy = top[y];</span><br><span class="line">    <span class="keyword">while</span>(fx != fy)&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[fx] &lt; deep[fy]) swap(x,y),swap(fx,fy);</span><br><span class="line">        modify(<span class="number">1</span>,seg[fx],seg[x],z);</span><br><span class="line">        x = par[fx]; fx = top[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deep[x] &gt; deep[y]) swap(x,y);</span><br><span class="line">    modify(<span class="number">1</span>,seg[x],seg[y],z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> sum(rt);</span><br><span class="line">    spread(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span> ,res= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res += query(rt&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res += query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="comment">/*合并时中间颜色相同,要减去一段*/</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid &amp;&amp; mid &lt; r &amp;&amp; rc(rt&lt;&lt;<span class="number">1</span>) == lc(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)) res--;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getcol</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//这个函数太好用了，哭哭</span></span><br><span class="line">    <span class="keyword">if</span>(l(rt) == r(rt)) <span class="keyword">return</span> lc(rt);</span><br><span class="line">    spread(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="keyword">return</span> getcol(rt&lt;&lt;<span class="number">1</span>,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> getcol(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = top[x], fy = top[y], res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fx != fy)&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[fx] &lt; deep[fy]) swap(fx,fy),swap(x,y);</span><br><span class="line">        res += query(<span class="number">1</span>,seg[fx],seg[x]);</span><br><span class="line">        <span class="keyword">if</span>(getcol(<span class="number">1</span>,seg[fx]) == getcol(<span class="number">1</span>,seg[par[fx]])) res--;</span><br><span class="line">        x = par[fx]; fx = top[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deep[x] &gt; deep[y]) swap(x,y);</span><br><span class="line">    res += query(<span class="number">1</span>,seg[x],seg[y]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y); </span><br><span class="line">        addEdge(x,y,<span class="number">1</span>); addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    preHandle(); <span class="keyword">char</span> op[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x,y));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            change(x,y,z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="「SDOI2014」旅行"><a href="#「SDOI2014」旅行" class="headerlink" title="「SDOI2014」旅行"></a>「SDOI2014」旅行</h4><p><strong>题意简述</strong><br>S 国有 N 个城市，编号从 1 到 N。城市间用 N−1 条双向道路连接，满足从一个城市出发可以到达其它所有城市。每个城市信仰不同的宗教，如飞天面条神教、隐形独角兽教、绝地教都是常见的信仰。为了方便，我们用不同的正整数代表各种宗教，S 国境内总共有 C 种不同的宗教。<br>S 国的居民常常旅行。旅行时他们总会走最短路，并且为了避免麻烦，只在信仰和他们相同的城市留宿。当然旅程的终点也是信仰与他相同的城市。S 国政府为每个城市标定了不同的旅行评级，旅行者们常会记下途中（包括起点和终点）留宿过的城市的评级总和或最大值。<br>在 S 国的历史上常会发生以下几种事件：</p><p>1、CC x c：城市 x 的居民全体改信了 c 教；</p><p>2、CW x w：城市 x 的评级调整为 w；</p><p>3、QS x y：一位旅行者从城市 x 出发，到城市 y，并记下了途中留宿过的城市的评级总和；</p><p>4、QM x y：一位旅行者从城市 x 出发，到城市 y，并记下了途中留宿过的城市的评级最大值。<br>由于年代久远，旅行者记下的数字已经遗失了，但记录开始之前每座城市的信仰与评级，还有事件记录本身是完好的。请根据这些信息，还原旅行者记下的数字。</p><p>为了方便，我们认为事件之间的间隔足够长，以致在任意一次旅行中，所有城市的评级和信仰保持不变。<br><strong>解题思路</strong><br>如果没有信仰，那就是简单的树链剖分模板题，但这题多了个信仰，正常思路是开数组存放对应信仰的评级，但是显然不现实，从空间角度来看。<br>这题用到了动态开点，和可持久化线段树类似，只需要稍微改一下线段树模板即可。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y,edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> deep[N],par[N],size[N],top[N],seg[N],rev[N],son[N];</span><br><span class="line"><span class="keyword">int</span> vis[N],a[N],c[N];<span class="comment">//a:初始评级 c:初始信仰</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    deep[x] = deep[fa]+<span class="number">1</span>;par[x] = fa;</span><br><span class="line">    size[x] = <span class="number">1</span>;vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(vis[y] || y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y,x);</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">        <span class="keyword">if</span>(size[y] &gt; size[son[x]]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x])&#123;</span><br><span class="line">        seg[son[x]] = ++seg[<span class="number">0</span>];</span><br><span class="line">        rev[seg[<span class="number">0</span>]] = son[x];</span><br><span class="line">        top[son[x]] = top[x];</span><br><span class="line">        dfs2(son[x],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(top[y]) <span class="keyword">continue</span>;</span><br><span class="line">        seg[y] = ++seg[<span class="number">0</span>]; rev[seg[<span class="number">0</span>]] = y;</span><br><span class="line">        top[y] = y; dfs2(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls,rs;</span><br><span class="line">    ll mx,sum;</span><br><span class="line">    SegmentTree()&#123;</span><br><span class="line">        ls = rs = mx = sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(x) t[x].ls</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(x) t[x].rs</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mx(x) t[x].mx</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">&#125;t[N*<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> root[N],sz = <span class="number">1</span>;<span class="comment">//最多有多少个根节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preHandle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    seg[<span class="number">0</span>] = seg[<span class="number">1</span>] = rev[<span class="number">1</span>] = top[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> &amp;rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos,ll val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) rt = ++sz;</span><br><span class="line">    mx(rt) = max(mx(rt),val); sum(rt) += val;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>; <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid) Add(ls(rt),l,mid,pos,val);</span><br><span class="line">    <span class="keyword">else</span> Add(rs(rt),mid+<span class="number">1</span>,r,pos,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        sum(rt) = mx(rt) = <span class="number">0</span>; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid) Delete(ls(rt),l,mid,pos);</span><br><span class="line">    <span class="keyword">else</span> Delete(rs(rt),mid+<span class="number">1</span>,r,pos);</span><br><span class="line">    sum(rt) = sum(ls(rt)) + sum(rs(rt));</span><br><span class="line">    mx(rt) = max(mx(ls(rt)),mx(rs(rt)));</span><br><span class="line">&#125;</span><br><span class="line">ll mx,sum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="comment">//  printf("%d %d %d %d %d\n",rt,L,R,l,r);</span></span><br><span class="line">    <span class="keyword">if</span>(!rt) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= L &amp;&amp; R &lt;= r)&#123;</span><br><span class="line">      <span class="comment">//  printf("%d %d\n",mx(rt),sum(rt));</span></span><br><span class="line">        mx = max(mx,mx(rt)); sum += sum(rt); <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) query(ls(rt),L,mid,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) query(rs(rt),mid+<span class="number">1</span>,R,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*返回x到y路径上信仰rt的评级最大值以及总和*/</span></span><br><span class="line">    <span class="keyword">int</span> fx = top[x],fy = top[y];</span><br><span class="line">    <span class="keyword">while</span>(fx != fy)&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[fx] &lt; deep[fy]) swap(x,y),swap(fx,fy);</span><br><span class="line">        query(rt,<span class="number">1</span>,seg[<span class="number">0</span>],seg[fx],seg[x]);</span><br><span class="line">        x = par[fx]; fx = top[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deep[x] &gt; deep[y]) swap(x,y);</span><br><span class="line">    query(rt,<span class="number">1</span>,seg[<span class="number">0</span>],seg[x],seg[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,a+i,c+i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        addEdge(x,y,<span class="number">1</span>); addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    preHandle();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        Add(root[c[i]],<span class="number">1</span>,seg[<span class="number">0</span>],seg[i],a[i]);</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>,op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">'C'</span>)&#123;</span><br><span class="line">            Delete(root[c[x]],<span class="number">1</span>,seg[<span class="number">0</span>],seg[x]);</span><br><span class="line">            Add(root[c[x] = y],<span class="number">1</span>,seg[<span class="number">0</span>],seg[x],a[x]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">'W'</span>)&#123;</span><br><span class="line">            Delete(root[c[x]],<span class="number">1</span>,seg[<span class="number">0</span>],seg[x]);</span><br><span class="line">            Add(root[c[x]],<span class="number">1</span>,seg[<span class="number">0</span>],seg[x],a[x] = y);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mx = sum = <span class="number">0</span>;<span class="comment">//一起更新，少写代码，美滋滋</span></span><br><span class="line">            ask(root[c[x]],x,y);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">'S'</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,mx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树链剖分笔记</title>
      <link href="/2019/10/10/lct/"/>
      <url>/2019/10/10/lct/</url>
      
        <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>树链剖分是用来维护静态树上路径信息的数据结构，静态即树的形态不能改变（增删点或者换根，改变了构造）。<br>其思想是将树上的路径分为重路径和轻边，然后为每个节点分配一个编号，重路径上节点的编号是连续的；接着对这些编号建立一棵线段树，这样就可以将重路径当作区间来维护了；利用了“每个点到根的路径上都有不超过O(logN)条轻边和O(logN)条重路径”结论来保证时间复杂度。</p><h4 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h4><p>树链剖分通常用于解决一类维护静态树上路径信息的问题，例如，给定一棵点带权的树，接下来每次操作会修改某条路径上所有点的权值（修改为同一个值或是加上同一个值等），以及询问某条路径上所有点的权值和。</p><p>当这棵树是一条链时，这个问题实际上就是一个序列上区间修改、区间询问的问题，可以用线段树等数据结构解决。</p><p>对于其他情况，由于树的形态是不变的，因此树链剖分的策略是将这些点按某种方式组织起来，剖分成若干条链，每条链就相当于一个序列。这样，操作的路径可以拆分为某几条链，也就是若干个完整序列或是某个序列上的一段区间，此时可利用线段树等处理序列上区间操作的数据结构解决问题。</p><p>树链剖分的核心是如何恰当的将树剖分为若干条链。当链的划分方式确定后，我们只要将它们看作是一个个序列，将所有序列按顺序拼接起来，每条链就成了一段区间，而序列上的区间问题是我们所熟悉和擅长的。</p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><h5 id="划分轻重边"><a href="#划分轻重边" class="headerlink" title="划分轻重边"></a>划分轻重边</h5><p>下面以点带权的树为例，结合路径权值修改、路径询问权值和问题，介绍常用的剖分方法，该方法是轻、重边剖分。<br>我们将树中的边分为两种：轻边 和 重边。如图1所示，图中红色的边是重边，其余的是轻边。<br><img src="/2019/10/10/lct/1.png" alt="1"><br>图1：节点数字代表子树大小（size）<br>我们可以以任意点为根，然后记size( u )为以u为根的子树的节点个数，令 v 为 u 所有儿子中 size 值最大的一个，则(u,v)是重边，v 称为 u 的重儿子。u 到其余儿子的边为轻边。</p><h5 id="轻重边的性质"><a href="#轻重边的性质" class="headerlink" title="轻重边的性质"></a>轻重边的性质</h5><p>轻重边有如下几个性质：</p><ol><li>如果(u , v)为轻边，则 size( v ) &lt;= size( u ) / 2。</li><li>从根到某一点v的路径上的轻边个数不多于O(logN)。</li><li>我们称某条路径为重路径（链），当且仅当它全部由重边组成（特殊地，一个点也算一条重路径）。那么对于每个点到根的路径上都有不超过O(logN)条轻边和O(logN)条重路径。</li></ol><p>同时我们也容易发现，一个点在且只在一条重路径上，而每条重路径一定是一条从根节点方向向叶节点方向延申的深度递增的路径（因为一个非叶节点有且只有一个重儿子）。</p><h5 id="如何处理树上的路径"><a href="#如何处理树上的路径" class="headerlink" title="如何处理树上的路径"></a>如何处理树上的路径</h5><p>对树进行轻、重边剖分后，操作所要处理的路径（u , v），我们可以分别处理u，v两个点到其最近公共祖先的路径。根据性质3，路径可以分解为最多O(logN)条的重路径和最多O(logN)的轻边，那么现在我们<strong>只考虑如何维护这两种对象。</strong></p><p>对于重路径，它们此时相当于一个序列，因此我们只需要用线段树维护。而对于轻边，我们可以直接跳过，访问下一条重路径，因为轻边的两端点一定在某两条重路径上。这两种操作的时间复杂度分别为$O(log^2N)$和O(logN)，因此总的时间复杂度为$O(log^2N)$。</p><h5 id="剖分方法"><a href="#剖分方法" class="headerlink" title="剖分方法"></a>剖分方法</h5><p>轻、重边剖分的过程可以用两次dfs实现，有时为了防止递归过深而导致栈溢出，也可以用bfs实现。<br><strong>剖分过程中主要计算如下7个值：</strong><br>par[x] : x在树中的父亲。<br>deep[x]：x在树中的深度。<br>size[x]：x的子树节点数（子树大小）。<br>son[x]：x的重儿子，即u-&gt;son[u]为重边。<br>top[x]：x所在重路径的顶部节点（深度最小）。<br>seg[x]：x所在线段树中的位置（下标）。<br>rev[x]：线段树中第x个位置对应的树中节点编号，即rev[seg[x] ] = x。</p><p>第一遍 dfs 时可以计算前 4 个值，第二遍 dfs 可以计算后 3 个值。而计算 seg 时，同一条重路径上的点需要按顺序排在连续的一段位置，也就是一段区间。</p><p>将一条路径(u ,v)拆分为若干条重路径的过程，实际上就是一个寻找最近公共祖先的过程。考虑“暴力”的做法，我们会选择u，v中深度较大的点向上走一步，直到u = v。现在有了重路径，由于我们记录了重路径的顶部节点top[x]，还记录了每个点在序列中的位置，因此我们不需要一步步走。假定top[u]和top[v]不同，那么它们的最近公共祖先可能在其中一条重路径上，也可能在其他的重路径上，因为LCA显然不可能在top深度较大的那条重路径上，所以我们先处理top深度较大的。假设u是深度较大的，则可以直接条到par[top[u]]处，且跳过的这一段，在线段树中是一段区间，若我们按照深度从小到大来存储点，则这段区间为：[seg[top[x]] , seg[x]]。当u，v的top相同时，说明它们走到了同一条重路径上，这时它们之间的路径也是序列上的一段区间，且u，v中深度较小的那点是原路径的LCA。</p><p>这样我们就可以将给出的任意路径拆分成若干条重路径，也就是若干个区间，并用线段树等数据结构处理操作。</p><h4 id="例题模板"><a href="#例题模板" class="headerlink" title="例题模板"></a>例题模板</h4><p>原题来自：ZJOI 2008</p><p>一树上有 n 个节点，编号分别为 1 到 n，每个节点都有一个权值 w。我们将以下面的形式来要求你对这棵树完成一些操作：<br>1.CHANGE u t ：把节点 u 权值改为 t；<br>2.QMAX u v ：询问点 u 到点 v 路径上的节点的最大权值；<br>3.QSUM u v ：询问点 u 到点 v 路径上的节点的权值和。<br>注意：从点 u 到点 v 路径上的节点包括 u 和 v 本身。</p><p>模板使用说明：</p><ul><li>将树拆分成若干条链，为树上每个点分配一个编号，同一条链上的编号连续，然后在这些编号上建立线段树维护。seg[x]是树上的节点x在线段树的下标，rev[y]是线段树下标为 y 节点在树中的编号。</li><li>树的节点编号要从1开始，不能从0。</li><li>子树在线段树中的下标是连续的，以 x 为根的子树起点下标是seg[x]，终点是seg[x]+size[x]-1。</li></ul><p><strong>代码模板</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y, edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,q,a[N];</span><br><span class="line"><span class="comment">/*父亲,深度,子树大小,重儿子,重路径顶部节点,</span></span><br><span class="line"><span class="comment">    树中节点在线段树中下标,线段树中节点对应树中位置*/</span></span><br><span class="line"><span class="keyword">int</span> par[N],deep[N],size[N],son[N],top[N],seg[N],rev[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*利用深搜更新par,size,deep,son数组*/</span></span><br><span class="line">    vis[x] = <span class="literal">true</span>; size[x] = <span class="number">1</span>;</span><br><span class="line">    par[x] = fa; deep[x] = deep[fa]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(y == fa || vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y,x);</span><br><span class="line">        size[x] += size[y]; <span class="comment">//累加子树大小</span></span><br><span class="line">        <span class="keyword">if</span>(size[y] &gt; size[son[x]]) son[x] = y;<span class="comment">//求重儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x])&#123; <span class="comment">//先走重儿子,使得重路径在线段树中连续</span></span><br><span class="line">        seg[son[x]] = ++seg[<span class="number">0</span>];<span class="comment">//0位置用不到,利用来计数</span></span><br><span class="line">        top[son[x]] = top[x];</span><br><span class="line">        rev[seg[<span class="number">0</span>]] = son[x];</span><br><span class="line">        dfs2(son[x],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(top[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">/*若y没有被遍历过,即y不是x的重儿子或者父亲*/</span></span><br><span class="line">        seg[y] = ++seg[<span class="number">0</span>]; rev[seg[<span class="number">0</span>]] = y;</span><br><span class="line">        top[y] = y; dfs2(y,x);</span><br><span class="line">        <span class="comment">/*如果x--&gt;y是轻边,那么y就是其所在重路径顶部节点*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    ll mx, sum;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mx(x) t[x].mx</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    l(rt) = l, r(rt) = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        mx(rt) = sum(rt) = a[rev[l]]; <span class="comment">//线段树上l节点对应着树上rev[l]点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    BuildTree(rt*<span class="number">2</span>,l,mid); BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    mx(rt) = max(mx(rt&lt;&lt;<span class="number">1</span>),mx(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>) + sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preHandle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>); <span class="comment">//我们以1号节点为根</span></span><br><span class="line">    <span class="comment">/*根节点所在重路径的顶部节点也是根节点,赋初值*/</span></span><br><span class="line">    seg[<span class="number">0</span>] = seg[<span class="number">1</span>] = top[<span class="number">1</span>] = rev[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    BuildTree(<span class="number">1</span>,<span class="number">1</span>,seg[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">ll tmx,tsum;<span class="comment">//利用全局变量同时统计2个答案</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*将以rt为根的区间内属于[l,r]部分的和累加到tsum上,并更新tmx*/</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">        tsum += sum(rt); tmx = max(tmx,mx(rt));</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) query(rt&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*返回x与y之间路径上权值最大点的权值*/</span></span><br><span class="line">    <span class="keyword">int</span> fx = top[x] , fy = top[y];</span><br><span class="line">    <span class="keyword">while</span>(fx != fy)&#123;<span class="comment">//先将x和y条整到同一个重链上</span></span><br><span class="line">        <span class="keyword">if</span>(deep[fx] &lt; deep[fy]) swap(x,y),swap(fx,fy);</span><br><span class="line">        query(<span class="number">1</span>,seg[fx],seg[x]);</span><br><span class="line">        x = par[fx]; fx = top[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deep[x] &gt; deep[y]) swap(x,y);<span class="comment">//路径浅的编号小</span></span><br><span class="line">    query(<span class="number">1</span>,seg[x],seg[y]); <span class="comment">//再更新一次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*把线段树节点x的权值改为val*/</span></span><br><span class="line">    <span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">        mx(rt) = sum(rt) = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l(rt) + r(rt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; mid) change(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,val);</span><br><span class="line">    <span class="keyword">else</span> change(rt&lt;&lt;<span class="number">1</span>,x,val);</span><br><span class="line">    mx(rt) = max(mx(rt&lt;&lt;<span class="number">1</span>),mx(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">    sum(rt) = sum(rt&lt;&lt;<span class="number">1</span>) + sum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">"123.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">"222.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        addEdge(x,y,<span class="number">1</span>); addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    preHandle();<span class="comment">//树链剖分预处理</span></span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= q;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>,op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'C'</span>) change(<span class="number">1</span>,seg[x],y);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmx = -INF; tsum = <span class="number">0</span>;</span><br><span class="line">            ask(x,y);<span class="comment">//同时更新最大值与路径和</span></span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">'M'</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,tmx);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,tsum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树上倍增LCA题集</title>
      <link href="/2019/10/09/lca-problems/"/>
      <url>/2019/10/09/lca-problems/</url>
      
        <content type="html"><![CDATA[<p>树上倍增法可以用于求LCA，当然在其它场合也有应用，在很多时候看似不是树形的问题，我们也可以通过转化成树形结构，然后在树中进行操作，这种操作可以是求二者之间的最近状态，或者是二者之间的距离，如最后一题。<br>另外关于树的题型，最好还是根据样例画图思考，往往可以比空想获得更多思路。</p><h4 id="点的距离"><a href="#点的距离" class="headerlink" title="点的距离"></a>点的距离</h4><p><strong>题意简述</strong><br>给定一棵 n 个点的树，Q 个询问，每次询问点 x 到点 y 两点之间的距离。<br><strong>解题思路</strong><br>模板题，用树上倍增法，初始化时间为O(NlogN)，查询时间O(logN)。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="comment">//anc[x][i]表示x往上走2^i步的祖先编号 </span></span><br><span class="line"><span class="keyword">int</span> anc[N][<span class="number">25</span>], deep[N],dis[N];</span><br><span class="line"><span class="keyword">int</span> root = <span class="number">1</span>;<span class="comment">//这棵树的根,无特殊说明可以为1 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++)</span><br><span class="line">anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i] , z = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dis[y] || y == root) <span class="keyword">continue</span>;</span><br><span class="line">deep[y] = deep[x]+<span class="number">1</span>;</span><br><span class="line">dis[y] = dis[x] + z;</span><br><span class="line">anc[y][<span class="number">0</span>] = x; dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[u] &lt; deep[v]) swap(u,v);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(deep[anc[u][i]] &gt;= deep[v]) u = anc[u][i];</span><br><span class="line"><span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(anc[u][i] != anc[v][i])&#123;</span><br><span class="line">u = anc[u][i]; v= anc[v][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">/*logN时间内返回x与y之间的距离,注意是否会爆int*/</span> </span><br><span class="line"><span class="keyword">return</span> dis[x] + dis[y] - <span class="number">2</span>*dis[Lca(x,y)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);<span class="comment">//双向边 </span></span><br><span class="line">&#125;</span><br><span class="line">deep[<span class="number">0</span>] = <span class="number">-1</span>; dfs(root);<span class="comment">//完成预处理 </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= q;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="暗的锁链"><a href="#暗的锁链" class="headerlink" title="暗的锁链*"></a>暗的锁链*</h4><p><strong>题意简述</strong><br>原题来自：POJ 3417</p><p>Dark 是一张无向图，图中有 N 个节点和两类边，一类边被称为主要边，而另一类被称为附加边。Dark 有 N–1 条主要边，并且 Dark 的任意两个节点之间都存在一条只由主要边构成的路径。另外，Dark 还有 M 条附加边。</p><p>你的任务是把 Dark 斩为不连通的两部分。一开始 Dark 的附加边都处于无敌状态，你只能选择一条主要边切断。一旦你切断了一条主要边，Dark 就会进入防御模式，主要边会变为无敌的而附加边可以被切断。但是你的能力只能再切断 Dark 的一条附加边。</p><p>现在你想要知道，一共有多少种方案可以击败 Dark。注意，就算你第一步切断主要边之后就已经把 Dark 斩为两截，你也需要切断一条附加边才算击败了 Dark。</p><p><strong>解题思路</strong><br>这是一道需要观察和转化题意的问题。<br>在树上如果有一条附加边，就形成了一个环，可知每个环内最多有一条附加边。如果一条主要边在环中，则称该主要边被<strong>覆盖</strong> ，它在几个环内，就被覆盖了几次。可知一个主要边最多被覆盖2次。<br>如果一条主要边被覆盖了 2 次，那么我们无论怎么切都切不断 Dark，因为切断了主要边后，还是一个环，而切断一个环需要切断两条边。如果一条主要边被覆盖了 1 次，那么我们切断该主要边后，再切断它的附加边即可，即只有一种方案。如果一条主要边被覆盖0次，那么我们切完该主要边后，可以任意切一条附加边，共 m 中方案（m 是附加边的条数）。综上所述，我们只需要求出每条主要边被附加边覆盖次数即可，我们设 f[x] 为 x 到其父节点的主要边被覆盖的次数。</p><p>我们可以利用<strong>树上差分</strong>来求 f 数组，树上差分的思想就不额外介绍了，具体做法是如果有一条附加边(x, y)，那么f[x]++ ,f[y]++，同时 f[ Lca(x, y) ] -= 2，这样当我们添加完附加边后，将 f 数组从叶子节点向上累加，即可更新完毕 f 数组。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x];head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,f[N];</span><br><span class="line"><span class="keyword">int</span> dis[N],deep[N],anc[N][<span class="number">24</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++) </span><br><span class="line">anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dis[y] || y == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">deep[y] = deep[x] + <span class="number">1</span>;</span><br><span class="line">dis[y] = dis[x] + z;</span><br><span class="line">anc[y][<span class="number">0</span>] = x; dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[x] &lt; deep[y]) swap(x,y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(deep[anc[x][i]] &gt;= deep[y]) x = anc[x][i];</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(anc[x][i] != anc[y][i])&#123;</span><br><span class="line">x = anc[x][i]; y = anc[y][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">f[x] += dfs2(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">f[x]++; f[y]++; f[Lca(x,y)] -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">dfs2(<span class="number">1</span>); <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(!f[i]) ans += m;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(f[i] == <span class="number">1</span>) ans++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="异象石"><a href="#异象石" class="headerlink" title="异象石*"></a>异象石*</h4><p><strong>题意简述</strong><br>原题来自：Contest Hunter Round #56</p><p>在 Adera 的异时空中有一张地图。这张地图上有 N 个点，有 N−1 条双向边把它们连通起来。起初地图上没有任何异象石，在接下来的 M 个时刻中，每个时刻会发生以下三种类型的事件之一：</p><p>地图的某个点上出现了异象石（已经出现的不会再次出现）；</p><p>地图某个点上的异象石被摧毁（不会摧毁没有异象石的点）；</p><p>向玩家询问使所有异象石所在的点连通的边集的总长度最小是多少。</p><p>请你作为玩家回答这些问题。下图是一个例子，灰色节点表示出现了异象石，加粗的边表示被选为连通异象石的边集。</p><p><strong>解题思路</strong><br>我也不太能理解这题的思路是怎么发现的。<br>很自然的想法就是求所有 k 个异象石两两之间的距离和，然后 / (k-1) 即为答案，但显然会超时。<br>正解是利用一个结论，该结论题解没给出证明，搞懂了再补上。<br>对这颗树先进行dfs遍历，给每个节点打上一个时间戳，设节点 x 的时间戳为 dfn[x]；设已存在的异象石中，dfn序是 x 前驱的节点编号为 pre，后继节点编号为 nex，那么在 x 处插入异象石后， ans += Dis(pre , x) + Dis(x, nex) - Dis(pre, nex)。<br>删除一个异象石同理，减去就好。<br>证明暂时没有，另外这个要做法记住，是用来求树上多个节点之间的最短总路径用的。</p><p>还要注意set的用法，如果set为空，那么begin() = end()，此时如果用指向end()的迭代器自增或自减都是不合法的。</p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x];head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,f[N];</span><br><span class="line"><span class="keyword">int</span> dis[N],deep[N],anc[N][<span class="number">24</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++) </span><br><span class="line">anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dis[y] || y == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">deep[y] = deep[x] + <span class="number">1</span>;</span><br><span class="line">dis[y] = dis[x] + z;</span><br><span class="line">anc[y][<span class="number">0</span>] = x; dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[x] &lt; deep[y]) swap(x,y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(deep[anc[x][i]] &gt;= deep[y]) x = anc[x][i];</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(anc[x][i] != anc[y][i])&#123;</span><br><span class="line">x = anc[x][i]; y = anc[y][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">f[x] += dfs2(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">f[x]++; f[y]++; f[Lca(x,y)] -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">dfs2(<span class="number">1</span>); <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(!f[i]) ans += m;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(f[i] == <span class="number">1</span>) ans++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树*"></a>次小生成树*</h4><p>这是阳哥哥负责的题型，我就不越界了。</p><h4 id="Dis"><a href="#Dis" class="headerlink" title="Dis"></a>Dis</h4><p><strong>题意简述</strong><br>给出 n 个点的一棵树，多次询问两点之间的最短距离。<br>注意：边是双向的。<br><strong>解题思路</strong><br>这个就是标准的模板题了，和第一题一样，注意一下细节即可。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],edge[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x];</span><br><span class="line">edge[tot] = z; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">int</span> anc[N][<span class="number">25</span>], deep[N],dis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++)</span><br><span class="line">anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i] , z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(dis[y] || y == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">deep[y] = deep[x]+<span class="number">1</span>;</span><br><span class="line">dis[y] = dis[x] + z;</span><br><span class="line">anc[y][<span class="number">0</span>] = x; dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[u] &lt; deep[v]) swap(u,v);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(deep[anc[u][i]] &gt;= deep[v]) u = anc[u][i];</span><br><span class="line"><span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(anc[u][i] != anc[v][i])&#123;</span><br><span class="line">u = anc[u][i]; v= anc[v][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> dis[x] + dis[y] - <span class="number">2</span>*dis[Lca(x,y)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addEdge(x,y,z); addEdge(y,x,z);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>);<span class="comment">//完成预处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= q;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="祖孙询问"><a href="#祖孙询问" class="headerlink" title="祖孙询问"></a>祖孙询问</h4><p><strong>题意简述</strong><br>已知一棵 n 个节点的有根树。有 m 个询问，每个询问给出了一对节点的编号 x 和 y，询问 x 与 y 的祖孙关系。<br><strong>解题思路</strong><br>简单的模板题，需要注意的是如果 x == y，那么是属于<strong>其它情况</strong>哦。<br>另外还需要注意一下，deep[0] = -1，否则会和根节点数值相等而出错。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> anc[N][<span class="number">25</span>], dis[N],deep[N];</span><br><span class="line"><span class="keyword">int</span> root;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++)</span><br><span class="line">anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(dis[y] || y == root) <span class="keyword">continue</span>;</span><br><span class="line">deep[y] = deep[x]+<span class="number">1</span>;</span><br><span class="line">dis[y] = dis[x] + <span class="number">1</span>;</span><br><span class="line">anc[y][<span class="number">0</span>] = x; dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[x] &lt; deep[y]) swap(x,y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(deep[anc[x][i]] &gt;= deep[y]) x = anc[x][i];</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(anc[x][i] != anc[y][i])&#123;</span><br><span class="line">x = anc[x][i]; y = anc[y][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">if</span>(y == <span class="number">-1</span>) root = x;</span><br><span class="line"><span class="keyword">else</span> addEdge(x,y,<span class="number">1</span>), addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 因为deep[root] = 0,如果deep[0] = 0,则会认为 0 号节点也是根 */</span></span><br><span class="line">deep[<span class="number">0</span>] = <span class="number">-1</span>; dfs(root);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">int</span> par = Lca(x,y);</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(par == x) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(par == y) <span class="built_in">puts</span>(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="聚会"><a href="#聚会" class="headerlink" title="聚会*"></a>聚会*</h4><p><strong>题意简述</strong><br>原题来自：AHOI 2008</p><p>Y 岛风景美丽宜人，气候温和，物产丰富。Y 岛上有 N 个城市，有 N−1 条城市间的道路连接着它们。每一条道路都连接某两个城市。幸运的是，小可可通过这些道路可以走遍 Y 岛的所有城市。神奇的是，乘车经过每条道路所需要的费用都是一样的。</p><p>小可可，小卡卡和小 YY 经常想聚会，每次聚会，他们都会选择一个城市，使得三个人到达这个城市的总费用最小。</p><p>由于他们计划中还会有很多次聚会，每次都选择一个地点是很烦人的事情，所以他们决定把这件事情交给你来完成。他们会提供给你地图以及若干次聚会前他们所处的位置，希望你为他们的每一次聚会选择一个合适的地点。</p><p><strong>解题思路</strong><br>在一棵树上求三个点 (x, y ,z) 之间的最短路径，我们求出dis[x, y] + dis[x , z] + dis[y , z]，画图就会发现每一段路径都被重复计算了 2 次，于是我们再将答案 / 2就得到了三个点之间的路径。<br>假设这个聚会点为 p ，那么显然 p 是三条路径的交汇点，否则路径和肯定不会是最短。下一步的目标就是求出这个交汇点的坐标。</p><p>如果我们以某个点为根，为每个节点更新深度deep（就像我们在求LCA时一样），那么显然 p 点就是 Lca[x, y] , Lca[x , z] , Lca[y , z] 三者中deep最大（最深）的点，这也可以通过画图观察出来，也很容易证明。</p><p>于是我们就可以利用树上倍增法求出Lca，在O(NlogN)时间内解决该题，但是常数不太优秀，极限数据还是会被卡掉，如果想满分需要用树链剖分，不过该思路已经可以通过一本通oj上的数据了。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],nex[M], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y, edge[tot] = z;</span><br><span class="line">nex[tot] = head[x] , head[x] = tot;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) </span><br><span class="line">res = res*<span class="number">10</span>+c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> root = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> deep[N],anc[N][<span class="number">24</span>],dis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++)</span><br><span class="line">anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(dis[y] || y == root) <span class="keyword">continue</span>;</span><br><span class="line">deep[y] = deep[x] + <span class="number">1</span>;</span><br><span class="line">dis[y] = dis[x] + <span class="number">1</span>;</span><br><span class="line">anc[y][<span class="number">0</span>] = x; dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[x] &lt; deep[y]) swap(x,y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(deep[anc[x][i]] &gt;= deep[y]) x = anc[x][i];</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(anc[x][i] != anc[y][i])&#123;</span><br><span class="line">x = anc[x][i]; y = anc[y][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dis</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> dis[x] + dis[y] - <span class="number">2</span>*dis[Lca(x,y)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">print(x/<span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">addEdge(x,y,<span class="number">1</span>); addEdge(y,x,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">deep[<span class="number">0</span>] = <span class="number">-1</span>; dfs(root);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt(); z = getInt();</span><br><span class="line"><span class="keyword">int</span> par = Lca(x,y); </span><br><span class="line"><span class="keyword">int</span> p2 = Lca(x,z) , p3 = Lca(y,z);</span><br><span class="line"><span class="keyword">if</span>(deep[par] &lt; deep[p2]) par = p2;</span><br><span class="line"><span class="keyword">if</span>(deep[par] &lt; deep[p3]) par = p3;</span><br><span class="line"><span class="keyword">int</span> res = Dis(x,y) + Dis(x,z) + Dis(y,z) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">print(par); <span class="built_in">putchar</span>(<span class="string">' '</span>); print(res); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="跳跳棋"><a href="#跳跳棋" class="headerlink" title="跳跳棋**"></a>跳跳棋**</h4><p><strong>题意简述</strong><br>原题来自：BZOJ 2144</p><p>跳跳棋是在一条数轴上进行的。棋子只能摆在整点上。每个点不能摆超过一个棋子。我们用跳跳棋来做一个简单的游戏：棋盘上有三颗棋子，分别在 a,b,c 这三个位置。我们要通过最少的跳动把他们的位置移动成 x,y,z（注意：棋子是没有区别的）。</p><p>跳动的规则很简单，任意选一颗棋子，对一颗中轴棋子跳动。跳动后两颗棋子距离不变。一次只允许跳过一颗棋子。</p><p>写一个程序，首先判断是否可以完成任务。如果可以，输出最少需要的跳动次数。<br><img src="/2019/10/09/lca-problems/1.png" alt="1"><br><strong>解题思路</strong><br>这题有好几个难点，思路也不是那么容易想到。</p><p>首先比较容易想到的是，有哪些点是可以达到的；设a,b,c升序，l1 = b-a, l2 = c-b，那么(l1, l2)可以转移到 (l1, l2-l1) 和 (l1-l2 , l2)。<br>那么每次转移了多少长度，向哪个方向转移的我们都知道了，自然就可以得到点的转移。就比如 (l1 , l2)  —&gt; (l1 , l2 - l1) ，就对应着(a ,b ,c)—&gt;(b, 2b-a, c)。</p><p>既然我们知道点如何转移，那么问题就变成了判断 (a , b, c) 和 (x , y , z) 是否可以转移到同一个状态。</p><p>我们上面只讨论了两端节点向中间跳（对应着合法长度的相减，a跳到b、c中间，c跳到a、b中间），没考虑中间节点向两边跳（a关于c跳，或c关于a跳，或b关于a、c跳，对应着合法长度的相加），实际上两者都成立，比如(l1 , l2)—&gt;(l1, l1+l2)对应着(a ,b ,c) —&gt; (b , a , c) ，但是如果我们将其中两点之间的距离不断变大，会终止于正无穷，但如果不断缩小，就会终止于某一个非负整数；基于此我们只考虑“两边的点向中间跳”这种情况，这对应着开始介绍的两个减法转移。</p><p>到此就有些明朗了，每个状态看作一个节点，转移一次就看作向上走一步，最终一定会终止于某一个状态，这个状态就可以看作根节点；我们将(a ,b ,c) 与 (x, y , z)同时“向上”转移，如果它们终止于同一个状态，就说明它们可以互相抵达，否则则不能。</p><p>接下来就是要判断最小的步数，即(a ,b ,c) 到 (x , y , z) 的最少转移次数。这就相当于求二者的LCA，因为它们有共同的“根节点”，并且有着到根节点的唯一路径，所以可以将它们的转移看作一棵树，边权为1，求着两个状态之间的距离。</p><p>由于我们利用的是合法长度的转移来对应着点的状态的转移，即(l1, l2) —&gt; (l1 , l2-l1)或(l1-l2, l2)。这和更相减损术 gcd(a, b) = gcd(a, b-a) = gcd(a-b, a)相同，而欧几里得又告诉我们 gcd(a ,b) = gcd(b ,a%b)，于是本来 O(N) 的减法变成了 O(log N)的除法（取模）。</p><p>我们可以在O(logN)的时间内转移到任意一个父状态，但是我们不知道该向上转移几步才是最少步数，于是我们要先将二者的<strong>深度</strong>调到相同，然后同时向上走 k 步，这可以用倍增实现，也可以用二分搜索实现。求深度我们可以在求第一问时顺便求解，同时深度也是最长路径，用于二分。</p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>],b[<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line">Node()&#123;&#125;</span><br><span class="line">Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z):x(x),y(y),z(z)&#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> Node&amp; B) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(x == B.x &amp;&amp; y == B.y &amp;&amp; z == B.z);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> deep;</span><br><span class="line"><span class="function">Node <span class="title">jump</span><span class="params">(Node h, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回从位置h向上跳step步后的状态,顺便记录一下当前深度(距根距离)*/</span></span><br><span class="line">Node res = h;</span><br><span class="line"><span class="keyword">int</span> t1 = h.y-h.x, t2 = h.z - h.y;</span><br><span class="line"><span class="keyword">if</span>(t1 == t2) <span class="keyword">return</span> res; </span><br><span class="line"><span class="keyword">if</span>(t1 &lt; t2)&#123;</span><br><span class="line"><span class="keyword">int</span> t = min(step,(t2<span class="number">-1</span>)/t1);<span class="comment">//用除法优化 </span></span><br><span class="line">step -= t; deep += t;<span class="comment">//记录一下深度 </span></span><br><span class="line">res.y += t*t1; res.x += t*t1;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = min(step,(t1<span class="number">-1</span>)/t2);</span><br><span class="line">step -= t; deep += t;</span><br><span class="line">res.y -= t*t2; res.z -= t*t2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(step) <span class="keyword">return</span> jump(res,step);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,Node h1,Node h2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(jump(h1,x) != jump(h2,x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span>;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span>;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,b+i);</span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">4</span>); sort(b+<span class="number">1</span>,b+<span class="number">4</span>);</span><br><span class="line">Node h1(a[1],a[2],a[3]) , h2(b[1],b[2],b[3]);</span><br><span class="line">Node aa = jump(h1,INF); <span class="keyword">int</span> d1 = deep; deep = <span class="number">0</span>;</span><br><span class="line">Node bb = jump(h2,INF); <span class="keyword">int</span> d2 = deep; deep = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(aa != bb)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"NO"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line"><span class="comment">/*计算步数：先调整到同一深度,再二分一起跳*/</span></span><br><span class="line"><span class="keyword">if</span>(d1 &lt; d2) swap(d1,d2),swap(h1,h2);</span><br><span class="line">h1 = jump(h1,d1-d2);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = d1;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid,h1,h2)) r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="number">2</span>*l+d1-d2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lca </tag>
            
            <tag> 树上倍增 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树相关问题</title>
      <link href="/2019/10/09/MSTs/"/>
      <url>/2019/10/09/MSTs/</url>
      
        <content type="html"><![CDATA[<p><strong>摘要：</strong><br>在对最小生成树算法有一定理解后，我们对典型的最小生成树题型应该不难解决，但是对于由最小生成树模型变形而来的几种模型，我们仍需做一次总结与记录。<br>首先我们需要提出最小生成树几个性质，便于推导算法；然后我们将介绍6种最小生成树相关问题模型，并讨论一般解法与更优解法；其中有的解法显而易见，接受起来也很简单，但有的解法却需要从理论上逻辑严密的进行推导，构造算法并证明算法的正确性，这部分难度稍大。<br>这6个相关问题分别是：增量最小生成树，最小瓶颈生成树，最小瓶颈路，每对节点的最小瓶颈路，次小生成树，最小有向生成树。</p><h4 id="图论中的2个性质："><a href="#图论中的2个性质：" class="headerlink" title="图论中的2个性质："></a>图论中的2个性质：</h4><ul><li><strong>切割性质：</strong> 假定所有边权均不相同。设S为既非空集也非全集的V的子集，边e是满足一个端点在S内，另一个端点不在S内的所有边中权值最小的一个，则图G的所有生成树均包含e。</li><li><strong>回路性质：</strong> 假定所有边权值均不相同。设C是图G中任意回路，边e是C上权值最大的边，则图G的所有生成树均不包含e。</li></ul><p>在此不给出证明。</p><h4 id="增量最小生成树"><a href="#增量最小生成树" class="headerlink" title="增量最小生成树"></a>增量最小生成树</h4><p><strong>问题描述：</strong><br>从包含n个点的空图开始，依次加入m条带权边。每加入一条边，输出当前图中的最小生成树权值（如果当前图不连通，则输出无解）。<br><strong>解题思路：</strong><br>如果每次重新求完整的最小生成树问题，总时间复杂度高达O(m^2 log n)。根据回路的性质，可以得到如下改进算法：</p><blockquote><p>每次求出新的最小生成树后，把其它的边删除。由于每次只需计算一个n条边（原生成树有 n - 1条，新加入一条）的图的最小生成树，Kruskal算法的时间复杂度降为O(n log n)，总时间复杂度为O(nm log n)。</p></blockquote><p>这个算法可以进一步改进:</p><blockquote><p>加入一条边e = (u, v)之后，图中恰好包含一个环。根据回路性质，删除该回路上权值最大的边即可，因此只需在加边之前的MST上找到u到v的唯一路径上的权值最大的边，再和e比较，删除权值较大的一条。由于路径唯一，可以用DFS或BFS找到这条u到v的路径，总时间复杂度为O(nm)。</p></blockquote><h4 id="最小瓶颈生成树"><a href="#最小瓶颈生成树" class="headerlink" title="最小瓶颈生成树"></a>最小瓶颈生成树</h4><p><strong>问题描述：</strong><br>给出加权无向图，求一棵生成树，使得最大边权值尽量小。</p><p><strong>解题思路：</strong><br>由于只关心最大边权值，我们可以从一个空图开始，按照权值从小到大的顺序依次加入各条边，则图第一次连通时，该图的最小生成树就是原图的最小瓶颈生成树。可以发现，原图的最小生成树就是一棵最小瓶颈生成树（但不是每棵最小瓶颈生成树都是最小生成树）。</p><h4 id="最小瓶颈路"><a href="#最小瓶颈路" class="headerlink" title="最小瓶颈路"></a>最小瓶颈路</h4><p><strong>问题描述：</strong><br>给定加权无向图的两个节点u和v，求出从u到v的一条路径，使得路径上最长边尽量短。</p><p><strong>解题思路：</strong><br>这个问题可以用二分法+BFS解决，但我们有更好的算法。先求出这个图的最小生成树，则起点和终点在树上的唯一路径就是我们要找的路径，这条路径上的最长边就是问题的答案。</p><h4 id="每对结点间的最小瓶颈路"><a href="#每对结点间的最小瓶颈路" class="headerlink" title="每对结点间的最小瓶颈路"></a>每对结点间的最小瓶颈路</h4><p><strong>问题描述：</strong><br>给出加权无向图，求每两个节点u和v之间的最小瓶颈路的最大边长f(u,v)。</p><p><strong>解题思路：</strong></p><blockquote><p>先求最小生成树。接下来，用DFS把最小生成树变成有根树，同时计算f(u,v)，当新访问一个节点u时，考虑所有已经访问过的老节点x，更新f(x,u) = max(f(x,v) , w(u,v))，其中v是u的父节点。每个f(u,v)只需经过常数时间计算，因此是时间复杂度为O(n^2)。</p></blockquote><h4 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a>次小生成树</h4><p><strong>问题描述：</strong><br>把所有生成树按照权值之和从大到小的顺序排列，求排在第二位的生成树。注意，如果最小生成树不唯一，次小生成树的权值与最小生成树相同。</p><p><strong>解题思路：</strong> </p><blockquote><p>次小生成树不会与最小生成树完全相同，因此可以枚举最小生成树中不在次小生成树中出现的边。注意最小生成树只有n-1条边，所以只需枚举n-1次。每次在剩下的边里求一次最小生成树，则这n-1棵“缺一条边的图”的最小生成树中权最小的就是原图的次小生成树。</p></blockquote><p>还有一种更好的方法：</p><blockquote><p>枚举要加入哪条新边。在最小生成树上加一条边u-v之后，图上会出现一条回路，因此删除的边必须在最小生成树上u到v的路径上，且是这条路径上的最长边。可以证明，次小生成树一定可以由最小生成树加一条边再删一条边得到（称为边交换），因此只需按照“每对节点之间的最小瓶颈路”的方法求出每对节点u和v在最小生成树中唯一路径的最大边权maxcost[u][v]，则剩下的部分只需要O(m)时间（枚举所有m-n+1条边进行交换，每次花O(1)时间求出新生成树的权值）。总时间复杂度为O(n^2)。</p></blockquote><h4 id="最小有向生成树"><a href="#最小有向生成树" class="headerlink" title="最小有向生成树"></a>最小有向生成树</h4><p><strong>问题描述：</strong><br>给定一个有向带权图G和其中一个节点u，找出一个以u为根节点，权和最小的有向生成树。有向生成树（directed spanning tree）也叫树形图（arborescence），是指一个类似树的有向图，满足以下条件：</p><ul><li>恰好有一个入度为0的点，称为根节点</li><li>其它节点的入度均为1</li><li>可以从根节点到达其它所有节点</li></ul><p>不难发现，如果树形图的节点数为n，它的边数一定为n-1，且树形图中不存在有向环。</p><p><strong>解题思路：</strong><br>固定根的最小树形图可以用朱-刘算法解决。</p><blockquote><p>首先是预处理，删除自环并判断根节点是否可以到达其它所有节点。如果不是，输出无解并终止程序。<br>接下来是算法的主过程：<br>首先，给所有非根节点选择一条权最小的入边。如果选出来的n-1条边不构成圈，则可以证明这些边就形成了一个最小树形图，否则把每个圈各收缩成一个点，继续上述过程。<br>缩圈之后，圈上所有边都消失了，因此在最终答案里需要加上这些边权之和。但这样做有个问题：假设在算法的某次迭代中，把圈C收缩为人工节点v，则在下一次迭代中，给v选择的入弧将与在圈C中的入弧发生冲突。（假设X在圈中已经有了入弧Y-&gt;X）因此如果收缩之后又选了一个入弧Z-&gt;X，必须把弧Y-&gt;X从最小树形图中删除。这等价于把弧Z-&gt;X的权值减少了Y-&gt;X的权值。</p></blockquote><h5 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h5><ul><li>刘汝佳，算法竞赛入门经典训练指南，北京：清华大学出版社，2012，343-344</li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树题集</title>
      <link href="/2019/10/07/segmentTree-problems/"/>
      <url>/2019/10/07/segmentTree-problems/</url>
      
        <content type="html"><![CDATA[<h4 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h4><p><strong>题意简述</strong><br>给定一数列，规定有两种操作，一是修改某个元素，二是求区间的连续和。<br><strong>解题思路</strong><br>线段树单点修改，区间查询的模板。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll dat;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dat(x) t[x].dat</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*为区间[l,r]建立以rt为根节点的子树*/</span></span><br><span class="line">l(rt) = l, r(rt) = r,dat(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid);</span><br><span class="line">BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">dat(rt) += val; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt) + r(rt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= mid) Add(rt*<span class="number">2</span>,p,val);</span><br><span class="line"><span class="keyword">else</span> Add(rt*<span class="number">2</span>+<span class="number">1</span>,p,val);</span><br><span class="line">dat(rt) = dat(rt*<span class="number">2</span>) + dat(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(rt) == l &amp;&amp; r(rt) == r) <span class="keyword">return</span> dat(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt) + r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> ask(rt*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r &lt;= mid) <span class="keyword">return</span> ask(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> ask(rt*<span class="number">2</span>,l,mid)+ask(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,k,a,b;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;k,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">if</span>(k) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(<span class="number">1</span>,a,b));</span><br><span class="line"><span class="keyword">else</span> Add(<span class="number">1</span>,a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="A-Simple-Problem-with-Integers"><a href="#A-Simple-Problem-with-Integers" class="headerlink" title="A Simple Problem with Integers"></a>A Simple Problem with Integers</h4><p><strong>题意简述</strong><br>这是一道模板题。</p><p>给定数列 a[1],a[2],…,a[n]，你需要依次进行 q 个操作，操作有两类：</p><p>C l r x：给定 l,r,x，对于所有 i∈[l,r]，将 a[i] 加上 x（换言之，将 a[l],a[l+1],…,a[r] 分别加上 x）；</p><p>Q l r：给定 l,r，求 ∑ri=la[i] 的值（换言之，求 a[l]+a[l+1]+⋯+a[r] 的值）。<br><strong>解题思路</strong><br>这题也是POJ3468。可以用很多种方法解决，是个练手的模板题。线段树区间修改+区间查询，延迟标记的简单使用。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll sum,add;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(x) t[x].add</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">l(rt) = l, r(rt) = r;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum(rt) = a[l]; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid); BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将延迟标记向下传一层*/</span></span><br><span class="line"><span class="keyword">if</span>(!add(p)) <span class="keyword">return</span>;</span><br><span class="line">sum(p*<span class="number">2</span>) += (r(p*<span class="number">2</span>)-l(p*<span class="number">2</span>)+<span class="number">1</span>)*add(p);</span><br><span class="line">sum(p*<span class="number">2</span>+<span class="number">1</span>) += (r(p*<span class="number">2</span>+<span class="number">1</span>)-l(p*<span class="number">2</span>+<span class="number">1</span>)+<span class="number">1</span>)*add(p);</span><br><span class="line">add(p*<span class="number">2</span>) += add(p); add(p*<span class="number">2</span>+<span class="number">1</span>) += add(p);</span><br><span class="line">add(p) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="comment">/*[l,r]内所有位置上元素都+val*/</span> </span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">sum(rt) += (r(rt)-l(rt)+<span class="number">1</span>)*val;</span><br><span class="line">add(rt) += val; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">spread(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) change(rt*<span class="number">2</span>,l,r,val);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) change(rt*<span class="number">2</span>+<span class="number">1</span>,l,r,val);</span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*回答[l,r]区间和*/</span> </span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> sum(rt);</span><br><span class="line">spread(rt); ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) res += ask(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) res += ask(rt*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,l,r,x;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'C'</span>)&#123;</span><br><span class="line">l = getInt(); r = getInt(); x = getInt();</span><br><span class="line">change(<span class="number">1</span>,l,r,x);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">l = getInt(); r = getInt();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(<span class="number">1</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="最大数"><a href="#最大数" class="headerlink" title="最大数"></a>最大数</h4><p><strong>题意简述</strong><br>原题来自：JSOI 2008</p><p>给定一个正整数数列 a1,a2,a3,⋯,an ，每一个数都在 0∼p–1 之间。可以对这列数进行两种操作：</p><p>添加操作：向序列后添加一个数，序列长度变成 n+1；</p><p>询问操作：询问这个序列中最后 L 个数中最大的数是多少。</p><p>程序运行的最开始，整数序列为空。写一个程序，读入操作的序列，并输出询问操作的答案。<br><strong>解题思路</strong><br>因为最多有N个数，那么先根据[1 , N]建立线段树，提前把位置空出来就好了，now指针记录最后一个位置，每次把新加入的元素插入++now，而询问最后L个数的最大值，则用ask(now - L , now)来查询即可，其它的就是线段树上维护区间最大值。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll mx;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mx(x) t[x].mx</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">l(rt) = l, r(rt) = r, mx(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid); BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">mx(rt) = val; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &gt; mid) change(rt*<span class="number">2</span>+<span class="number">1</span>,p,val);</span><br><span class="line"><span class="keyword">else</span> change(rt*<span class="number">2</span>,p,val);</span><br><span class="line">mx(rt) = max(mx(rt*<span class="number">2</span>),mx(rt*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> mx(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt) + r(rt)&gt;&gt;<span class="number">1</span> , res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) res = ask(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) res = max(res,ask(rt*<span class="number">2</span>+<span class="number">1</span>,l,r));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m,p,ans,now;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;p);</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,N<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%d"</span>,op,&amp;x);</span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'A'</span>) change(<span class="number">1</span>,++now,(x*<span class="number">1l</span>l+ans)%p);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans = ask(<span class="number">1</span>,now-x+<span class="number">1</span>,now));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="花神游历各国"><a href="#花神游历各国" class="headerlink" title="花神游历各国*"></a>花神游历各国*</h4><p><strong>题意简述</strong><br>原题来自：BZOJ 3211</p><p>花神喜欢步行游历各国，顺便虐爆各地竞赛。花神有一条游览路线，它是线型的，也就是说，所有游历国家呈一条线的形状排列，花神对每个国家都有一个喜欢程度（当然花神并不一定喜欢所有国家）。</p><p>每一次旅行中，花神会选择一条旅游路线，它在那一串国家中是连续的一段，这次旅行带来的开心值是这些国家的喜欢度的总和，当然花神对这些国家的喜欢程序并不是恒定的，有时会突然对某些国家产生反感，使他对这些国家的喜欢度 δ 变为 $\sqrtδ$（可能是花神虐爆了那些国家的 OI，从而感到乏味）。</p><p>现在给出花神每次的旅行路线，以及开心度的变化，请求出花神每次旅行的开心值。</p><p><strong>解题思路</strong><br>我刚开始想的是如何把修改延迟，但是后来发现不太容易实现。很容易的发现的就是1e9开根10次后就是1了（当然还有下取整），所以题目范围内所有数最多开根10次就会变成1或0，也就是说我们可以记录每个点被修改了多少次，如果已经修改了10次以上，那么再修改也无意义了。<br>于是我们可以每次修改都修改到叶子节点（因为无法延迟或整段修改），同时记录每个节点被修改了多少次，如果一段区间修改次数最小的节点都修改了10次，那么这一段区间就都不用修改了；这就会大大降低时间复杂度，因为每一个节点最多被修改10次，O(10NlogN)。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,mi;</span><br><span class="line">ll sum;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mi(x) t[x].mi</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">l(rt) = l,r(rt) = r,mi(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum(rt) = a[l]; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid); BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(mi(rt) &gt; <span class="number">10</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">sum(rt) = a[l(rt)] = <span class="built_in">sqrt</span>(a[l(rt)]); </span><br><span class="line">mi(rt)++; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt) + r(rt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) change(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) change(rt*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">mi(rt) = min(mi(rt*<span class="number">2</span>),mi(rt*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> sum(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>; ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) res += ask(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) res += ask(rt*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,op,l,r;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;op,&amp;l,&amp;r);</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(<span class="number">1</span>,l,r));</span><br><span class="line"><span class="keyword">else</span> change(<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="维护序列"><a href="#维护序列" class="headerlink" title="维护序列*"></a>维护序列*</h4><p><strong>题意简述</strong><br>原题来自：AHOI 2009</p><p>老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。</p><p>有长为 n 的数列，不妨设为 a1,a2,⋯,an 。有如下三种操作形式：</p><p>把数列中的一段数全部乘一个值；</p><p>把数列中的一段数全部加一个值；</p><p>询问数列中的一段数的和，由于答案可能很大，你只需输出这个数模 P 的值。</p><p><strong>解题思路</strong><br>这个如果修改操作只有 2 或 1，那么就是一个区间修改-延迟标记的模板题，但是它把“乘”和“加”操作放在了一起，当然还是需要用延迟标记来做，add表示待加上的值，mul表示待乘的值。<br>有一个问题，就是我们在向下传递延迟标记时，是先传递加法呢，还是乘法呢？其实问题的根源不在这，而在于我们在做乘法时，对加法的延迟标记也要乘 val，即 add = add * val，因为满足结合律。搞完这点剩下就是写起来比较麻烦而已，没别的难点了</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll add,mul,sum;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x) t[x].mul</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(x) t[x].add</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,P;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">l(rt) = l, r(rt) = r, add(rt) = <span class="number">0</span>, mul(rt) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum(rt) = a[l]; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid); BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread_add</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将累加标记向下传一层*/</span></span><br><span class="line"><span class="keyword">if</span>(!add(p)) <span class="keyword">return</span>;</span><br><span class="line">sum(p*<span class="number">2</span>) = (sum(p*<span class="number">2</span>) + (r(p*<span class="number">2</span>) - l(p*<span class="number">2</span>)+<span class="number">1</span>)*add(p)%P)%P;</span><br><span class="line">sum(p*<span class="number">2</span>+<span class="number">1</span>) = (sum(p*<span class="number">2</span>+<span class="number">1</span>) + (r(p*<span class="number">2</span>+<span class="number">1</span>) - l(p*<span class="number">2</span>+<span class="number">1</span>)+<span class="number">1</span>)*add(p)%P)%P;</span><br><span class="line">add(p*<span class="number">2</span>) = (add(p*<span class="number">2</span>) + add(p))%P; </span><br><span class="line">add(p*<span class="number">2</span>+<span class="number">1</span>) = (add(p*<span class="number">2</span>+<span class="number">1</span>)+add(p))%P; </span><br><span class="line">add(p) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread_mul</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将累乘标记向下传一层,累乘标记对累加标记也有影响*/</span> </span><br><span class="line"><span class="keyword">if</span>(mul(p) == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">sum(p*<span class="number">2</span>) = sum(p*<span class="number">2</span>)*mul(p)%P;</span><br><span class="line">sum(p*<span class="number">2</span>+<span class="number">1</span>) = sum(p*<span class="number">2</span>+<span class="number">1</span>)*mul(p)%P;</span><br><span class="line">mul(p*<span class="number">2</span>) = mul(p*<span class="number">2</span>)*mul(p)%P;</span><br><span class="line">mul(p*<span class="number">2</span>+<span class="number">1</span>) = mul(p*<span class="number">2</span>+<span class="number">1</span>)*mul(p)%P;</span><br><span class="line"><span class="comment">/*更新add标记*/</span> </span><br><span class="line">add(p*<span class="number">2</span>) = add(p*<span class="number">2</span>)*mul(p)%P;</span><br><span class="line">add(p*<span class="number">2</span>+<span class="number">1</span>) = add(p*<span class="number">2</span>+<span class="number">1</span>)*mul(p)%P; </span><br><span class="line">mul(p) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">add(rt) = add(rt)*val%P;<span class="comment">//更新add标记！ </span></span><br><span class="line">sum(rt) = sum(rt)*val%P;</span><br><span class="line">mul(rt) = mul(rt)*val%P;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">spread_mul(rt);spread_add(rt); </span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) Mul(rt*<span class="number">2</span>,l,r,val);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) Mul(rt*<span class="number">2</span>+<span class="number">1</span>,l,r,val);</span><br><span class="line">sum(rt) = (sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>))%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r)&#123;</span><br><span class="line">sum(rt) = (sum(rt) + (r(rt)-l(rt)+<span class="number">1</span>)*val % P)%P;</span><br><span class="line">add(rt) = (add(rt)+val)%P; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">spread_mul(rt); spread_add(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) Add(rt*<span class="number">2</span>,l,r,val);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) Add(rt*<span class="number">2</span>+<span class="number">1</span>,l,r,val);</span><br><span class="line">sum(rt) = (sum(rt*<span class="number">2</span>) + sum(rt*<span class="number">2</span>+<span class="number">1</span>))%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(rt) &amp;&amp; r(rt) &lt;= r) <span class="keyword">return</span> sum(rt)%P;</span><br><span class="line">spread_mul(rt); spread_add(rt) ;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) res += ask(rt*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) res += ask(rt*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> res%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;P);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,a+i), a[i] %= P;</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,op,t,g,c;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op);</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;t,&amp;g,&amp;c);</span><br><span class="line">Mul(<span class="number">1</span>,t,g,c);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;t,&amp;g,&amp;c);</span><br><span class="line">Add(<span class="number">1</span>,t,g,c);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t,&amp;g);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(<span class="number">1</span>,t,g));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一维RMQ问题题集</title>
      <link href="/2019/10/07/st-problems/"/>
      <url>/2019/10/07/st-problems/</url>
      
        <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/index.php" target="_blank" rel="noopener">书本配套OJ</a><br><a href="http://www.mfstem.org/" target="_blank" rel="noopener">本校OJ</a></p><p>ST表使用说明：</p><ul><li>常用于离线问题，或当作辅助数据结构，查询时间非常优秀，O(1)</li><li>二维st表也很好实现，不过本题集中未涉及</li><li>st表内也可以维护的是下标而非值，在某些时候很有用</li></ul><h4 id="数列区间最大值"><a href="#数列区间最大值" class="headerlink" title="数列区间最大值"></a>数列区间最大值</h4><p><strong>题意简述</strong><br>输入一串数字，给你 M 个询问，每次询问就给你两个数字 X,Y，要求你说出 X 到 Y 这段区间内的最大数。<br><strong>解题思路</strong><br>st表模板题。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>] ,Log[N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'-'</span> &amp;&amp; (c &lt;<span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i]= Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)&#123;</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="最敏捷的机器人"><a href="#最敏捷的机器人" class="headerlink" title="最敏捷的机器人"></a>最敏捷的机器人</h4><p><strong>题意简述</strong><br>Wind 设计了很多机器人。但是它们都认为自己是最强的，于是，一场比赛开始了……</p><p>机器人们都想知道谁是最敏捷的，于是它们进行了如下一个比赛。首先，他们面前会有一排共 n 个数，它们比赛看谁能最先把每连续 k 个数中最大和最小值写下来，当然，这些机器人运算速度都很快，它们比赛的是谁写得快。</p><p>但是 Wind 也想知道答案，你能帮助他吗？<br><strong>解题思路</strong><br>st表模板题，不过还要维护一下最小值，多开一个数组即可。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>] ,Log[N], st2[N][<span class="number">22</span>];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'-'</span> &amp;&amp; (c &lt;<span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i]= Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st2[i][<span class="number">0</span>] = st[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)&#123;</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">st2[i][j] = min(st2[i][j<span class="number">-1</span>],st2[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> mx = max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"><span class="keyword">int</span> mi = min(st2[l][k],st2[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,mx,mi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n-m+<span class="number">1</span>;i++) ask(i,i+m<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="与众不同"><a href="#与众不同" class="headerlink" title="与众不同*"></a>与众不同*</h4><p><strong>题意简述</strong><br>A 是某公司的 CEO，每个月都会有员工把公司的盈利数据送给 A，A 是个与众不同的怪人，A 不注重盈利还是亏本，而是喜欢研究「完美序列」：一段连续的序列满足序列中的数互不相同。<br>A 想知道区间 [L,R] 之间最长的完美序列长度。</p><p><strong>解题思路</strong><br>我们可以通过标记数组在O(N)时间内求出每个位置“作为结束位置”时的最长完美序列长度，以及它的起点。<br>设last[ x ] 表示 x 上次出现的位置；bgn[ p ]表示以位置 p 为末尾的完美序列的起点位置；len[p] 表示以位置 p 为末尾的完美序列的长度。显然我们可以在一次遍历内更新完毕上述三个数组，O(N)。<br>那么对于任意区间[ L , R ]，其内的最长完美序列长度仅有 2 种可能，一种是终点在区间内，起点不在；另一种是起点和终点都在区间内。此时我们已经可以通过一次遍历来求答案了，但是复杂度最差O(N)，不可取。由于bgn[]是单调递增的，所以对于某个位置 pos，[ L , pos-1] 所有位置上的起点都小于 L，[pos , R]上所有位置上的起点都大于L，那么我们可以通过ST表维护 [pos ,R] 上的最大的 len 值，在O(1)时间内求出，那么答案就是max(pos-L , ask(pos , R) )。</p><p>我们可以通过二分搜索来查找 pos ,复杂度 O(log N)，根据len数组构造st表，O(NlogN)，总时间复杂度O( (N+M)logN )。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">1e6</span>;</span><br><span class="line"><span class="comment">/*last[x]为x上一次出现的位置;</span></span><br><span class="line"><span class="comment">bgn[p]为以位置p结尾的起点位置;len[p]为以p结尾的完美序列长度*/</span></span><br><span class="line"><span class="keyword">int</span> last[SZ],bgn[N],len[N];</span><br><span class="line"><span class="keyword">int</span> a[N],Log[N],st[N][<span class="number">22</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_st</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = len[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;<span class="number">1</span>&lt;&lt;j &lt;= n;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(bgn[mid] &gt;= x) r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">bgn[i] = max(bgn[i<span class="number">-1</span>],last[a[i]+B]+<span class="number">1</span>);<span class="comment">//起始位置必须合法 </span></span><br><span class="line">len[i] = i - bgn[i] + <span class="number">1</span>;</span><br><span class="line">last[a[i]+B] = i;</span><br><span class="line">&#125;</span><br><span class="line">init_st();<span class="comment">//建立len数组的st表 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,p,res;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);x++,y++; </span><br><span class="line">p = bsearch(x,y,x);<span class="comment">//找到[x,y]内第一个bgn大于等于x的位置 </span></span><br><span class="line"><span class="keyword">if</span>(p &lt;= y) res = max(p-x,ask(p,y));</span><br><span class="line"><span class="keyword">else</span> res = p-x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="天才的记忆"><a href="#天才的记忆" class="headerlink" title="天才的记忆"></a>天才的记忆</h4><p><strong>代码示例：</strong> 模板模板，题面和思路不说了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>] ,Log[N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'-'</span> &amp;&amp; (c &lt;<span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i]= Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)&#123;</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt();;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">init(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Balanced-Lineup"><a href="#Balanced-Lineup" class="headerlink" title="Balanced Lineup"></a>Balanced Lineup</h4><p><strong>代码示例：</strong> 和“敏捷的机器人”一样，都是要维护最大以及最小值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">22</span>] ,Log[N], st2[N][<span class="number">22</span>];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'-'</span> &amp;&amp; (c &lt;<span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i]= Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st2[i][<span class="number">0</span>] = st[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>) &lt;= n;i++)&#123;</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">st2[i][j] = min(st2[i][j<span class="number">-1</span>],st2[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> mx = max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"><span class="keyword">int</span> mi = min(st2[l][k],st2[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mx-mi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">ask(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="选择客栈"><a href="#选择客栈" class="headerlink" title="选择客栈*"></a>选择客栈*</h4><p><strong>题意描述</strong><br>丽江河边有 n 家很有特色的客栈，客栈按照其位置顺序从 1 到 n 编号。</p><p>每家客栈都按照某一种色调进行装饰（总共 k 种，用整数 0 k−1 表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。</p><p>两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。</p><p>晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 p 。</p><p>他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 p 元的咖啡店小聚。</p><p><strong>解题思路</strong><br>没看正解是啥，我没用到st表，不过倒是用到了求RMQ的步骤。<br>共三个辅助数组，col[k] 表示当前第k种颜色客栈的数量；val[x]表示客栈x的最低消费；mip[x]表示 [x, n] 内第一个最低消费小于等于 p 元的客栈位置。<br>如果第一个人入住客栈x，第二个人能够入住的旅店的位置一定是大于等于mip[x]的，并且要颜色和 x 相同，即col[ a[i] ]种选择方案。所以我们只需要从前往后顺序遍历一遍并统计答案即可，复杂度O(N)。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> col[K];</span><br><span class="line"><span class="keyword">int</span> n,m,p;</span><br><span class="line"><span class="keyword">int</span> a[N],val[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'-'</span> &amp;&amp; (c &lt;<span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) neg = <span class="literal">true</span>,c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>,c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg?-ans:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mip[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">mip[n+<span class="number">1</span>] = n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(val[i] &gt; p) mip[i] = mip[i+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> mip[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">1</span>; ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> now = mip[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = pre;j &lt; now;j++) col[a[j]]--;</span><br><span class="line"><span class="comment">//printf("%d %d %d\n",pre,now,col[a[i]]);</span></span><br><span class="line">ans += col[a[i]]; pre = now;</span><br><span class="line"><span class="keyword">if</span>(now == i) ans--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt(); p = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= n;i++)&#123;</span><br><span class="line">a[i] = getInt(); val[i] = getInt(); </span><br><span class="line">col[a[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> st表 </tag>
            
            <tag> RMQ问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组题集</title>
      <link href="/2019/10/06/BIT-problems/"/>
      <url>/2019/10/06/BIT-problems/</url>
      
        <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/index.php" target="_blank" rel="noopener">书本配套OJ</a><br><a href="http://www.mfstem.org/contests" target="_blank" rel="noopener">我校OJ</a><br><strong>树状数组知识点：</strong></p><ul><li>单点修改，区间求和，O(logN)。</li><li>区间修改，区间求和，O(logN)。</li><li>二维树状数组单点修改，子矩阵求和，时间复杂度O(logN * logN)，空间O(N^2)。</li></ul><p>与线段树相比功能比较单一，不够灵活，但胜在简短易写，可以用来打辅助。</p><p><strong>注意事项</strong></p><ul><li>树状数组修改的下标不能为0，因为 lowbit(0) = 0，这就死循环了。</li><li>注意树状数组的空间，这是由值域来决定的，而不是定义域。</li></ul><h4 id="数列操作"><a href="#数列操作" class="headerlink" title="数列操作"></a>数列操作</h4><p><strong>题目描述</strong><br>给定n个数列,规定有两种操作，一是修改某个元素，二是求子数列[a,b]的连续和。数列元素个数最多10万个，询问操作最多10万次。<br><strong>解题思路</strong><br>模板题。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,m; </span><br><span class="line">ll A[N],c[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">/*把第x位置上的数+y*/</span></span><br><span class="line"><span class="keyword">for</span>(;x &lt;= n;x += x&amp;-x) c[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回[1,x]元素和*/</span></span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x) res += c[x];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">int</span> k,a,b;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,A+i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Add(i,A[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;k,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">if</span>(k) Add(a,b);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(b)-ask(a<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="数星星-Stars"><a href="#数星星-Stars" class="headerlink" title="数星星 Stars"></a>数星星 Stars</h4><p><strong>题意简述</strong><br>给定 n 个点，定义每个点的等级是在该点左下方（含正左、正下）的点的数目，试统计每个等级有多少个点。<br>(详细描述见原题面)</p><p><strong>解题思路</strong><br>由于y是升序的，我们只需要记录比当前x小的star有多少个即可得知其等级 x ，然后用num[x]表示等级为x的星星个数，最终答案就是num数组。<br>CDQ分治也可以写，都是先将一维给变的有序，再统计另一维度。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c[N],n;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//若x=0则死循环 </span></span><br><span class="line"><span class="keyword">for</span>(;x &lt; N;x += x&amp;-x) c[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x) res += c[x];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">ans[ask(x+<span class="number">1</span>)]++;<span class="comment">//要注意x = 0这种情况 </span></span><br><span class="line">Add(x+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="校门外的树"><a href="#校门外的树" class="headerlink" title="校门外的树*"></a>校门外的树*</h4><p><strong>题意简述</strong></p><p>原题来自：Vijos P1448<br>校门外有很多树，学校决定在某个时刻在某一段种上一种树，保证任一时刻不会出现两段相同种类的树，现有两种操作：</p><ul><li>K=1，读入 l,r 表示在 l 到 r 之间种上一种树，每次操作种的树的种类都不同；</li><li>K=2，读入 l,r 表示询问 l 到 r 之间有多少种树。</li></ul><p><strong>解题思路</strong><br>刚开始以为是区间修改的题，后来发现不是。这题利用了差分数组的思想。如果我们假设c0[ x ] 存放 [1, x] 的左端点数量，c1[]存放右端点数量；如果所求区间为[l , r]，那么一共只可能有 6 种不同的线段：</p><ul><li>第一种是全在r右侧；</li><li>第二种是左端点在 [l ,r] 内，右端点在r右侧；</li><li>第三种是左右端点都在[l ,r] 内；</li><li>第四种是右端点在[l ,r]内，左端点在 l 左侧；</li><li>第五种是左右端点全在 l 左侧；</li><li>第六种是左端点在 l 左侧，右端点在 r 右侧。</li></ul><p>那么我们用 l 右侧所有的右端点的数量，减去 r 右侧左端点的数量，可以画图理解，简单。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,m; </span><br><span class="line">ll A[N],c[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> ty,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">/*把第x位置上的数+y*/</span></span><br><span class="line"><span class="keyword">for</span>(;x &lt; N;x += x&amp;-x) c[ty][x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> ty,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回[1,x]元素和*/</span></span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x) res += c[ty][x];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">int</span> k,a,b;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;k,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">Add(<span class="number">0</span>,a,<span class="number">1</span>); Add(<span class="number">1</span>,b,<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">/*分类讨论,所有线段共6种情况 */</span> </span><br><span class="line"><span class="keyword">int</span> t1 = ask(<span class="number">1</span>,N<span class="number">-1</span>) - ask(<span class="number">1</span>,a<span class="number">-1</span>); </span><br><span class="line"><span class="keyword">int</span> t2 = ask(<span class="number">0</span>,N<span class="number">-1</span>) - ask(<span class="number">0</span>,b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,t1-t2);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="清点人数"><a href="#清点人数" class="headerlink" title="清点人数"></a>清点人数</h4><p><strong>题意简述</strong><br>NK 中学组织同学们去五云山寨参加社会实践活动，按惯例要乘坐火车去。由于 NK 中学的学生很多，在火车开之前必须清点好人数。<br>初始时，火车上没有学生。当同学们开始上火车时，年级主任从第一节车厢出发走到最后一节车厢，每节车厢随时都有可能有同学上下。年级主任走到第 m 节车厢时，他想知道前 m 节车厢上一共有多少学生，但是他没有调头往回走的习惯。也就是说每次当他提问时，m 总会比前一次大。<br><strong>解题思路</strong><br>也是模板题。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c[N] ,n,k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;x &lt; N;x += x&amp;-x) c[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x) res += c[x];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= k;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'A'</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x); <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'B'</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y); Add(x,y);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y); Add(x,-y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h4><p><strong>题意简述</strong><br>题目来源：CQOI 2006<br>有一个 n 个元素的数组，每个元素初始均为 0。有 m 条指令，要么让其中一段连续序列数字反转——0 变 1，1 变 0（操作 1），要么询问某个元素的值（操作 2）。</p><p><strong>解题思路</strong><br>一个位置如果反转偶数次，那么它还是0，否则是1，因此我们只需要统计每个位置被反转了几次即可，用到了树状数组区间修改单点查询。树状数组区间修改的推导就不写了，书上有。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">2</span>][N],n,m ,num[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> ty,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;x &lt;= n;x += x&amp;-x) c[ty][x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> ty,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x) res += c[ty][x];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin); </span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line">z = getInt();</span><br><span class="line"><span class="keyword">if</span>(z == <span class="number">1</span>)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">Add(<span class="number">0</span>,x,<span class="number">1</span>); Add(<span class="number">0</span>,y+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">Add(<span class="number">1</span>,x,x); Add(<span class="number">1</span>,y+<span class="number">1</span>,-y<span class="number">-1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">y = getInt(); x = y;</span><br><span class="line"><span class="keyword">int</span> res = (y+<span class="number">1</span>)*ask(<span class="number">0</span>,y) - ask(<span class="number">1</span>,y) - x*ask(<span class="number">0</span>,x<span class="number">-1</span>) + ask(<span class="number">1</span>,x<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res&amp;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="打鼹鼠"><a href="#打鼹鼠" class="headerlink" title="打鼹鼠*"></a>打鼹鼠*</h4><p><strong>题意简述</strong><br>这是一道模板题。<br>给出一个 n×m 的零矩阵 A，你需要完成如下操作：<br>1 x y k：表示元素 Ax,y自增 k；<br>2 a b c d：表示询问左上角为 (a,b)，右下角为 (c,d) 的子矩阵内所有数的和。</p><p><strong>解题思路</strong><br>是二维树状数组模板题，但是空间卡的很紧，开到N = 5000就险过，开到N = (1&lt;&lt;12)+10就好了一点。<br>和vijos那个原题不同，数据不一样，范围也不一样，这题不会出现下标为0的情况。就注意一下二维更新和查询时，每次的y需要恢复原值即可，因此需要用个变量存放一下y初值。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = (<span class="number">1</span>&lt;&lt;<span class="number">12</span>)+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll c[N][N]; </span><br><span class="line"><span class="keyword">int</span> n ,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line"><span class="comment">//printf("%d %d %d\n",x,y,z);</span></span><br><span class="line"><span class="keyword">for</span>(;x &lt;= n;x += x&amp;-x)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> ty = y;ty &lt;= m;ty += ty&amp;-ty) c[x][ty] += z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> ty = y;ty;ty -= ty&amp;-ty) res += c[x][ty];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d,x,y,k,op;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt(); m = getInt();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op) != EOF)&#123;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">x = getInt(); y = getInt(); k = getInt();</span><br><span class="line">Add(x,y,k);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">a = getInt(); b = getInt(); c = getInt();d = getInt();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(c,d)-ask(c,b<span class="number">-1</span>)-ask(a<span class="number">-1</span>,d)+ask(a<span class="number">-1</span>,b<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> 二维树状数组 </tag>
            
            <tag> 树状数组区间修改 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AC自动机题集</title>
      <link href="/2019/10/06/ac-problems/"/>
      <url>/2019/10/06/ac-problems/</url>
      
        <content type="html"><![CDATA[<h4 id="Keywords-Search"><a href="#Keywords-Search" class="headerlink" title="Keywords Search"></a>Keywords Search</h4><p><strong>题意描述</strong><br>原题来自：HDU 2222<br>给定 n 个长度不超过 50 的由小写英文字母组成的单词准备查询，以及一篇长为 m 的文章，问：文中出现了多少个待查询的单词。多组数据。<br><strong>解题思路</strong><br>模板题<br><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;<span class="comment">//模式串个数 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">10</span>;<span class="comment">//文本串长度 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[N][<span class="number">50</span>],s[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">50</span>*N;<span class="comment">//trie节点数 </span></span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],End[SZ],tot ;</span><br><span class="line"><span class="keyword">int</span> fail[SZ];<span class="comment">//失配指针,类似于nex</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="keyword">sizeof</span> trie);</span><br><span class="line"><span class="built_in">memset</span>(End,<span class="number">0</span>,<span class="keyword">sizeof</span> End); tot = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 向trie树中插入字符串s */</span> </span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*利用bfs更新fail数组*/</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) trie[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop();</span><br><span class="line"><span class="comment">//printf("%d\n",q.size());</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.push(trie[p][i]);</span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 统计匹配成功的模式串个数并累加到ans上 */</span> </span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">int</span> k = trie[p][ch];</span><br><span class="line"><span class="keyword">while</span>(k &gt; <span class="number">1</span>)&#123;</span><br><span class="line">ans += End[k]; End[k] = <span class="number">0</span>;</span><br><span class="line">k = fail[k];</span><br><span class="line">&#125;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t,n;<span class="comment">//数组组数, 模式串个数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line">getFail(); ans = <span class="number">0</span>;</span><br><span class="line">ask(s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">init();<span class="comment">//多组数据不要忘了初始化！ </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[i]);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="玄武密码"><a href="#玄武密码" class="headerlink" title="玄武密码"></a>玄武密码</h4><p><strong>题意描述</strong></p><p>原题来自：JSOI 2012<br>在美丽的玄武湖畔，鸡鸣寺边，鸡笼山前，有一块富饶而秀美的土地，人们唤作进香河。相传一日，一缕紫气从天而至，只一瞬间便消失在了进香河中。老人们说，这是玄武神灵将天书藏匿在此。很多年后，人们终于在进香河地区发现了带有玄武密码的文字。更加神奇的是，这份带有玄武密码的文字，与玄武湖南岸台城的结构有微妙的关联。于是，漫长的破译工作开始了。<br>经过分析，我们可以用东南西北四个方向来描述台城城砖的摆放，不妨用一个长度为 N 的序列来描述，序列中的元素分别是 E，S，W，N，代表了东南西北四向，我们称之为母串。而神秘的玄武密码是由四象的图案描述而成的 M 段文字。<br>现在，考古工作者遇到了一个难题。对于每一段文字，其前缀在母串上的最大匹配长度是多少呢？</p><p><strong>解题思路</strong><br>求每个子串在母串上的最大匹配长度。如果挨个用子串来匹配母串，复杂度太高，所以要用AC自动机，以母串来匹配子串。<br>将母串在建立好的AC自动机上进行匹配，那么其所能到达的节点，就是可以和母串匹配的长度，所以我们每到一个节点，就对其进行标记，顺便也对其fail指针所指向的节点标记，那么最后一个被标记的节点，就是该子串所能匹配的最大长度。</p><p>那么我们如何找到最后一个被标记的节点呢？通过par数组，par[x]存放x的父亲节点的编号，如此就可以从后向前遍历了（下述代码中是nex数组）。</p><p>所以具体步骤有三步：</p><ul><li>根据所有子串建立AC自动机，同时更新par数组(代码中是nex数组)</li><li>利用母串对自动机上节点进行标记</li><li>利用par数组自底向上查找最后一个被标记的节点，该节点到根节点的路径长度就是与母串最大匹配，为此我们还需要记录每个字串结束时的节点编号End[id]，以及长度Len[id]</li></ul><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s[N],str[M][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = M*<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">5</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> fail[SZ],vis[SZ],End[SZ],nex[SZ];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIdx</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ch == <span class="string">'E'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">'S'</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">'W'</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = getIdx(s[i]);</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot,nex[tot] = p;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) trie[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">q.push(trie[p][i]);</span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mark</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = getIdx(s[i]);</span><br><span class="line"><span class="keyword">int</span> k = trie[p][ch];</span><br><span class="line"><span class="keyword">while</span>(k &gt; <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[k]) <span class="keyword">break</span>;</span><br><span class="line">vis[k] = <span class="number">1</span>; k = fail[k];</span><br><span class="line">&#125;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str[x]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = End[x];i &gt; <span class="number">1</span>;i = nex[i],len--) <span class="keyword">if</span>(vis[i]) <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) End[i] = Insert(str[i]);</span><br><span class="line">getFail();</span><br><span class="line">Mark(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) search(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[i]);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Censoring"><a href="#Censoring" class="headerlink" title="Censoring"></a>Censoring</h4><p><strong>题意简述</strong><br>原题来自：USACO 2015 Feb. Gold<br>有一个长度不超过 105 的字符串 S。Farmer John 希望在 S 中删掉 n 个屏蔽词（一个屏蔽词可能出现多次），这些词记为 t1∼tn。FJ 在 S 中从头开始寻找屏蔽词，一旦找到一个屏蔽词，FJ 就删除它，然后又从头开始寻找（而不是接着往下找）。<br>FJ 会重复这一过程，直到 S 中没有屏蔽词为止。注意删除一个单词后可能会导致 S 中出现另一个屏蔽词。<br>这 n 个屏蔽词不会出现一个单词是另一个单词子串的情况，这意味着每个屏蔽词在 S 中出现的开始位置是互不相同的，请帮助 FJ 完成这些操作并输出最后的 S。<br><strong>解题思路</strong><br>可以用KM+栈来解决，这里用AC自动机解决。<br>很容易想到的一个思路就是，建立好AC自动机后，从根节点开始匹配，如果匹配到叶子节点，即有End标记的节点，就说明当前字串是屏蔽词，删掉它，假设该子串长为 len ，那就将指针 p 回退到 len 步之前，继续匹配。<br>如此一来我们需要记录每个时刻的p指针，以及母串中保留的字符，用栈就可以很好的维护。如果屏蔽词匹配成功，长度为 len，那么母串中保留的字符从栈顶弹出 len 个，同时保存 p 的栈也弹出 len 个元素，栈顶元素就是 len 步之前的指针。</p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N], s[N];</span><br><span class="line"><span class="keyword">int</span> n, fail[SZ];</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],tot = <span class="number">1</span>,End[SZ];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p] = len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) trie[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.push(trie[p][i]); </span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> path[N];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>,Stack[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">getFail();<span class="comment">//为什么非要更新Fail数组呢 </span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,p = <span class="number">1</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = str[i]-<span class="string">'a'</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">Stack[++top] = p; path[top] = str[i];</span><br><span class="line"><span class="keyword">if</span>(End[p]) top -= End[p], p = Stack[top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= top;i++) <span class="built_in">putchar</span>(path[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s); Insert(s);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h4><p><strong>题意简述</strong><br>原题来自：TJOI 2013<br>某人读论文，一篇论文是由许多单词组成。但他发现一个单词会在论文中出现很多次，现在想知道每个单词分别在论文中出现多少次。<br><strong>解题思路</strong><br>这个文章是由这 n 个单词组成的，现在问每个单词出现多少次。直接用母串在fail树上匹配统计相同前缀个数是不对的，因为这样可能出现两个子串的重叠。根据AC自动机的特点啊，如果有个节点 x 的 fail 指针指向 y，那么说明 y 是 x 的前缀，即 y 是 x 的子串，那么自然有多少个 fail 指针指向 y，y就出现了多少次，而这个次数就是我们要求的单词出现的次数。</p><p>那么首先要记录AC自动机上每个节点出现的次数，因为单词可能出现重复。然后要记录结束时该子串对应的节点编号，End[id] = p；由于我们 fail 指针是从上到下更新的，而我们要统计次数需要从下到上转移，于是利用栈来存储 fail 指针转移时的节点编号，而后再更新 num 数组即可。<br><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">220</span>;</span><br><span class="line"><span class="built_in">string</span> str[N], s;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],End[SZ],tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> num[SZ];<span class="comment">// num[x] 为经过节点x的数量 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="keyword">const</span> <span class="keyword">int</span>&amp; id)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = s.length(), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">num[p]++;</span><br><span class="line">&#125;</span><br><span class="line">End[id] = p; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> fail[SZ];</span><br><span class="line"><span class="keyword">int</span> Stack[SZ], top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) trie[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop(); </span><br><span class="line">Stack[++top] = p;<span class="comment">//倒序记录编号 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.push(trie[p][i]);</span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i],i);</span><br><span class="line">getFail();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = top;i &gt; <span class="number">0</span>;--i)&#123;</span><br><span class="line">num[fail[Stack[i]]] += num[Stack[i]];</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cout</span> &lt;&lt; num[End[i]] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; str[i];</span><br><span class="line">solve(); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最短母串"><a href="#最短母串" class="headerlink" title="最短母串"></a>最短母串</h4><p><strong>题意描述</strong><br>原题来自：HNOI 2006<br>给定 n 个字符串 S1,S2,⋯,Sn，要求找到一个最短的字符串 T，使得这 n 个字符串都是 T 的子串。<br><strong>解题思路</strong><br>根据经验容易想到，母串要走完AC自动机上所有 有结束标记（End标记）的节点，而本题的答案就是找到最短的&amp;字典序最小的母串。<br>那提到结束标记 End，就应该想到 End 标记的转移，我们在求fail数组时顺便转移。如果每个结束标记都用不同id标识，那么母串只要能包含所有不同的结束标记即可。</p><p>既然只有最多12个子串，那么可以考虑用状态压缩节省空间。我们用 bfs 来求最短&amp;字典序最小母串。<br>由于母串最长600，而AC自动机上节点个数最多600，但是每个节点状态有1&lt;&lt;12种，因此 <code>vis[606][(1&lt;&lt;12)+1]</code> 用于表示该节点的对应状态是否被访问过； path[(1&lt;&lt;12)+1]用于存放由上一个状态转移而来需要添加的字符；s[606]自然就是存放最终母串。<br>当然还需要一些辅助数组，par[ ip ]记录 ip 的上一个状态的编号，用于查找路径；当然理论上讲path也算辅助数组。<br>接下来我们就可以通过bfs来实现不同状态间的转移了，实质上是bfs+状态压缩，实现起来还是有些难度的。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">60</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">600</span>+<span class="number">10</span>;<span class="comment">//一定要想好大小啊 </span></span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n, fail[SZ];</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>], End[<span class="number">30</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">605</span>][(<span class="number">1</span>&lt;&lt;<span class="number">12</span>)+<span class="number">1</span>]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch]; </span><br><span class="line">&#125;</span><br><span class="line">End[p] |= <span class="number">1</span>&lt;&lt;id;<span class="comment">//状压常用 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) trie[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.push(trie[p][i]);</span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">End[trie[p][i]] |= End[fail[trie[p][i]]];<span class="comment">//常用技巧 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*用来bfs计算最短母串*/</span></span><br><span class="line"><span class="keyword">char</span> path[<span class="number">606</span>*(<span class="number">1</span>&lt;&lt;<span class="number">12</span>)] ,s[<span class="number">606</span>];</span><br><span class="line"><span class="keyword">int</span> par[<span class="number">606</span>*(<span class="number">1</span>&lt;&lt;<span class="number">12</span>)],len = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="comment">/*分别是节点编号,当前状态,当前字符位置 */</span> </span><br><span class="line"><span class="keyword">int</span> p,now,ip;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;Node&gt; q2; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">q2.push(Node&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q2.empty())&#123;</span><br><span class="line">Node x = q2.front(); q2.pop();</span><br><span class="line"><span class="keyword">int</span> p = x.p,now = x.now,ip = x.ip;</span><br><span class="line"><span class="keyword">if</span>(now == (<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="comment">/*所有子串都包含了,可以输出答案了*/</span> </span><br><span class="line"><span class="keyword">for</span>(;ip;ip = par[ip]) s[len++] = path[ip];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,nex;i &lt; <span class="number">26</span>;i++)</span><br><span class="line"><span class="keyword">if</span>(!vis[trie[p][i]][nex = now|End[trie[p][i]]])&#123;</span><br><span class="line"><span class="comment">/*当前节点的第i个字符的 nex 状态未被访问过,访问并压入队列*/</span> </span><br><span class="line">vis[trie[p][i]][nex] = <span class="number">1</span>;</span><br><span class="line">path[++cnt] = i+<span class="string">'A'</span>, par[cnt] = ip;</span><br><span class="line"><span class="comment">/*压入下一个节点的编号,状态,字符结束位置*/</span> </span><br><span class="line">q2.push(Node&#123;trie[p][i],nex,cnt&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">getFail(); bfs();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--) <span class="built_in">putchar</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str); Insert(str,i<span class="number">-1</span>); </span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="POI-2000-病毒"><a href="#POI-2000-病毒" class="headerlink" title="POI 2000 病毒"></a>POI 2000 病毒</h4><p><strong>题意简述</strong></p><p>二进制病毒审查委员会最近发现了如下的规律：某些确定的二进制串是病毒的代码。如果某段代码中不存在任何一段病毒代码，那么我们就称这段代码是安全的。现在委员会已经找出了所有的病毒代码段，试问，是否存在一个无限长的安全的二进制代码。<br>示例：例如如果 {011,11,00000} 为病毒代码段，那么一个可能的无限长安全代码就是 010101⋯。如果 {01,11,000000} 为病毒代码段，那么就不存在一个无限长的安全代码。<br>请写一个程序，读入病毒代码，判断是否存在一个无限长的安全代码，将结果输出。</p><p><strong>解题思路</strong><br>本题要求找出一个无限长的安全的代码，无限长，当且仅当我们有一个安全的子串可以循环使用时才能构成。我们将AC自动机看作树，从根出发，那么叶子节点，即有End标记的节点是不能走的，因为该路径构成了病毒。同样的道理，如果当前节点fail指针所指向的节点有End标记，那么当前节点也不能走，因为它的子串是病毒串，所以我们在更新fail指针时顺便转移End标记（常用技巧）。<br>所以如果有一条路径，它上面的所有节点都没有End标记，且该路径构成环，那么它就可以构成一个无限长的安全字符串。</p><p>于是我们就只需要在AC自动机上通过dfs来找是否存在满足条件的环即可，而用拓扑排序不太好写。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> str[N];</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">3</span>],End[SZ],fail[SZ],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = s.length(), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">bool</span> f[SZ];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line">trie[<span class="number">0</span>][<span class="number">0</span>] = trie[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.push(trie[p][i]);</span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">End[trie[p][i]] |= End[trie[fail[p]][i]];<span class="comment">//转移标记</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> vis[SZ],ins[SZ];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">vis[p] = ins[p] = <span class="number">1</span>;    <span class="comment">//ins判断环,vis访问标记</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> k = trie[p][i];</span><br><span class="line"><span class="keyword">if</span>(ins[k]) flag = <span class="literal">true</span>;<span class="comment">//构成环了,这里也可以return</span></span><br><span class="line"><span class="keyword">if</span>(!End[k] &amp;&amp; !vis[k]) dfs(k);<span class="comment">//下一个满足条件的节点,递归访问它</span></span><br><span class="line">&#125;</span><br><span class="line">ins[p] = <span class="number">0</span>;<span class="comment">//释放p节点的标记</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line">getFail();</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="built_in">cout</span> &lt;&lt; <span class="string">"TAK"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NIE"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; str[i];</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="文本生成器"><a href="#文本生成器" class="headerlink" title="文本生成器"></a>文本生成器</h4><p><strong>题意简述</strong></p><p>原题来自：JSOI 2007JSOI<br>交给队员 ZYX 一个任务，编制一个称之为「文本生成器」的电脑软件：该软件的使用者是一些低幼人群，他们现在使用的是 GW 文本生成器 v6 版。该软件可以随机生成一些文章――总是生成一篇长度固定且完全随机的文章——也就是说，生成的文章中每个字节都是完全随机的。<br>如果一篇文章中至少包含使用者们了解的一个单词，那么我们说这篇文章是可读的（我们称文章 a 包含单词 b，当且仅当单词 b 是文章 a 的子串）。但是，即使按照这样的标准，使用者现在使用的 GW 文本生成器 v6 版所生成的文章也是几乎完全不可读的。<br>ZYX 需要指出 GW 文本生成器 v6 生成的所有文本中可读文本的数量，以便能够成功获得 v7 更新版。你能帮助他吗？</p><p><strong>解题思路</strong><br>首先易得所有不同的文本总数为$26^m$种，我们有两种容易想到的思路来求解，一个是利用容斥原理直接计算可读的文章总数，另一种是想办法计算不可读的文章数，再用不同的文章总数减去它。第一种思路很难实现，主要来看第二种思路如何实现。<br>类似上一题，如果一个文章是不可读的，那么从根出发，它不能经过有End标记的节点，也不能经过“fail指针指向的节点有End标记”的节点。所以不可读的文章总数就等于长度为m的<strong>合法路径</strong>数。所谓的合法路径就是上面提到的，路径上所有节点都没有End标记，且其fail指针指向的节点也没End标记。<br>我们通过动态规划来求<strong>方案总数</strong>，设f(i,j)表示从根节点出发，走了 i 步到达节点 j 时的合法方案总数，那么显然 f(0 , 1) = 1，因为节点 1 是AC自动机的根节点。<br>状态转移方程请结合代码理解。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">6000</span>*<span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">65</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> str[N][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],End[SZ],fail[SZ],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) trie[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.push(trie[p][i]);</span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">End[trie[p][i]] |= End[trie[fail[p]][i]];<span class="comment">//标记转移 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">110</span>][SZ] ,ans ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAns</span><span class="params">()</span></span>&#123;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= tot;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(End[j]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">26</span>;k++)&#123;</span><br><span class="line"><span class="comment">/*f[i][trie[j][k]]的方案总数显然等于它所有父亲的方案总数的和*/</span></span><br><span class="line">f[i][trie[j][k]] = (f[i][trie[j][k]]+f[i<span class="number">-1</span>][j])%P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>,tmp = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot;i++) </span><br><span class="line"><span class="keyword">if</span>(!End[i]) res = (res+f[m][i])%P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) tmp = tmp*<span class="number">26</span>%P;</span><br><span class="line">ans = (tmp-res+P)%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line">getFail();</span><br><span class="line">getAns();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[i]);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC自动机 </tag>
            
            <tag> 状态压缩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AC自动机模板</title>
      <link href="/2019/10/02/acji/"/>
      <url>/2019/10/02/acji/</url>
      
        <content type="html"><![CDATA[<h4 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h4><p>AC自动机是用来处理字符串匹配问题。KMP是处理单模式串匹配问题，而AC自动机是用于处理多模式串匹配问题，例如：给出 n 个单词，再给出一段包含 m 个字符的文章，问有多少个单词在文章中出现过？以下模板就是根据该问题整理。</p><p><strong>使用说明</strong><br>其中的trie树编号是从 1 开始，每次使用前都要初始化 tot = 1，以及trie数组、End数组都要初始化。<br>SZ设计要合理，SZ表示字典树中的节点数目上限，太多或太少都会运行错误。<br>本文利用queue来实现bfs，嫌慢可以手写模拟，不会麻烦多少。</p><p><strong>代码示例</strong><br><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1479" target="_blank" rel="noopener">Keywords Search</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;<span class="comment">//模式串个数 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">10</span>;<span class="comment">//文本串长度 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[N][<span class="number">50</span>],s[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">50</span>*N;<span class="comment">//trie节点数 </span></span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],End[SZ],tot ;</span><br><span class="line"><span class="keyword">int</span> fail[SZ];<span class="comment">//失配指针,类似于nex</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="keyword">sizeof</span> trie);</span><br><span class="line"><span class="built_in">memset</span>(End,<span class="number">0</span>,<span class="keyword">sizeof</span> End); tot = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 向trie树中插入字符串s */</span> </span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*利用bfs更新fail数组*/</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) trie[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">q.push(<span class="number">1</span>); fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front(); q.pop();</span><br><span class="line"><span class="comment">//printf("%d\n",q.size());</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][i]) trie[p][i] = trie[fail[p]][i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.push(trie[p][i]);</span><br><span class="line">fail[trie[p][i]] = trie[fail[p]][i];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 统计匹配成功的模式串个数并累加到ans上 */</span> </span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">int</span> k = trie[p][ch];</span><br><span class="line"><span class="keyword">while</span>(k &gt; <span class="number">1</span>)&#123;</span><br><span class="line">ans += End[k]; End[k] = <span class="number">0</span>;</span><br><span class="line">k = fail[k];</span><br><span class="line">&#125;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t,n;<span class="comment">//数组组数, 模式串个数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line">getFail(); ans = <span class="number">0</span>;</span><br><span class="line">ask(s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">init();<span class="comment">//多组数据不要忘了初始化！ </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[i]);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="对getFail-函数的一些解释"><a href="#对getFail-函数的一些解释" class="headerlink" title="对getFail()函数的一些解释"></a>对getFail()函数的一些解释</h5><p>fail 数组就像是 kmp 算法中的 nex 数组一样，是在失配时转移指针用的，利用它可以使得时间控制在O(N)。<br>就上述代码而言，我们是如何更新fail数组的呢？</p><ul><li>首先根节点若失配，则无法匹配字符，即 fail[1] = 0。</li><li>若当前位置有字符，则它的失配指针指向“它父亲节点失配指针所指向节点 的 下一个节点”，即 <code>fail[ trie[p][i] ]  = fail[ fail[p] ][i]</code>，其思想类似kmp中nex转移。</li><li>若当前位置无字符，即<code>trie[p][i] = 0</code>，那么就让当前节点指向其失配指针的子节点，即<code>trie[p][i] = trie[ fail[p] ][i]</code>。</li></ul><p>第 3 步破坏了 trie 的结构，但这样可以优化时间。若不存在<code>trie[p][i]</code> 的转移边则指向 <code>trie[ fail[p] ][i]</code>，因为在具体问题中，若不存在<code>trie[p][i]</code> 则需要沿着 p 的前缀指针走到第一个满足存在 i 字符的转移边的点 v，得到<code>trie[v][i]</code>，那么我们直接令 <code>trie[p][i] = trie[v][i]</code> 即可使得该情况得到优化，类似记忆化 &amp; 路径压缩。<br>也正是这个原因，我们在构建 fail 数组时，没有处理 v 的转移边 i 不存在的情况，而是直接<code>fail[ trie[p][i] = trie[v][i]</code>（其中 <code>trie[v][i]</code> 在之前已经处理好了）。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>董永建，信息学竞赛一本通提高版，福州：福建教育出版社，2018.6，93-97</li><li><a href="https://bestsort.cn/2019/04/28/402/" target="_blank" rel="noopener">bestsort</a>的博客</li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> AC自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trie字典树练习题集</title>
      <link href="/2019/09/30/trie-problems/"/>
      <url>/2019/09/30/trie-problems/</url>
      
        <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/index.php" target="_blank" rel="noopener">测试地址</a></p><h4 id="Phone-List"><a href="#Phone-List" class="headerlink" title="Phone List"></a>Phone List</h4><p>原题来自：POJ 3630<br>给定 n 个长度不超过 10 的数字串，问其中是否存在两个数字串 S,T，使得 S 是 T 的前缀，多组数据。</p><p><strong>解题思路</strong><br>Trie的经典应用，可以作为模板题练手。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>], tot;</span><br><span class="line"><span class="keyword">int</span> End[SZ];</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 将字串s插入trie树 */</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s) ,p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][ch] == <span class="number">0</span>) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 字串s是否有前缀 */</span> </span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(End[p]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(search(str[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n); </span><br><span class="line"><span class="comment">/* 初始化trie相关变量 */</span></span><br><span class="line"><span class="built_in">memset</span>(End,<span class="number">0</span>,<span class="keyword">sizeof</span> End); tot = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="keyword">sizeof</span> trie);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[i]);</span><br><span class="line"><span class="keyword">if</span>(solve()) <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="The-XOR-Largest-Pair"><a href="#The-XOR-Largest-Pair" class="headerlink" title="The XOR Largest Pair"></a>The XOR Largest Pair</h4><p><strong>题意简述</strong><br>在给定的 N 个整数 A1,A2,…,AN 中选出两个进行异或运算，得到的结果最大是多少？</p><p><strong>解题思路</strong><br>就是将每个整数看作31位的01字符串，然后全部插入到Trie上，再分别对每个整数从高位到低位优先在Trie上走和该位相反的节点。01字典树。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">5e6</span>+<span class="number">10</span>;<span class="comment">//大小要合理！！！ </span></span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">3</span>], End[SZ], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][ch] == <span class="number">0</span>) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][!ch]) p = trie[p][!ch], res |= <span class="number">1</span>&lt;&lt;i;</span><br><span class="line"><span class="keyword">else</span> p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) calc(a[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Codechef-REBXOR"><a href="#Codechef-REBXOR" class="headerlink" title="Codechef REBXOR*"></a>Codechef REBXOR*</h4><p><strong>题意简述</strong><br><img src="/2019/09/30/trie-problems/1.png" alt="trie-problems/1.png"><br><strong>解题思路</strong><br>这题用的是 “Trie维护异或前缀和”，根据异或的特性，我们从左到右依次将元素插入后，再利用 x^y^x = y 这个特性在常数时间利用 Trie 找最大区间异或和。本题还是很有参考意义的，尤其是异或前缀和这一技巧。<br>当然由于OJ上给定的空间过小，本代码没过，待解决。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">20</span>*N;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">3</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],lmx[N],rmx[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">32</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">32</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][!ch]) p = trie[p][!ch],res |= <span class="number">1</span>&lt;&lt;i;</span><br><span class="line"><span class="keyword">else</span> p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;Insert(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/* x 用于累计异或前缀和,Trie用于求最大异或区间*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">x ^= a[i]; Insert(x);</span><br><span class="line">lmx[i] = max(search(x),lmx[i<span class="number">-1</span>]);</span><br><span class="line"><span class="comment">//包含x的最大区间异或和 与  不包含x的区间的最大异或和 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="keyword">sizeof</span> trie); tot = <span class="number">1</span>;</span><br><span class="line">Insert(<span class="number">0</span>); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">x ^= a[i]; Insert(x);</span><br><span class="line">rmx[i] = max(search(x),rmx[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) ans = max(ans,lmx[i]+rmx[i+<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = getInt();</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Immediate-Decodability"><a href="#Immediate-Decodability" class="headerlink" title="Immediate Decodability"></a>Immediate Decodability</h4><p><strong>题意简述</strong><br>原题来自：ACM Pacific NW Region 1998<br>给出一些数字串，判断是否有一个数字串是另一个串的前缀。<br><strong>解题思路</strong><br>和第1题一样，模板题。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> End[SZ];</span><br><span class="line"><span class="keyword">int</span> n,t,cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 将字串s插入trie树 */</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s) ,p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][ch] == <span class="number">0</span>) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 字串s是否有前缀 */</span> </span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(End[p]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(search(str[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[++n]) != EOF)&#123;</span><br><span class="line"><span class="comment">/* 初始化trie相关变量 */</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(str[n]) == <span class="number">1</span> &amp;&amp; str[n][<span class="number">0</span>] == <span class="string">'9'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!solve()) <span class="built_in">printf</span>(<span class="string">"Set %d is immediately decodable\n"</span>,++cnt);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Set %d is not immediately decodable\n"</span>,++cnt);</span><br><span class="line"><span class="built_in">memset</span>(End,<span class="number">0</span>,<span class="keyword">sizeof</span> End); tot = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="keyword">sizeof</span> trie); n = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="L语言"><a href="#L语言" class="headerlink" title="L语言*"></a>L语言*</h4><p><strong>题意简述</strong></p><p>原题来自：HNOI 2004<br>标点符号的出现晚于文字的出现，所以以前的语言都是没有标点的。现在你要处理的就是一段没有标点的文章。<br>一段文章 T 是由若干小写字母构成。一个单词 W 也是由若干小写字母构成。一个字典 D 是若干个单词的集合。<br>我们称一段文章 T 在某个字典 D 下是可以被理解的，是指如果文章 T 可以被分成若干部分，且每一个部分都是字典 D 中的单词。例如字典 D 中包括单词 is , your , what , name ，则文章 whatisyourname 是在字典 D 下可以被理解的，因为它可以分成 4 个单词： what , is , your , name ，且每个单词都属于字典 D，而文章 whatisyouname 在字典 D 下不能被理解，但可以在字典 D′=D+you 下被理解。这段文章的一个前缀 whatis ，也可以在字典 D 下被理解 而且是在字典 D 下能够被理解的最长的前缀。<br>给定一个字典 D ，你的程序需要判断若干段文章在字典 D 下是否能够被理解。 并给出其在字典 D 下能够被理解的最长前缀的位置。<br><strong>解题思路</strong><br>这题有点难的地方是  文章中某个前缀可能由多个单词组合出来，于是我们需要对每个可能是单词末尾的位置再进行下一次匹配，检查其后是否有字典D中的单词。</p><p>我们首先将所有单词插入字典树，由于单词长度小于10，所以对于每个单词，我们最多比较10次就能知道该字串是否为字典D中的单词。每次匹配都要从字典树的根开始匹配。<br>我们设f[i]表示 “文章中第 i 位是否为可以被D理解的某个前缀的末尾”；如果 f[i] 为 1 ，那么说明[1, i]都可以被D理解，接下来只要再从 i+1 位开始尝试在字典树匹配单词即可。<br>这是存在性DP，状态转移很简单，在字典树查找单词时，若当前位置是某个单词的末尾，即End[ p ] = 1，那么f[ pos ] = 1（pos为当前字符位置），时间复杂度为O(10N)。</p><p><strong>优化</strong><br>在 查找/匹配 单词时，我习惯将其封装为一个函数search(char * s)，但是最差情况我们会调用1e6次该函数，虽然该函数内最多只比较10次，但是函数传参以及保护现场以及恢复等步骤还是会大大增加花费的时间。经过测试，写成函数调用形式在1e6数据下大概会比直接展开慢几十秒，当然还是可以通过一些步骤优化函数调用的。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],End[SZ], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> str[N],s[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">bool</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str)<span class="number">-1</span>, ans;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f); f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//printf("%d\n",len);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!f[i]) <span class="keyword">continue</span>;</span><br><span class="line">ans = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>,p = <span class="number">1</span>;j &lt;= len;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = str[j]-<span class="string">'a'</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line"><span class="keyword">if</span>(!p) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(End[p]) f[j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s); Insert(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'#'</span>; solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Secret-Message-秘密信息"><a href="#Secret-Message-秘密信息" class="headerlink" title="Secret Message 秘密信息"></a>Secret Message 秘密信息</h4><p><strong>题意描述</strong><br>原题来自：USACO 2008 Dec. Gold<br>贝茜正在领导奶牛们逃跑。为了联络，奶牛们互相发送秘密信息。信息是二进制的，共有 M 条。反间谍能力很强的约翰已经部分拦截了这些信息，知道了第 i 条二进制信息的前 bi 位。<br>他同时知道，奶牛使用 N 条密码。但是，他仅仅了解第 j 条密码的前 cj位。对于每条密码 j ，他想知道有多少截得的信息能够和它匹配。也就是说，有多少信息和这条密码有着相同的前缀。当然，这个前缀长度必须等于密码和那条信息长度的较小者。</p><p><strong>解题思路</strong><br>根据所给样例呢，可以更加明确题意。首先我们将M条信息看作01字符串，同理N条密码也看作01字符串，题意问的就是对于每个密码，有多少条信息可能和该密码匹配，如果一条信息 A 和密码 B 匹配，那么有 A 是 B 的前缀或 B 是 A 的前缀。<br>于是我们就只需要先把01数组转化为01字符串，再用trie统计即可，当然由于同一信息可能会重复出现，所以 End[p] 记录的是以 p 结尾的字串个数。<br>在本机与洛谷上都是可以AC的，复杂度大概O(5e5)，但是在一本通OJ就过不去，猜测可能是不支持关闭 scanf 同步流？待修改。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="built_in">string</span> str[N],s[N];</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">2</span>],End[SZ],tot = <span class="number">1</span>,tc[SZ];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = s.length(), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">tc[p]++;</span><br><span class="line">&#125;</span><br><span class="line">End[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span></span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; s &lt;&lt; "-" &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">int</span> len = s.length(), p = <span class="number">1</span>,res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'0'</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line"><span class="keyword">if</span>(!p) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(End[p] &amp;&amp; i != len<span class="number">-1</span>) res += End[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res + tc[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">cout</span> &lt;&lt; search(s[i]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("222.txt","w",stdout);</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,k;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>,x;j &lt;= k;j++) <span class="built_in">cin</span> &gt;&gt; x, str[i] += x+<span class="string">'0'</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; str[i] &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,k;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>,x;j &lt;= k;j++) <span class="built_in">cin</span> &gt;&gt; x, s[i] += x+<span class="string">'0'</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; s[i] &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="【SCOI2016】背单词"><a href="#【SCOI2016】背单词" class="headerlink" title="【SCOI2016】背单词*"></a>【SCOI2016】背单词*</h4><p><strong>题意简述</strong><br>Lweb 面对如山的英语单词，陷入了深深的沉思，「我怎么样才能快点学完，然后去玩三国杀呢？」。<br>这时候睿智的凤老师从远处飘来，他送给了 Lweb 一本计划册和一大缸泡椒，然后凤老师告诉 Lweb ，我知道你要学习的单词总共有 n 个，现在我们从上往下完成计划表，对于一个序号为 x 的单词（序号 1…x−1 都已经被填入）：</p><ul><li>如果存在一个单词是它的后缀，并且当前没有被填入表内，那他需要吃 n×n 颗泡椒才能学会；</li><li>当它的所有后缀都被填入表内的情况下，如果在 1…x−1 的位置上的单词都不是它的后缀，那么他吃 x 颗泡椒就能记住它；</li><li>当它的所有后缀都被填入表内的情况下，如果 1…x−1 的位置上存在是它后缀的单词，所有是它后缀的单词中，序号最大为 y，那么你只要吃 x−y 颗泡椒就能把它记住。</li></ul><p>Lweb 是一个吃到辣辣的东西会暴走的奇怪小朋友，所以请你帮助 Lweb，寻找一种最优的填写单词方案，使得他记住这  n 个单词的情况下，吃最少的泡椒。</p><p><strong>解题思路</strong><br>首先把所有字符串反转，那么后缀就变成前缀了，就可以用trie维护。<br>刚开始我是想记录每个字符串的前缀个数，然后根据个数从小到大分配编号，但显然不行。<br>正解是将所有字符串构成一棵树，一个节点的父亲就是它的前缀，而没有前缀的字符串父亲为 0 号节点。我们可以利用 trie中的 search 时填边建树。<br>这样我们就有一棵有向树了，假设我们给节点 x 分配的序号是 f[x] ，那么显然 ans += f[x] - f[par[x] ]，其中 par[x] 代表 x 的父亲节点。所以我们需要让每个节点和它父亲节点的编号相差尽量小，那么自然是优先给节点数少的子树分配编号咯，所以对于每个节点 x ，我们选择节点最小的一棵子树，为它们分配编号。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">6e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> tc[N];<span class="comment">//记录后缀个数</span></span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">30</span>],End[SZ], tot = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> par[N], head[N], ver[N], nex[N],tot2 = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot2] = y, nex[tot2] = head[x], head[x] = tot2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">int</span> len = s.length(), p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">End[p] = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">int</span> len = s.length(), p = <span class="number">1</span> ,res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = s[i]-<span class="string">'a'</span>;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line"><span class="keyword">if</span>(End[p] &amp;&amp; i != len<span class="number">-1</span>) par[id] = End[p];</span><br><span class="line">&#125;</span><br><span class="line">addEdge(par[id],id);<span class="comment">//顺便建树啦 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> str[N];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> num[N];<span class="comment">//记录子树x的节点个数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i != <span class="number">-1</span>;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line">num[x] += dfs(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num[x]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">priority_queue&lt; pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="keyword">int</span> f[N]; <span class="comment">//记录x编号 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">ans += cnt - f[par[x]]; f[x] = cnt; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i != <span class="number">-1</span>;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line">q.push(make_pair(-num[y],y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> nnex[q.size()],tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> y = q.top().second;q.pop();</span><br><span class="line">nnex[tt++] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tt;i++) cnt++, calc(nnex[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(str[i],i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) search(str[i],i);</span><br><span class="line">num[<span class="number">0</span>] = dfs(<span class="number">0</span>); calc(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; str[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) reverse(str[i].begin(),str[i].end());</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="The-xor-longest-Path"><a href="#The-xor-longest-Path" class="headerlink" title="The xor-longest Path*"></a>The xor-longest Path*</h4><p><strong>题意简述</strong><br>原题来自：POJ 3764<br>给定一棵 n 个点的带权树，求树上最长的异或和路径。</p><p><strong>解题思路</strong><br>设 d[x] 表示 x 到根节点的路径异或和，那么显然由于异或的特性，x^y^x = y，我们任选两个点 x 和 y ，那么d[x] ^ d[y]就是 x 和 y 之间的路径异或和，因为从LCA(x , y)到根节点的路径都被抵消了。<br>所以原问题就成了从 d[1,n] 中选两个数，使它们的异或和最大。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N],nex[N],edge[N],tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,d[N];<span class="comment">//d[x]:x到根节点的路径异或和 </span></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y, nex[tot] = head[x];</span><br><span class="line">edge[tot] = z, head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//printf("%d %d %d\n",x,y,z);</span></span><br><span class="line">d[y] = d[x]^z;</span><br><span class="line">dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">32</span>*N;</span><br><span class="line"><span class="keyword">int</span> trie[SZ][<span class="number">2</span>], tot2 = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>,p = <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][ch]) trie[p][ch] = ++tot2;</span><br><span class="line">p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回x与集合中异或和最大的 结果*/</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>,p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> ch = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][!ch]) p = trie[p][!ch],res |= <span class="number">1</span>&lt;&lt;i;</span><br><span class="line"><span class="keyword">else</span> p = trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/* 计算并输出答案 */</span></span><br><span class="line">dfs(<span class="number">1</span>); <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Insert(d[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) ans = max(ans,search(d[i]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line">n = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt; n;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt(); z = getInt();</span><br><span class="line">addEdge(x,y,z); addEdge(y,x,z);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法练习题集</title>
      <link href="/2019/09/29/kmp-problems/"/>
      <url>/2019/09/29/kmp-problems/</url>
      
        <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/index.php" target="_blank" rel="noopener">测试地址</a></p><h4 id="剪花布条"><a href="#剪花布条" class="headerlink" title="剪花布条"></a>剪花布条</h4><p><strong>题意简述</strong><br>原题来自：HDU 2087<br>一块花布条，里面有些图案，另有一块直接可用的小饰条，里面也有一些图案。对于给定的花布条和小饰条，计算一下能从花布条中尽可能剪出几块小饰条来呢？</p><p><strong>解题思路</strong><br>就是普通的kmp算法，只不过这里的两个模式串不能重叠，我们基于贪心策略遇到一个选一个即可。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> f[N],nex[N];</span><br><span class="line"><span class="keyword">char</span> S[N],T[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getF</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(s)<span class="number">-1</span>, m = <span class="built_in">strlen</span>(t)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; (j == m || s[i] != t[j+<span class="number">1</span>])) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == t[j+<span class="number">1</span>]) j++;</span><br><span class="line">f[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">getNex(T);</span><br><span class="line">getF(S,T);</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(S)<span class="number">-1</span>, m = <span class="built_in">strlen</span>(T)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt; r &amp;&amp; f[i] == m) ans++ ,r = i+m<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,S+<span class="number">1</span>) &amp;&amp; S[<span class="number">1</span>] != <span class="string">'#'</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,T+<span class="number">1</span>); S[<span class="number">0</span>] = T[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Power-Strings"><a href="#Power-Strings" class="headerlink" title="Power Strings"></a>Power Strings</h4><p>在之前的字符串与Hash题集中做过，而且刚过去不久，不整理了。</p><h4 id="Radio-Transmission"><a href="#Radio-Transmission" class="headerlink" title="Radio Transmission"></a>Radio Transmission</h4><p><strong>题意简述</strong><br>给你一个字符串，它是由某个字符串不断自我连接形成的。但是这个字符串是不确定的，现在只想知道它的最短长度是多少。</p><p><strong>解题思路</strong><br>求最短循环节，给定的字符串可能是由循环节循环构成的字串的一个子串，所以就直接用求最短循环节就可以了，省去用字符串hash判断该串是否满足了。<br><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n,nex[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">getNex(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n - nex[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="OKR-Periods-of-Words"><a href="#OKR-Periods-of-Words" class="headerlink" title="OKR-Periods of Words"></a>OKR-Periods of Words</h4><p><strong>题意简述</strong></p><p>原题来自：POI 2006<br>串是有限个小写字符的序列，特别的，一个空序列也可以是一个串。一个串 P 是串 A 的前缀，当且仅当存在串 B，使得 A=PB。如果P≠A并且 P 不是一个空串，那么我们说 P 是 A 的一个 proper 前缀。<br>定义 Q 是 A 的周期，当且仅当 Q 是 A 的一个 proper 前缀并且 A 是 QQ 的前缀（不一定要是 proper 前缀）。比如串 abab 和 ababab 都是串 abababa 的周期。串 A 的最大周期就是它最长的一个周期或者是一个空串（当 A 没有周期的时候），比如说，ababab 的最大周期是 abab。串 abc 的最大周期是空串。<br>给出一个串，求出它所有前缀的最大周期长度之和。</p><p><strong>解题思路</strong><br>题意有一些绕，但是还好给的是中文题面，尚可理解。就是说P是A的一个真子串，且是A的前缀，那么P就是A的proper前缀。若Q是A的proper前缀，且A是QQ（两个Q拼接在一起）的前缀（前缀不必要是真子串），那么Q就是A的周期。<br>现在要求的是A的 所有前缀的 最长周期的长度之和。</p><p>如果要是求最短周期的长度，那么直接就是求最短循环节，跑一遍nex就解决了；现在要求最长周期的长度，相当于求最长的循环节（该循环节不能等于原串！否则就不是proper前缀了），那么就不断的令 j = nex[j]，找到非零的最小 nex[j] （将nex数组看作father数组，一棵father树），那么最长循环节就是 i - j 了。</p><p>这样会超时，因为我们每次令j = nex[j]相当于从叶子节点走到根节点，最坏情况是O(N)才能找到最小的非零 nex[j]，总时间复杂度就是O(N^2)。</p><p><strong>优化</strong><br>我们令 f[j] 表示根到 j 路径上最小非零的值。（我们把nex数组看作一棵树！！！）<br>那么对于任意的nex[p]，若nex[p] != 0，那么最长周期就是 p - f[nex[p] ]。<br>我们在求nex数组时顺便更新 f 数组，和记忆化类似，思路不难理解。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n,nex[N],f[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s)<span class="number">-1</span>; f[<span class="number">0</span>] = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line"><span class="keyword">if</span>(j) f[j] = min(j,f[nex[j]]);</span><br><span class="line"><span class="comment">//printf("%d %d\n",j,f[j]);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">getNex(str);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex[i]) ans += i - f[nex[i]];</span><br><span class="line"><span class="comment">//printf("%d %c\n",ans,str[i]);</span></span><br><span class="line"><span class="comment">//printf("%d %d\n",nex[i],f[i]);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="似乎在梦中见过的样子"><a href="#似乎在梦中见过的样子" class="headerlink" title="似乎在梦中见过的样子"></a>似乎在梦中见过的样子</h4><p><strong>题意简述</strong><br>原题来自：2014 年湖北省队互测 Week2<br>「Madoka，不要相信 QB！」伴随着 Homura 的失望地喊叫，Madoka 与 QB 签订了契约。<br>这是 Modoka 的一个噩梦，也同时是上个轮回中所发生的事。为了使这一次 Madoka 不再与 QB 签订契约，Homura 决定在刚到学校的第一天就解决 QB。然而，QB 也是有许多替身的（但在第八话中的剧情显示它也有可能是无限重生的），不过，意志坚定的 Homura 是不会放弃的——她决定消灭所有可能是 QB 的东西。现在，她已感受到附近的状态，并且把它转化为一个长度为 n 的字符串交给了学 OI 的你。<br>现在你从她的话中知道，所有形似于 A+B+A 的字串都是 QB 或它的替身，且 ∣A∣≥k,∣B∣≥1（位置不同其他性质相同的子串算不同子串，位置相同但拆分不同的子串算同一子串），然后你必须尽快告诉 Homura 这个答案——QB 以及它的替身的数量。<br>注：对于一个字符串 S，∣S∣ 表示 S 的长度。</p><p><strong>解题思路</strong><br>这题需要对照样例来理解题意，经过分析后，发现题意是如果有一个子串满足ABA形式，其中 |A|&gt;=k 且 B 不是空串，那么该子串就是QB大魔王。现在问有多少个这样的子串。</p><p>首先看思路，对于一个字符串(s[1,n])，我们通过求它的nex数组，如果nex[n] &gt;= k 并且 nex[n] 小于 n/2，那么该串就是QB；如果nex[n] &gt;= n/2，那么nex[ nex[n] ] ，一直到根节点的路径上，只要有一个nex大于k且小于n/2，该串就也是QB。</p><p>综上所述，我们对于一个下标为[1, p]的字符串，需要找到nex[p]到根节点（将nex数组看作一棵树）路径上大于等于 k 的最小 nex值（贪心思想）。我们用 f 数组来存放该值。之所以用 f 数组存放，是为了防止最坏情况O(N^2)遍历。</p><p>所以我们对原字符串 S 的每一个后缀都进行上述操作，时间复杂度共O(N^2)，勉强过。但是常数稍微大一些就过不了了，所以统计答案也要在求 nex 和更新 f 数组时顺便累加，如果觉得这样太怂了，还可以进行别的优化，不过我懒得改了。</p><p><strong>代码示例</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">15000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> nex[N],k, f[N], ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//f[i]为nex[i]到根中,大于k的最小的一个 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s)<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex); f[<span class="number">0</span>] = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt;= len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line"><span class="keyword">if</span>(j &lt; k) f[j] = INF; </span><br><span class="line"><span class="keyword">else</span> f[j] = min(j,f[nex[j]]);</span><br><span class="line"><span class="keyword">if</span>(f[j]&lt;&lt;<span class="number">1</span> &lt; i) ans++;</span><br><span class="line"><span class="comment">//printf("%d %d %d %d\n",i,j,f[j],nex[j]);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(str)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">getNex(str+i<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Censoring"><a href="#Censoring" class="headerlink" title="Censoring"></a>Censoring</h4><p>这个我一看就知道KMP很难写，应该用自动机，所以放在自动机专题整理，另外吐槽一下书上的翻译是谁写的，太敷衍了吧。</p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希与哈希表</title>
      <link href="/2019/09/28/hash/"/>
      <url>/2019/09/28/hash/</url>
      
        <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>哈希算法是通过一个哈希函数 H，将一种数据（字符串、大数等）转化为能够用变量表示或者能直接作为数组下标的数，通过哈希函数转化得到的数值我们成为哈希值。通过哈希值可以实现快速查找和匹配。本文主要介绍两种哈希算法的应用：字符串 Hash 和哈希表。</p><h4 id="字符串Hash"><a href="#字符串Hash" class="headerlink" title="字符串Hash"></a>字符串Hash</h4><p>字符串Hash有几种不同的用途，但是基于同一个原理，就是通过hash值匹配。<br>首先就是模式串匹配问题，n = |S| , m = |T| ，可以通过维护原串中所有长度为 m 的子串的哈希值，实现在O(1)时间内转移，并在O(1)时间内与 T 串的 hash值判等，若相等则有可能匹配成功。<br>大部分模式串匹配问题是用KMP求解，但是如果要是从主串中每次选出两个子串判断是否匹配的问题，还是需要用字符串 Hash 求解。</p><p><strong>具体流程</strong><br>我们设计的哈希函数 H 应当能在O(1)时间内实现相邻子串间的转移，或在预处理后，对不同的子串应该能在O(1)时间内求出其哈希值；这里用到叫做 滚动哈希 的优化技巧。</p><p>我们选取两个合适的互质的常数 b 和 h(b &lt; h)，假设字符串 $C = c_1c_2…c_m$，那么我们定义函数：$H(C) = (c_1b^{m-1} + c_2b^{m-2} + … + c_mb^0)\:mod\:h$。</p><p>这里的b是基数，相当于把字符串看作是 b 进制数。<br>这一过程是递推计算的，设H(C , k+1)是前 k 个字符构成的字符串的哈希值，则（不考虑取模）：$H(C , k+1) = H(C, k) * b + c_{k+1}$。</p><p>如果我们要<strong>求 C 中从 k 出发长度为 m 的子串的哈希值</strong>，那么$hsh = H(C , k+m) - H(C, k) * b^m$，hsh即为所求。</p><p><strong>预处理</strong></p><p>我们通过预处理求出所有C[a1, k]（k &lt;= n）的哈希值并存储在hash数组中（hash[i] = H(C,i) ），并预处理 base 数组（base[i] = $b^i$），那么我们就可以在O(1)时间内求出任意一个子串的哈希值。</p><p>在实现算法时，我们通常利用32位或者64位无符号整数计算哈希值，并取 $h = 2^{32}$ 或 $h = 2^{64}$，通过自然溢出省去取模运算。通常 b 取131 或 13331时效果较好。</p><p><strong>代码实现</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bse[i] = b^i , hsh[i] = H(str, i) */</span></span><br><span class="line">bse[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//bse和hsh都是unsigned long long </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    hsh[i] = hsh[i<span class="number">-1</span>]*b + str[i]-<span class="string">'a'</span>;</span><br><span class="line">    bse[i] = bse[i<span class="number">-1</span>]*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正确性证明</strong><br>上述做法可以保证相同的字符串所产生的哈希值一定是相同的，但是不同的字符串所产生的哈希值一定是不同的吗？<br>并不一定，但是冲突的几率很小，我们通常认为算法竞赛不会出现不同字符串哈希值冲突的情况。实际上根据生日悖论，对于哈希值在[0 , n)内均匀分布的哈希函数，出现不同字符串哈希值相等的期望步数是 $O(\sqrt N)$，可以作为一个参考。<br>更进一步的，我们还可以使用 <strong>“双哈希”</strong> 降低冲突的概率，即取用不同的模数，把不同的模数算出的哈希值记下来，只有几个哈希值都一样，才判定字符串匹配。我们通常用双哈希就可以将冲突的概率降到很低，如果分别取 h = 1e9+7 和 h = 1e9+9，就几乎不可能发生冲突，因为它们是一对“孪生素数”。</p><h4 id="哈希表与哈希函数"><a href="#哈希表与哈希函数" class="headerlink" title="哈希表与哈希函数"></a>哈希表与哈希函数</h4><p>哈希表是一种高效的数据结构，查找时间效率是常数时间，同时也很容易实现，需要付出的代价是消耗内存，但在如今这点内存已不成问题。</p><p><strong>问题模型</strong><br>给定 n 个数，这些数可能很大，判断每个数在之前有无出现过，出现了几次？</p><p><strong>算法流程</strong><br>这里具体分为三步：构造哈希函数 H()；将元素映射到哈希表；解决冲突。<br>首先要解决存储问题，我们先用线性表，即一维数组来存放元素。对于每个元素val，key = H(val)（这里的 key 是小于 1e7 的，可以当作数组的下标），于是我们就将val存放在数组下标为 key 的位置上。</p><p>而不同的元素它们key值是不同的（理想情况），相同的元素key值一定是相同的（任何情况），于是我们就可以通过O(1)时间的H()转化，读取数组内对应位置上的元素。</p><p>为了减少冲突呢，我们必须构造一个好的哈希函数H，这在后面会单独介绍常用的构造方法。但是不管多么优秀的哈希函数，都不可避免存在冲突，因此我们还需要有解决冲突的对策。我们想到可以用链表来解决冲突，即该一维表的每一个位置都是一条链表，具有相同哈希值的元素都放在同一条链上，当查找时只需要遍历这条链即可。这就叫哈希（链）表。</p><h5 id="哈希函数的构造"><a href="#哈希函数的构造" class="headerlink" title="哈希函数的构造"></a>哈希函数的构造</h5><p>哈希函数是决定哈希表查找效率的关键，只有哈希值分配的足够均匀时，单词查找的复杂度才会尽量小。以下介绍几种效果好的、容易实现的哈希函数。<br><strong>（1）基数转换法</strong><br>基数转换法就是开头的字符串Hash所采用的转换方法：将 val 值看作另一种进制数，然后再把它转化成对应的十进制数，再用除余法对其取余。一般取大于10的数作为转换的基数，并且两个基数是互质的。一般来说，取 131 或 13331较好。</p><p>如 val = 236075 原本是十进制数，现在将它看作十三进制数$(236075) _ {13}$然后再将它转换为十进制数。<br>$(236075)_ {13} = 2 <em> 13^5 + 3 </em> 13^4 + 6 <em> 13^3 + 7 </em> 13 + 5 = (841547) _ {10}$</p><p><strong>（2）除余法</strong><br>选择一个适当的正整数 b，用其对 b 取模的余数作为哈希值，即：H(val) = val mod b，这个方法应用的最多，并且多数情况下性价比也是最高的。关键在于 b 的选取，一般选 b 是数组下标能存储得下并且尽量大的质数（一般根据空间取1e6左右的质数）。选质数是因为 通常b的约数越多，冲突的几率就越大。</p><p><strong>（3）乘积取整法</strong><br>我们用值 val 乘以一个在(0,1)中的实数 A（最好是无理数，$(\sqrt 5 - 1)/2$是一个实际效果很好的数），得到一个(0 , k)之间实数；取其小数部分，乘以哈希表的大小 M 再向下取整，即得 val 在Hash表中的位置。函数表达式可以写成：H(val) = { M( val * A mod 1 ) }。</p><h5 id="散列表模板"><a href="#散列表模板" class="headerlink" title="散列表模板"></a>散列表模板</h5><p>例题：门票(tickets)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">2181271</span>; </span><br><span class="line"><span class="keyword">int</span> nex[N],num[N],head[N],tot = <span class="number">1</span>;<span class="comment">// 用邻接表方式实现哈希表 </span></span><br><span class="line"><span class="keyword">int</span> top , stk[N];<span class="comment">//数组模拟堆栈,用于哈希表的初始化 </span></span><br><span class="line">ll a,b,c;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">tot = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span>(top) head[stk[top--]] = <span class="number">0</span>;<span class="comment">//只清空用了的表,节省时间 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将x插入哈希表*/</span></span><br><span class="line"><span class="keyword">int</span> h = x % P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[h] ;i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i] == x) <span class="keyword">return</span>; <span class="comment">//相同的值已经存放过了 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(!head[h]) stk[++top] = h; <span class="comment">//第一次出现的哈希值入栈</span></span><br><span class="line"><span class="comment">/* 邻接表添加元素基本套路 */</span></span><br><span class="line">nex[++tot] = head[h]; head[h] = tot; num[tot] = x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ask</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 返回 x 是否存在*/</span></span><br><span class="line"><span class="keyword">int</span> h = x%P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[h];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i] == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll x = <span class="number">1</span>; Insert(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">2e6</span>;i++)&#123;</span><br><span class="line">x = (x*a + x%b)%c;</span><br><span class="line"><span class="keyword">if</span>(ask(x)) <span class="keyword">return</span> i;</span><br><span class="line">Insert(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*多组样例要调用init()*/</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>董永建，信息学竞赛一本通提高版，福州：福建教育出版社，2018.6，63-69</li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串循环节问题</title>
      <link href="/2019/09/27/xhj/"/>
      <url>/2019/09/27/xhj/</url>
      
        <content type="html"><![CDATA[<p><strong>循环节与最短循环节：</strong><br>若某个字符串是由某个子串循环构成的，那么就称该子串为原串的循环节，长度最短的循环节就是最短循环节。<br>如abababab，abab和ab都是原串的循环节，而最短循环节是ab。</p><p><strong>结论：</strong><br>如果字符串 s 有个循环节 son，n = |s| , x = |son|，字符数组下标从1开始，那么：</p><ol><li>x 一定是 n 的约数。</li><li>那么s[1,n-x] = s[x, n] = son。</li></ol><p><strong>证明：</strong><br>结论1：如果 x 不是 n 的约数，那么自然 n 就不可能由 若干个 x 相加构成，即不满足 n = k * x ，其中 k 是正整数。<br>结论2：若想s[1 ,n-x] = s[x, n] ，必须s[1, x] = s[ x ,2x] = s[2x , 3x] = … = s[n-x , n]，刚好符合循环节定义，因此 结论2 成立。</p><h4 id="求单个字符串的最短循环节"><a href="#求单个字符串的最短循环节" class="headerlink" title="求单个字符串的最短循环节"></a>求单个字符串的最短循环节</h4><p><strong>例1：</strong> POJ 2406 Power Strings (KMP)<br><a href="http://poj.org/problem?id=2406" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong> 给定一个字符串 s ，求出它最多由某个子串 循环几次 构成。</p><p><strong>解题思路：</strong><br>首先 s 必须是由某个循环节循环若干次构成的，否则无解。题意让求最多循环几次构成，那么既然 s 的长度固定是 n，自然是循环节越短，那么循环次数越多了。<br>我们先求出KMP算法中的nex数组。<br><strong>结论3：</strong> 此时若 s 有解，那么最短循环节长度为 x = n - nex[n] 。</p><p><strong>证明：反证法</strong> </p><ol><li>首先根据结论2，因为 s[1,nex[n] ] = s[n - nex[n] , n]，所以必然存在长度为 x = n - nex[n]的循环节，问题就在于它是不是最短的。</li><li>假设存在循环节，长度为 y（y &lt; x） ，那么根据结论2，一定有： s[1, n-y] = s[y , n]；如此一来nex[n] = n-y &gt; n-x，这和nex数组定义矛盾，因此不存在y &lt; x。</li><li>综上所述，n - nex[n] 一定为最短循环节的长度。</li></ol><p>因此本题的答案就是 n/(n-nex[n])，若不能整除，则无解。</p><p><strong>代码示例：</strong> 见附录部分 code-1：Power Strings</p><h4 id="求任意子串的最短循环节"><a href="#求任意子串的最短循环节" class="headerlink" title="求任意子串的最短循环节"></a>求任意子串的最短循环节</h4><p><strong>例2：</strong> bzoj2795 Horrible Poem<br><a href="http://www.mfstem.org/contest/57/problem/F" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给出一个由小写英文字母组成的字符串 S，再给出 q 个询问，要求回答 S 某个子串的最短循环节长度。如果字符串 B 是字符串 A 的循环节，那么 A 可以由 B 重复若干次得到。</p><p><strong>解题思路：</strong><br>此题的 q 很大，我们不可能对每一个子串都O(n)求出 nex 数组再回答。我们利用 滚动哈希 ，在O(1)时间内利用 结论2 判断某个长度是否为循环节。<br>再根据结论1，可以得知循环节长度一定是子串长度 m 的约数，因此我们$O(\sqrt m)$分解约数，再用O(1)复杂度用hash判断，本题总复杂度就是 $O(q \sqrt m)$。</p><p>一般到这里就该结束了，我们利用了 结论1 和 结论2 大大减少了求循环节的时间。但是在本题还是不够，还需要优化。还能优化的地方就只有求约数的$O(\sqrt m)$复杂度了，我们可以通过质因数分解在$O(log_2^m)$时间内分解约数，于是最终复杂度就是 $O(q\:log_2^n)$，可以通过了。</p><p><strong>代码示例：</strong> 见附录部分code-2：Horrible Poem</p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p><strong>code-1：Power Strings</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> nex[N]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;str[i];i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; str[i] != str[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(str[i] == str[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算答案并输出*/</span></span><br><span class="line">getNex(str);</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(str)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(n%(n-nex[n])) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n/(n-nex[n]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>) &amp;&amp; str[<span class="number">1</span>] != <span class="string">'.'</span>)&#123;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'*'</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>code-2：Horrible Poem</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Q = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line">ull hsh[N],bse[N] , b = <span class="number">31</span>; <span class="comment">//采用无符号长整形,通过自然溢出省去取模 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*判断x是否为子串s[l,r]的最短循环节长度*/</span> </span><br><span class="line">ull h1 = hsh[r-x] - hsh[l<span class="number">-1</span>]*bse[r-x+<span class="number">1</span>-l];</span><br><span class="line">ull h2 = hsh[r] - hsh[l<span class="number">-1</span>+x]*bse[r-x+<span class="number">1</span>-l];</span><br><span class="line"><span class="keyword">return</span> h1 == h2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> v[N],primes[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPri</span><span class="params">()</span></span>&#123;<span class="comment">//线性筛 </span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i])&#123;</span><br><span class="line">primes[cnt++] = i;</span><br><span class="line">v[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cnt;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(primes[j] &gt; v[i] || primes[j]*i &gt; N)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">v[i*primes[j]] = primes[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*回答子串s[l,r]的最短循环节长度*/</span> </span><br><span class="line"><span class="keyword">int</span> len = r-l+<span class="number">1</span>, ans = len, d = len;</span><br><span class="line"><span class="keyword">while</span>(d != <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = v[d];</span><br><span class="line"><span class="keyword">while</span>(d%tmp == <span class="number">0</span> &amp;&amp; check(l,r,ans/tmp)) d /= tmp,ans /= tmp;</span><br><span class="line"><span class="keyword">while</span>(d%tmp == <span class="number">0</span>) d /= tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*预处理出hash数组,v数组*/</span></span><br><span class="line">getPri(); bse[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">hsh[i] = hsh[i<span class="number">-1</span>]*b + str[i]-<span class="string">'a'</span>;</span><br><span class="line">bse[i] = bse[i<span class="number">-1</span>]*b;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>) &#123; x=x*<span class="number">10</span>+c-<span class="string">'0'</span>; c=getchar(); &#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">n = read();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>); str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">q = read();</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,l,r;i &lt;= q;i++)&#123;</span><br><span class="line">l = read(); r = read();</span><br><span class="line">ask(l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
            <tag> 循环节 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串与哈希题集</title>
      <link href="/2019/09/26/hash-and-kmp/"/>
      <url>/2019/09/26/hash-and-kmp/</url>
      
        <content type="html"><![CDATA[<p>我校OJ：<a href="http://www.mfstem.org/contest/57/problems" target="_blank" rel="noopener">测试地址</a><br>图书配套OJ：<a href="http://ybt.ssoier.cn:8088/index.php" target="_blank" rel="noopener">测试地址</a></p><h4 id="A-Oulipo"><a href="#A-Oulipo" class="headerlink" title="A. Oulipo"></a>A. Oulipo</h4><p><strong>Description</strong><br>给出两个字符串s1,s2（只有大写字母），求s1在s2中出现多少次。例如：s1=”ABA”,s2=”ABAABA”,答案为2。</p><p><strong>解题思路：</strong><br>KMP算法的模板，也可以用拓展KMP解决。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> nex[N];<span class="comment">//nex[i] = T[i,n-1]与T[0,n-1]最长公共前缀 </span></span><br><span class="line"><span class="keyword">char</span> S[N],T[N]; <span class="comment">//S为目标串,T为模式串 </span></span><br><span class="line"><span class="keyword">int</span> extend[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算nex数组*/</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str) ,i = <span class="number">0</span>, j, p0 ;</span><br><span class="line">nex[<span class="number">0</span>] = len;</span><br><span class="line"><span class="keyword">while</span>(i+<span class="number">1</span> &lt; len &amp;&amp; str[i] == str[i+<span class="number">1</span>]) i++;</span><br><span class="line">nex[<span class="number">1</span>] = i; p0 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex[i-p0]+i &lt; nex[p0]+p0) nex[i] = nex[i-p0];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j = nex[p0]+p0-i;</span><br><span class="line"><span class="keyword">if</span>(j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i+j &lt; len &amp;&amp; str[j] == str[j+i]) j++;</span><br><span class="line">nex[i] = j; p0 = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exKMP</span><span class="params">(<span class="keyword">char</span>* str1,<span class="keyword">char</span> *str2)</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算str2与str1的所有后缀的最长公共前缀长度,存放在extend数组中*/</span> </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>,j,p0,l1 = <span class="built_in">strlen</span>(S), l2 = <span class="built_in">strlen</span>(T);</span><br><span class="line">getNex(str2);</span><br><span class="line"><span class="keyword">while</span>(i &lt; l1 &amp;&amp; i &lt; l2 &amp;&amp; str1[i] == str2[i]) i++;</span><br><span class="line">extend[<span class="number">0</span>] = i;p0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; l1;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex[i-p0]+i &lt; extend[p0]+p0) extend[i] = nex[i-p0];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">j = extend[p0]+p0-i;</span><br><span class="line"><span class="keyword">if</span>(j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i+j &lt; l1 &amp;&amp; j &lt; l2 &amp;&amp; str1[j+i] == str2[j]) j++;</span><br><span class="line">extend[i] = j; p0 = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算并输出答案*/</span></span><br><span class="line"><span class="keyword">int</span> l1 = <span class="built_in">strlen</span>(S), l2 = <span class="built_in">strlen</span>(T), ans = <span class="number">0</span>;</span><br><span class="line">exKMP(S,T); <span class="keyword">int</span> len = <span class="built_in">strlen</span>(T);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; l1;i++)</span><br><span class="line"><span class="keyword">if</span>(extend[i] == len) ans++;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,T,S);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="B-图书管理"><a href="#B-图书管理" class="headerlink" title="B. 图书管理"></a>B. 图书管理</h4><p><strong>Description</strong><br>图书管理是一件十分繁杂的工作，在一个图书馆中每天都会有许多新书加入。为了更方便的管理图书（以便于帮助想要借书的客人快速查找他们是否有他们所需要的书），我们需要设计一个图书查找系统。该系统需要支持 2 种操作：</p><ol><li>add(s) 表示新加入一本书名为 s 的图书。</li><li>find(s) 表示查询是否存在一本书名为 s 的图书。</li></ol><p><strong>解题思路：</strong><br>该题本意是用hash解决，但是我偷懒直接用map了。。。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span> ,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> tmp = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>;s[i];i++) tmp += s[i];</span><br><span class="line">mp[tmp] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> tmp = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>;s[i];i++) tmp += s[i];</span><br><span class="line"><span class="keyword">if</span>(mp.count(tmp)) <span class="built_in">cout</span> &lt;&lt; <span class="string">"yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"no"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">getline(<span class="built_in">cin</span>,str);</span><br><span class="line"><span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'a'</span>) add(str);</span><br><span class="line"><span class="keyword">else</span> Find(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="C-Power-Strings"><a href="#C-Power-Strings" class="headerlink" title="C. Power Strings"></a>C. Power Strings</h4><p><strong>Description</strong><br>给定若干个长度 ≤10^6的字符串，询问每个字符串最多是由多少个相同的子字符串重复连接而成的。如：ababab 则最多有 3 个 ab 连接而成。<br><strong>解题思路：</strong><br>本题是循环节问题，有个结论：若字符串 s 是由某个长度为 x 的子串循环构成，那么必定有s[1,n-x] = s[x, n]。而根据nex数组的定义，nex[n] 就是 s[x, n] 的长度n-x。<br>因此如果该题有解，则n % (n-nex[n])为0，答案就是n/(n-nex[n)。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> nex[N]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;str[i];i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; str[i] != str[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(str[i] == str[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算答案并输出*/</span></span><br><span class="line">getNex(str);</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(str)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(n%(n-nex[n])) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n/(n-nex[n]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>) &amp;&amp; str[<span class="number">1</span>] != <span class="string">'.'</span>)&#123;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'*'</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="D-Seek-the-Name-Seek-the-Fame"><a href="#D-Seek-the-Name-Seek-the-Fame" class="headerlink" title="D. Seek the Name, Seek the Fame"></a>D. Seek the Name, Seek the Fame</h4><p><strong>Description</strong><br>给定若干字符串（这些字符串总长 ≤4×10^5 ），在每个字符串中求出所有既是前缀又是后缀的子串长度。例如：ababcababababcabab，既是前缀又是后缀的：ab，abab，ababcabab，ababcababababcabab。</p><p><strong>解题思路：</strong><br>依然是利用KMP算法中的nex数组求解。首先该串本身是最长的“既是前缀又是后缀”的子串，下一个满足条件的子串是s[1,nex[n] ] ，下下个是s[1, nex[ nex[n] ] ]，… 。</p><p>道理很简单，就是想起来有点绕；如果存在一个长度为 x 的子串 son“既是前缀又是后缀”，那么有s[1,x] = s[n-x,n] = son，那么它的长度不还是不超过 nex[n] 吗？所以上述方法可以从大到小遍历所有可能的长度（不是所有子串！）。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> nex[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">getNex(str); <span class="keyword">int</span> n = <span class="built_in">strlen</span>(str)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>; ans[++cnt] = n;</span><br><span class="line"><span class="keyword">while</span>(nex[n])&#123;</span><br><span class="line">ans[++cnt] = nex[n];</span><br><span class="line">n = nex[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = cnt;i &gt; <span class="number">1</span>;i--) <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>))&#123;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="E-friends"><a href="#E-friends" class="headerlink" title="E. friends"></a>E. friends</h4><p><strong>Description</strong><br>有三个好朋友喜欢在一起玩游戏，A 君写下一个字符串 S，B 君将其复制一遍得到 T，C 君在 T 的任意位置（包括首尾）插入一个字符得到 U。现在你得到了 U，请你找出 S。</p><p><strong>解题思路：</strong><br>本题如果用nex或者hash求解，细节有点多，当然细心点应该是能写出来的。我的解题思路很简单，O(N)复杂度，主要基于如下基本推论：</p><ol><li>如果n为偶数，无解。</li><li>如果前n/2+1个字符通过删去一个，可以等同于后n/2个字符，则匹配成功。</li><li>如果后n/2+1个字符通过删去一个，可以等同于前n/2个字符，则匹配成功。</li><li>如果 2 和 3 都匹配成功，且两个得到的原串不同，则说明解不唯一。</li></ol><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N],tmp[N],s1[N],s2[N];</span><br><span class="line"><span class="keyword">int</span> n,nex[N],tot;</span><br><span class="line"><span class="keyword">char</span> ans1[N],ans2[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> *s1,<span class="keyword">char</span> *s2)</span></span>&#123;</span><br><span class="line">tot = <span class="number">0</span>; <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= n/<span class="number">2</span> &amp;&amp; j &lt;= n/<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(s1[i] != s2[j])&#123;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">flag = <span class="literal">true</span>; j++;</span><br><span class="line"><span class="keyword">if</span>(s1[i] != s2[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">tmp[tot++] = s1[i];</span><br><span class="line">i++ , j++;</span><br><span class="line">&#125;</span><br><span class="line">tmp[tot] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"NOT POSSIBLE"</span>); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n/<span class="number">2</span>;i++) s1[i] = str[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n/<span class="number">2</span>+<span class="number">1</span>;i++) s2[i] = str[i+n/<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> flag1,flag2;</span><br><span class="line">flag1 = check(s1,s2);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n/<span class="number">2</span>;i++) ans1[i] = tmp[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n/<span class="number">2</span>+<span class="number">1</span>;i++) s1[i] = str[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n/<span class="number">2</span>;i++) s2[i] = str[i+n/<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">flag2 = check(s2,s1);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n/<span class="number">2</span>;i++) ans2[i] = tmp[i];</span><br><span class="line"><span class="keyword">if</span>(flag1 &amp;&amp; flag2)&#123;</span><br><span class="line"><span class="keyword">bool</span> f = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n/<span class="number">2</span>;i++) </span><br><span class="line"><span class="keyword">if</span>(ans1[i] != ans2[i]) f = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!f)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"NOT UNIQUE"</span>); <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag1 || flag2)&#123;</span><br><span class="line"><span class="keyword">if</span>(flag1) <span class="built_in">puts</span>(ans1);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(ans2);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"NOT POSSIBLE"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%s"</span>,&amp;n,str+<span class="number">1</span>);</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'#'</span>; solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="F-A-Horrible-Poem"><a href="#F-A-Horrible-Poem" class="headerlink" title="F. A Horrible Poem"></a>F. A Horrible Poem</h4><p><strong>Description</strong><br>给出一个由小写英文字母组成的字符串 S，再给出 q 个询问，要求回答 S 某个子串的最短循环节。如果字符串 B 是字符串 A 的循环节，那么 A 可以由 B 重复若干次得到。</p><p><strong>解题思路：</strong><br>这个是最短循环节问题，另外本题卡常十分严格。为了快速求解，本题还用到了线性筛、滚动哈希优化等策略。</p><p>首先是基础的字符串循环节知识。如果字符串 s 是由某个子串循环得到，|s| = n，那么<br>循环节的长度一定是 len 的约数，包括最短循环节。因此一个策略就是对于 n 的所有约数，挨个判断是否为最短循环节的长度，而判断原理如下：</p><ul><li>如果字符串 s 的最短循环节长度为 x ，那么必然有 s[1, x] = s[n-x, n] 。</li></ul><p>我们可以通过滚动哈希技巧来在O(1)时间完成判断。那么现在主要花费的时间在于找寻 n 的约数上，一般做法$O(\sqrt n)$，于是这种做法总复杂度为$O(q \sqrt n)$。</p><p>但是这题卡常很严重，这样还是会超时。于是就要利用质因数分解定理在$O(log_2^n)$时间内完成约数分解，总时间复杂度为$O(q log_2^n)$。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Q = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line">ull hsh[N],bse[N] , b = <span class="number">31</span>; <span class="comment">//采用无符号长整形,通过自然溢出省去取模 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*判断x是否为子串s[l,r]的最短循环节长度*/</span> </span><br><span class="line">ull h1 = hsh[r-x] - hsh[l<span class="number">-1</span>]*bse[r-x+<span class="number">1</span>-l];</span><br><span class="line">ull h2 = hsh[r] - hsh[l<span class="number">-1</span>+x]*bse[r-x+<span class="number">1</span>-l];</span><br><span class="line"><span class="keyword">return</span> h1 == h2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> v[N],primes[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPri</span><span class="params">()</span></span>&#123;<span class="comment">//线性筛 </span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i])&#123;</span><br><span class="line">primes[cnt++] = i;</span><br><span class="line">v[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cnt;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(primes[j] &gt; v[i] || primes[j]*i &gt; N)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">v[i*primes[j]] = primes[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*回答子串s[l,r]的最短循环节长度*/</span> </span><br><span class="line"><span class="keyword">int</span> len = r-l+<span class="number">1</span>, ans = len, d = len;</span><br><span class="line"><span class="keyword">while</span>(d != <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = v[d];</span><br><span class="line"><span class="keyword">while</span>(d%tmp == <span class="number">0</span> &amp;&amp; check(l,r,ans/tmp)) d /= tmp,ans /= tmp;</span><br><span class="line"><span class="keyword">while</span>(d%tmp == <span class="number">0</span>) d /= tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*预处理出hash数组,v数组*/</span></span><br><span class="line">getPri(); bse[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">hsh[i] = hsh[i<span class="number">-1</span>]*b + str[i]-<span class="string">'a'</span>;</span><br><span class="line">bse[i] = bse[i<span class="number">-1</span>]*b;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>) &#123; x=x*<span class="number">10</span>+c-<span class="string">'0'</span>; c=getchar(); &#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">n = read();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>); str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">q = read();</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,l,r;i &lt;= q;i++)&#123;</span><br><span class="line">l = read(); r = read();</span><br><span class="line">ask(l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="G-Beads"><a href="#G-Beads" class="headerlink" title="G. Beads"></a>G. Beads</h4><p><strong>Description</strong><br>Zxl有一次决定制造一条项链，她以非常便宜的价格买了一长条鲜艳的珊瑚珠子，她现在也有一个机器，能把这条珠子切成很多块（子串），每块有k（k&gt;0）个珠子，如果这条珠子的长度不是k的倍数，最后一块小于k的就不要拉（nc真浪费），保证珠子的长度为正整数。 Zxl喜欢多样的项链，为她应该怎样选择数字k来尽可能得到更多的不同的子串感到好奇，子串都是可以反转的，换句话说，子串（1，2，3）和（3,2,1）是一样的。写一个程序，为Zxl决定最适合的k从而获得最多不同的子串。例如：这一串珠子是： (1,1,1,2,2,2,3,3,3,1,2,3,3,1,2,2,1,3,3,2,1)。<br>k=1的时候，我们得到3个不同的子串：(1),(2),(3)<br>k=2的时候，我们得到6个不同的子串： (1,1),(1,2),(2,2),(3,3),(3,1),(2,3)<br>k=3的时候，我们得到5个不同的子串：  (1,1,1),(2,2,2),(3,3,3),(1,2,3),(3,1,2)<br>k=4的时候，我们得到5个不同的子串： (1,1,1,2),(2,2,3,3),(3,1,2,3),(3,1,2,2),(1,3,3,2)</p><p><strong>解题思路：</strong><br>刚开始时间复杂度算错了，n + n/2 + n/3 + n/4 + … + 1是调和级数，时间复杂度并不高，因此两层循环加上 滚动哈希 O(1)的判断是可以很快通过的。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> col[N] , n;</span><br><span class="line">ull hsh[N],hsh2[N],bse[N] , B = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;ull,<span class="keyword">int</span>&gt; vis;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">int</span> tc , mx , k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">bse[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">hsh[i] = hsh[i<span class="number">-1</span>]*B+col[i], bse[i] = bse[i<span class="number">-1</span>]*B;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--) </span><br><span class="line">hsh2[i] = hsh2[i+<span class="number">1</span>]*B+col[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">vis.clear(); cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt;= n;j += i)&#123;</span><br><span class="line">ull h1 = hsh[j] - hsh[j-i]*bse[i];</span><br><span class="line">ull h2 = hsh2[j-i+<span class="number">1</span>] - hsh2[j+<span class="number">1</span>]*bse[i];</span><br><span class="line"><span class="keyword">if</span>(vis.count(h1*h2) == <span class="number">0</span>)&#123;</span><br><span class="line">vis[h1*h2] = <span class="number">1</span>; cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf("%llu %llu\n",h1,h2);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf("%d %d\n",cnt,mx);</span></span><br><span class="line"><span class="keyword">if</span>(cnt == mx) ans.push_back(i);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cnt &gt; mx) &#123;</span><br><span class="line">ans.clear(); ans.push_back(i); mx = cnt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,mx,ans.size());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ans.size();i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,col+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="H-Antisymmetry"><a href="#H-Antisymmetry" class="headerlink" title="H. Antisymmetry"></a>H. Antisymmetry</h4><p><strong>Description</strong><br>对于一个01字符串，如果将这个字符串0和1取反后，再将整个串反过来和原串一样，就称作“反对称”字符串。比如00001111和010101就是反对称的，1001就不是。<br>现在给出一个长度为N的01字符串，求它有多少个子串是反对称的。</p><p><strong>解题思路：</strong><br>01串的题目真是变化多端啊。要想解决本题首先要得出几个推论：</p><ol><li>“反对称”的串长度一定是偶数。</li><li>如果一个子串是“反对称”的，那么它一定关于中轴线，左右01对应（如0101）。</li><li>如果一个串是“反对称”的，那么和它共中轴线的子串也是“反对称”的。</li></ol><p>然后就发现和回文串的性质有些相似，仅有 2 点不同，就是回文串长度可以为奇，以及回文串是关于中轴对称而不是相反。</p><p>那么我们依然可以利用Manacher算法，只不过将判等 改为判“反”即可。当然也要用通配符“#”来填充，因为所有“反对称” 的串长度必须为偶，所以我们在“#”上进行计算，以此来保证长度为偶数。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N],s2[<span class="number">2</span>*N];</span><br><span class="line"><span class="keyword">int</span> n,len[<span class="number">2</span>*N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="string">'#'</span> &amp;&amp; b == <span class="string">'#'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="string">'1'</span> &amp;&amp; b == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="string">'0'</span> &amp;&amp; b == <span class="string">'1'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">s2[<span class="number">0</span>] = <span class="string">'$'</span>,s2[<span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">s2[i&lt;&lt;<span class="number">1</span>] = str[i<span class="number">-1</span>];</span><br><span class="line">s2[(i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">&#125;</span><br><span class="line">s2[n*<span class="number">2</span>+<span class="number">2</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span>, mid;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">2</span>*n+<span class="number">2</span>;i += <span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt; mx) len[i] = min(len[<span class="number">2</span>*mid-i],mx-i);</span><br><span class="line"><span class="keyword">else</span> len[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( check(s2[i-len[i]], s2[i+len[i]]) ) len[i]++;</span><br><span class="line"><span class="keyword">if</span>(len[i]+i &gt; mx)&#123;</span><br><span class="line">mx = len[i] + i;</span><br><span class="line">mid = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">2</span>*n+<span class="number">2</span>;i++) ans += len[i]&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str); </span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="I-门票-tickets"><a href="#I-门票-tickets" class="headerlink" title="I. 门票(tickets)"></a>I. 门票(tickets)</h4><p><strong>Description</strong><br>已知数列$a_n, a_0 = 1$, $a_{i+1} = (a_i * A + a_i \:mod \:B ) \:mod \:C$，请问给定A，B和C，该数列在第几项第一次出现重复？</p><p><strong>解题思路：</strong><br>map太慢了啊，我测试了读入输出，测试了乘法和取模，就是没有怀疑map，浪费很多时间。<br>手写hash函数，利用邻接表来消除冲突，如此一来快了很多。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">2181271</span>; </span><br><span class="line"><span class="keyword">int</span> nex[N],num[N],head[N],tot = <span class="number">1</span>;<span class="comment">// 用邻接表方式实现哈希表 </span></span><br><span class="line"><span class="keyword">int</span> top , stk[N];<span class="comment">//数组模拟堆栈,用于哈希表的初始化 </span></span><br><span class="line">ll a,b,c;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">tot = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span>(top) head[stk[top--]] = <span class="number">0</span>;<span class="comment">//只清空用了的表,节省时间 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将x插入哈希表*/</span></span><br><span class="line"><span class="keyword">int</span> h = x % P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[h] ;i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i] == x) <span class="keyword">return</span>; <span class="comment">//相同的值已经存放过了 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(!head[h]) stk[++top] = h; <span class="comment">//第一次出现的哈希值入栈</span></span><br><span class="line"><span class="comment">/* 邻接表添加元素基本套路 */</span></span><br><span class="line">nex[++tot] = head[h]; head[h] = tot; num[tot] = x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ask</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 返回 x 是否存在*/</span></span><br><span class="line"><span class="keyword">int</span> h = x%P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[h];i;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i] == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll x = <span class="number">1</span>; Insert(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">2e6</span>;i++)&#123;</span><br><span class="line">x = (x*a + x%b)%c;</span><br><span class="line"><span class="keyword">if</span>(ask(x)) <span class="keyword">return</span> i;</span><br><span class="line">Insert(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*多组样例要调用init()*/</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="J-收集雪花-snowflakes"><a href="#J-收集雪花-snowflakes" class="headerlink" title="J. 收集雪花(snowflakes)"></a>J. 收集雪花(snowflakes)</h4><p><strong>Description</strong><br>不同的雪花往往有不同的形状。在北方的同学想将雪花收集起来，作为礼物送给在南方的同学们。一共有 n 个时刻，给出每个时刻下落雪花的形状，用不同的整数表示不同的形状。在收集的过程中，同学们不希望有重复的雪花。你可以从任意  a 时刻开始，在 b 时刻停止。a 到 b 时刻中间的雪花也都将被收集。他们希望收集的雪花最多。</p><p><strong>解题思路：</strong><br>这个用hash有点难写，难在重置哈希表。我用的是离散化+双指针，只需要维护左边界即可。如果当前雪花第二次出现，那么知道它上一次出现位置是v[p] ，所以先用当前区间长度更新答案，再将左边界更新为 v[p] + 1。<br>正确性证明就不写了，很显然。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], n, v[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("123.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i),b[i] = a[i];</span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">int</span> tot = unique(a+<span class="number">1</span>,a+<span class="number">1</span>+n)-a<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,l = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> p = lower_bound(a+<span class="number">1</span>,a+tot+<span class="number">1</span>,b[i])-a;</span><br><span class="line"><span class="keyword">if</span>(v[p] &gt;= l)&#123;</span><br><span class="line">ans = max(ans,i-l);</span><br><span class="line">l = v[p]+<span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line">v[p] = i;</span><br><span class="line"><span class="keyword">if</span>(i == n) ans = max(ans,i-l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓展KMP </tag>
            
            <tag> 哈希 </tag>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/2019/09/26/kmp/"/>
      <url>/2019/09/26/kmp/</url>
      
        <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>KMP算法，又称模式匹配算法，能够在线性时间内判定字符串 T 是否为 S 的子串，并求出字符串 T 在 S 中各次出现的位置。<br>KMP算法比较晦涩难懂。本文对于思想介绍略简，侧重于实现。</p><h4 id="问题模型与算法思路"><a href="#问题模型与算法思路" class="headerlink" title="问题模型与算法思路"></a>问题模型与算法思路</h4><p><strong>问题模型：</strong> 给定两个字符串 S 和 T ，试求出 T 在 S 中第一次出现的位置。</p><p>上述问题模型是模式串匹配最基础的模型，即单模式串匹配问题，这类问题是KMP算法以及字符串Hash大展身手的题型。</p><p><strong>算法思路1：Hash</strong><br>设|S| = n , |T| = m。如果不考虑冲突，那么我们可以将 S 的所有长度为 m 的子串hash值都求出来，复杂度为O(N)。将这 n-m+1 个子串与T的hash值在O(1)的时间内一一比对，即可通过hash值是否相同来判断是否匹配成功。<br>但实际上如果n和m很大(1e6)，那么散列值冲突是不可避免的，此时需要二次判断或者通过其他方法（构造更好的散列函数）来在保证速度的情况下提升正确性。</p><p><strong>算法思路2：KMP</strong><br>设|S| = n , |T| = m。首先考虑一个朴素算法，那就是将字符串 S 中的每一个长度为m的子串都与 T 进行一次匹配，失配后再匹配下一个，复杂度O(NM)。<br>手动模拟一下可以发现，上述做法中指向字符串 S 的指针和 T 的指针都有回退$^{[1]}$，但实际上我们并不需要发生回退，KMP算法就是通过防止指针回退来提升朴素算法效率的。</p><p>假设我们 S[i] 和 T[j+1] 发生了失配，如果我们知道 “T 中以 j 为末尾的真子串” 和 T[1, j] 的最长公共前缀的长度（假设为len，len一定小于 j ），那么显然 T[1, len] = S[i-len+1, i]；于是此时的 j = len，接着匹配即可。我们用nex数组（见下文）来存放 T 对应位置的“len”。</p><p>详细的讲，<strong>KMP算法分为两步：</strong></p><ol><li>对字符串 T 进行自我“匹配”，求出一个数组 nex，其中 nex[i] 表示“ T 中以 i 结尾的非前缀子串”与“ T 的前缀”能够匹配的最大长度，即：<br>&emsp;&emsp;nex[i] = max{j}，其中j &lt; i 并且 T[i-j+1, i] = T[1 ,j]。</li><li>对字符串 T 与 S 进行匹配，求出一个数组 f ，其中 f[i] 表示“S 中以 i 结尾的子串”与“ T 的前缀”能够匹配的最长长度。即：<br>&emsp;&emsp;f[i] = max{j}，其中j &lt;= i并且 S[i-j+1, i] = T[1, j]</li></ol><p><em>[1] 指针回退：在朴素做法中，如果发生失配，则要将指向 S 串的指针回退到当前子串起始位置，并右移至下一个子串起始位置，同理指向 T 的指针也要回到起始位置。</em></p><h4 id="Next数组"><a href="#Next数组" class="headerlink" title="Next数组"></a>Next数组</h4><p>首先要明白什么是Next数组（以下简称nex数组）。<br>nex[i]表示“T 中以 i 结尾的非前缀子串”与“T 的前缀”能够匹配的最长长度，即：nex[i] = max{j}，其中j &lt; i 并且 T[i-j+1, i] = T[i, j]。</p><blockquote><p>跳过：nex数组起到什么辅助作用，为什么要用nex数组？</p></blockquote><p><strong>nex 数组的求法</strong></p><ol><li>初始化 nex[1] = j = 0，假设nex[1, i-1] 已求出，下面求nex[i]。</li><li>不断尝试拓展匹配长度 j，如果拓展失败（下一个字符不相等），令 j 变为nex[j]，直至 j 为0（应该从头开始匹配）。</li><li>如果能够拓展成功，匹配长度 j 就增加1。nex[i] 的值就是 j 。</li></ol><p><strong>代码块</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/*更新模式串s的nex数组*/</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="f-数组"><a href="#f-数组" class="headerlink" title="f 数组"></a>f 数组</h4><p>按照前面的定义， f[i] 表示“S 中以 i 结尾的子串”与“ T 的前缀”能够匹配的最长长度。可以发现 f 数组和 nex 数组定义是一致的，因此他们的求解过程也基本一致。</p><p><strong>代码块</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getF</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">const</span> <span class="keyword">char</span> *T)</span></span>&#123;</span><br><span class="line"><span class="comment">/*求解 f 数组,S是目标串,T是模式串*/</span> </span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(S),len2 = <span class="built_in">strlen</span>(T);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;i &lt; len1;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; (j == len2 || S[i] != T[j+<span class="number">1</span>])) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(S[i] == T[j+<span class="number">1</span>]) j++;</span><br><span class="line">f[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题讲解"><a href="#例题讲解" class="headerlink" title="例题讲解"></a>例题讲解</h4><p><a href="https://www.luogu.org/problem/P3375" target="_blank" rel="noopener">测试地址</a><br><strong>代码模板</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">KMP算法模板-ValenShi</span></span><br><span class="line"><span class="comment">最后修改：2019/9/26</span></span><br><span class="line"><span class="comment">使用说明：</span></span><br><span class="line"><span class="comment">1.字符串起始位置是1而不是0,修改可能会出错.</span></span><br><span class="line"><span class="comment">2.记得初始化nex与f数组</span></span><br><span class="line"><span class="comment">3.原串长度与模式串长度都在函数中用strlen更新,无需修改全局变量 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s1[N],s2[N];</span><br><span class="line"><span class="keyword">int</span> nex[N],f[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="comment">/*更新模式串s的nex数组*/</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]) j++;</span><br><span class="line">nex[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getF</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">const</span> <span class="keyword">char</span> *T)</span></span>&#123;</span><br><span class="line"><span class="comment">/*求解 f 数组,S是目标串,T是模式串*/</span> </span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(S),len2 = <span class="built_in">strlen</span>(T);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;i &lt; len1;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; (j == len2 || S[i] != T[j+<span class="number">1</span>])) j = nex[j];</span><br><span class="line"><span class="keyword">if</span>(S[i] == T[j+<span class="number">1</span>]) j++;</span><br><span class="line">f[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*求解nex数组与f数组,并 按要求 输出答案*/</span></span><br><span class="line">getNex(s2);</span><br><span class="line">getF(s1,s2);</span><br><span class="line"><span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(s1)<span class="number">-1</span>,len2 = <span class="built_in">strlen</span>(s2)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len1;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(f[i] == len2) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i-len2+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len2;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,nex[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,s1+<span class="number">1</span>,s2+<span class="number">1</span>);</span><br><span class="line">s1[<span class="number">0</span>] = s2[<span class="number">0</span>] = <span class="string">'#'</span>;<span class="comment">//不然strlen函数无法使用 </span></span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>董永建，信息学竞赛一本通提高版，福州：福建教育出版社，2018.6，74-81</li><li>李煜东，算法竞赛进阶指南，郑州：河南电子音像出版社，2017.10，65-67</li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fish eating fruits</title>
      <link href="/2019/09/22/fish-eating-fruit/"/>
      <url>/2019/09/22/fish-eating-fruit/</url>
      
        <content type="html"><![CDATA[<p><a href>测试地址</a><br><strong>题意简述：</strong><br>树上任意两点之间的路径按照模 3 为 012 分类，将两点间距离加和，乘 2 即为答案。 </p><p><strong>解题思路：</strong><br>可以采用树上dp解决，也可以点分治，这里先给出一种树上dp做法：<br><code>dp[i][k]</code> 表示距 i 模 3 为 k 的节点距离和。<br><code>tc[i][k]</code> 表示距 i 模 3 为 k 的节点数目。<br><code>ans[k]</code>  表示所有路径中模 3 为 k 的路径的总长度。<br>目标答案是<code>ans[k]</code> 。<br>初始状态 <code>tc[i][0] = 1</code> 。</p><p>如果每次只考虑所有经过根 x 的路径，并且路径上的一个端点在x的一个子树上，另一个端点在另一个子树上（其他所有情况都可以在x的祖先或者子节点被考虑到，所以这样可以包含所有情况）。<br>假设当前枚举到x的子节点y，之前遍历的子节点已经使得dp和tc数组更新完成，那么我们要计算的路径起点在y，终点在之前遍历过的所有子节点中。<br><strong>分类讨论答案贡献：</strong></p><ol><li>边 x-y 对答案的贡献：设 j，k属于{0,1,2}，x 到 y 的边权为 z ，那么z对答案的贡献为<code>tc[x][j] * tc[y][k] * z</code>。</li><li>终点是 y 的所有路径长度的贡献：<code>dp[y][k] * tc[x][j] * z</code>。</li><li>起点是 x 的所有路径长度的贡献：<code>dp[x][j] * tc[y][k] * z</code>。</li></ol><p><strong>于是状态转移方程：</strong><br><code>dp[x][(j+z)%3] += dp[y][j] + z * tc[y][j]</code><br><code>tc[x][(j+z)%3] += tc[y][j]</code></p><p>当然，在状态转移前也要更新ans数组。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N],ver[N],edge[N],nex[N];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll tc[N][<span class="number">4</span>], dp[N][<span class="number">4</span>], ans[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 利用dfs进行状态转移,x为当前子树根节点 */</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i != <span class="number">-1</span>;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;<span class="comment">//y是父节点则跳过 </span></span><br><span class="line">dfs(y,x);</span><br><span class="line"><span class="comment">/* 这里统计答案 */</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">3</span>;k++)&#123;</span><br><span class="line">ans[(j+k+z)%<span class="number">3</span>] += (dp[x][j]*tc[y][k]%P+dp[y][k]*tc[x][j]%P)%P;</span><br><span class="line">ans[(j+k+z)%<span class="number">3</span>] += z*tc[x][j]%P*tc[y][k]%P;</span><br><span class="line">ans[(j+k+z)%<span class="number">3</span>] %= P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在这里转移状态 */</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)&#123;</span><br><span class="line">dp[x][(j+z)%<span class="number">3</span>] = (dp[x][(j+z)%<span class="number">3</span>] + dp[y][j] + z*tc[y][j])%P;</span><br><span class="line">tc[x][(j+z)%<span class="number">3</span>] = (tc[x][(j+z)%<span class="number">3</span>] + tc[y][j])%P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line"><span class="built_in">memset</span>(tc,<span class="number">0</span>,<span class="keyword">sizeof</span> tc);</span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span> ans);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) tc[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 统计答案并输出 */</span> </span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,ans[i]*<span class="number">2</span>%P);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[<span class="number">2</span>]*<span class="number">2</span>%P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head); tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addEdge(x+<span class="number">1</span>,y+<span class="number">1</span>,z); addEdge(y+<span class="number">1</span>,x+<span class="number">1</span>,z);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树上DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces Round 586(Div1+Div2)</title>
      <link href="/2019/09/21/cf-586/"/>
      <url>/2019/09/21/cf-586/</url>
      
        <content type="html"><![CDATA[<h4 id="A-Cards"><a href="#A-Cards" class="headerlink" title="A. Cards"></a>A. Cards</h4><p><a href="https://codeforces.com/contest/1220/problem/A" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定一个长度为 n 的字符串，该字符串可以组合出来几个one和几个zero，每个字符只能用一次。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> nn;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,z,e,r,o;</span><br><span class="line">n = z = e = r = o = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= nn;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i] == <span class="string">'o'</span>) o++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'z'</span>) z++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'r'</span>) r++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'e'</span>) e++;</span><br><span class="line"><span class="keyword">else</span> n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> one,zero;</span><br><span class="line">one = min(n,min(o,e));</span><br><span class="line">n -= one, o -= one, e -= one;</span><br><span class="line">zero = min(o,min(e,min(z,r)));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= one;i++) <span class="built_in">printf</span>(<span class="string">"1 "</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= zero;i++) <span class="built_in">printf</span>(<span class="string">"0 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;nn);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="B-Multiplication-Table"><a href="#B-Multiplication-Table" class="headerlink" title="B. Multiplication Table"></a>B. Multiplication Table</h4><p><a href="https://codeforces.com/contest/1220/problem/B" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定一个n <em> n表格，其中$M_{i,j} = a_i </em> a_j$，现在有个坏蛋把序列a给扔了，同时把M_{i,i}都给扣走了，现在请你利用剩下的信息求出a序列。</p><p><strong>解题思路：</strong><br>不是高斯消元题，其实是个找规律题。如果我们能求出来$a_1$，那么我们就可以根据第一列求出所有答案。而我们又可以根据$a_1a_2 = x$ , $a_1a_3 = y$ , $a_2a_3 = z$来求出$a_1$，于是就可以在求出其他所有结果了。<br><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line">ll mat[N][N],ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">ans[<span class="number">1</span>] = mat[<span class="number">1</span>][<span class="number">2</span>]*mat[<span class="number">1</span>][<span class="number">3</span>]/mat[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">ans[<span class="number">1</span>] = (ll)<span class="built_in">sqrt</span>(ans[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">ans[i] = mat[<span class="number">1</span>][i]/ans[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">printf</span>(<span class="string">"%I64d "</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>,&amp;mat[i][j]);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-Substring-Game-in-the-Lesson"><a href="#C-Substring-Game-in-the-Lesson" class="headerlink" title="C. Substring Game in the Lesson"></a>C. Substring Game in the Lesson</h4><p><a href="https://codeforces.com/contest/1220/problem/C" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>Ann和Mike在玩游戏，有一个字符串s，初始时有l  = r = k ，每个人轮流操作：</p><ul><li>选择l’ &lt; l , r’ &lt; r，且s[l’,r’] 字典序小于 s[l,r]，然后令l = l’, r = r’。</li><li>若不能做任何操作，则失败。</li></ul><p>Ann先手，对于每个位置k，输出谁必胜。</p><p><strong>题意简述：</strong><br>简单的博弈论，首先必败态是“在 l 之前不存在l’ &lt; l ， 且s[l’ , r] 字典序小于 s[l ,r] ”，而若当前不是必败态，则一定可以使得下一个状态一定是必败态，于是只需要判断每个位置前面是否有字典序比其小的字符即可。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mi = (<span class="keyword">int</span>)str[<span class="number">0</span>],n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mi &lt; (<span class="keyword">int</span>)str[i]) vis[i] = <span class="number">1</span>;</span><br><span class="line">mi = min(mi,(<span class="keyword">int</span>)str[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line"><span class="keyword">if</span>(vis[i]) <span class="built_in">printf</span>(<span class="string">"Ann\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Mike"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="D-Alex-and-Julian"><a href="#D-Alex-and-Julian" class="headerlink" title="D. Alex and Julian"></a>D. Alex and Julian</h4><p><a href="https://codeforces.com/contest/1220/problem/D" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定一个正整数集合B，令全集Z(所有整数)内的元素作为无向图的顶点，对于图中内任意两点i 和 j，若abs(i - j)属于集合B，则 i 和 j 之间有一条无向边。现在请问最少删除B中几个顶点可以使得剩下的图是二分图。</p><p><strong>解题思路：</strong><br>不是二分图问题，只用到了“一张图是二分图，当且仅当图中不存在奇环”这一二分图判定定理。<br>至于为啥不能用二分图算法来解决呢，从问题规模就可以猜到，因为要构造图需要$O((1e18)^2)$，显然n的规模不允许这样做。</p><p>那么从数学角度考虑（找规律），若有节点0和节点a，那么0 到 a有边，若还存在节点2 <em> a ，那么a 和2 </em> a也有边，且2 <em> a与 0也有边，这就是奇环了（哪怕还有3 </em> a，也还是奇环+一个偶环），因此不能有2 <em> a，同理也不能有4 </em> a，因此若想保留a，那么2 <em> a，4 </em> a， 8 * a， … 都要删去。<br>但是这样做法复杂度过高，因为顶点集合是[1, 1e18]，挨个计算显然不现实，因此我们可以对集合B中每个元素b，B中有哪些元素可以和b一起被保留。</p><p>若a中有x个因数2，b中有y个因数2（x != y），那么a和b一定不能同时存在；假设c = lcm(a ,b)那么0 -&gt; a -&gt; 2 <em> a -&gt; … -&gt; c -&gt; … -&gt; 2 </em> b -&gt; b -&gt; 0一定可以构成一个奇环 ，因此a和b不能同时存在。所以若是x != y，则a和b不能同时存在（a和b都是集合B内元素）。</p><p>若是x = y，那么a和b可以同时存在，因为它们不存在a是b的倍数，或者b是a的倍数这种情况，也就不能删去0，因此若有环则一定是偶环。</p><p>综上所述，我们通过统计B集合中每个元素有多少个因子2即可判断最多同时存在多少个元素，即最少删去多少个元素。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="keyword">int</span> tc[N],num[N],n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ll tmp = a[i];</span><br><span class="line"><span class="keyword">while</span>(tmp &amp;&amp; tmp%<span class="number">2</span> == <span class="number">0</span>) tc[i]++,tmp/=<span class="number">2</span>;</span><br><span class="line">num[tc[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">64</span>;i++)</span><br><span class="line"><span class="keyword">if</span>(num[p] &lt; num[i]) p = i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n-num[p]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line"><span class="keyword">if</span>(tc[i] != p) <span class="built_in">printf</span>(<span class="string">"%I64d "</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="E-Tourism"><a href="#E-Tourism" class="headerlink" title="E. Tourism"></a>E. Tourism</h4><p><a href="https://codeforces.com/contest/1220/problem/E" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>一共有n个点和m条无向边，每个点有权值，同一条边不能<strong>连续经过</strong>两次；每个点的权值最多只能加一次；给出每个点的权值以及无向图的边，给出起点编号s，求出怎样才能走才能使得权值和最大。</p><p><strong>解题思路：</strong><br>很容易发现如果经过一个环，那么该环上所有点的权值都可以拿到，且可以从环上任意一点出环，于是我们就可以将一个环缩为一个点，将图中所有环都缩为点后，无向图就成了无根树。题目就成了求无根树上从s出发的最远路径。于是该方法需要Tarjan缩点+树上dp，同时需要注意叶子节点不能缩（一定不是环）。</p><p>另一种方法就是利用拓扑排序。我们可以通过画图等模拟发现，最终答案一定是一些环与从环上出发的一条最长链。<br>于是我们可以考虑如下算法：</p><ol><li>利用拓扑排序，每次都从叶子节点出发，将路径上的权值累加到环上的对应节点（另开数组存放）并终止，并标记路径上的所有点。</li><li>由于环上所有点可互相到达，因此将所有未被标记的点的权值累加（有可能好几个环，但是环与环之间的路径未被标记，并且可达），即为可获得的环上最大权值和。</li><li>找从环上某点出发的最长链，与上述结果相加即为最终答案。</li></ol><p>很显然上述算法是正确的，我们将答案分为了两部分：可互达的“连通环”以及“从环上出发的最长链”。又由于我们是从s出发的，上述算法我们是累加未被标记的节点，因此如果标记的时候遇到了s，那么就将结果累加到s的附加域并终止；最终累加时候因为从 s 出发的链未被标记，因此依然会被累加。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[M],ver[M],nex[M];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> deg[N];<span class="comment">//入度,初始值为0 </span></span><br><span class="line">ll w[N],cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; </span><br><span class="line">head[x] = tot; deg[y]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> n,m,s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line"><span class="keyword">if</span>(deg[i] == <span class="number">1</span> &amp;&amp; i != s) q.push(i);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">deg[x] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(deg[y] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">deg[y]--;</span><br><span class="line">cnt[y] = max(cnt[y],cnt[x]+w[x]);</span><br><span class="line"><span class="keyword">if</span>(deg[y] == <span class="number">1</span> &amp;&amp; y != s) q.push(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll s1 = <span class="number">0</span>,s2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(deg[i] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">s1 += w[i];</span><br><span class="line">s2 = max(s2,cnt[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,s1+s2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,w+i); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y); addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博弈论 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5 连续内存分配</title>
      <link href="/2019/09/20/os5/"/>
      <url>/2019/09/20/os5/</url>
      
        <content type="html"><![CDATA[<h3 id="计算机体系结构和内存层次"><a href="#计算机体系结构和内存层次" class="headerlink" title="计算机体系结构和内存层次"></a>计算机体系结构和内存层次</h3><ul><li>计算机体系结构</li><li>内存层次</li><li>操作系统的内存管理方式</li></ul><h4 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h4><p>基本的分配和释放的管理要求。cpu高速缓存，存储管理单元（MMU），内存最小访问单位8bit；32位的意思是一次可以读写32位；高速缓存用来存放会重复使用的数据，用来提高效率；</p><h4 id="内存层次"><a href="#内存层次" class="headerlink" title="内存层次"></a>内存层次</h4><p>缓存速度最快，首先去缓存找数据，若未命中则去内存中找，若仍未命中则去外存（虚拟内存）中找，这三者速度差别很大。</p><h4 id="操作系统的内存管理"><a href="#操作系统的内存管理" class="headerlink" title="操作系统的内存管理"></a>操作系统的内存管理</h4><p>知识点：我们希望的理想状态。逻辑存储单元。<br><strong>存储管理要达到的效果：</strong></p><ul><li>抽象：逻辑地址空间</li><li>保护：独立地址空间</li><li>共享：访问相同内存</li><li>虚拟化：更大的地址空间</li></ul><h4 id="操作系统中采用的内存管理方式："><a href="#操作系统中采用的内存管理方式：" class="headerlink" title="操作系统中采用的内存管理方式："></a>操作系统中采用的内存管理方式：</h4><ul><li>重定位（relocation）</li><li>分段（segmentation）</li><li>分页（paging）</li><li>虚拟存储（目前多数系统，如Linux，采用按需页式虚拟存储）</li></ul><p><strong>实现高度依赖硬件：</strong></p><ul><li>与计算机存储架构紧耦合</li><li>MMU（内存管理单元）：处理CPU存储访问请求的硬件</li></ul><h3 id="地址空间和地址生成"><a href="#地址空间和地址生成" class="headerlink" title="地址空间和地址生成"></a>地址空间和地址生成</h3><h4 id="地址空间的定义"><a href="#地址空间的定义" class="headerlink" title="地址空间的定义"></a>地址空间的定义</h4><p>物理地址空间-硬件支持的地址空间（地址总线条数）。</p><ul><li>起始地址为0，知道$MAX_{sys}$</li></ul><p>逻辑地址空间-在CPU运行的进程看到的地址</p><ul><li>起始地址为0，直到$MAX_{prog}$</li></ul><p>地址是从哪里来的？</p><h4 id="逻辑地址生成"><a href="#逻辑地址生成" class="headerlink" title="逻辑地址生成"></a>逻辑地址生成</h4><p><img src="/2019/09/20/os5/1.png" alt="1"></p><p><center>图1：逻辑地址生成图示</center></p><h4 id="地址生成时机和限制"><a href="#地址生成时机和限制" class="headerlink" title="地址生成时机和限制"></a>地址生成时机和限制</h4><p>编译时：</p><ul><li>假设起始地址已知</li><li>如果起始地址改变，必须重新编译</li></ul><p>加载时：</p><ul><li>如编译时起始位置位置，编译器需生成可重定位的代码</li><li>加载时，生成绝对地址</li></ul><p>执行时：</p><ul><li>执行时代码可移动</li><li>需地址转换（映射）硬件支持</li></ul><h4 id="地址生成过程"><a href="#地址生成过程" class="headerlink" title="地址生成过程"></a>地址生成过程</h4><p>CPU：</p><ul><li>ALU：需要逻辑地址的内存内容</li><li>MMU：进行逻辑地址和物理地址的转换</li></ul><p>内存：</p><ul><li>发送物理地址的内容给CPU</li><li>或接受CPU数据到物理地址</li></ul><p>操作系统：</p><ul><li>建立逻辑地址LA和物理地址PA的映射</li></ul><h4 id="地址检查"><a href="#地址检查" class="headerlink" title="地址检查"></a>地址检查</h4><p>检查段的长度和偏移量是否为有效范围。</p><h3 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h3><h4 id="连续内存分配和内存碎片"><a href="#连续内存分配和内存碎片" class="headerlink" title="连续内存分配和内存碎片"></a>连续内存分配和内存碎片</h4><p><strong>连续内存分配：</strong> 给进程分配一块不小于指定大小的连续的物理内存。<br><strong>内存碎片：</strong> 空闲内存不能被利用。<br><strong>外部碎片：</strong> 分配单元之间的未被使用的内存。<br><strong>内部碎片：</strong> 分配单元内部的未被使用的内存，取决于分配单元大小是否要调整。</p><h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p><strong>动态内存分配：</strong></p><ul><li>当程序被加载可执行时，分配一个进程指定大小可变的分区（块，内存块）</li><li>分区的地址是连续的</li></ul><p><strong>操作系统需要维护的数据结构：</strong></p><ul><li>所有进程的已分配分区</li><li>空闲分区（Empty-blocks）</li></ul><p><strong>动态分区分配策略：</strong></p><ul><li>最先匹配</li><li>最优匹配</li><li>最差匹配</li></ul><h4 id="最先匹配（First-Fit-Allocation）策略"><a href="#最先匹配（First-Fit-Allocation）策略" class="headerlink" title="最先匹配（First Fit Allocation）策略"></a>最先匹配（First Fit Allocation）策略</h4><p>思路：分配n个字节时，使用第一个可用的空间比n大的空闲块。<br>原理&amp;实现：</p><ul><li>空闲分区列表按照地址顺序排序</li><li>分配过程中，搜索一个合适的分区</li><li>释放分区时，检查是否可与临近的空闲分区合并</li></ul><p>优点：</p><ul><li>简单</li><li>在高地址上有大块的空闲分区</li></ul><p>缺点：</p><ul><li>外部碎片多</li><li>分配大块时较慢</li></ul><h4 id="最佳匹配（Best-Fit-Allocation）策略"><a href="#最佳匹配（Best-Fit-Allocation）策略" class="headerlink" title="最佳匹配（Best Fit Allocation）策略"></a>最佳匹配（Best Fit Allocation）策略</h4><p>思路：分配n个字节时，查找并使用不小于n的最小空闲分区<br>原理&amp;实现：</p><ul><li>空闲分区列表按照大小排序</li><li>分配时，查找一个合适的分区</li><li>释放时，查找并合并临近的空闲分区（如果找到）</li></ul><p>优点： 大部分分配的尺寸较小时，效果很好</p><ul><li>可避免大的空闲分区被拆分</li><li>可减小外部碎片的大小</li><li>相对简单</li></ul><p>缺点：</p><ul><li>外部碎片</li><li>释放分区慢</li><li>容易产生很多无用的小碎片</li></ul><h4 id="最差匹配（Worst-Fit-Allocation）策略"><a href="#最差匹配（Worst-Fit-Allocation）策略" class="headerlink" title="最差匹配（Worst Fit Allocation）策略"></a>最差匹配（Worst Fit Allocation）策略</h4><p>思路：分配n字节，使用尺寸不小于n的最大空闲分区。<br>原理&amp;实现：</p><ul><li>空闲分区按从大到小排序</li><li>分配时，选最大的分区</li><li>释放时，检查是否可与临近的空闲分区合并，进行可能的合并，并调整空闲分区列表的顺序</li></ul><p>优点：</p><ul><li>中等大小的分配较多时，效果最好</li><li>避免出现太多的小碎片</li></ul><p>缺点：</p><ul><li>释放分区较慢</li><li>外部碎片</li><li>容易破坏大的空闲分区，因此后续难以分配大的分区</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存分配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dudu&#39;s maze 解题报告</title>
      <link href="/2019/09/15/dudu-maze/"/>
      <url>/2019/09/15/dudu-maze/</url>
      
        <content type="html"><![CDATA[<p><a href="https://nanti.jisuanke.com/t/41402" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>在一个无向图中，有 k 个怪物点，n-k个糖果点，每个糖果点有1个糖果，且可以移动到相邻的点，但是每个点的糖果只能拿一次（但是可以经过多次）。而每个怪物点没糖果，但是可以随机传送到相邻的点，只能传送一次（即只能进一次怪物房），请问最终拿到糖果的最优期望是多少？<br><strong>解题思路：</strong><br>dfs求连通块+染色，我现在还是不明白我单独染色为什么一直超时，无语了，就按照下面的代码写吧，用标记数组单独存放被染色的连通块糖果数，相当于记忆化。当然节点1所在的连通块糖果都能拿到，然后再选择走和1相连的且期望最大的怪物点即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[<span class="number">2</span>*N],nex[<span class="number">2</span>*N],tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,t,k;</span><br><span class="line"><span class="keyword">int</span> vis[N],mst[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y;nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> vm[N],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"><span class="keyword">int</span> tc[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="number">1</span>; ans++; tc[x]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i != <span class="number">-1</span>;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(mst[y])&#123;</span><br><span class="line">vm[++cnt] = y;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">dfs1(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num[col]) <span class="keyword">return</span> num[col];</span><br><span class="line"><span class="keyword">if</span>(vis[x] || mst[x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> res = <span class="number">1</span>; vis[x] = col;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i != <span class="number">-1</span>;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y] || mst[y]) <span class="keyword">continue</span>;</span><br><span class="line">res += dfs2(y,col);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">ans = <span class="number">0</span>; cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span> num);</span><br><span class="line">dfs1(<span class="number">1</span>); <span class="keyword">double</span> mx = <span class="number">0</span>; <span class="keyword">int</span> col = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++)&#123;</span><br><span class="line"><span class="keyword">double</span> pp = <span class="number">0</span>,ecnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = head[vm[i]] ;j != <span class="number">-1</span>;j = nex[j]) ecnt++;</span><br><span class="line"><span class="comment">//printf("ecnt: %f\n",ecnt);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = head[vm[i]] ;j != <span class="number">-1</span>;j = nex[j])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[j]; <span class="keyword">double</span> tmp;</span><br><span class="line"><span class="keyword">if</span>(vis[y]) tmp = num[vis[y]];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">tmp = dfs2(y,++col);</span><br><span class="line">num[col] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">pp += tmp;</span><br><span class="line"><span class="comment">//printf("%d %f\n",ver[j] ,tmp);</span></span><br><span class="line">&#125;</span><br><span class="line">pp /= ecnt;</span><br><span class="line"><span class="keyword">if</span>(mx - pp &lt; <span class="number">0</span>) mx = pp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.7f\n"</span>,mx+ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c!=<span class="string">'-'</span> &amp;&amp; (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) neg = <span class="literal">true</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">ans = ans*<span class="number">10</span> + c-<span class="string">'0'</span>, c = getchar();</span><br><span class="line"><span class="keyword">return</span> neg ? -ans : ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">t = getInt();</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">tot = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(mst,<span class="number">0</span>,<span class="keyword">sizeof</span> mst);</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">n = getInt(), m = getInt(),k = getInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">x = getInt(); y = getInt();</span><br><span class="line">addEdge(x,y);addEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= k;i++) x = getInt() , mst[x] = <span class="number">1</span>;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs连通块 </tag>
            
            <tag> 染色 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 72 解题报告</title>
      <link href="/2019/09/10/cf-r72/"/>
      <url>/2019/09/10/cf-r72/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1217" target="_blank" rel="noopener">题集链接</a></p><h4 id="A-Creating-a-Character"><a href="#A-Creating-a-Character" class="headerlink" title="A.Creating a Character"></a>A.Creating a Character</h4><p><strong>题意简述：</strong><br>有三个数a，b，c，将c分配在a和b上，使得a&gt;b，请问有多少种分配方案？两个方案不同，当且仅当它们对应的a或b不相等。</p><p><strong>解题思路：</strong><br>假设将c分配给a和b后使得a = b = res，那么显然若原始的a &gt; res，就说明b+c &lt; a，那么答案就是c+1（当然特判b+c&lt;a也行）；否则a &lt;= res，此时分配给a的值一定要大于res - a，所以共c - (res-a) = c-res + a 种不同方案。 </p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a,b,c,t,d;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a+c &lt;= b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = a+b+c&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a &gt; res) <span class="keyword">return</span> c+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> c-res+a; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="B-Zmei-Gorynich"><a href="#B-Zmei-Gorynich" class="headerlink" title="B.Zmei Gorynich"></a>B.Zmei Gorynich</h4><p><strong>题意简述：</strong><br>一条恶龙共 x 滴血，勇士有n件武器，每件武器有伤害值 d 和 副作用 h，表示着将会给恶龙造成 d 点伤害，之后会给恶龙回 h 点血。当某一时刻恶龙血量低于0时则会死亡，请问勇者最少砍多少次才能杀死恶龙？如果杀不死输出-1，一个武器可以重复使用。<br><strong>解题思路：</strong><br>如果当前有一个武器能杀死恶龙（d &gt;= x），那么就可以忽略他的副作用 h ，直接秒杀恶龙；否则我们就要选择一个d-h最大的来砍恶龙，所以我们最多用两把武器，一把用来消耗，一把用来终结恶龙。当无法秒杀恶龙，也无法消耗恶龙时，说明无法杀死恶龙。否则就可以通过计算最少需要消耗多少次来O(1)计算答案。</p><p>特别注意是否能一刀秒杀恶龙等特殊情况。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> t1,t2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//恶龙本来就死了</span></span><br><span class="line"><span class="keyword">if</span>(t1 &gt;= x) <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//秒杀恶龙</span></span><br><span class="line"><span class="keyword">if</span>(t2 &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//无法杀死恶龙</span></span><br><span class="line">x -= t1;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x%t2) res++;</span><br><span class="line">res += x/t2;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;x); t1 = t2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,ta,tb;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;ta,&amp;tb);</span><br><span class="line">t1 = max(t1,ta);</span><br><span class="line">t2 = max(t2,ta-tb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="C-The-Number-Of-Good-Substrings"><a href="#C-The-Number-Of-Good-Substrings" class="headerlink" title="C.The Number Of Good Substrings"></a>C.The Number Of Good Substrings</h4><p><strong>题意简述：</strong><br>给定一个01串 s ，假设 sub 是 s 的子串，定义f(sub) = “sub十进制的值”。若f(sub) = len(sub)，f(sub) = 子串sub的长度，那么称sub为“优秀的子串”。<br>现在给定字符串s，试求出s的“优秀的子串”的数量。</p><p><strong>解题思路：</strong><br>刚开始想用KMP算法：对于每一可能的长度（共2e5种可能的情况）转化为二进制的01串，再用KMP计算该串在 s 中出现的次数，将所有情况累加即为答案。<br>但是KMP超时了，还是对KMP不太熟悉，上述算法复杂度应该是$O(N^2)$，是不行的。</p><p>再考虑由于$2^{20} &gt; 2e5$ 所以我们其实可以通过将 s 所有长度为 [1 , 20] 的子串挨个判断是否为“优秀的子串”，如此O(20N)时间内求出结果。具体做法是从左向右，将上一个 1 作为子串左端点，然后依次向右延申，长度+1，并将其转化为十进制，如果该十进制要大于区间长度，则后续肯定也不可能是“优秀子串”，故退出。能这样做是因为左边的0不影响十进制数的大小，而右边的0影响。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> last = <span class="number">0</span>,x,l,len = <span class="built_in">strlen</span>(str); ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;str[i];i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i] == <span class="string">'0'</span>) <span class="keyword">continue</span>; x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; len &amp;&amp; j &lt;= i+<span class="number">25</span>;j++)&#123;</span><br><span class="line">x = x*<span class="number">2</span>+str[j]-<span class="string">'0'</span>;</span><br><span class="line">l = j-x+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= last) <span class="keyword">break</span>;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">last = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="D-Coloring-Edges"><a href="#D-Coloring-Edges" class="headerlink" title="D.Coloring Edges"></a>D.Coloring Edges</h4><p><strong>题意简述：</strong><br>给定一个有 n 个点 m 条边的有向图，该有向图无自环无重边。我们对该有向图进行染色，一个好的染色方案当且仅当图中没有一个环是同一个颜色。请问要想使得该染色方案是好的，最少需要多少种不同的颜色？并输出每条边的颜色。<br><strong>解题思路：</strong><br>首先通过手画几种样例可以得出，我们最多只需要2种不同的颜色就可以完成图的着色。因此若图中有环，则k = 2，否则k = 1。而当k = 2时，即图中有环，需要2种不同颜色染色时，我们知道有向图中，若存在环，则必然有从编号小的点指向编号大的点，也有编号大的点指向编号小的点。因此，若边u-&gt;v，若u &lt; v则染颜色1，否则染颜色2，这样可以保证该环被拆分成两种颜色。</p><p><em>注：若有向图中不存在环，则不一定有 “从编号小的点指向编号大的点，同时也有从编号大的点指向编号小的点。”</em></p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[N],ver[N],nex[N];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x];</span><br><span class="line">head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,xx[N],yy[N];</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span>;</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[y] == <span class="number">1</span>)&#123;</span><br><span class="line">flag = <span class="literal">true</span>; <span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!vis[y]) dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">vis[x] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!vis[i]) dfs(i);</span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(xx[i] &gt; yy[i]) <span class="built_in">printf</span>(<span class="string">"2 "</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"1 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">printf</span>(<span class="string">"1 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;xx[i],&amp;yy[i]);</span><br><span class="line">addEdge(xx[i],yy[i]);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu6629 string matching（拓展KMP）</title>
      <link href="/2019/09/06/hdu6629-String-Match/"/>
      <url>/2019/09/06/hdu6629-String-Match/</url>
      
        <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6629" target="_blank" rel="noopener">hdu6629string matching</a><br><strong>Description:</strong><br>给出一个字符串S，我们执行“求出S所有后缀与S的最长公共前缀长度”这个操作，我们采取暴力算法(算法流程见题面)，请问我们在该算法中共执行了多少次比较操作？<br><strong>Input:</strong><br>第一行一个整数t，接下来共t组测试用例，每个测试用例输入一个长度小于1e6的字符串S。<br><strong>解题思路：</strong><br>可以用拓展KMP做，其中S是原串，T也是原串。暴力算法的比较次数就等同于所有后缀的最长公共前缀长度和，若没有比到字符串末尾，则还要加上一次失配的操作比较。由于本题T也是S，故可以在计算nex数组的同时便统计答案。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> nex[N];<span class="comment">//nex[i] = T[i,n-1]与T[0,n-1]最长公共前缀 </span></span><br><span class="line"><span class="keyword">char</span> S[N];<span class="comment">//S为目标串,T为模式串 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str) ,i = <span class="number">0</span>,j,p0 ;</span><br><span class="line">nex[<span class="number">0</span>] = len;</span><br><span class="line"><span class="keyword">while</span>(i+<span class="number">1</span> &lt; len &amp;&amp; str[i] == str[i+<span class="number">1</span>]) i++;</span><br><span class="line">nex[<span class="number">1</span>] = i; p0 = <span class="number">1</span>; ans += nex[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(nex[<span class="number">1</span>] != len<span class="number">-1</span>) ans++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex[i-p0]+i &lt; nex[p0]+p0) nex[i] = nex[i-p0];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j = nex[p0]+p0-i;</span><br><span class="line"><span class="keyword">if</span>(j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i+j &lt; len &amp;&amp; str[j] == str[j+i]) j++;</span><br><span class="line">nex[i] = j; p0 = i;</span><br><span class="line">&#125;</span><br><span class="line">ans += nex[i];</span><br><span class="line"><span class="keyword">if</span>(nex[i] != len-i) ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算并返回答案*/</span></span><br><span class="line">ans = <span class="number">0</span>; getNex(S);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,S);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓展KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓展KMP算法</title>
      <link href="/2019/09/06/exkmp/"/>
      <url>/2019/09/06/exkmp/</url>
      
        <content type="html"><![CDATA[<p><strong>问题模型：</strong><br>给定字符串S和子串T，S的长度为n，T的长度为m；求字符串T与字符串S的每一个后缀d的最长公共前缀。</p><h4 id="拓展KMP算法"><a href="#拓展KMP算法" class="headerlink" title="拓展KMP算法"></a>拓展KMP算法</h4><p>假设 extend[] 数组： extend[i] 表示 T 与 S[i, n] 的最长公共前缀，目的是求出所有的 extend[0~n-1]。<br>（注意到，如果存在extend[i] = m，则说明 T 在 S 中完全出现过，那么问题就变成标准KMP算法了。）<br>我们下面的目标就是如何在较短的时间内更新extend数组；与KMP算法类似，我们通过利用next数组来阻止指针的回退。</p><p><strong>下面先通过一般的例子来看我们是如何更新extend数组的：</strong></p><p>S = “aaaabaa” , T = “aaaaa”。</p><p>显然extend[0] = 4，显然当匹配到第5个时失配，共匹配了5次。<br>我们考虑利用已知的信息来计算extend[1]，已知S[1 , 3] = T[1 , 3]，现在要用S[1 , n-1]和T[0 , n-1]进行匹配，如果我们设 nex[1] 存放 T[1 , n-1] 与 T[0 , n-1] 的最长公共前缀，nex[1] = 4，这就说明<strong>对于S[1, n-1]，T[1 , n-1]能匹配上的字符，T[0,n-1]的前nex[1]个也能匹配的上</strong>，由于T[1,n-1]只能匹配S[1 , 3]共3个字符，那么显然前 3 个字符都可以成功匹配，我们直接匹配下一位即可；于是extend[1] = 3。</p><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><p><strong>定义extend[]数组：</strong> extend[i] 表示字符串 T 与字符串 S[i , n] 的最长公共前缀长度。<br><strong>定义nex[]数组：</strong> nex[i] 表示 T[i , n] 与 T[1 , n] 的最长公共前缀的长度。</p><p>首先我们从左到右计算extend数组，假设在某一时刻 extend[0 , k] 已经计算完毕，并且之前匹配过程中所达到的最远距离为p，所谓最远距离即 p = MAX{ i+extend[i]  (0 &lt;= i &lt;= k) } 的最大值，p’ 为达到最远距离时的 i 。</p><p><strong>现在来利用已知的信息求extend[k+1]：</strong><br>已知S[p’ , p] = T[0, p-p’]，即S[k+1 , p] = T[k+1 - p’ , p-p’]。<br>设 len = nex[k+1 - p’] ，即 len 为 T[k+1 - p’ , n-1] 与 T[0 , n-1]的最长公共前缀。</p><ul><li>如果k+len &lt; p，则extend[k+1] = len：<br>此时由于已知条件 以及 nex数组性质，可以知道前 len 个字符一定是匹配的。若S[k+ len+1] = T[len]，则说明 nex 是len+1而非len，于是与nex数组矛盾，故不成立；因此若k+len &lt; p，则extend[k+1] = len。</li></ul><p><img src="/2019/09/06/exkmp/1.png" alt="1"><br>(图1：当k+len&lt;p时情形，其中po = p’，图片来自 <em>dyx心心</em> 的博客)</p><ul><li>若k+len &gt;= p：<br>此时已知的是S[k+1 , p] = T[0 , p-k-1]，但是 S[p+1] 是否等同于 T[p-k] 尚且未知，因此需要向后遍历判断，同时更新p与p’。</li></ul><p><img src="/2019/09/06/exkmp/2.png" alt="2"><br>(图2：当k+len &gt;= p时情形，其中po = p’，图片来自 <em>dyx心心</em> 的博客)</p><p>对于nex数组，其求法和extend数组类似，详情参考代码中getNex()函数实现方法。</p><h4 id="例题模板"><a href="#例题模板" class="headerlink" title="例题模板"></a>例题模板</h4><p><a href="https://www.luogu.org/problem/P5410" target="_blank" rel="noopener">洛谷P5410拓展KMP模板</a><br><strong>题意简述：</strong><br>给定字符串S和T，输出next数组以及extend数组。</p><p><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> nex[N];<span class="comment">//nex[i] = T[i,n-1]与T[0,n-1]最长公共前缀 </span></span><br><span class="line"><span class="keyword">char</span> S[N],T[N]; <span class="comment">//S为目标串,T为模式串 </span></span><br><span class="line"><span class="keyword">int</span> extend[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNex</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算nex数组*/</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str) ,i = <span class="number">0</span>, j, p0 ;</span><br><span class="line">nex[<span class="number">0</span>] = len;</span><br><span class="line"><span class="keyword">while</span>(i+<span class="number">1</span> &lt; len &amp;&amp; str[i] == str[i+<span class="number">1</span>]) i++;</span><br><span class="line">nex[<span class="number">1</span>] = i; p0 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex[i-p0]+i &lt; nex[p0]+p0) nex[i] = nex[i-p0];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j = nex[p0]+p0-i;</span><br><span class="line"><span class="keyword">if</span>(j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i+j &lt; len &amp;&amp; str[j] == str[j+i]) j++;</span><br><span class="line">nex[i] = j; p0 = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exKMP</span><span class="params">(<span class="keyword">char</span>* str1,<span class="keyword">char</span> *str2)</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算str2与str1的所有后缀的最长公共前缀长度,存放在extend数组中*/</span> </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>,j,p0,l1 = <span class="built_in">strlen</span>(S), l2 = <span class="built_in">strlen</span>(T);</span><br><span class="line">getNex(str2);</span><br><span class="line"><span class="keyword">while</span>(i &lt; l1 &amp;&amp; i &lt; l2 &amp;&amp; str1[i] == str2[i]) i++;</span><br><span class="line">extend[<span class="number">0</span>] = i;p0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; l1;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex[i-p0]+i &lt; extend[p0]+p0) extend[i] = nex[i-p0];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">j = extend[p0]+p0-i;</span><br><span class="line"><span class="keyword">if</span>(j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i+j &lt; l1 &amp;&amp; j &lt; l2 &amp;&amp; str1[j+i] == str2[j]) j++;</span><br><span class="line">extend[i] = j; p0 = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*计算并输出答案*/</span></span><br><span class="line"><span class="keyword">int</span> l1 = <span class="built_in">strlen</span>(S), l2 = <span class="built_in">strlen</span>(T);</span><br><span class="line">exKMP(S,T);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; l2;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,nex[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; l1;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,extend[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,S,T);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://blog.csdn.net/dyx404514/article/details/41831947#commentBox" target="_blank" rel="noopener">dyx心心的博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 拓展KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu6638 Snowy Smile-线段树维护最大子矩阵</title>
      <link href="/2019/09/03/hdu6638-Snowy-Smile/"/>
      <url>/2019/09/03/hdu6638-Snowy-Smile/</url>
      
        <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6638" target="_blank" rel="noopener">题目链接</a></p><h4 id="Snowy-Smile"><a href="#Snowy-Smile" class="headerlink" title="Snowy Smile"></a>Snowy Smile</h4><p><strong>题意简述：</strong><br>给出平面上n(n &lt;= 2000)个点，点的坐标在-1e9~1e9之间，试求出最大子矩阵的和是多少。</p><p><strong>解题思路：</strong><br>考虑数据范围，2e3个点离散化后可能会有2e3个，本题中各个点是离散的，所以用普通的动态规划比较麻烦，因此本题采用$O(N^2log_2N)$的线段树+枚举。<br>我们对x，枚举所有可能的x[i]和x[j]其中x[i]为上界，x[j]为下界，这个枚举花费时间为$O(N^2)$，而对于每一种可能的组合，再利用线段树$O(log_2N)$求出最大连续子段和，因此总时间$O(N^2log_2N)$。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3010</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">int</span> tmp[N];<span class="comment">//离散化用</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Chest</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,val;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Chest &amp; B) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt; B.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;cs[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="comment">/*分别为区间和,区间最大子段和,</span></span><br><span class="line"><span class="comment">从左侧开始的最大子段和,从右侧开始的最大子段和*/</span></span><br><span class="line">ll sum,mx,lx,rx; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mx(x) tr[x].mx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lx(x) tr[x].lx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rx(x) tr[x].rx </span></span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*在区间[l,r]上建立一棵线段树*/</span></span><br><span class="line">sum(rt) = mx(rt) = lx(rt) = rx(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid);</span><br><span class="line">BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="comment">/*用于根据rt的子节点更新rt的4个数据*/</span></span><br><span class="line">sum(rt) = sum(rt*<span class="number">2</span>)+sum(rt*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">mx(rt) = max(rx(rt*<span class="number">2</span>)+lx(rt*<span class="number">2</span>+<span class="number">1</span>),max(mx(rt*<span class="number">2</span>),mx(rt*<span class="number">2</span>+<span class="number">1</span>)));</span><br><span class="line">lx(rt) = max(lx(rt*<span class="number">2</span>),sum(rt*<span class="number">2</span>)+lx(rt*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">rx(rt) = max(rx(rt*<span class="number">2</span>+<span class="number">1</span>),sum(rt*<span class="number">2</span>+<span class="number">1</span>)+rx(rt*<span class="number">2</span>));</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p,<span class="keyword">int</span> val,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将线段树p位置的值设为val;l,r是辅助作用哦*/</span></span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum(rt) += val;</span><br><span class="line">lx(rt) = rx(rt) = mx(rt) = sum(rt); </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= mid) Insert(rt*<span class="number">2</span>,p,val,l,mid);</span><br><span class="line"><span class="keyword">else</span> Insert(rt*<span class="number">2</span>+<span class="number">1</span>,p,val,mid+<span class="number">1</span>,r);</span><br><span class="line">spread(rt);<span class="comment">//在回溯时更新节点的值 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回当前最大连续子段和*/</span></span><br><span class="line"><span class="keyword">return</span>  tr[<span class="number">1</span>].mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">sort(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">int</span> cnt = unique(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+n)-tmp<span class="number">-1</span>;</span><br><span class="line">sort(cs+<span class="number">1</span>,cs+<span class="number">1</span>+n);</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*我们对每一个x[i]上限,枚举所有可能x[j]的下限,</span></span><br><span class="line"><span class="comment">并利用线段树求出x[i]~x[j]最大字段和*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(cs[i].x == cs[i<span class="number">-1</span>].x &amp;&amp; i != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,cnt);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(cs[j].x != cs[j<span class="number">-1</span>].x &amp;&amp; i != j) ans = max(ans,ask());</span><br><span class="line"><span class="keyword">int</span> y = lower_bound(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+cnt,cs[j].y)-tmp;</span><br><span class="line">Insert(<span class="number">1</span>,y,cs[j].val,<span class="number">1</span>,cnt);</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans,ask());<span class="comment">//如果全部相等,在此处特判 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;cs[i].x,&amp;cs[i].y,&amp;cs[i].val);</span><br><span class="line">tmp[i] = cs[i].y;</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 最大子矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019航电多校7部分题解</title>
      <link href="/2019/09/02/hdu7/"/>
      <url>/2019/09/02/hdu7/</url>
      
        <content type="html"><![CDATA[<h4 id="A-A-B-C"><a href="#A-A-B-C" class="headerlink" title="A. A + B = C"></a>A. <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6646" target="_blank" rel="noopener">A + B = C</a></h4><p>有空再写，麻烦死了。</p><h4 id="F-Final-Exam"><a href="#F-Final-Exam" class="headerlink" title="F. Final Exam"></a>F. <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6651" target="_blank" rel="noopener">Final Exam</a></h4><p><strong>题意简述</strong><br>题意有点绕，一份考试总分为m分n道题，每道题可能为 n 类科目中的一类。如果我们想做出一道分值为 a 的题，那么我们至少要复习该题所在的科目 a+1 分钟以上。请问如果我们要想最少做出k题，需要花多长时间？</p><p><strong>解题思路:</strong><br>首先搞清题意，就是我们目标是最少做出k题需要花费的最少时间，那么最坏情况就是老师针对我们，出我们复习时间最少的n - k + 1道题，令每道题都等于该学生复习的时间（因为总分确定，这样才最优）。那么如果我想通过，那就要令自己复习时间最少的n-k+1门科目复习总时间 &gt; m，这样老师就无论如何也针对不了我了。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">ll n,m,k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = n-k+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = m/tmp + <span class="number">1</span>;</span><br><span class="line">ll ans = (k<span class="number">-1</span>)*b + m+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="K-Kejin-Player"><a href="#K-Kejin-Player" class="headerlink" title="K. Kejin Player"></a>K. <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6656" target="_blank" rel="noopener">Kejin Player</a></h4><p><strong>题意简述：</strong><br>满级为n+1级，从第 i 级升到 i+1 级需要a[i]金币，成功几率为r[i] / s[i] ，如果成功则等级从i变为i+1，失败则等级从 i 变为 x[i] （x[i] &lt;= i）。<br>请问从l升到r级，需要多少金币？<br><strong>解题思路：</strong><br>这是一道概率dp题，且概率可以加减，设f[ x ] 为从1级升到x级需要的金币，那么从l级升到r级需要f[r] - f[l]金币。这是因为升到某一级需要的金币数是固定的，所以满足加减原则。<br>加速我们当前在 i 级，有 p 的概率花费a[i]金币升到 i+1 级，假设我们尝试了t次才升级成功，即： </p><script type="math/tex; mode=display">f[i+1] = f[i] + a[i]  + (t - 1) * a[i] + (t - 1) * (f[ i ] - f[ x[i] ])</script><p>又因为$\frac{t-1}{t} = p$，得$t = \frac{s[i]}{r[i]}$，带入得：</p><script type="math/tex; mode=display">f[i+1] = f[i] +  \frac{s[i]}{r[i]} * a[i] + (\frac{s[i]}{r[i]} - 1) * (f[ i ] - f[ x[i] ])</script><p>遇到这种概率题，设试了t次才成功，然后用概率表示 t 即可得出递推公式。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll r[N],s[N],x[N],a[N];<span class="comment">//p = r/s</span></span><br><span class="line"><span class="keyword">int</span> t,n,q;</span><br><span class="line"><span class="keyword">const</span> ll P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll f[N];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b,ll m)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = res*a%m;</span><br><span class="line">a = a*a%m;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*预处理出所有答案*/</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ll pp = s[i]*qpow(r[i],P<span class="number">-2</span>,P)%P; <span class="comment">//s[i]/r[i]的逆元 </span></span><br><span class="line">f[i+<span class="number">1</span>] = (f[i] + pp*a[i]%P </span><br><span class="line">+ (pp<span class="number">-1</span>)*(f[i]-f[x[i]])%P+P)%P;</span><br><span class="line"><span class="comment">//printf("%lld\n",f[i+1]);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>,r+i,s+i,x+i,a+i);</span><br><span class="line">solve();<span class="comment">//离线 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,tl,tr;i &lt;= q;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;tl,&amp;tr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(f[tr]-f[tl]+P)%P);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博弈论 </tag>
            
            <tag> 概率dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓展欧拉定理+幂塔函数</title>
      <link href="/2019/09/02/exphi/"/>
      <url>/2019/09/02/exphi/</url>
      
        <content type="html"><![CDATA[<h4 id="拓展欧拉定理与幂塔函数"><a href="#拓展欧拉定理与幂塔函数" class="headerlink" title="拓展欧拉定理与幂塔函数"></a>拓展欧拉定理与幂塔函数</h4><p><strong>欧拉定理：</strong> 若gcd(a,p) = 1，则 $a^p \equiv a^{b \% \varphi (p)}(mod \: p)$，其中gcd(a,p) = 1。<br><strong>拓展欧拉定理：</strong> 假设a为任意数，b和m为正整数，且$b &gt; \varphi(m)$，a和m不一定要互质，那么有如下公式：</p><script type="math/tex; mode=display">a^b~\equiv~\begin{cases}a^{b~Mod~\phi(m)} &\gcd(a,m)~=~1 \\a^b &\gcd(a,m)~\neq~1~\land~b~<~\phi(m) \\ a^{b~Mod~\phi(m)~+~\phi(m)} &\gcd(a,m)~\neq~1~\land~b~\geq~\phi(m)\end{cases} \:\:(Mod\: m)</script><p><em>注：拓展欧拉定理的证明可以参考<a href="https://zhuanlan.zhihu.com/p/24902174" target="_blank" rel="noopener">证明</a></em></p><p><strong>幂塔函数</strong>： 形如</p><script type="math/tex; mode=display">a^{a^{a^{...}}} mod \: m</script><p>的函数我们称为幂塔函数，该函数应从上向下计算，即$a^{a^{a^a}} = a^{(a^{({a^a})})}$，因此其中间变量会急剧上升，普通方法无法计算。</p><h4 id="例题：2019南京icpc网络赛-B-Super-Log"><a href="#例题：2019南京icpc网络赛-B-Super-Log" class="headerlink" title="例题：2019南京icpc网络赛 B.Super_Log"></a>例题：2019南京icpc网络赛 B.Super_Log</h4><p><a href="https://nanti.jisuanke.com/t/41299" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定a和k以及m，试求出</p><script type="math/tex; mode=display">a^{a^{a^{...}}} mod \: m</script><p>其中共k层幂塔。其中a，k和m小于等于1e6。<br><strong>解题思路：</strong><br>首先使用拓展欧拉定理需要 $b &gt; \varphi(m)$，所以对于不同的b要分类讨论一下。设</p><script type="math/tex; mode=display">f(a,k,m) = a^{a^{a^{...}}} \% m</script><p>其中a是有k层的幂塔。</p><ol><li>首先，当a = 1或者b = 0时特判，得出答案为 1%m。</li><li>本题中b = f(a, k-1,INF)，如果a &gt;= phi(m)，那么显然b一定大于phi(m)，即满足拓展欧拉定理中第3种情况；</li><li>如果k = 1，则b = f(a,k-1,INF) = 1，此时只需判断phi(m)是否大于1即可判断当然情况符合拓展欧拉定理第3还是第2种情况。</li><li>剩下的情况我们就可以通过递归来判断b是否大于phi(m)，因为若b &gt;= phi(m)，那么$log_ab &gt;= log_a phi(m)$</li></ol><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b,ll m)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = res*a%m;</span><br><span class="line">a = a*a%m;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> v[N],primes[N],phi[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i])&#123;</span><br><span class="line">primes[cnt++] = i;</span><br><span class="line">v[i] = i;</span><br><span class="line">phi[i] = i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cnt;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(primes[j] &gt; v[i] || primes[j]*i &gt;= N)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">v[i*primes[j]] = primes[j];</span><br><span class="line">phi[i*primes[j]] = phi[i]*(i%primes[j] ? primes[j]<span class="number">-1</span> : primes[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll a,ll b,ll p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> p &lt;= <span class="number">1</span>;<span class="comment">//f(a,0,p) = 1</span></span><br><span class="line"><span class="keyword">if</span>(a &gt;= p) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//f(a,b,INF) &gt; p</span></span><br><span class="line"><span class="keyword">return</span> check(a,b<span class="number">-1</span>,<span class="built_in">log</span>(p)/<span class="built_in">log</span>(a)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll a,ll b,ll m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(m == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//递归终止条件1,此时之后答案恒为0 </span></span><br><span class="line"><span class="keyword">if</span>(b &lt;= <span class="number">1</span>) <span class="keyword">return</span> qpow(a,b,m);<span class="comment">//递归终止条件2 </span></span><br><span class="line">ll ph = phi[m];</span><br><span class="line"><span class="comment">//printf("%lld\n",ph);</span></span><br><span class="line"><span class="keyword">if</span>(gcd(a,m) == <span class="number">1</span>) <span class="keyword">return</span> qpow(a,f(a,b<span class="number">-1</span>,ph),m);<span class="comment">//欧拉定理 </span></span><br><span class="line"><span class="keyword">if</span>(check(a,b<span class="number">-1</span>,ph)) <span class="keyword">return</span> qpow(a,f(a,b<span class="number">-1</span>,ph)+ph,m);<span class="comment">//拓展欧拉定理情况1 </span></span><br><span class="line"><span class="keyword">return</span> qpow(a,f(a,b<span class="number">-1</span>,ph),m); <span class="comment">//拓展欧拉定理情况2 </span></span><br><span class="line">&#125;</span><br><span class="line">ll a,b,m;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f(a,b,m));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.cnblogs.com/SovietPower/p/8353374.html" target="_blank" rel="noopener">SovietPower的博客</a></li><li>《算法竞赛进阶指南》,李煜东,P142-143.</li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 幂塔函数 </tag>
            
            <tag> 拓展欧拉定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018南京icpc网络赛</title>
      <link href="/2019/08/30/2018nanjing/"/>
      <url>/2019/08/30/2018nanjing/</url>
      
        <content type="html"><![CDATA[<p>有嗲难，还有些卡时，思路还有些难想，虽然都是经典模型。</p><h4 id="A-An-Olympian-Math-Problem"><a href="#A-An-Olympian-Math-Problem" class="headerlink" title="A. An Olympian Math Problem"></a>A. An Olympian Math Problem</h4><p><a href="https://nanti.jisuanke.com/t/A1947" target="_blank" rel="noopener">原题链接</a><br><strong>解题思路：</strong><br>如果是比赛时我估计会推公式，但在这通过率面前，我猜了个公式就交了，然后过了。答案就是n-1。</p><h4 id="E-AC-Challenge"><a href="#E-AC-Challenge" class="headerlink" title="E. AC Challenge"></a>E. AC Challenge</h4><p><a href="https://nanti.jisuanke.com/t/A1951" target="_blank" rel="noopener">原题链接</a><br><strong>解题思路：</strong><br>状压dp，这类题做的很少，没忘这方面想。开始用的拓扑排序，但是很明显没有考虑到所有情况。用状压的话，就这题而言，是需要先判断当前状态是否合法，判断完之后再更新答案数组dp，最终答案是dp[(1&lt;<n+1)-2]，这与我代码设计有关，因为我是设右边第2位（也就是左移1）为第一题，而我们更新答案时是将所有“未做但是能做的题”更新成“已做该题”，那么最终答案显然就是1111...1共n个1，由于最低位没用，就是111...10即n个1和1个0，所以答案状态是(1<<n+1)-2。 以后n小于20要往状压dp上想。上述介绍请结合代码以及注释看。 **代码示例：** 以后这个状态最好不要用 i 表示，看起来太乱了。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N],s[N],p[N][N];</span><br><span class="line">ll dp[<span class="number">1</span>&lt;&lt;<span class="number">23</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= (<span class="number">1</span>&lt;&lt;n+<span class="number">1</span>);i++)&#123;</span><br><span class="line"><span class="comment">/*先判断是否该状态合法,若合法则计算其值*/</span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>((<span class="number">1</span>&amp;(i&gt;&gt;j)) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= s[j];k++)</span><br><span class="line"><span class="keyword">if</span>((<span class="number">1</span>&amp;(i&gt;&gt;p[j][k])) == <span class="number">0</span>)&#123;</span><br><span class="line">flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(!flag) <span class="keyword">break</span>; <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!(i&gt;&gt;j&amp;<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">ll t = <span class="number">0</span>,s = i;</span><br><span class="line"><span class="keyword">while</span>(s)&#123;</span><br><span class="line"><span class="keyword">if</span>(s&amp;<span class="number">1</span>) t++; s &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">dp[i] = max(dp[i],dp[i^(<span class="number">1</span>&lt;&lt;j)]+t*a[j]+b[j]);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dp[(<span class="number">1</span>&lt;&lt;n+<span class="number">1</span>)<span class="number">-2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,a+i,b+i,s+i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= s[i];j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></n+1)-2]，这与我代码设计有关，因为我是设右边第2位（也就是左移1）为第一题，而我们更新答案时是将所有“未做但是能做的题”更新成“已做该题”，那么最终答案显然就是1111...1共n个1，由于最低位没用，就是111...10即n个1和1个0，所以答案状态是(1<<n+1)-2。></p><h4 id="J-Sum"><a href="#J-Sum" class="headerlink" title="J. Sum"></a>J. Sum</h4><p><a href="https://nanti.jisuanke.com/t/A1956" target="_blank" rel="noopener">原题链接</a><br><strong>解题思路：</strong><br>我想了一个O(9N)的算法，但是超时了，本机大概1.6-2.5s，很难受；是采用唯一分解定理判断每一个数可以分解为多少个“数对”相乘。然后改用线性筛，思想当然没变，但是利用线性筛的O(N)常数较小，本机0.7~1.1s，通过率大概1/4。<br>然后是朋友提供的解法思路，主要是统计“平方对”，不单独统计每个数对s的贡献，而是直接计算s，也是O(N)，但是更快，稳过。<br><strong>代码示例1：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll f[N],s[N];<span class="comment">//f数组表示单个元素结果,表示所求答案 </span></span><br><span class="line"><span class="keyword">int</span> v[N],primes[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*利用线性筛预处理f数组与s数组*/</span> </span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">primes[++cnt] = i;</span><br><span class="line">v[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= cnt;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(primes[j] &gt; v[i] || primes[j]*i &gt; N) <span class="keyword">break</span>;</span><br><span class="line">v[i*primes[j]] = primes[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">s[<span class="number">1</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//f[1]也要初始化 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(v[i] == i) f[i] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = i,k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x%v[i] == <span class="number">0</span>)&#123;</span><br><span class="line">x /= v[i];k++;</span><br><span class="line"><span class="keyword">if</span>(k &gt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k &gt; <span class="number">2</span>) f[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">2</span>) f[i] = f[x];<span class="comment">//dp思想 </span></span><br><span class="line"><span class="keyword">else</span> f[i] = f[x]*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">s[i] = s[i<span class="number">-1</span>]+f[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*会卡常,有时过有时不过,真正比赛还需要稍微优化,大概1/4过*/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">solve();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,s[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>代码示例2：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 20000070</span></span><br><span class="line"><span class="keyword">int</span> square[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXN;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        square[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;MAXN;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> k=i*i;</span><br><span class="line">        <span class="keyword">if</span>(!square[k]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=k;j&lt;MAXN;j+=k)</span><br><span class="line">        &#123;</span><br><span class="line">            square[j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;MAXN;i++)</span><br><span class="line">        cnt[i]=cnt[i<span class="number">-1</span>]+square[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!square[i])<span class="keyword">continue</span>;</span><br><span class="line">            sum+=(cnt[n/i]-cnt[i])*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="L-Magical-Girl-Haze"><a href="#L-Magical-Girl-Haze" class="headerlink" title="L. Magical Girl Haze"></a>L. Magical Girl Haze</h4><p><a href="https://nanti.jisuanke.com/t/A1958" target="_blank" rel="noopener">原题链接</a><br><strong>解题思路：</strong><br>先把图分层，再进行Dijkstra算法，做过好几遍了，但还是超时很多法，空间大小没计算好，以后一定要注意。<br><strong>代码示例:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">6e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[N],nex[M],ver[M],tot;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">edge[++tot] = z; ver[tot] = y;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t,n,k,m;</span><br><span class="line">ll d[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line">priority_queue&lt;pair&lt;ll,ll&gt; &gt; q;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1l</span>l&lt;&lt;<span class="number">60</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">q.push(make_pair(<span class="number">0</span>,s));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= (k+<span class="number">1</span>)*n;i++) d[i] = INF;</span><br><span class="line">d[s] = <span class="number">0</span>;<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.top().second; q.pop();</span><br><span class="line"><span class="keyword">if</span>(vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">vis[x] = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line"><span class="keyword">if</span>(d[y] &gt; d[x]+z)&#123;</span><br><span class="line">d[y] = d[x]+z;</span><br><span class="line"><span class="keyword">if</span>(!vis[y]) q.push(make_pair(-d[y],y));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">dijkstra(<span class="number">1</span>);ll ans = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k+<span class="number">1</span>;i++) ans = min(ans,d[i*n]);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k); </span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head); tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= k;j++) addEdge(x+n*j,y+n*j,z);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= k;j++) addEdge(x+n*(j<span class="number">-1</span>),y+n*j,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压dp </tag>
            
            <tag> 线性筛 </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019航电暑期多校10部分题解</title>
      <link href="/2019/08/30/hdu10/"/>
      <url>/2019/08/30/hdu10/</url>
      
        <content type="html"><![CDATA[<h4 id="1005-Welcome-Party"><a href="#1005-Welcome-Party" class="headerlink" title="1005 Welcome Party"></a>1005 Welcome Party</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6695" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>一共有n名同学，每位同学都会唱歌和跳舞，第 i 位同学的唱歌和跳舞的能力值分别为$x_i,y_i$，现在将这些同学分为唱歌队和跳舞队，每队的价值等于该队中该能力值最高的同学的能力值，请问两队价值差最小是多少呢？</p><p><strong>解题思路：</strong><br>这题其实不算太难，但是思路容易乱。首先由于每队的价值等于该队中最高的能力值，所以可以从高到低枚举每一位同学的x，并更新ans；对当前枚举到的x，我们在所有其他同学中找到最接近 x 的 y （即abs(x-y)最小），这个y必须是 <strong>比所有被枚举过的同学的y要大。</strong> 否则该同学就不是跳舞队中最大能力值（因为被枚举过的同学一定去跳舞了），该y就不能更新答案了。<br>当然细节在于如何找寻最接近x的y。</p><p><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">pair&lt;ll,ll&gt; a[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="built_in">multiset</span>&lt;ll&gt; s2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">s2.clear();</span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n); ll ans = <span class="number">1l</span>l&lt;&lt;<span class="number">60</span>, mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) s2.insert(a[i].y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line"><span class="comment">//先把当前同学的y删掉,防止选到同一位同学 </span></span><br><span class="line">s2.erase(s2.find(a[i].y)); </span><br><span class="line"><span class="comment">//要么比mx大的值更新ans,要么就mx更新ans </span></span><br><span class="line"><span class="keyword">if</span>(mx) ans = min(ans,<span class="built_in">abs</span>(mx-a[i].x));</span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;ll&gt;::iterator it = s2.lower_bound(a[i].x);</span><br><span class="line"><span class="keyword">if</span>(it == s2.end()) it--;</span><br><span class="line"><span class="keyword">if</span>(*it &gt;= mx) ans = min(ans,<span class="built_in">abs</span>(*it-a[i].x));</span><br><span class="line"><span class="keyword">if</span>(it != s2.begin()) it--;</span><br><span class="line"><span class="keyword">if</span>(*it &gt;= mx) ans = min(ans,<span class="built_in">abs</span>(*it-a[i].x));</span><br><span class="line">mx = max(mx,a[i].y);</span><br><span class="line"><span class="comment">//printf("%lld %lld %lld %lld %lld\n",mx,a[i].x,a[i].y,*it,ans);</span></span><br><span class="line"></span><br><span class="line">s2.insert(a[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1011-Make-Rounddog-Happy"><a href="#1011-Make-Rounddog-Happy" class="headerlink" title="1011 Make Rounddog Happy"></a>1011 Make Rounddog Happy</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6701" target="_blank" rel="noopener">测试地址</a></p><p><strong>题意简述：</strong><br>给出一个包含n个元素的序列a，其中 $1 &lt;= a_i &lt;= n$，友好子串的定义如下：</p><ul><li>[l , r]位置上的所有元素各不相同。</li><li>$Max(a_l, a_{l+1} , … , a_r) - (r - l + 1) &lt;= k$。</li></ul><p>给出一个序列，请问该序列中有多少友好子串。</p><p><strong>解题思路：</strong><br>这题是启发式分治，所谓启发式算法主要是指基于直观或经验而构造的算法，它不一定是最优的，但一定是可行的，并且时间要在可接受范围内。现阶段的启发式算法主要以仿自然算法（模拟）为主。<br>假设一个区间[l,r]内最大的元素下标为p，那么对于a[p]，在[l,r]内有多少个子区间包含p，且满足a[p] - k &lt;= r-l+1，这是子问题。我们可以将该问题分为[l , p]与[p , r]来看，我们对于这两个区间任选其一统计即可，于是我们可以选元素较少的那一个区间，这样元素最多不超过(r-l+1)/2。<br>假设左区间 [l  , p] 元素较少，我们在本次统计中（对[l , r]上以a[p]为最大值的子区间个数）对于每个位置 i （i 属于[l , p]）来计算以 i 为左端点，有多少个子区间满足要求；而满足要求的子区间个数等于tr-tl+1，因为[tl , tr]中任意一个位置都可以作为右端点，因为其满足a[p] - k &lt;= R-L（R为[tl ,tr]内一点，L为 i ）。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> a[N],st[N][<span class="number">25</span>],Log[N]; </span><br><span class="line"><span class="keyword">int</span> t,n,k;</span><br><span class="line"><span class="keyword">int</span> L[N],R[N];<span class="comment">//记录每个位置左右最远 不重复 且比其小的数的数量 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*初始化st表*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)) &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> t1 = st[i][j<span class="number">-1</span>],t2 = st[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>];</span><br><span class="line">st[i][j] = a[t1] &lt; a[t2]?t2:t1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回[l,r]内最大的数的下标*/</span> </span><br><span class="line"><span class="keyword">int</span> kk = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> t1 = st[l][kk], t2 = st[r-(<span class="number">1</span>&lt;&lt;kk)+<span class="number">1</span>][kk];</span><br><span class="line"><span class="keyword">return</span> a[t1] &lt; a[t2]?t2:t1;</span><br><span class="line">&#125; </span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*递归统计答案*/</span></span><br><span class="line"><span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> p = ask(l,r); <span class="keyword">int</span> tt = a[p]-k;</span><br><span class="line"><span class="keyword">if</span>(p-l &lt; r-p)&#123;<span class="comment">//左边点更少 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt;= p;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> tr = min(R[i],r), tl = max(p,i+tt<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(tl &gt; tr) <span class="keyword">continue</span>;</span><br><span class="line">ans += tr-tl+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = r;i &gt;= p;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> tl = max(l,L[i]), tr = min(i-tt+<span class="number">1</span>,p);</span><br><span class="line"><span class="keyword">if</span>(tl &gt; tr) <span class="keyword">continue</span>;</span><br><span class="line">ans += tr-tl+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cal(l,p<span class="number">-1</span>);</span><br><span class="line">cal(p+<span class="number">1</span>,r);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> vis[N];<span class="comment">//记录i最后一次出现的位置 </span></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回答案*/</span></span><br><span class="line">init(); ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="comment">/*以下代码用于更新L与R数组,通过简单的尺取法思想*/</span> </span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[a[i]]) pre = max(pre,vis[a[i]]+<span class="number">1</span>);</span><br><span class="line">L[i] = pre; vis[a[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line">pre = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) vis[i] = n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[a[i]] != n+<span class="number">1</span>) pre = min(vis[a[i]]<span class="number">-1</span>,pre);</span><br><span class="line">R[i] = pre; vis[a[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line">cal(<span class="number">1</span>,n);<span class="comment">//递归分治计算 </span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,solve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 启发式分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可持久化线段树（主席树）</title>
      <link href="/2019/08/28/dynamic-zx/"/>
      <url>/2019/08/28/dynamic-zx/</url>
      
        <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>主席树，又称可持久化线段树，属于可持久化数据结构。“主席”这一名词是由于发明者缩写为HJT，和某位主席拼音缩写相同（有些牵强），故将该数据结构称为主席树。<br>主席树既保留了线段树的灵活，也拥有了可持久化数据结构的特点，在处理某些特定问题时有着其它数据结构不具有的优势。<br>本文将首先介绍什么是“可持久化数据结构”，随后介绍主席树的思想，关于代码实现将结合例题讲解。</p><h4 id="可持久化数据结构"><a href="#可持久化数据结构" class="headerlink" title="可持久化数据结构"></a>可持久化数据结构</h4><p>可持久数据结构主要指的是我们可以查询历史版本的情况并支持插入，利用使用之前历史版本的数据结构来减少对空间的消耗（能够对历史进行修改的是函数式编程 [1]）。</p><p>我们经常会遇到这样的问题：我们需要维护一个数据结构，我们可以修改单一结点的值，查询单一结点的值，但是最关键的是我们可能还需要回退之前做过的某些操作。这里回退是指回到未做这些操作之前的状态。</p><p>在无回退操作的情况下，我们有大把的数据结构可供选择来解决这些问题。但是一旦涉及到回退操作，选择就少的多了。我们将支持回退操作的数据结构称为可持久化数据结构。</p><p>稍微思考一下如何可以在原来数据结构的基础上使其变得可持久化，有一个很简单的方案。我们每次操作都将重新建立一个新的数据结构，并将之前的操作都先在其上执行一次，之后执行该次操作。我们按操作执行顺序将这些数据结构维护成一个序列S，此时S[0]表示未经任何操作的初始数据结构。对于i&gt;0，S[i]表示在S[0]的基础上执行过序号1到i的所有操作后得到的新的数据结构。在这样的做法下，我们称S[i]为版本i，回退操作等价于切换到某个特定版本。若操作i表示切换为版本j，那么我们可以直接将S[i]设置为S[j]的克隆。</p><p>上面提到的做法下很容易发现可以使得任意数据结构都可以支持回退操作，但是缺点也是非常明显，空间和时间的复杂度都奇高。每一次操作都需要累加之前操作的时间复杂度，空间也是，我们为了保存各个版本需要耗费大量的内存。</p><p>先说明时间复杂度的优化，对于i号操作，我们完全可以直接克隆版本S[i-1]并在其上执行i号操作，这样时间复杂度基本上就向空间复杂度看齐了。下面我们就可以专注于空间复杂度的优化（对应的也就是时间复杂度的优化）。</p><p>数据结构是用于保存数据的，我们将其保存数据的单元称为结点，我们可以利用结点来刻画整个数据结构的骨架。数据结构基本分为两类，一类是稳定的，一类是不稳定的。稳定的数据结构，其特定是在修改的结点的值之后不会改变结点之间的关系，而不稳定的数据结构在结点值变更后需要重新维护结点之间的关联。稳定的数据结构有线段树，后缀数组，前缀树等等，不稳定的数据结构主要就是各种二叉平衡树。对于稳定的树状结构，若孩子没有保存指向父结点的指针，即由父亲负责记录所有的孩子，我们很容易发现，当我们对某个结点更改时（修改值，新增，删除等操作），我们只需要同时修改该结点的所有祖先结点即可，那我们是不是也可以只克隆这些结点而非整个数据结构呢？答案是肯定的。由于父亲维护孩子，因此一个孩子允许有多个父亲，故所有没有被直接影响的结点都可以继续复用。我们将部分树状数据结构（特定是稳定和父亲维护父子关系）的一次操作的空间复杂度优化到了O(h)，其中h是树状数据结构的高度。</p><p>当我们将上面的想法作用到线段树时，就得到了常说的主席树。其高度为$O(log_2(n))$，其中n为线段树维护的区间大小，同时其时间和空间复杂度均为$O(log_2(n)^2)$。</p><p><em>引用自：<a href="https://www.cnblogs.com/dalt/p/8324781.html" target="_blank" rel="noopener">陶无语的博客</a></em></p><h4 id="静态主席树"><a href="#静态主席树" class="headerlink" title="静态主席树"></a>静态主席树</h4><p>我们按照“是否支持修改”来将主席树划分为静态和动态。静态主席树一旦建树成功，就不再支持修改，只能够用于查询。静态主席树维护元素出现次数的前缀和。</p><blockquote><p>例题：洛谷P3834，查询区间第k大值<br>给定n个元素，共m个询问，每次询问给出[l ,r]和k，回答区间[l , r]内第k大元素值是多少。</p></blockquote><h5 id="建树："><a href="#建树：" class="headerlink" title="建树："></a>建树：</h5><p>考虑用主席树解决上述问题，给出如下建树步骤：</p><ol><li>新建一棵完整的空树，其根节点编号存放在root[0]内。</li><li>依次将n个元素插入到“版本0”的空树中，他们的“版本号”（根节点）存放在root[i]中。</li></ol><p>对于每一个“新版本”，我们都在原来基础上新增“需要修改的节点”，并将其根节点记录在root数组中。<br>如此我们的时空花费都与修改的路径成正比，即每次$O(log_2N)$。</p><p>当然这些都是从理论思想上来讲的，比较抽象；具体到这一题，我们令线段树维护区间内元素数量，每个节点有三个变量，分别是 ls , rs , sum，即左儿子编号，右儿子编号，区间内元素个数。<br>初始时sum都为0，随后将n个元素依次插入形成n棵新的线段树，而这n+1棵（包括编号为0的空树）构成了一棵静态主席树。<br>所以建树操作其实分为两步：BuildTree()建立一棵空树并返回根节点编号；updata()在原树基础上“增加一棵新树”，并返回该版本的根节点编号。</p><p>虽然不同历史版本的线段树节点之间有交叉以重复利用，但每个历史版本都有唯一且独立的根节点</p><h5 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h5><p>由于线段树维护的是区间内元素的数量，所以不同版本的线段树的对应节点是可以加减的，那么root[i] - root[j]意义就是“第 i 个版本的线段树比第 j 个版本的线段树多几个元素”。如果我们再加上区间范围限制[l , r]，那么我们也可以查询“第 i 个版本比第 j 个版本，在[l , r]上多几个元素”。</p><p>具体到本题，我们需要查询区间[l , r]内第k大的元素，已知线段树可以加减，那么对于询问(l , r , k)，我们就需要在root[l-1] 与 root[r]两棵线段树上找寻答案，不要忘记了这颗线段树是根据权值建立的，也就是所谓的权值线段树。那么在res个数中找第k个，显然二分（树上），参见代码。</p><h5 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h5><p>见附录部分code-1：洛谷P3834静态主席树模板-求区间第k大值</p><h4 id="动态主席树"><a href="#动态主席树" class="headerlink" title="动态主席树"></a>动态主席树</h4><p>静态主席树虽然支持历史查询，但其功能还是不太强大，因为其不支持更改。我们将支持修改的主席树称为动态主席树，但是这个功能添加起来并不容易。静态主席树还可以看作是线段树通过小修改得到，而动态主席树则是树套树。</p><p>思想依旧是维护元素出现次数的前缀和，可以类比差分数组，我们都知道前缀和数组是不支持修改的，如果要修改，就需要用 树状数组/线段树 来维护，这里也是类似。</p><p>我们考虑“外层用树状数组，内层用记录区间内数值出现次数的线段树”来实现支持修改的可持久化线段树，也即动态主席树。</p><p>在静态主席树上，可以通过两个权值线段树相减来求得区间第k大值，在这里我们仍旧是通过这种方法求区间第k大，不同的是我们需要保证所有线段树的数据是正确的（维护修改）。<br>如果我们用树状数组来维护不同版本的权值线段树的编号，那么对于“将位置 p 的 x 修改为 y”这一操作，我们需要修改共logN个版本的权值线段树，如此修改操作的时间复杂度是$O((log_2N)^2)$。<br>值得注意的是，此时空间复杂度 = 树状数组空间 * 权值线段树空间 = $N^2$，但是树状数组实际上只保存权值线段树的“版本号”而已，因此实际上用到的空间也就只有权值线段树上的$O(N(log_2N)^2)$个节点的空间，因此动态开点即可。</p><h5 id="例题2：洛谷P2617"><a href="#例题2：洛谷P2617" class="headerlink" title="例题2：洛谷P2617"></a>例题2：洛谷P2617</h5><p><strong>代码模板：</strong> 见附录部分code-2</p><h4 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h4><p>[1] 函数式编程：“函数式编程”是一种“编程范式”(programming paradigm)，也就是如何编写程序的方法论。它属于“结构化编程”的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。</p><p><em>引用自：<a href="https://www.cnblogs.com/aezero/p/4979890.html" target="_blank" rel="noopener">aezero的博客</a></em></p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p><strong>code-1：洛谷P3834静态主席树模板-求区间第k大值</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zxTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls,rs,sum;<span class="comment">//左右儿子,区间内元素个数</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(x) tr[x].ls</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(x) tr[x].rs</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[x].sum</span></span><br><span class="line">&#125; tr[N*<span class="number">40</span>];<span class="comment">//注意数组大小</span></span><br><span class="line"><span class="keyword">int</span> sz = <span class="number">0</span>;<span class="comment">//不同版本的树的总数 </span></span><br><span class="line"><span class="keyword">int</span> root[N];<span class="comment">//root[i]存放第i棵树的树根的编号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*建树,和普通线段树相同*/</span></span><br><span class="line">    <span class="keyword">int</span> rt = ++sz;sum(rt) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> rt;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ls(rt) = BuildTree(l,mid);</span><br><span class="line">    rs(rt) = BuildTree(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> pre,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*新建一棵树,其比pre树多一个元素x*/</span></span><br><span class="line">    <span class="keyword">int</span> rt = ++sz;</span><br><span class="line">    tr[rt] = tr[pre]; sum(rt)++;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> rt;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) ls(rt) = updata(ls(pre),l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> rs(rt) = updata(rs(pre),mid+<span class="number">1</span>,r,x);</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> pre,<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*  依次是:上一个树根,当前树根,区间左右端点,所求区间第k大</span></span><br><span class="line"><span class="comment">        返回该区间第k大数的下标 */</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> res = sum(ls(rt)) - sum(ls(pre));</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(res &gt;= k) <span class="keyword">return</span> ask(ls(pre),ls(rt),l,mid,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ask(rs(pre),rs(rt),mid+<span class="number">1</span>,r,k-res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i),tmp[i] = a[i];</span><br><span class="line">    <span class="comment">//离散化</span></span><br><span class="line">    sort(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">int</span> tot = unique(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+n)-tmp<span class="number">-1</span>;</span><br><span class="line">    root[<span class="number">0</span>] = BuildTree(<span class="number">1</span>,tot);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot,a[i])-tmp;</span><br><span class="line">        root[i] = updata(root[i<span class="number">-1</span>],<span class="number">1</span>,tot,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用主席树可以加减原理计算</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,l,r,k;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;k);</span><br><span class="line">        <span class="keyword">int</span> x = ask(root[l<span class="number">-1</span>],root[r],<span class="number">1</span>,tot,k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tmp[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>code2-洛谷P2617动态主席树</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="comment">/*线段树节点,要存放左右儿子编号,区间内元素个数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls,rs,sum;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(x) tr[x].ls</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(x) tr[x].rs</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[x].sum</span></span><br><span class="line">&#125;tr[N*<span class="number">400</span>];<span class="comment">//空间要N(logN)^2大小</span></span><br><span class="line"><span class="comment">/*因为要离散化,所以要提前读取所有操作*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,k;<span class="comment">//查询操作,询问区间[l,r]内第k大数的值</span></span><br><span class="line">    <span class="keyword">int</span> p,x;    <span class="comment">//修改操作,修改位置p位置上的元素为x</span></span><br><span class="line">&#125;qy[N];</span><br><span class="line"><span class="keyword">int</span> sz = N;<span class="comment">/*不同版本的线段树总数,</span></span><br><span class="line"><span class="comment">即动态申请节点编号,初始值要为N,因为前n个节点被使用*/</span></span><br><span class="line"><span class="keyword">int</span> a[N],n,m,tot = <span class="number">0</span>;<span class="comment">//tot离散化用</span></span><br><span class="line"><span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*对以rt为根的线段树,区间[l,r]内新增一个元素x*/</span></span><br><span class="line">    sum(rt) += d;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>; <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!ls(rt)) ls(rt) = ++sz;<span class="comment">//如果该子树没有子节点则新建</span></span><br><span class="line">    <span class="keyword">if</span>(!rs(rt)) rs(rt) = ++sz;<span class="comment">//动态申请节点</span></span><br><span class="line">    <span class="keyword">if</span>(p &lt;= mid) Insert(ls(rt),l,mid,p,d);</span><br><span class="line">    <span class="keyword">else</span> Insert(rs(rt),mid+<span class="number">1</span>,r,p,d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> p,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*向树状数组中的 线段树中 位置p值+d,要从l开始哦*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = l;x &lt;= n;x += x&amp;-x) Insert(x,<span class="number">1</span>,tot,p,y); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t1[N],t2[N],c1,c2;<span class="comment">//临时记录遍历路径</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*返回区间[l,r]内第k大元素的值(离散化后的)*/</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c1;i++) res -= sum(ls(t1[i]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c2;i++) res += sum(ls(t2[i]));</span><br><span class="line">    <span class="keyword">if</span>(res &gt;= k)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c1;i++) t1[i] = ls(t1[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c2;i++) t2[i] = ls(t2[i]);</span><br><span class="line">    <span class="keyword">return</span> ask(l,mid,k);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c1;i++) t1[i] = rs(t1[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c2;i++) t2[i] = rs(t2[i]);</span><br><span class="line"><span class="keyword">return</span> ask(mid+<span class="number">1</span>,r,k-res);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp[N*<span class="number">2</span>];<span class="comment">//离散化用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">c1 = c2 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*我们将树状数组上待查询的线段树的左儿子编号先存储*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l;i;i -= i&amp;-i) t1[++c1] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = r;i;i -= i&amp;-i) t2[++c2] = i;</span><br><span class="line"><span class="keyword">int</span> x = ask(<span class="number">1</span>,tot,k);<span class="comment">//注意查询区间是[1,tot] </span></span><br><span class="line"><span class="keyword">return</span> tmp[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i),tmp[++tot] = a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'C'</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;qy[i].p,&amp;qy[i].x);</span><br><span class="line">            tmp[++tot] = qy[i].x;<span class="comment">//先存储,方便离散化</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;qy[i].l,&amp;qy[i].r,&amp;qy[i].k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//离散化</span></span><br><span class="line">    sort(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot);</span><br><span class="line">    tot = unique(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot)-tmp<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p = lower_bound(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot,a[i])-tmp;</span><br><span class="line">        add(i,p,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(qy[i].l)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = qy[i].l, r = qy[i].r;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(l<span class="number">-1</span>,r,qy[i].k));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> p = lower_bound(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot,qy[i].x)-tmp;</span><br><span class="line">            <span class="keyword">int</span> pre = lower_bound(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+tot,a[qy[i].p])-tmp;</span><br><span class="line">            add(qy[i].p,pre,<span class="number">-1</span>); add(qy[i].p,p,<span class="number">1</span>); a[qy[i].p] = qy[i].x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权值线段树</title>
      <link href="/2019/08/27/qz-tree/"/>
      <url>/2019/08/27/qz-tree/</url>
      
        <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>权值线段树是在普通线段树的基础上进行更改，利用值域建树而非定义域（下标）；这使得线段树具有了一些新的功能，本文就将从权值线段树的来历，用途以及算法流程方面来介绍该数据结构。最终我们会用两个例题来体现权值线段树的用途，当然该代码也作为参考模板。</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>线段树是将下标不断二分，使得树上每个节点对应一段区间，从而将区间操作拆分成有关若干节点的操作。权值线段树与之类似，都是将一段区间不断二分，并令树上每个节点对应一段区间，以此实现“将区间操作变为对树上某条路径的操作”，只不过这里划分的区间不再是下标，而是权值。</p><p>至此其实权值线段树的特点已经很明显了，一般的线段树对下标建树，而权值线段树对权值建树；普通线段树对下标上的值进行操作（加减乘除），而权值线段树对值所对应的下标进行操作。</p><h4 id="权值线段树的用途"><a href="#权值线段树的用途" class="headerlink" title="权值线段树的用途"></a>权值线段树的用途</h4><p>这就好比一个是对 <strong>定义域</strong> 建树，而另一个是对 <strong>值域</strong> 建树，所以权值线段树具有如下用途：</p><ul><li>统计范围内元素的个数（这里的范围是指值域上的范围，例如：求逆序对）。</li><li>查询序列中，下标大于r的 第一个大于 k 的数。</li></ul><p>只是对线段树进行简单的更改，就使其拥有了这些功能（虽然这些功能其它数据结构也能实现），可见线段树的灵活性。</p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>第一步：通常元素的值域范围很大，但是个数很少，所以一般会先对这n个数离散化处理，处理之后就只有tot个不同的值([1 , tot])。</p><p>第二步：对区间[1, tot]建立线段树。</p><p>第三步：按照题意进行操作。</p><h4 id="例题1：求逆序对"><a href="#例题1：求逆序对" class="headerlink" title="例题1：求逆序对"></a>例题1：求逆序对</h4><p><a href="https://www.luogu.org/problem/P1908" target="_blank" rel="noopener">测试地址：洛谷P1908</a><br>虽然我们有更好的求逆序对的方法，例如归并、CDQ分治、树状数组等，但是这题其实也很好的体现权值线段树的思路，作为入门还是很好理解的。</p><p>首先我们将较为分散的n个元素按照权值离散化，离散化之后这n个元素取值范围（映射集合）就在[1,tot]之间，而若  i &gt; j，那么 i 代表的元素一定比 j 代表的元素大。</p><p>接下来从前向后遍历原数组的n个元素，找到其离散化后的标号i，再统计线段树中&gt;i的元素个数有多少个，累加到答案即可。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">权值线段树模板 最后修改:2019/8/25 </span></span><br><span class="line"><span class="comment">洛谷P1908:给出n个数求逆序对数量 </span></span><br><span class="line"><span class="comment">由于值域过于分散,且数字太大,采用离散化方法 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,sum;</span><br><span class="line"><span class="comment">/* 左端点,右端点,[l,r]内元素总数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[x].sum</span></span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ll val;<span class="keyword">int</span> id;</span><br><span class="line"><span class="comment">/*元素的值,序号,用于离散化*/</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; rhs)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &lt; rhs.val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;tmp[N]; </span><br><span class="line"><span class="keyword">int</span> n,tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*对[l,r]建立一棵子树,该子树根节点是rt*/</span></span><br><span class="line">l(rt) = l, r(rt) = r, sum(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid);</span><br><span class="line">BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">/*查询大于等于y的数的个数*/</span> </span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt)) <span class="keyword">return</span> sum(rt);</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(y &lt;= mid) <span class="keyword">return</span> ask(rt*<span class="number">2</span>,y)+sum(rt*<span class="number">2</span>+<span class="number">1</span>); <span class="comment">//加上整段右区间 </span></span><br><span class="line"><span class="keyword">return</span> ask(rt*<span class="number">2</span>+<span class="number">1</span>,y);<span class="comment">//答案在右子树 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">/*将p位置+1*/</span></span><br><span class="line"><span class="keyword">if</span>(l(rt) &lt;= p &amp;&amp; p &lt;= r(rt)) sum(rt)++;</span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt)) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= mid) updata(rt*<span class="number">2</span>,p);</span><br><span class="line"><span class="keyword">else</span> updata(rt*<span class="number">2</span>+<span class="number">1</span>,p);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//首先离散化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) tmp[i].val = a[i],tmp[i].id = i; </span><br><span class="line">sort(tmp+<span class="number">1</span>,tmp+<span class="number">1</span>+n); tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">1</span> || tmp[i].val != tmp[i<span class="number">-1</span>].val) ++tot;</span><br><span class="line">a[tmp[i].id] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//离散化之后值域[1,tot],以此为区间建树</span></span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,tot); </span><br><span class="line"><span class="comment">//下一步就是查询与更新了</span></span><br><span class="line">ll ans = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ans += ask(<span class="number">1</span>,a[i]+<span class="number">1</span>);<span class="comment">//在前i-1个数中,比a[i]大的有多少</span></span><br><span class="line">updata(<span class="number">1</span>,a[i]);<span class="comment">//值为a[i]的数+1 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="例题2：2019CCPC网络赛-B-array"><a href="#例题2：2019CCPC网络赛-B-array" class="headerlink" title="例题2：2019CCPC网络赛 B.array"></a>例题2：2019CCPC网络赛 B.array</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6703" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定1~n共n个数组成的序列，有m次操作，每次操作有两种可能：</p><ol><li>(1,pos)令 $a_{pos} = a_{pos}+1,000,000$。</li><li>(2, r , k) 回答不在$a_i(1&lt;= i &lt;= r)$内的，大于等于k的最小值。</li></ol><p>强制在线。<br><strong>解题思路：</strong><br>首先是理解题意，然后如果按照题目要求来解题，我们需要每次都通过遍历来排除[1,r]内的元素，显然会超时。由于题目中$a_i$是各不相同的，又是小于n的，因此我们可以将原问题转化为求“大于等于k的所有元素中，第一个下标大于r的元素的值”。对于这个问题我们每次需要询问所有值在[k,n+10]内，第一个下标大于r的即可。</p><p>于是我们可以通过建立权值线段树，线段树的下标是值$a_i$，值是下标i，对于每个操作1，就相当于把pos位置上的数删掉了。加上一些小剪枝就可以过。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="comment">/*区间[l,r]内元素个数为sum*/</span></span><br><span class="line"><span class="keyword">int</span> l,r,sum,mx;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mx(x) tr[x].mx</span></span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="comment">/*a数组存放序列,b数组离散化用</span></span><br><span class="line"><span class="comment">tot是离散化后不同元素个数 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ll a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> n,m,tot,t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*对[l,r]建立一棵根为rt的子树*/</span></span><br><span class="line">l(rt) = l, r(rt) = r , mx(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid);</span><br><span class="line">BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="comment">/*p位置值+1(值为p的元素的数量+1)*/</span></span><br><span class="line"><span class="comment">//printf("%d %d %d %d %d\n",rt,l(rt),r(rt),p,d);</span></span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">mx(rt) = d; <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= mid) Insert(rt*<span class="number">2</span>,p,d);</span><br><span class="line"><span class="keyword">else</span> Insert(rt*<span class="number">2</span>+<span class="number">1</span>,p,d); </span><br><span class="line">mx(rt) = max(mx(rt*<span class="number">2</span>),mx(rt*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> k,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">//printf("%d %d %d %d %d %d\n",rt,l(rt),r(rt),k,r,mx(rt));</span></span><br><span class="line"><span class="comment">/*返回[k,n]中第一个大于r的值*/</span></span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line"><span class="keyword">if</span>(mx(rt) &lt;= r) <span class="keyword">return</span> -INF;</span><br><span class="line"><span class="keyword">return</span> l(rt);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(k &lt;= mid &amp;&amp; mx(rt*<span class="number">2</span>) &gt; r) res = ask(rt*<span class="number">2</span>,k,r);</span><br><span class="line"><span class="keyword">if</span>(res &lt;= <span class="number">0</span>) <span class="keyword">return</span> ask(rt*<span class="number">2</span>+<span class="number">1</span>,k,r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,a+i);</span><br><span class="line">Insert(<span class="number">1</span>,a[i],i);<span class="comment">//a[i]下标为 i </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n+<span class="number">1</span>;i &lt;= n+<span class="number">10</span>;i++) Insert(<span class="number">1</span>,i,INF);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,op,pos,r,k;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op);</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;pos);</span><br><span class="line">pos ^= ans;</span><br><span class="line">Insert(<span class="number">1</span>,a[pos],INF);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;r,&amp;k);</span><br><span class="line">k ^= ans, r ^= ans;</span><br><span class="line">ans = ask(<span class="number">1</span>,k,r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019CCPC网络赛部分题解</title>
      <link href="/2019/08/25/2019ccpc/"/>
      <url>/2019/08/25/2019ccpc/</url>
      
        <content type="html"><![CDATA[<h4 id="1001-amp"><a href="#1001-amp" class="headerlink" title="1001 ^&amp;^"></a>1001 ^&amp;^</h4><p><strong>题意简述：</strong><br>给定正整数a和b，找到一个最小的正整数c，使得(a^c)&amp;(b^c)最小。<br><strong>解题思路：</strong><br>两个数按位与最小结果肯定是0啊，所以对于a和b，如果它们对应二进制位上有0，则c置为0即可，因为0^0 = 0 , 这就保证了异或之后肯定有一个是0，再&amp;之后还是0；若它们对应二进制位都是1，则只能置c的对应二进制位为1了，因为1^1 = 0。</p><p>值得注意的是，所求结果c是正整数，所以如果当c = 0时，则需要从低位向高位，将0-1或1-0位时，c对应二进制位 = 1。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">ll a,b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((a&amp;(<span class="number">1l</span>l&lt;&lt;i)) &amp;&amp; (b&amp;(<span class="number">1l</span>l&lt;&lt;i))) c = c|(<span class="number">1l</span>l&lt;&lt;i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((a&amp;(<span class="number">1l</span>l&lt;&lt;i)) != (b&amp;(<span class="number">1l</span>l&lt;&lt;i)))&#123;</span><br><span class="line">                c = c|(<span class="number">1l</span>l&lt;&lt;i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;a,&amp;b);</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1002-array"><a href="#1002-array" class="headerlink" title="1002 array"></a>1002 array</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6703" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定1~n共n个数组成的序列，有m次操作，每次操作有两种可能：</p><ol><li>(1,pos)令 $a_{pos} = a_{pos}+1,000,000$。</li><li>(2, r , k) 回答不在$a_i(1&lt;= i &lt;= r)$内的，大于等于k的最小值。</li></ol><p>强制在线。<br><strong>解题思路：</strong><br>首先是理解题意，然后如果按照题目要求来解题，我们需要每次都通过遍历来排除[1,r]内的元素，显然会超时。由于题目中$a_i$是各不相同的，又是小于n的，因此我们可以将原问题转化为求“大于等于k的所有元素中，第一个下标大于r的元素的值”。对于这个问题我们每次需要询问所有值在[k,n+10]内，第一个下标大于r的即可。</p><p>于是我们可以通过建立权值线段树，线段树的下标是值$a_i$，值是下标i，对于每个操作1，就相当于把pos位置上的数删掉了。加上一些小剪枝就可以过。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="comment">/*区间[l,r]内元素个数为sum*/</span></span><br><span class="line"><span class="keyword">int</span> l,r,sum,mx;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mx(x) tr[x].mx</span></span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="comment">/*a数组存放序列,b数组离散化用</span></span><br><span class="line"><span class="comment">tot是离散化后不同元素个数 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ll a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> n,m,tot,t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">/*对[l,r]建立一棵根为rt的子树*/</span></span><br><span class="line">l(rt) = l, r(rt) = r , mx(rt) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildTree(rt*<span class="number">2</span>,l,mid);</span><br><span class="line">BuildTree(rt*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> p,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="comment">/*p位置值+1(值为p的元素的数量+1)*/</span></span><br><span class="line"><span class="comment">//printf("%d %d %d %d %d\n",rt,l(rt),r(rt),p,d);</span></span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line">mx(rt) = d; <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= mid) Insert(rt*<span class="number">2</span>,p,d);</span><br><span class="line"><span class="keyword">else</span> Insert(rt*<span class="number">2</span>+<span class="number">1</span>,p,d); </span><br><span class="line">mx(rt) = max(mx(rt*<span class="number">2</span>),mx(rt*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> k,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">//printf("%d %d %d %d %d %d\n",rt,l(rt),r(rt),k,r,mx(rt));</span></span><br><span class="line"><span class="comment">/*返回[k,n]中第一个大于r的值*/</span></span><br><span class="line"><span class="keyword">if</span>(l(rt) == r(rt))&#123;</span><br><span class="line"><span class="keyword">if</span>(mx(rt) &lt;= r) <span class="keyword">return</span> -INF;</span><br><span class="line"><span class="keyword">return</span> l(rt);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> mid = l(rt)+r(rt)&gt;&gt;<span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(k &lt;= mid &amp;&amp; mx(rt*<span class="number">2</span>) &gt; r) res = ask(rt*<span class="number">2</span>,k,r);</span><br><span class="line"><span class="keyword">if</span>(res &lt;= <span class="number">0</span>) <span class="keyword">return</span> ask(rt*<span class="number">2</span>+<span class="number">1</span>,k,r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">BuildTree(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,a+i);</span><br><span class="line">Insert(<span class="number">1</span>,a[i],i);<span class="comment">//a[i]下标为 i </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n+<span class="number">1</span>;i &lt;= n+<span class="number">10</span>;i++) Insert(<span class="number">1</span>,i,INF);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,op,pos,r,k;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op);</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;pos);</span><br><span class="line">pos ^= ans;</span><br><span class="line">Insert(<span class="number">1</span>,a[pos],INF);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;r,&amp;k);</span><br><span class="line">k ^= ans, r ^= ans;</span><br><span class="line">ans = ask(<span class="number">1</span>,k,r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1004-Path"><a href="#1004-Path" class="headerlink" title="1004 Path"></a>1004 Path</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6705" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>一共有n个点m条边和q次询问，每次询问给出一个整数k，请问在图中的所有路径中第k短的路径长度是多少？</p><p><strong>解题思路：</strong><br>刚开始思路有些不对，其实这题并不是求最短路或者A *  或怎样，据说是常见套路。<br>首先前m短的边就是这m条边，我们可以利用优先队列维护 路径，而一条路径由“起点，终点，路径长度，上一个点的编号，该边在上一个点所有边中的排名”构成。</p><p>这样每次从最小堆中弹出一条路径，该路径就是剩下所有路径中最短的一条；而且该路径只有“从当前终点出发走下一条最短边”和“返回到上一个节点par，然后从par走次短边”这两种可能会对最终答案有贡献，所以将这两条路径再压入最小堆即可，如此反复操作直至求得所有最短路径。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x:边的起点,y:终点,par:上一个点的编号,</span></span><br><span class="line"><span class="comment">rk:在上一个点的所有出边中名次,d:路径长度 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> x,y,par,rk;</span><br><span class="line">ll d;</span><br><span class="line">Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y,ll d,<span class="keyword">int</span> par,<span class="keyword">int</span> rk):x(x),y(y),d(d),par(par),rk(rk)&#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; B)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> d &gt; B.d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">ll dis[N];</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"><span class="keyword">int</span> t,n,m,qq,k;</span><br><span class="line"><span class="keyword">int</span> a[N],ord[N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,ll&gt; pa;</span><br><span class="line"><span class="built_in">vector</span>&lt;pa&gt; G[N];<span class="comment">//存储点的所有出边,按权值升序 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">Node e = q.top();q.pop();</span><br><span class="line">dis[++cnt] = e.d;</span><br><span class="line"><span class="keyword">if</span>(cnt &gt; k) <span class="keyword">break</span>;<span class="comment">//统计出来前k个即可</span></span><br><span class="line"><span class="comment">/*只有两种情况可能更新答案*/</span> </span><br><span class="line"><span class="keyword">if</span>(G[e.par].size() &gt; e.rk+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> x = e.x,y = G[e.x][e.rk+<span class="number">1</span>].second , par = x, rk = e.rk+<span class="number">1</span>;</span><br><span class="line">ll z = e.d - G[e.x][e.rk].first+G[e.x][rk].first;</span><br><span class="line">q.push(Node(x,y,z,par,rk));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(G[e.y].size()) </span><br><span class="line">q.push(Node(e.y,G[e.y][<span class="number">0</span>].second,e.d+G[e.y][<span class="number">0</span>].first,e.y,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;qq); k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) G[i].clear(),ord[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">G[x].push_back(make_pair(z,y));</span><br><span class="line">q.push(Node(x,y,z,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) sort(G[i].begin(),G[i].end());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= qq;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i),k = k&gt;a[i]?k:a[i];</span><br><span class="line">solve();<span class="comment">//预处理 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= qq;i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dis[a[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1006-Shuffle-Card"><a href="#1006-Shuffle-Card" class="headerlink" title="1006 Shuffle Card"></a>1006 Shuffle Card</h4><p><strong>解题思路：</strong><br>队友一发过了，听说是个模拟题，ccfnb。<br><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,q,s;</span><br><span class="line"><span class="keyword">int</span> bk[Max];</span><br><span class="line"><span class="keyword">int</span> val[Max];</span><br><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; deq;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val[i]);</span><br><span class="line">        deq.push_back(val[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s);</span><br><span class="line">        deq.push_front(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!deq.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(!bk[deq.front()])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,deq.front());</span><br><span class="line">            bk[deq.front()] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        deq.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1007-Windows-Of-CCPC"><a href="#1007-Windows-Of-CCPC" class="headerlink" title="1007 Windows Of CCPC"></a>1007 Windows Of CCPC</h4><p><strong>题意简述：</strong><br>输出CCPC，当然是2 <em> 2矩阵输出，此为单元。如果n &gt; 1，那么就递归n - 1次，每次递归都把C替换成一个标准单元，把P替换为一个“反单元”（反单元即将标准单元中的C替换为P，P替换为C，即PPCP，也是2 </em> 2矩阵形式）作为新的矩阵。<br>给定n，输出结果。<br><strong>解题思路：</strong><br>就是简单的模拟，用数组，当然最好用putchar，否则可能会超时，还有就是n最大是10，可以输出到txt文件中肉眼观察一下是否正确再提交。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,k;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3400</span>;</span><br><span class="line"><span class="keyword">char</span> G[N][N];</span><br><span class="line"><span class="keyword">char</span> tmp[N][N]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    G[<span class="number">1</span>][<span class="number">1</span>] = G[<span class="number">1</span>][<span class="number">2</span>] = G[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">'C'</span>;</span><br><span class="line">    G[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">'P'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= (<span class="number">1</span>&lt;&lt;i);j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> z = <span class="number">1</span>;z &lt;= (<span class="number">1</span>&lt;&lt;i);z++)&#123;</span><br><span class="line">                <span class="keyword">int</span> r = <span class="number">2</span>*(j<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> c = <span class="number">2</span>*(z<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(G[j][z] == <span class="string">'C'</span>)&#123;</span><br><span class="line">                    tmp[r][c] = tmp[r][c+<span class="number">1</span>] = tmp[r+<span class="number">1</span>][c+<span class="number">1</span>] = <span class="string">'C'</span>;</span><br><span class="line">                    tmp[r+<span class="number">1</span>][c] = <span class="string">'P'</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tmp[r][c] = tmp[r][c+<span class="number">1</span>] = tmp[r+<span class="number">1</span>][c+<span class="number">1</span>] = <span class="string">'P'</span>;</span><br><span class="line">                    tmp[r+<span class="number">1</span>][c] = <span class="string">'C'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= (<span class="number">1</span>&lt;&lt;i);j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> z = <span class="number">1</span>;z &lt;= (<span class="number">1</span>&lt;&lt;i);z++)</span><br><span class="line">              G[j][z] = tmp[j][z];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1</span>&lt;&lt;k;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">1</span>&lt;&lt;k;j++) <span class="built_in">putchar</span>(G[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("out.txt","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1008-Fishing-Master"><a href="#1008-Fishing-Master" class="headerlink" title="1008 Fishing Master"></a>1008 Fishing Master</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6709" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>一共有n条鱼，钓任意一条鱼需要花费时间k，而煮熟一条鱼需要花费$t_i$ 时间，这n条鱼的顺序不固定，即我们每次可以钓我们想要的那条。在钓鱼的k时间内不能中断，即我们不能在钓鱼的时间内去煮或者拿出，当然一次只能煮一条鱼。请问煮熟这n条鱼最少花费多少时间？<br>tip：在钓上来一条鱼后，我们可以选择等锅里的鱼煮熟（如果需要的话），或者直接去钓鱼，回来再说，因为同一时刻我们手里可以有任意多条鱼，不局限于一条。极限情况就是我们先钓完n条鱼，再一条一条煮。</p><p><strong>解题思路：</strong><br>这题细节很多，题意很多地方稍不注意就会有歧义，所以做这种题之前一定要先了解清楚题意到底是什么规则以及要求什么。搞清楚了之后算法的设计就并不难想了，是贪心策略。<br>如果极限情况，我们花费的最多时间就是“先把n条鱼全部钓上来，再挨个煮”，花费的时间是$sum = n * k+\sum_{i = 1}^nt_i$，而我们能减少花费的时间，当且仅当我们在钓鱼的同时去煮鱼；而又由于钓鱼的时间段不能终止，所以就相当于我们有n-1段时间，每段时间大小为k，那么对于任意煮一条鱼的时间$t_i$：</p><ul><li>若$t_i$ 是 k 的倍数，$\frac{t_i}{k} = cnt$ 那么这cnt份时间完全被利用了，即sum -= cnt * k</li><li>若$t_i &gt; k$，那么说明我们可以先煮几段k，而剩下的部分再考虑是等待还是继续钓鱼，$\frac{t_i}{k} = cnt$，sum -= cnt <em> k , $t_i$ -= cnt </em> k</li><li>经过上面的操作之后，剩下的$t_i$就都是小于k的了，那么如果此时我们还剩res段时间，则挑最大的res个$t_i$来煮，这样就能最大化利用时间了，如果res = 0，则算法结束。</li></ul><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> tt,n;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll t[N],k,a[N];</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll ans = n*k;<span class="keyword">int</span> res = n<span class="number">-1</span>,tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i]%k == <span class="number">0</span> &amp;&amp; res) ans -= t[i],res -= t[i]/k;</span><br><span class="line">        <span class="keyword">else</span> a[++tot] = t[i]%k, cnt += t[i]/k;</span><br><span class="line">        ans += t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt;= res)&#123;</span><br><span class="line">        ans -= k*res;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    ans -= cnt*k;res -= cnt;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+tot);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = tot;i &gt;= <span class="number">1</span> &amp;&amp; res;i--)&#123;</span><br><span class="line">       <span class="comment">// printf("%lld %d %lld\n",b[i],res,ans);</span></span><br><span class="line">        ans -= a[i];res--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tt);</span><br><span class="line">    <span class="keyword">while</span>(tt--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>,&amp;n,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,t+i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,solve());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权值线段树 </tag>
            
            <tag> 贪心策略 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JZOJ4920降雷皇(最长上升子序列数量)</title>
      <link href="/2019/08/24/JZOJ4920/"/>
      <url>/2019/08/24/JZOJ4920/</url>
      
        <content type="html"><![CDATA[<p><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1742" target="_blank" rel="noopener">测试地址</a></p><h5 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h5><p>哈蒙有n条导线排成一排，每条导线有一个电阻值，神奇的电光只能从一根导线传到电阻比它大的上面，而且必须从左边向右传导，当然导线不必是连续的。</p><p>哈蒙想知道电光最多能通过多少条导线，还想知道这样的方案有多少。</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>第一问就是简单的LIS问题，即询问最长上升子序列的长度。第二问是询问最长上升子序列的数量，如果用暴力做法，只需要多开一个数组记录数量即可，时间复杂度O(N^2)；实际上我们可以利用BIT来代替枚举，使得时间复杂度至O(NlogN)。</p><p>我们用一个结构体Node{v,s}来表示当最长上升子序列长度为v时，方案数是s。那么对于每一个新元素x，我们只需要找出所有 <strong>电阻值小于x的</strong> 最长上升子序列的长度v以及数量s即可（符合BIT维护前缀和功能）。</p><p>当我们求出当前元素 x 的 v(最长上升子序列长度) 和 s(方案数) 后，用来更新ans，并将其插入树状数组第x个位置。由于题目保证x小于1e5，所以树状数组开到1e5即可。</p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*代码参考：信息学奥赛一本通P263*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll P = <span class="number">123456789</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ll v,s;</span><br><span class="line">Node()&#123;</span><br><span class="line">v = <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;tr[N],tmp,ans;</span><br><span class="line"><span class="keyword">int</span> n,ty;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> x,Node y)</span></span>&#123;</span><br><span class="line"><span class="comment">/*更改电阻值为x时的长度和方案数*/</span> </span><br><span class="line"><span class="keyword">while</span>(x &lt;= N)&#123;</span><br><span class="line"><span class="keyword">if</span>(y.v &gt; tr[x].v) tr[x] = y;<span class="comment">//如果长度变长,直接更新答案 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(y.v == tr[x].v) tr[x].s = (tr[x].s+y.s)%P;</span><br><span class="line">x += x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回当电阻 &lt;= x时,最长上升子序列的长度和方案数*/</span></span><br><span class="line">Node res;res.s = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[x].v &gt; res.v) res = tr[x];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tr[x].v == res.v) res.s = (res.s + tr[x].s)%P;</span><br><span class="line">x -= x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ckmax</span><span class="params">(Node &amp;x,<span class="keyword">const</span> Node&amp; y)</span></span>&#123;</span><br><span class="line"><span class="comment">/*更新最终答案,即最长上升子序列以及个数*/</span></span><br><span class="line"><span class="keyword">if</span>(x.v &lt; y.v) x = y;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x.v == y.v) x.s = (x.s+y.s)%P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;ty);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">tmp = ask(x<span class="number">-1</span>);<span class="comment">//因为这里保证x不超过1e5,所以不需要离散化 </span></span><br><span class="line">tmp.v++;</span><br><span class="line">ckmax(ans,tmp);<span class="comment">//更新答案 </span></span><br><span class="line">updata(x,tmp);<span class="comment">//更新树状数组 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans.v);</span><br><span class="line"><span class="keyword">if</span>(ty == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans.s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LIS </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rikka with Coin 解题报告</title>
      <link href="/2019/08/22/hdu6685/"/>
      <url>/2019/08/22/hdu6685/</url>
      
        <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6685" target="_blank" rel="noopener">测试地址</a><br>本题为2019航电icpc暑期多校训练第9场的第6题。</p><h5 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h5><p>有10分，20分，50分，100分的硬币若干（反正够用），商店有n件商品（n&lt;101），每件商品的价格给出；请问要想可以买下任意一件商品，最少带多少个硬币？</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>我一开始思路是背包，然后觉得w（商品的价值）太大了，可能用大背包，就放弃了。原来这题需要转化一下思维，并不是用背包而是简单的遍历。首先我们需要明白，就是如若我们买一件物品需要用2个10分的硬币，那么我们换成一个10分一个20分的肯定是可以的，而且反而能买的价格更多了（从10,20变为10,20,30），同理：</p><ul><li>如果有4个20分的，就可以用1个10分，2个20分，1个50分的硬币代替。因为原来可以表示20,40,60,80,现在可以表示10,20,30,40,50,60,70,80,90,100。</li><li>如果有2个50分的，同理，可以用1个50，1个100替代。</li></ul><p>于是我们知道了10分，20分，50分的硬币最多需要1个，3个，1个，所以三层循环遍历所有可能的情况，对于每种情况，判断是否可以表出所有物品（当然不足的用100分的硬币替代）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= a;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= b;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= c;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>((x-i*<span class="number">10</span>-j*<span class="number">20</span>-k*<span class="number">50</span>)%<span class="number">100</span> == <span class="number">0</span>) </span><br><span class="line">res = min((x-i*<span class="number">10</span>-j*<span class="number">20</span>-k*<span class="number">50</span>)/<span class="number">100</span>,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = check2(w[i],a,b,c);</span><br><span class="line"><span class="keyword">if</span>(tmp == INF) <span class="keyword">return</span> INF; </span><br><span class="line"><span class="keyword">else</span> res = max(res,tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf("%d %d %d %d\n",res,a,b,c);</span></span><br><span class="line"><span class="keyword">return</span> res+a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">if</span>(w[i]%<span class="number">10</span>)&#123;<span class="built_in">puts</span>(<span class="string">"-1"</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">3</span>;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= <span class="number">1</span>;k++)</span><br><span class="line">ans = min(ans,check(i,j,k));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,w+i);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018徐州icpc网络赛A、B题解</title>
      <link href="/2019/08/21/2018xuzhou-icpc/"/>
      <url>/2019/08/21/2018xuzhou-icpc/</url>
      
        <content type="html"><![CDATA[<h4 id="A-Hard-to-prepare"><a href="#A-Hard-to-prepare" class="headerlink" title="A. Hard to prepare"></a>A. Hard to prepare</h4><p><a href="https://nanti.jisuanke.com/t/A2000" target="_blank" rel="noopener">测试地址</a><br>抱怨一下，这题目真的是长，题意理解起来有点费劲，当然费劲的只是因为题面长而不是表述不清。<br><strong>题意简述：</strong><br>从$[1,2^k-1]$中选出n个数，将n个数围成一圈，要求相邻的两个数NXOR大于0，即异或后按位取反的值大于0。问共有多少种不同的方案。</p><p><strong>解题思路：</strong><br>通过简单证明，我们会发现只有1按位取反的值才是0，所以两个数 异或 != 1 就可以相邻；而与x异或 = 1 的数，有且仅有一个。</p><p>首先如果不是环形，而是一条直线，那么一共 $2 ^ k  *  (2 ^ k - 1) ^ {n-1}$​ 种不同的方案，这里设A = ​2^k​。环形和直线不同之处在于，直线首尾的值异或可能 = 1，即我们之前的答案多算了首尾异或=1的情况。那么我们接下来就需要设法减去这些值。</p><p>我们通过动态规划思想来计算这些多加上的值。假设当前位置为 i ，直线首元素是a，尾元素是b，且a^b = 1；设x是位置 i 元素 = a时的方案数，y是位置 i 元素 = b时的方案数，z是位置 i 不等于a和b时的方案数。</p><p>那么我们初始状态（第2个位置时）x = 1 , y = 0 , z = A - 2；目标是求第n-1 位时的 y + z（首位是a，末位是b时，中间2~n-1位的不同排列情况数）。<br>那么易得：<br>x = x + z;<br>y = y + z;<br>z = z<em>(A-3)+(x+y) </em> (A-2).<br>于是我们从第3位递推到第n-1位即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,k;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = res*a%P;</span><br><span class="line">        a = a*a%P;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll A = qpow(<span class="number">2</span>,k);</span><br><span class="line">    ll ans = A*qpow(A<span class="number">-1</span>,n<span class="number">-1</span>)%P;</span><br><span class="line">    ll x = <span class="number">1</span>,y = <span class="number">0</span>,z = A<span class="number">-2</span>;</span><br><span class="line">    <span class="comment">/*x:当前位置数和A相同方案数,</span></span><br><span class="line"><span class="comment">y:当前位置数和B相同方案数,</span></span><br><span class="line"><span class="comment">z:当前位置的数和AB都不同的方案数。 </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; n;i++)&#123;</span><br><span class="line">        ll t1 = x+z,t2 = y+z;</span><br><span class="line">        z = z*(A<span class="number">-3</span>)%P+(x+y)*(A<span class="number">-2</span>)%P;</span><br><span class="line">        z = z%P;</span><br><span class="line">        x = t1%P, y = t2%P;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//  printf("%lld %lld %lld\n",ans,y,z);</span></span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">2</span>) ans = (ans - A*(y+z)%P+P)%P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="B-BE-GE-or-NE"><a href="#B-BE-GE-or-NE" class="headerlink" title="B. BE,GE or NE"></a>B. BE,GE or NE</h4><p><a href="https://nanti.jisuanke.com/t/A2001" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>这是一个博弈论题。有两个人，小K和小S在玩游戏，该游戏一共有n次操作，俩人轮流进行。初始给定一个数值m，每次操作有三种选择：加上a；减去b；若c为1，则m = -1。每次三选一，其中小K想使得最终值&gt;= k，而小S想使得最终值&lt;= l，否则两人平局。给定这n次操作的a,b,c值，请问两人都采取最优策略，最终结果是谁胜出或是平局？</p><p><strong>解题思路：</strong><br>首先每个决策的选举会影响之后的决策，即不满足无后效，因此我们不能单纯的从后向前推（从动态规划角度）。而从博弈论来看，如果当前局面可以转移到必胜态，则当前选手必胜，换到这题，就是使得当前选手得分最大或最小。由于得分只有200种可能，于是可能的状态只有1000 * 200 = 200,000种，记忆化搜索即可。</p><p><strong>代码示例：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">250</span>];</span><br><span class="line"><span class="keyword">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="keyword">int</span> n,m,k,l;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; n) <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">if</span>(f[pos][sum+<span class="number">100</span>] != INF) <span class="keyword">return</span> f[pos][sum+<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">if</span>(pos&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = -INF;</span><br><span class="line">        <span class="keyword">if</span>(a[pos]) x = max(x,dfs(pos+<span class="number">1</span>,min(<span class="number">100</span>,sum+a[pos])));</span><br><span class="line">        <span class="keyword">if</span>(b[pos]) x = max(x,dfs(pos+<span class="number">1</span>,max(<span class="number">-100</span>,sum-b[pos])));</span><br><span class="line">        <span class="keyword">if</span>(c[pos]) x = max(x,dfs(pos+<span class="number">1</span>,-sum));</span><br><span class="line">        f[pos][sum+<span class="number">100</span>] = x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = INF;</span><br><span class="line">        <span class="keyword">if</span>(a[pos]) x = min(x,dfs(pos+<span class="number">1</span>,min(sum+a[pos],<span class="number">100</span>)));</span><br><span class="line">        <span class="keyword">if</span>(b[pos]) x = min(x,dfs(pos+<span class="number">1</span>,max(<span class="number">-100</span>,sum-b[pos])));</span><br><span class="line">        <span class="keyword">if</span>(c[pos]) x = min(x,dfs(pos+<span class="number">1</span>,-sum));</span><br><span class="line">        f[pos][sum+<span class="number">100</span>] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[pos][sum+<span class="number">100</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;k,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,a+i,b+i,c+i);</span><br><span class="line">    <span class="keyword">int</span> ans = dfs(<span class="number">1</span>,m);</span><br><span class="line">    <span class="keyword">if</span>(ans &gt;= k) <span class="built_in">puts</span>(<span class="string">"Good Ending"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ans &lt;= l) <span class="built_in">puts</span>(<span class="string">"Bad Ending"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Normal Ending"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博弈论 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 基础数据结构模板</title>
      <link href="/2019/08/20/chapter1/"/>
      <url>/2019/08/20/chapter1/</url>
      
        <content type="html"><![CDATA[<h2 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ol><li>并查集</li><li>求最近公共祖先LCA</li><li>平方分割法</li><li>莫队算法（一维，二维）</li><li>st表（一维，二维）</li><li>二叉堆（优先队列）</li><li>单调栈与笛卡尔树</li><li>CDQ分治</li></ol><h3 id="1-并查集"><a href="#1-并查集" class="headerlink" title="1 并查集"></a>1 并查集</h3><h4 id="1-1-并查集“拓展域”"><a href="#1-1-并查集“拓展域”" class="headerlink" title="1.1 并查集“拓展域”"></a>1.1 并查集“拓展域”</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关押罪犯</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> par[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;B) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt; B.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; nodes[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == par[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> par[x] = Find(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    par[Find(x)] = Find(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;nodes[i].a,&amp;nodes[i].b,&amp;nodes[i].c);</span><br><span class="line">        par[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(nodes+<span class="number">1</span>,nodes+<span class="number">1</span>+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = nodes[i].a,y = nodes[i].b,d = nodes[i].c;</span><br><span class="line">        <span class="keyword">int</span> x_en = x+n, y_en = y+n;</span><br><span class="line">        <span class="keyword">if</span>(Find(x) == Find(y))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Merge(x,y_en);Merge(x_en,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-并查集“边带权”"><a href="#1-2-并查集“边带权”" class="headerlink" title="1.2 并查集“边带权”"></a>1.2 并查集“边带权”</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POJ1773</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">21000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,ans;</span><br><span class="line">&#125; q[N];</span><br><span class="line"><span class="keyword">int</span> a[N],par[N],d[N],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    a数组用来离散化，par[x]代表x的父节点编号，d[x]代表</span></span><br><span class="line"><span class="comment">    从x到根节点路径和，cnt也是用于离散化。</span></span><br><span class="line"><span class="comment">    这里根节点即集合的代表节点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x] == x) <span class="keyword">return</span> x;   <span class="comment">//找到根节点，返回</span></span><br><span class="line">    <span class="keyword">int</span> root = Find(par[x]);    <span class="comment">//临时存根节点</span></span><br><span class="line">    d[x] ^= d[par[x]];          <span class="comment">//路径压缩，距离数组d也应该更新</span></span><br><span class="line">    <span class="keyword">return</span> par[x] = root;       <span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">char</span> rs[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;q[i].l,&amp;q[i].r,rs);</span><br><span class="line">        <span class="keyword">if</span>(rs[<span class="number">0</span>] == <span class="string">'o'</span>) q[i].ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> q[i].ans = <span class="number">0</span>;</span><br><span class="line">        a[cnt++] = q[i].l<span class="number">-1</span>;    <span class="comment">//这里需要存l-1，为了使l也包含在内</span></span><br><span class="line">        a[cnt++] = q[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下两行代码离散化用</span></span><br><span class="line">    sort(a,a+cnt);</span><br><span class="line">    <span class="keyword">int</span> len = unique(a,a+cnt)-a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) par[i] = i; <span class="comment">//初始化爸爸数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;      </span><br><span class="line">        <span class="comment">//左右边界在离散化数组中的编号：</span></span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(a,a+len,q[i].l<span class="number">-1</span>)-a;</span><br><span class="line">        <span class="keyword">int</span> y = lower_bound(a,a+len,q[i].r)-a;  </span><br><span class="line">        <span class="comment">//左右边界的祖先分别为ta和tb</span></span><br><span class="line">        <span class="keyword">int</span> ta = Find(x),tb = Find(y);</span><br><span class="line">        <span class="keyword">if</span>(ta == tb)&#123;   <span class="comment">//如果已经在同一个集合内，则判断是否矛盾</span></span><br><span class="line">            <span class="keyword">if</span>((d[x]^d[y]) != q[i].ans)&#123;<span class="comment">//矛盾的条件就是事实和结果不同</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            par[ta] = tb;d[ta] = d[x]^d[y]^q[i].ans;</span><br><span class="line">            <span class="comment">//这里d[ta]的值需要推导一下。</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            我们将x所在的集合和y所在的集合合并，那么就需要更新d数组</span></span><br><span class="line"><span class="comment">            这里d[x]存放的是x到par[x]的距离，所以合并两个集合对于</span></span><br><span class="line"><span class="comment">            非根节点来说并无影响，关键是对于两个根d[ta]和d[tb]如何处理</span></span><br><span class="line"><span class="comment">            如果我们将ta代表的集合归于tb下，那么就需要更新d[ta],而已知</span></span><br><span class="line"><span class="comment">            ans = d[x]^d[y]^d[ta]，即x到y的总路径等于x到ta XOR y到tb XOR </span></span><br><span class="line"><span class="comment">            ta到tb；对上式变形，得：d[ta] = ans^d[x]^d[y],而后三者是已知，</span></span><br><span class="line"><span class="comment">            故可以求出d[ta]。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-倍增法求-LCA"><a href="#2-倍增法求-LCA" class="headerlink" title="2 倍增法求 LCA"></a>2 倍增法求 LCA</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HDU2586求树上任意两个节点的路径的边权和  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2</span>*<span class="number">41000</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N],nex[N],edge[N],tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;x ^= y;y^=x;x^=y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y,edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x],head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    deep[x]表示x的深度,anc[x][i]为x向上走2^i步的祖先 </span></span><br><span class="line"><span class="comment">    dis[x]为节点到根节点的距离,即边权或点权和 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="keyword">int</span> deep[N],anc[N][<span class="number">25</span>],dis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.初始化anc数组，</span></span><br><span class="line"><span class="comment">        2.初始化deep数组</span></span><br><span class="line"><span class="comment">        3.初始化dis数组</span></span><br><span class="line"><span class="comment">        以上三个都可以通过dfs来实现</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++)</span><br><span class="line">        anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(dis[y] || y == <span class="number">1</span>) <span class="keyword">continue</span>;<span class="comment">//防止重复访问</span></span><br><span class="line">        deep[y] = deep[x]+<span class="number">1</span>;</span><br><span class="line">        dis[y] = dis[x] + z;</span><br><span class="line">        anc[y][<span class="number">0</span>] = x;</span><br><span class="line">        dfs(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 先把深度调到一致，再按照二进制拆分思想找寻最近公共祖先 */</span></span><br><span class="line">    <span class="keyword">if</span>(deep[u] &lt; deep[v]) swap(u,v);    <span class="comment">//u是较深的节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[anc[u][i]] &gt;= deep[v]) u = anc[u][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(anc[u][i] != anc[v][i])&#123;</span><br><span class="line">            u = anc[u][i];</span><br><span class="line">            v = anc[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> anc[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="comment">/*返回u到v的距离*/</span></span><br><span class="line">    <span class="keyword">return</span> dis[u] + dis[v] <span class="number">-2</span>*dis[Lca(u,v)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">        <span class="built_in">memset</span>(deep,<span class="number">0</span>,<span class="keyword">sizeof</span> deep);</span><br><span class="line">        <span class="built_in">memset</span>(anc,<span class="number">0</span>,<span class="keyword">sizeof</span> anc);</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head);<span class="comment">//head也要初始化</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            addEdge(x,y,z);</span><br><span class="line">            addEdge(y,x,z);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x,y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-平方分割法"><a href="#3-平方分割法" class="headerlink" title="3 平方分割法"></a>3 平方分割法</h3><p><strong>问题模型：</strong></p><blockquote><p>给定一个数列$a_1,a_2,…,a_n$，目标是在O（&radic;n）复杂度内实现以下两个功能：</p><ul><li>给定s，t，求$a_s,a_{s+1},…a_t$的最小值</li><li>给定i，x，把$a_i$的值变为x。</li></ul></blockquote><p><strong>基于平方分割的RMQ的复杂度：</strong><br>在更新值时，由于每个桶内有b个元素，所以复杂度是O(b) = O(&radic;n)<br>而查询为：O(n/b+b) = O(&radic;n+&radic;n) = O(&radic;n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> mi[N/B];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">a[pos] = y;</span><br><span class="line">mi[pos/B] = min(mi[pos/B],y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = INF;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r &amp;&amp; l%B) ans = min(ans,a[l++]);</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r &amp;&amp; r%B) ans = min(ans,a[--r]);</span><br><span class="line"><span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line"><span class="keyword">int</span> b = l/B;</span><br><span class="line">ans = min(ans,mi[b]);</span><br><span class="line">l += B;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N/B;i++) mi[i] = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">mi[i/B] = min(mi[i/B],a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="keyword">int</span> op,x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;op,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>) updata(x,y);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; query(x,y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-莫队算法"><a href="#4-莫队算法" class="headerlink" title="4 莫队算法"></a>4 莫队算法</h3><p><strong>SPOJ D-query：</strong> 给定一个数组，每次询问一个区间内有多少个不同的元素。</p><p><strong>复杂度分析：</strong> 莫队算法是离线算法，可以解决一类离线的区间问题，对于序列上的区间询问问题，如果从 [l,r] 的答案能够 O(1) 扩展到 [l−1,r],[l+1,r],[l,r+1],[l,r−1] 的答案，那么可以在 $O(n\sqrt n)$ 的复杂度内求出所有询问的答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">31000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Q = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],m;</span><br><span class="line"><span class="keyword">int</span> ans,sum[<span class="number">1010000</span>];<span class="comment">//一个全局答案ans和标记数组sum是必要的 </span></span><br><span class="line"><span class="comment">//当然也可以离散化 </span></span><br><span class="line"><span class="keyword">int</span> len;<span class="comment">//块大小，在读入询问前需要先赋值 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,block,id;</span><br><span class="line">Query()&#123;&#125;</span><br><span class="line">Query(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> id):l(l),r(r),id(id)&#123;</span><br><span class="line">block = l/len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Query &amp;B) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(block == B.block) <span class="keyword">return</span> block&amp;<span class="number">1</span>? r &lt; B.r : r &gt; B.r;</span><br><span class="line"><span class="comment">//小优化，使得r呈波浪形 </span></span><br><span class="line"><span class="keyword">return</span> block &lt; B.block;</span><br><span class="line">&#125;</span><br><span class="line">&#125;query[Q];</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//增加或减少一个x位置上的数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">x = a[x]; </span><br><span class="line">sum[x] += v;</span><br><span class="line"><span class="keyword">if</span>(v &gt; <span class="number">0</span>) ans += sum[x] == <span class="number">1</span>;<span class="comment">//判等是为了防止重复计数 </span></span><br><span class="line"><span class="keyword">else</span> ans -= sum[x] == <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">len = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">query[i] = Query(x,y,i);</span><br><span class="line">&#125;</span><br><span class="line">sort(query+<span class="number">1</span>,query+<span class="number">1</span>+m);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>,r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l &lt; query[i].l) Move(l,<span class="number">-1</span>),l++;</span><br><span class="line"><span class="keyword">while</span>(l &gt; query[i].l) Move(l<span class="number">-1</span>,<span class="number">1</span>),l--;</span><br><span class="line"><span class="keyword">while</span>(r &gt; query[i].r) Move(r,<span class="number">-1</span>),r--;</span><br><span class="line"><span class="keyword">while</span>(r &lt; query[i].r) Move(r+<span class="number">1</span>,<span class="number">1</span>),r++;</span><br><span class="line">q.push(make_pair(-query[i].id,ans));<span class="comment">//大根堆变为小根堆 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.top().second;q.pop();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-st表"><a href="#5-st表" class="headerlink" title="5 st表"></a>5 st表</h3><h4 id="5-1一维st表"><a href="#5-1一维st表" class="headerlink" title="5.1一维st表"></a>5.1一维st表</h4><p><strong>问题模型：</strong></p><p>给定一个长度为n的序列，有m次询问，每次给定区间[L , R]，求区间内最大值。</p><p>我们设 <code>st[i][j]</code> 为从 i 开始的 $2^j$ 个数中的最大值。假设这n个数存放的序列a中，根据定义 <code>st[i][j]</code> = max{a[k] | $i &lt;= k &lt;= i+2^j - 1$}。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],st[N][<span class="number">25</span>],Log[N];<span class="comment">//2^20就过一百万了，完全够用 </span></span><br><span class="line"><span class="comment">//初始化st表 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">Log[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//预处理log函数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;<span class="comment">//涉及到位运算多加括号! </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)) &lt;= n;i++)&#123;</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> mx = max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"><span class="comment">//printf("%d %d\n",k,mx);</span></span><br><span class="line"><span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,l,r;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(l,r));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-二维st表"><a href="#5-2-二维st表" class="headerlink" title="5.2 二维st表"></a>5.2 二维st表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">令t1 = st[a][b][c];</span><br><span class="line">令t2 = st[a][b+c-(1&lt;&lt;k)+1][c];</span><br><span class="line">令t3 = st[a+c-(1&lt;&lt;k)+1][b][c];</span><br><span class="line">令t4 = st[a+c-(1&lt;&lt;k)+1][b+c-(1&lt;&lt;k)+1][c];</span><br><span class="line">ans = max&#123;t1 , t2 , t3 , t4&#125;；</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N],n,m,len,Log[N];</span><br><span class="line"><span class="keyword">int</span> st[<span class="number">3</span>][N][N][<span class="number">15</span>];<span class="comment">//0最小，1最大值 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mx = a;<span class="keyword">if</span>(mx &lt; b) mx = b;<span class="keyword">if</span>(mx &lt; c) mx = c;<span class="keyword">if</span>(mx &lt; d) mx = d;</span><br><span class="line"><span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mi = a;<span class="keyword">if</span>(mi &gt; b) mi = b;<span class="keyword">if</span>(mi &gt; c) mi = c;<span class="keyword">if</span>(mi &gt; d) mi = d;</span><br><span class="line"><span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++) </span><br><span class="line">st[<span class="number">0</span>][i][j][<span class="number">0</span>] = st[<span class="number">1</span>][i][j][<span class="number">0</span>] = a[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= <span class="number">12</span>;k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span> &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j + (<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span> &lt;= m;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> t1 = st[<span class="number">0</span>][i][j][k<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> t2 = st[<span class="number">0</span>][i+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][j][k<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> t3 = st[<span class="number">0</span>][i][j+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][k<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> t4 = st[<span class="number">0</span>][i+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][j+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][k<span class="number">-1</span>];</span><br><span class="line">st[<span class="number">0</span>][i][j][k] = min(t1,t2,t3,t4);</span><br><span class="line">t1 = st[<span class="number">1</span>][i][j][k<span class="number">-1</span>];</span><br><span class="line">t2 = st[<span class="number">1</span>][i+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][j][k<span class="number">-1</span>];</span><br><span class="line">t3 = st[<span class="number">1</span>][i][j+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][k<span class="number">-1</span>];</span><br><span class="line">t4 = st[<span class="number">1</span>][i+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][j+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][k<span class="number">-1</span>];</span><br><span class="line">st[<span class="number">1</span>][i][j][k] = max(t1,t2,t3,t4);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[len];</span><br><span class="line"><span class="keyword">int</span> t1 = st[<span class="number">0</span>][r][c][k];</span><br><span class="line"><span class="keyword">int</span> t2 = st[<span class="number">0</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c][k];</span><br><span class="line"><span class="keyword">int</span> t3 = st[<span class="number">0</span>][r][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line"><span class="keyword">int</span> t4 = st[<span class="number">0</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line"><span class="keyword">int</span> mi = min(t1,t2,t3,t4);</span><br><span class="line">t1 = st[<span class="number">1</span>][r][c][k];</span><br><span class="line">t2 = st[<span class="number">1</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c][k];</span><br><span class="line">t3 = st[<span class="number">1</span>][r][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line">t4 = st[<span class="number">1</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line"><span class="keyword">int</span> mx = max(t1,t2,t3,t4);</span><br><span class="line"><span class="comment">//printf("%d %d\n",mx,mi);</span></span><br><span class="line"><span class="keyword">return</span> mx - mi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n-len+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m-len+<span class="number">1</span>;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = ask(i,j,len);</span><br><span class="line">ans = ans &lt; tmp?ans:tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-二叉堆"><a href="#6-二叉堆" class="headerlink" title="6 二叉堆"></a>6 二叉堆</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左儿子：2*rt+1, 右儿子: 2*rt+2,时间复杂度O(N)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> heap[N];</span><br><span class="line"><span class="keyword">int</span> sz = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//i是自己节点的编号 </span></span><br><span class="line"><span class="keyword">int</span> i = sz++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//p是父亲节点的编号</span></span><br><span class="line"><span class="keyword">int</span> p = (i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(heap[p] &lt;= x) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">heap[i] = heap[p];</span><br><span class="line">i = p; </span><br><span class="line">&#125;</span><br><span class="line">heap[i] = x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = heap[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//要提到根的数值x</span></span><br><span class="line"><span class="keyword">int</span> x = heap[--sz];</span><br><span class="line"><span class="comment">//从根开始向下交换 </span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i*<span class="number">2</span> + <span class="number">1</span> &lt; sz)&#123;</span><br><span class="line"><span class="comment">//左右儿子 </span></span><br><span class="line"><span class="keyword">int</span> a = i*<span class="number">2</span>+<span class="number">1</span>,b = i*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(b &lt; sz &amp;&amp; heap[b] &lt; heap[a]) a = b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(heap[a]  &gt;= x) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">heap[i] = heap[a];</span><br><span class="line">i = a;</span><br><span class="line">&#125;</span><br><span class="line">heap[i] = x;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-单调栈与笛卡尔树"><a href="#7-单调栈与笛卡尔树" class="headerlink" title="7 单调栈与笛卡尔树"></a>7 单调栈与笛卡尔树</h3><p>笛卡尔树（Cartesian Tree）是一种同时满足堆性质和二叉搜索树性质的一棵二叉树。因此笛卡尔树的树根对应着该树的极值（堆性质），并且对其中序遍历得到的是原序列一段连续的区间（二叉搜索树性质）。<br>我们假设利用一个整数序列A：a1~an 建立笛卡尔树，那么树上每个节点有2个键值，idx（下标）和 val（值）。我们使树上每个节点的idx满足二叉搜索树性质，而val满足堆性质，于是笛卡尔树就建成了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],tot = <span class="number">0</span>,n;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function">ll <span class="title">max</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b?b:a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> idx,val;<span class="comment">//下标、权值 </span></span><br><span class="line"><span class="keyword">int</span> l,r,par;<span class="comment">//左儿子、右儿子、父亲节点的编号 </span></span><br><span class="line">Node()&#123;&#125;</span><br><span class="line">Node(<span class="keyword">int</span> idx,<span class="keyword">int</span> val)</span><br><span class="line">:idx(idx),val(val)&#123;</span><br><span class="line">l = r = par = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BuildTree</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> k = i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(t[k].val &gt; t[i].val) k = t[k].par;</span><br><span class="line">t[i].l = t[k].r;<span class="comment">//k的右子树作为i的左子树 </span></span><br><span class="line">t[k].r = i;<span class="comment">//i作为k的右子树 </span></span><br><span class="line">t[i].par = k;<span class="comment">//i的父亲是k </span></span><br><span class="line">t[t[i].l].par = i;<span class="comment">//i的左子树的父亲是i </span></span><br><span class="line"><span class="comment">//printf("%d %d\n",i,k);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t[<span class="number">0</span>].r;<span class="comment">//最终树的根节点的编号 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="comment">//printf("%d\n",rt);</span></span><br><span class="line"><span class="keyword">if</span>(rt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">ll sz = <span class="number">1</span>;</span><br><span class="line">sz += dfs(t[rt].l);</span><br><span class="line">sz += dfs(t[rt].r);</span><br><span class="line">ans = max(ans,sz*(t[rt].val));</span><br><span class="line"><span class="keyword">return</span> sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)</span><br><span class="line">t[i] = Node(i,a[i]);</span><br><span class="line">tot = ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> rt = BuildTree();</span><br><span class="line">dfs(rt);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-CDQ分治"><a href="#8-CDQ分治" class="headerlink" title="8 CDQ分治"></a>8 CDQ分治</h3><h4 id="8-2-二维CDQ分治"><a href="#8-2-二维CDQ分治" class="headerlink" title="8.2 二维CDQ分治"></a>8.2 二维CDQ分治</h4><blockquote><p>给定一个N个元素的序列A，初始值全部为0，对这个序列进行以下两种操作：<br>　　操作1：格式为1 x k，把位置x的元素加上k（位置从1标号到N）。<br>　　操作2：格式为2 x y，求出区间[x,y]内所有元素的和。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Q = N*<span class="number">3</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> type,pos;</span><br><span class="line">    ll val;</span><br><span class="line">    Node(<span class="keyword">int</span> type,<span class="keyword">int</span> pos,ll val):type(type),pos(pos),val(val)&#123;&#125;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == b.pos) <span class="keyword">return</span> type &lt; b.type;</span><br><span class="line">        <span class="keyword">return</span> pos &lt; b.pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> aidx = <span class="number">0</span>,qidx = <span class="number">0</span>;</span><br><span class="line">Node query[Q];</span><br><span class="line">Node tmp[Q];</span><br><span class="line">ll ans[Q];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r<span class="number">-1</span>) <span class="keyword">return</span>;<span class="comment">//左闭右开嘛</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    CDQ(l,mid);</span><br><span class="line">    CDQ(mid,r);</span><br><span class="line">    <span class="keyword">int</span> p = l,q = mid,k = <span class="number">0</span>;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; mid &amp;&amp; q &lt; r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(query[p] &lt; query[q])&#123;</span><br><span class="line">            <span class="keyword">if</span>(query[p].type == <span class="number">1</span>)</span><br><span class="line">                sum += query[p].val;</span><br><span class="line">            tmp[k++] = query[p++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> x = query[q].val;</span><br><span class="line">            <span class="keyword">if</span>(query[q].type == <span class="number">2</span>)</span><br><span class="line">                ans[x] -= sum;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(query[q].type == <span class="number">3</span>)</span><br><span class="line">                ans[x] += sum;</span><br><span class="line">            tmp[k++] = query[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; mid) tmp[k++] = query[p++];<span class="comment">//这里不用再累加修改的值，因为用不到了啊 </span></span><br><span class="line">    <span class="keyword">while</span>(q &lt; r)&#123;</span><br><span class="line">    <span class="comment">//这里还需将我们累加的结果进行运算，我们规定就是要累加左区间，查询右区间嘛 </span></span><br><span class="line">        <span class="keyword">int</span> x = query[q].val;</span><br><span class="line">        <span class="keyword">if</span>(query[q].type == <span class="number">2</span>)</span><br><span class="line">            ans[x] -= sum;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(query[q].type == <span class="number">3</span>)</span><br><span class="line">            ans[x] += sum;</span><br><span class="line">        tmp[k++] = query[q++];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++)</span><br><span class="line">        query[i+l] = tmp[i]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        query[qidx++] = Node(<span class="number">1</span>,i,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span>)&#123;</span><br><span class="line">            query[qidx++] = Node(a,b,c);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            query[qidx++] = Node(<span class="number">2</span>,b<span class="number">-1</span>,aidx);</span><br><span class="line">            query[qidx++] = Node(<span class="number">3</span>,c,aidx);</span><br><span class="line">            aidx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CDQ(<span class="number">0</span>,qidx);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; aidx;i++) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-三维CDQ分治"><a href="#8-2-三维CDQ分治" class="headerlink" title="8.2 三维CDQ分治"></a>8.2 三维CDQ分治</h4><p>&emsp;&emsp;在二维偏序问题拓展中，我们利用二维有序当作索引，来查找想要的结果。类似的，我们可不可以用三维有序对来当下标，找寻想要的答案集合T呢？<br><strong>例题：</strong> </p><blockquote><p>&emsp;&emsp;平面上有N个点，每个点的横纵坐标在[0,1e7]之间，有M个询问，每个询问为查询在指定矩形之内有多少个点，矩形用(x1,y1,x2,y2)的方式给出，其中(x1,y1)为左下角坐标，(x2,y2)为右上角坐标。</p></blockquote><p><strong>解题思路：</strong><br>&emsp;&emsp;我们同样将查询区间内点数量分成四个求前缀和操作（这里需要用容斥原理）。将平面上点看成插入操作，查询矩形内点个数看成查询操作。那么对于每个操作，有<time , x y>三个维度作为索引（或者下标），又因为time是默认有序的，所以我们需要根据x归并，同时用树状数组维护y的前缀和。我们按照CDQ分治的思想，统计左边区间节点对右边区间查询的贡献。（这里所说的左右区间概念引自归并排序）详细思想请对照代码。<br><strong>代码示例：</strong> </time></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BZOJ1935</span></span><br><span class="line"><span class="comment">单点修改，区间查询</span></span><br><span class="line"><span class="comment">CDQ+树状数组 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">50</span>;<span class="comment">//最大节点数量 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> op,x,y,val;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">op = 1是修改值操作，2是减去前缀和操作，3是加上前缀和操作</span></span><br><span class="line"><span class="comment">x、y代表坐标</span></span><br><span class="line"><span class="comment">val有两重用法， 当是修改值操作时，val代表要修改的值； </span></span><br><span class="line"><span class="comment">当表示求前缀和操作时，val代表答案数组ans的下标（因为最终结果要累加） </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node &amp;B) <span class="keyword">const</span>&#123; </span><br><span class="line"><span class="comment">//x为第一关键字，y为第二关键字，op为第三关键字，升序排序 </span></span><br><span class="line"><span class="keyword">if</span>(x == B.x)&#123;</span><br><span class="line"><span class="keyword">if</span>(y == B.y) <span class="keyword">return</span> op &lt; B.op;</span><br><span class="line"> <span class="keyword">return</span> y &lt; B.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x &lt; B.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数，无参的用来创建数组，有参的用来快速赋值 </span></span><br><span class="line">Node()&#123;&#125;</span><br><span class="line">Node(<span class="keyword">int</span> op,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> val):op(op),x(x),y(y),val(val)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node Q[<span class="number">7</span>*N];<span class="comment">//为啥是7倍，因为每个查询操作被分成四个子操作了嘛 </span></span><br><span class="line">Node tmp[<span class="number">7</span>*N];</span><br><span class="line"><span class="keyword">int</span> ans[N],st[<span class="number">10100000</span>];<span class="comment">//树状数组没开离散化，当然如果范围再大点就要开了 </span></span><br><span class="line"><span class="keyword">int</span> qidx = <span class="number">0</span>,aidx = <span class="number">2</span>;<span class="comment">//分别代表查询集合Q和答案集合ans的下标 </span></span><br><span class="line"><span class="comment">//以下俩个函数是树状数组的函数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;x &lt; N;x += x&amp;-x) st[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x) sum += st[x];</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CDQ分治的用法 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(r-l &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">solve(l,mid);</span><br><span class="line">solve(mid,r);</span><br><span class="line"><span class="keyword">int</span> p = l,q = mid,k = l;</span><br><span class="line"><span class="keyword">while</span>(p &lt; mid &amp;&amp; q &lt; r)&#123;</span><br><span class="line"><span class="keyword">if</span>(Q[p] &lt; Q[q])&#123;</span><br><span class="line"><span class="keyword">if</span>(Q[p].op == <span class="number">1</span>) add(Q[p].y,Q[p].val);</span><br><span class="line">tmp[k++] = Q[p++];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q[q].op == <span class="number">2</span>)  ans[Q[q].val] -= ask(Q[q].y);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Q[q].op == <span class="number">3</span>)ans[Q[q].val] += ask(Q[q].y);</span><br><span class="line">tmp[k++] = Q[q++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(q &lt; r)&#123;</span><br><span class="line"><span class="keyword">if</span>(Q[q].op == <span class="number">2</span>)  ans[Q[q].val] -= ask(Q[q].y);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Q[q].op == <span class="number">3</span>) ans[Q[q].val] += ask(Q[q].y);</span><br><span class="line">tmp[k++] = Q[q++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们用这种方法来清空树状数组，可以节省时间 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt; p;i++)</span><br><span class="line"><span class="keyword">if</span>(Q[i].op == <span class="number">1</span>) add(Q[i].y,-Q[i].val);</span><br><span class="line"><span class="keyword">while</span>(p &lt; mid) tmp[k++] = Q[p++];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt; r;i++) Q[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">Q[qidx++] = Node(<span class="number">1</span>,x+<span class="number">1</span>,y+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">Q[qidx++] = Node(<span class="number">3</span>,x1,y1,aidx);</span><br><span class="line">Q[qidx++] = Node(<span class="number">2</span>,x1,y2+<span class="number">1</span>,aidx);</span><br><span class="line">Q[qidx++] = Node(<span class="number">2</span>,x2+<span class="number">1</span>,y1,aidx);</span><br><span class="line">Q[qidx++] = Node(<span class="number">3</span>,x2+<span class="number">1</span>,y2+<span class="number">1</span>,aidx++);</span><br><span class="line">&#125;</span><br><span class="line">solve(<span class="number">0</span>,qidx);<span class="comment">//依旧左闭右开 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; aidx;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ValenShi的ACM模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu6681 Rikka with Cake</title>
      <link href="/2019/08/19/hdu6681/"/>
      <url>/2019/08/19/hdu6681/</url>
      
        <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6681" target="_blank" rel="noopener">测试地址</a></p><h5 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h5><p>直接看样例其实就明白了，看图说话，就是给出一个左下角坐标为(0,0)，右上角为(n,m)的矩形；然后有k条线段，这些线段不重叠，都是从矩形内某一点出发到矩形某一边为止，这些线段共四种，都与坐标轴平行。<br><img src="/2019/08/19/hdu6681/1.png" alt="1"><br>请问这些线段将矩形分为了几个不连通的面？（图一是3个，图二是5个）</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>首先考虑到任意两条直线的x，y坐标都是不同的，所以不会出现重叠现象。观察得，肯定是相交的线段才能分割出新的面（一条横的线与几条竖线相交就会增加几个面）。<br>所以我们只需考虑，假设先将所有与y轴平行的线加入，然后对于每一条与x轴平行的线，有几条与其相交，最终答案就是这些交点个数再+1。</p><p>现在的问题就是对于每个与x轴平行的线，有多少与y轴平行的线与其相交。如果挨个计算并累加，计算完所有线段需要O(N^2)时间。其实我们会发现，找与(x , y)至左边界（L）的横线相交的线段，只需要找出 x’ &lt;= x &amp;&amp; y’ &lt;= y的向上方(U) 的线段以及 x’ &lt;= x &amp;&amp; y’ &gt;= y的向下 (D) 的线段的数量即可。这是二维偏序问题，是4个二维偏序问题。而二维偏序问题可以在$O(Nlog_2^N)$时间内用CDQ分治解决，写起来也不是很麻烦（还好不是三维）。</p><p>PS：呜呜呜正解是欧拉定理呜呜呜呜呜</p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,t;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">    Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y):x(x),y(y)&#123;t = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; B)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; B.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node U[N],D[N],R[N],L[N],tmp[N];</span><br><span class="line">Node TU[N];</span><br><span class="line"><span class="keyword">int</span> cu,cd,cr,cl,cnt;</span><br><span class="line"><span class="keyword">int</span> n,m,t,k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq1</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    cdq1(l,mid); cdq1(mid,r);</span><br><span class="line">    <span class="keyword">int</span> p = l,q = mid,tk = <span class="number">0</span>,tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; mid &amp;&amp; q &lt; r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(TU[p].y &lt;= TU[q].y)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!TU[p].t) tt++;</span><br><span class="line">            tmp[tk++] = TU[p++];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(TU[q].t) cnt += tt;</span><br><span class="line">            tmp[tk++] = TU[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; mid) tmp[tk++] = TU[p++];</span><br><span class="line">    <span class="keyword">while</span>(q &lt; r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(TU[q].t) cnt += tt;</span><br><span class="line">        tmp[tk++] = TU[q++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tk;i++) TU[i+l] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(Node a,Node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    对于L[i],有多少U中x &lt; L[i].x &amp;&amp; y &lt; L[i].y,</span></span><br><span class="line"><span class="comment">            有多少D中x &lt; L[i].x &amp;&amp; y &gt; L[i].y;</span></span><br><span class="line"><span class="comment">    对于R[i]有多少U中x &gt; R[i].x &amp;&amp; y &lt; R[i].y,</span></span><br><span class="line"><span class="comment">            有多少D中x &gt; R[i].x &amp;&amp; y &gt; R[i].y;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cu;i++) TU[i] = U[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cl;i++) TU[i+cu] = L[i],TU[i+cu].t = <span class="number">1</span>;</span><br><span class="line">    stable_sort(TU,TU+cu+cl);</span><br><span class="line">    cdq1(<span class="number">0</span>,cl+cu);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cd;i++) TU[i] = D[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cl;i++) TU[i+cd] = L[i],TU[i+cd].t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cl+cd;i++) TU[i].y *= <span class="number">-1</span>;</span><br><span class="line">    stable_sort(TU,TU+cd+cl);</span><br><span class="line">    cdq1(<span class="number">0</span>,cl+cd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cu;i++) TU[i] = U[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cr;i++) TU[i+cu] = R[i],TU[i+cu].t = <span class="number">1</span>;</span><br><span class="line">    stable_sort(TU,TU+cr+cu,cmp2);</span><br><span class="line">    <span class="comment">//for(int i = 0;i &lt; cr+cu;i++) printf("%d %d\n",TU[i].x,TU[i].y);</span></span><br><span class="line">    cdq1(<span class="number">0</span>,cr+cu);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cd;i++) TU[i] = D[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cr;i++) TU[i+cd] = R[i],TU[i+cd].t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cd+cr;i++) TU[i].y *= <span class="number">-1</span>;</span><br><span class="line">    stable_sort(TU,TU+cr+cd,cmp2);</span><br><span class="line">    cdq1(<span class="number">0</span>,cr+cd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        cu = cd = cr = cl = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;<span class="keyword">char</span> dir[<span class="number">5</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;x,&amp;y,dir);</span><br><span class="line">            <span class="keyword">if</span>(dir[<span class="number">0</span>] == <span class="string">'U'</span>) U[cu++] = Node(x,y);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dir[<span class="number">0</span>] == <span class="string">'D'</span>) D[cd++] = Node(x,y);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dir[<span class="number">0</span>] == <span class="string">'L'</span>) L[cl++] = Node(x,y);</span><br><span class="line">            <span class="keyword">else</span> R[cr++] = Node(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CDQ分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bzoj1093最大半连通子图</title>
      <link href="/2019/08/18/bzoj1093/"/>
      <url>/2019/08/18/bzoj1093/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.mfstem.org/contest/17/problem/B" target="_blank" rel="noopener">测试地址</a></p><h5 id="问题简述"><a href="#问题简述" class="headerlink" title="问题简述"></a>问题简述</h5><p>给出一个有向图，求其最大半连通子图的节点个数，以及不同的最大半连通子图的数目。<br>（子图、半连通图、最大半连通子图等定义请参照原题）</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>本题是《信息学奥赛一本通·提高篇》中，强连通分量章节的一道例题。本题思路其实很清晰也很明确，就是求最大半连通子图的节点数，以及有多少个这样的子图。可以得知，如果一个子图是强连通的，那么他一定是半连通的，所以对于所有的强连通分量，我们都缩为一个点，这样就得到了一个有向无环图（DAG）。<br>我们对得到的DAG进行建图得到G’，每个节点的“权值”就等于该强连通分量的顶点数；于是原问题就成了在 G’ 上找到权值最大的<strong>链</strong>（因为我们可以保证对于链上任意两点u和v，都单向或双向可达）。<br>找到了“最长链”之后，下一步是找<strong>不同的最长链的个数</strong> ，这一步用到类似DP的思想，即设f[i]为到节点 i 时，达到局部最长链时不同方案数，我们只需要在进行<strong>拓扑排序求最长链</strong> 的同时<strong>递推更新f[]</strong> 即可。</p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><p>虽然写代码时的思路很清晰，但是代码还是写的很乱，可读性很差；因为涉及变量太多、太乱，所以每个变量或数组的作用是什么并不是一目了然，但我也懒得写注释了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y;nex[tot] = head[x];head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head2[N],ver2[M],nex2[M],tot2 = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    ver2[++tot2] = y; nex2[tot2] = head2[x];head2[x] = tot2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Stack[N],top;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],num,co[N],col;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++num;</span><br><span class="line">Stack[++top] = u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> v = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">Tarjan(v);</span><br><span class="line">low[u] = min(low[u],low[v]);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!co[v]) low[u] = min(low[u],dfn[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[u] == dfn[u])&#123;</span><br><span class="line">co[u] = ++col;</span><br><span class="line"><span class="keyword">while</span>(Stack[top] != u)&#123;</span><br><span class="line">co[Stack[top]] = col;</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,P;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; e[M];</span><br><span class="line"><span class="keyword">int</span> du[N],dis[N],si[N];<span class="comment">//si[col]记录强连通分量col节点个数</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> mxnum,mxcol;</span><br><span class="line"><span class="keyword">int</span> f[N];<span class="comment">//到i距离为最长的方案数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(si,<span class="number">0</span>,<span class="keyword">sizeof</span> si);</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) si[co[i]]++,f[co[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++) <span class="keyword">if</span>(!du[i]) q.push(i),dis[i] = si[i];</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head2[x];i ;i = nex2[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> y = ver2[i];du[y]--;</span><br><span class="line">            <span class="keyword">if</span>(!du[y]) q.push(y);</span><br><span class="line">            <span class="keyword">if</span>(dis[y] &lt; dis[x]+si[y])&#123;</span><br><span class="line">                dis[y] = dis[x] + si[y];</span><br><span class="line">                f[y] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(dis[mxcol] &lt; dis[y]) mxcol = y;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dis[y] == dis[x]+si[y])</span><br><span class="line">                f[y] = (f[y]+f[x])%P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++)</span><br><span class="line">        <span class="keyword">if</span>(dis[i] == dis[mxcol]) mxnum = (mxnum+f[i])%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    num = col = top = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="keyword">sizeof</span> dfn);</span><br><span class="line">    <span class="built_in">memset</span>(co,<span class="number">0</span>,<span class="keyword">sizeof</span> co);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = head[i];j ;j = nex[j])&#123;</span><br><span class="line">            <span class="keyword">int</span> y = ver[j];</span><br><span class="line">            e[++cnt] = make_pair(co[i],co[y]);</span><br><span class="line">            <span class="comment">//printf("%d %d %d %d\n",co[i],co[y],i,y);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf("cnt %d\n",cnt);</span></span><br><span class="line">    sort(e+<span class="number">1</span>,e+<span class="number">1</span>+cnt);tot2 = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(du,<span class="number">0</span>,<span class="keyword">sizeof</span> du);</span><br><span class="line">    <span class="built_in">memset</span>(head2,<span class="number">0</span>,<span class="keyword">sizeof</span> head2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i].first != e[i].second &amp;&amp;</span><br><span class="line">         (e[i].first != e[i<span class="number">-1</span>].first || e[i].second != e[i<span class="number">-1</span>].second))</span><br><span class="line">            addEdge2(e[i].first,e[i].second), du[e[i].second]++;</span><br><span class="line">        <span class="comment">//printf("%d %d\n",e[i].first,e[i].second);</span></span><br><span class="line">    &#125;</span><br><span class="line">    topo();<span class="comment">//拓扑排序找出最长链</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>,dis[mxcol],mxnum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;P);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,a,b;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        addEdge(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强连通分量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大整数开方根模板</title>
      <link href="/2019/08/18/bigsqrt/"/>
      <url>/2019/08/18/bigsqrt/</url>
      
        <content type="html"><![CDATA[<p><strong>例1：</strong> 试判断n是否为完全平方数(Perfect square)，$n &lt;=10^{200}$。</p><p>本来想写一篇关于牛顿迭代法+高精度运算的C++版本的模板，但是涉及到高精度加减乘除，动辄300行代码以上，还是在网上找个JAVA的大整数开方根的模板凑合用吧。</p><p>用JAVA书写代码，需要注意的是时间和空间，内存超限很常见。</p><h4 id="大数开平方根模板"><a href="#大数开平方根模板" class="headerlink" title="大数开平方根模板"></a>大数开平方根模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static BigInteger sqrt(String x) &#123;</span><br><span class="line">        int mlen = x.length();    //被开方数的长度</span><br><span class="line">        int len;    //开方后的长度</span><br><span class="line">        BigInteger beSqrtNum = new BigInteger(x);//被开方数</span><br><span class="line">        BigInteger sqrtOfNum;    //存储开方后的数</span><br><span class="line">        BigInteger sqrtOfNumMul;    //开方数的平方</span><br><span class="line">        String sString;//存储sArray转化后的字符串</span><br><span class="line">        if(mlen%2 == 0)    len = mlen/2;</span><br><span class="line">        else    len = mlen/2+1;</span><br><span class="line">        char[] sArray = new char[len];</span><br><span class="line">        Arrays.fill(sArray, &apos;0&apos;);//开方数初始化为0</span><br><span class="line">        for(int pos=0; pos&lt;len; pos++)&#123;</span><br><span class="line">         //从最高开始遍历数组，每一位都转化为开方数平方后刚好不大于被开方数的程度</span><br><span class="line">            for(char num=&apos;1&apos;; num&lt;=&apos;9&apos;; num++)&#123;</span><br><span class="line">                sArray[pos] = num;</span><br><span class="line">                sString = String.valueOf(sArray);</span><br><span class="line">                sqrtOfNum = new BigInteger(sString);</span><br><span class="line">                sqrtOfNumMul = sqrtOfNum.multiply(sqrtOfNum);</span><br><span class="line">                if(sqrtOfNumMul.compareTo(beSqrtNum) == 1)&#123;</span><br><span class="line">                    sArray[pos]-=1;</span><br><span class="line">                    break;    </span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new BigInteger(String.valueOf(sArray));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断n是否为Perfect-square"><a href="#判断n是否为Perfect-square" class="headerlink" title="判断n是否为Perfect square"></a>判断n是否为Perfect square</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> T = cin.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cas = <span class="number">1</span>; cas &lt;= T; ++cas) &#123;</span><br><span class="line">            String str = cin.next();</span><br><span class="line">            BigInteger n = <span class="keyword">new</span> BigInteger(str);</span><br><span class="line">            BigInteger m = n.multiply(n.subtract(BigInteger.ONE)).shiftRight(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//System.out.println(n);</span></span><br><span class="line">            <span class="comment">//System.out.println(m);</span></span><br><span class="line">            <span class="keyword">boolean</span> nIsSquare = isSquare(n);</span><br><span class="line">            <span class="keyword">boolean</span> mIsSquare = isSquare(m);</span><br><span class="line">            <span class="keyword">if</span> (nIsSquare &amp;&amp; mIsSquare) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Arena of Valor"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nIsSquare &amp;&amp; !mIsSquare) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Hearth Stone"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!nIsSquare &amp;&amp; mIsSquare) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Clash Royale"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"League of Legends"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSquare</span><span class="params">(BigInteger n)</span> </span>&#123;</span><br><span class="line">        BigInteger low = BigInteger.ZERO;</span><br><span class="line">        BigInteger high = n;</span><br><span class="line">        <span class="keyword">while</span> (low.compareTo(high) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            BigInteger mid = low.add(high).shiftRight(<span class="number">1</span>);</span><br><span class="line">            BigInteger square = mid.multiply(mid);</span><br><span class="line">            <span class="keyword">int</span> result = square.compareTo(n);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                high = mid.subtract(BigInteger.ONE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid.add(BigInteger.ONE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>Molex的<a href="https://www.cnblogs.com/yzm10/p/9651696.html" target="_blank" rel="noopener">博客</a></li><li>2019焦作网络赛 J 题<a href="https://nanti.jisuanke.com/t/A2020" target="_blank" rel="noopener">Participate in E-sports</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国剩余定理（拓展）</title>
      <link href="/2019/08/18/realchina/"/>
      <url>/2019/08/18/realchina/</url>
      
        <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>在《孙子算经》中有这样一个问题：“今有物不知其数，三三数之剩二（除以3余2），五五数之剩三（除以5余3），七七数之剩二（除以7余2），问物几何？”这个问题称为“孙子问题”，该问题的一般解法国际上称为“中国剩余定理”。</p><p>中国剩余定理是数论四大定理之一，其重要性不容置疑，本文主要介绍中国剩余定理问题的经典模型，然后再对更一般的情况进行拓展，得到拓展中国剩余定理，当然最重要的是给出模板并附上模板使用说明书。</p><h4 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h4><p>若$m_1,m_2,…,m_n$是两两互质的正整数，M = $\prod_{i = 1}^{n} m_i$, $M_i = M/m_i$，$t_i$是线性同余方程$M_it_i \equiv1(mod\: m_i)$的一个解。对于任意的n个整数$a_1,a_2,…,a_n$，则同余方程组</p><p><img src="/2019/08/18/realchina/1.png" alt="1"></p><p>有整数解，方程组的解为$x = a_1M_1t_1 + a_2M_2t_2 + … + a_nM_nt_n$。并且在模M意义下有唯一解。</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>因为$M_i = M/m_i$是除$m_i$之外所有模数的倍数，所以$\forall k \neq i, a_iM_it_i \equiv 0(mod\:m_k)$。又因为$a_iM_it_i \equiv a_i(mod\: m_i)$，所以带入$x = \sum_{i = 1}^n a_iM_it_i$，原方程组成立。<br>证毕。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>中国剩余定理给出了模数两两互质的线性同余方程组的一个特殊解。方程组的通解可以表示为$x + kM(k \in Z)$。有些题目要求我们求出最小的非负整数解，只需把 x 对M取模，并让 x 落在0~M-1的范围内即可。</p><p>另外，即使模数不满足两两互质，我们也有办法判断线性同余方程组是否有解，并求出方程组的解。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 代码出自:洛谷用户sumijie 2019/8/18</span></span><br><span class="line"><span class="comment"> * 使用说明:</span></span><br><span class="line"><span class="comment"> *    1.ll为自定义类型,视题目数据而定,并不一定是__int128</span></span><br><span class="line"><span class="comment"> *    2.N为方程组中方程个数,视数据而定</span></span><br><span class="line"><span class="comment"> * 输入：</span></span><br><span class="line"><span class="comment"> *    输入第一行包含整数 n.</span></span><br><span class="line"><span class="comment"> *    接下来 n 行,每行两个非负整数 ai,bi</span></span><br><span class="line"><span class="comment"> * 输出:</span></span><br><span class="line"><span class="comment"> *    输出一行,为满足条件的最小非负整数x.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> __int128 ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;g,ll &amp;x,ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        g = a; x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b,a%b,g,y,x);</span><br><span class="line">    y-=(a/b)*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">ll a1,a2,n1,n2;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">abs</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;<span class="number">0</span>?x:-x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">china</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll d = a2 - a1;</span><br><span class="line">    ll g,x,y;</span><br><span class="line">    exgcd(n1,n2,g,x,y);</span><br><span class="line">    <span class="keyword">if</span> (d % g == <span class="number">0</span>) &#123;</span><br><span class="line">        x = ((x*d/g)%(n2/g)+(n2/g))%(n2/g);</span><br><span class="line">        a1 = x*n1 + a1;</span><br><span class="line">        n1 = (n1*n2)/g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;          <span class="comment">//方程个数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> as[N];<span class="comment">//余数</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ns[N];<span class="comment">//模数</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">realchina</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*返回线性同余方程组的最小非负整数解*/</span></span><br><span class="line">    a1 = as[<span class="number">0</span>];</span><br><span class="line">    n1 = ns[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        a2 = as[i];</span><br><span class="line">        n2 = ns[i];</span><br><span class="line">        china();</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;ns[i]&gt;&gt;as[i];<span class="comment">//输入模数和余数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">long</span> <span class="keyword">long</span>)realchina()&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>董永建，信息学竞赛一本通提高篇，福州：福建教育出版社，2018.6，401-403</li><li>洛谷网用户sumijie的<a href="https://www.luogu.org/blog/sumijie/solution-p4777" target="_blank" rel="noopener">博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵快速幂模板</title>
      <link href="/2019/08/17/Matrix/"/>
      <url>/2019/08/17/Matrix/</url>
      
        <content type="html"><![CDATA[<p>矩阵快速幂常用于动态规划中的“矩阵加速链乘”里，可以将线性的递归式优化为$O(log_2N)$，是一种很常用的技巧。由于矩阵快速幂不像普通的整数快速幂一样方便记忆，因此整理模板以便需要时参考。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************</span></span><br><span class="line"><span class="comment"> 最后修改：2019/8/17 ValenShi</span></span><br><span class="line"><span class="comment"> 使用说明：</span></span><br><span class="line"><span class="comment">    1.注意矩阵是在Mod P下相乘</span></span><br><span class="line"><span class="comment">    2.矩阵为nn*nn的方阵,使用前需对nn赋值</span></span><br><span class="line"><span class="comment">    3.矩阵有效行列下标是1~nn</span></span><br><span class="line"><span class="comment">    4.注意memset头文件以及 long long</span></span><br><span class="line"><span class="comment"> *********************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> nn; <span class="comment">//nn 为矩阵大小 nn*nn</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mat</span>&#123;</span></span><br><span class="line">    ll v[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line">    Mat()&#123;<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span> v);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">Mul</span><span class="params">(<span class="keyword">const</span> Mat&amp; a,<span class="keyword">const</span> Mat&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 返回矩阵a*矩阵b的结果 */</span></span><br><span class="line">    Mat c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= nn;i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= nn;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= nn;k++)</span><br><span class="line">          c.v[i][j] = (c.v[i][j]+a.v[i][k]*b.v[k][j]%P)%P;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">qpow</span><span class="params">(Mat A,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 返回矩阵A^b后的结果(矩阵) */</span></span><br><span class="line">    Mat c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= nn;i++) c.v[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) c = Mul(c,A);</span><br><span class="line">        A = Mul(A,A);</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伸展树笔记</title>
      <link href="/2019/08/16/splay/"/>
      <url>/2019/08/16/splay/</url>
      
        <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><strong>前置知识：</strong></p><ul><li>树-&gt;二叉搜索树-&gt;平衡树-&gt;AVL树-&gt;Treap-&gt;伸展树</li><li>左单(双)旋、右单(双)旋、左右双旋</li></ul><p><strong>伸展树(Splay Tree)</strong> 是平衡二叉查找树的一种，具有二叉查找树的所有性质；伸展树又称Self-Adjusting Search Trees，即<strong>自调整的二叉搜索树</strong> 。与普通的二叉查找树相比，其维护更少的节点额外信息，空间性能更优且编程复杂度更低。它由Daniel Sleator 和 Robert Tarjan创造。在伸展树上的一般操作都基于<strong>伸展操作</strong>。</p><h4 id="需要伸展树的原因："><a href="#需要伸展树的原因：" class="headerlink" title="需要伸展树的原因："></a>需要伸展树的原因：</h4><p>各种查找树都有各自的优缺点以及适用范围。例如，对于一棵具有n个节点的平衡树，虽然其查找的时间复杂度不超过O(log n)，但是如果访问模式不均匀（询问点不随机），平衡树的效率就会受影响，此时我们需要额外的空间记录平衡信息，同时也加大了编程复杂度。<br>这些查找树的设计目标都是减少最坏情况下单次操作时间，但是如果我们的目标是使一系列查找操作的总时间最少，那我们更好的目标就是降低操作的摊平时间。此处的摊平时间指的是在一系列最坏情况下的操作序列中单次操作的平均时间。而伸展树就是为实现这一目标而设计的。</p><h4 id="和其他平衡树或具有明确限制的数据结构相比，伸展树的优点："><a href="#和其他平衡树或具有明确限制的数据结构相比，伸展树的优点：" class="headerlink" title="和其他平衡树或具有明确限制的数据结构相比，伸展树的优点："></a>和其他平衡树或具有明确限制的数据结构相比，伸展树的优点：</h4><ul><li>从摊平角度讲，它们忽略常量因子，因此绝对不会比有明确限制的数据结构差。而且它们可以依据适用情况进行调整，于是在<strong>使用模式不均匀</strong>的情况下更加有效。</li><li>由于无需存储限制信息，它们所需空间更小，实现起来也更加简洁。</li><li>它们的查找和更新算法概念简单，易于实现。</li></ul><h4 id="潜在的两个缺点："><a href="#潜在的两个缺点：" class="headerlink" title="潜在的两个缺点："></a>潜在的两个缺点：</h4><ul><li>它们需要更多的局部调整，尤其是在查找期间。（而其他有明确限制的查找树仅需要在更新期间进行调整，查找期间则不用）</li><li>一系列查找操作中的某一个可能会耗时较长。这在实际应用中需要作为是否选用的参考依据。</li></ul><h4 id="什么是伸展树："><a href="#什么是伸展树：" class="headerlink" title="什么是伸展树："></a>什么是伸展树：</h4><p>假设要对一个二叉搜索树执行一系列查找操作，为了使得总时间最小，那么被查找频率高的节点自然就要放在靠近根的位置。于是想到一个简单的设计方案，<strong>在每次查找之后对树进行重构，把被查找的条目搬到离树根近一点的位置。</strong> 顺着这个思路，splay诞生了。<br>splay是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列旋转把该节点搬移到树根，同时使得该条路径上的点尽量靠近树根。</p><h4 id="构建方法"><a href="#构建方法" class="headerlink" title="构建方法"></a>构建方法</h4><p><strong>两种可能的重构方法：</strong></p><ul><li>单旋：在查找完位于节点x中的条目之后，旋转链接x和其父节点的边。（除非x是根）</li><li>搬移至树根：在查找完位于节点x中的条目后，旋转链接x和其父节点的边，然后重复这个操作直至x成为树根。</li></ul><p><strong>注：</strong><br>上述两个方法是不一样的，一种是查找x后仅交换一次，另一个是将被查询的节点x旋转至树根。<br><strong>旋转示意图：</strong><br>其中三角形代表子树，而图示的树也可能是一棵更大的树的子树。<br><img src="/2019/08/16/splay/1.png" alt="1"></p><p><strong>上述两种重构方法的示意图：</strong><br>其中被查询节点是a。<br><img src="/2019/08/16/splay/2.png" alt="2"></p><p><strong>注：</strong></p><ul><li>若x为p(x)的左孩子，交换x和p(x)的位置，称为右旋。</li><li>若x为p(x)的右孩子，交换x和p(x)的位置，称为左旋。</li></ul><p><strong>不幸的是，上述两个重构方法在摊分效率方面表现的都不太好。</strong> 如果有很长的随机查询序列，那么上述两种重构方法的查询时间复杂度是O(N)。显然我们需要一种性能更强大的重构方法。</p><h4 id="伸展操作"><a href="#伸展操作" class="headerlink" title="伸展操作"></a>伸展操作</h4><p>我们采取的重构方法叫做splaying，即伸展，它和上述“搬移至树根”相似。它们都是沿着<strong>查询路径</strong> 做旋转倒置，将被查询的节点通过此方法移动到根节点。不同的是，伸展操作是按照该结构上的查找顺序<strong>成对旋转</strong> 。对于伸展树中的一个节点x，我们重复如下操作<strong>直到</strong> x 成为树的根节点。</p><p><strong><em>Splaying Step</em></strong><br><em>Case 1(zig)：</em> 如果p(x)是x的父节点，并且p(x)是树的根，那么旋转x和p(x)间的边。（此为最终步骤）<br><em>Case 2(zig-zig)：</em> 如果p(x)不是根节点，并且x和p(x)都是左儿子或者右儿子，那么旋转链接p(x)和g(x)的边，然后旋转链接x和p(x)的边。<br><em>Case 3(zig-zag)：</em> 如果p(x)不是根，并且x是左儿子 p(x)是右儿子，或者相反，那么旋转链接x和p(x)的边，然后旋转链接x和p(x)的新边。</p><p><strong>注：</strong><br>其中我们假设p(x)为x的父节点，g(x)为p(x)的父节点。下图三个操作a、b、c分别对应上述的zig、zig-zig、zig-zag。</p><p><img src="/2019/08/16/splay/3.png" alt="3"></p><p><strong>分析：</strong><br>对于深度为d的节点x做伸展操作，需要花费的时间和d成比例，即和查找x的时间成比例。伸展操作并不仅仅是将x移动到根节点，而是<strong>将查找路径上的节点的深度都粗略减少了一半。</strong> 如此一来使得伸展树的效率非同凡响。效率证明略，不过我们依然可以根据如下1种常规情况(Figures 4)及2种极端情况(Figures 5)下进行splaying操作后 树的构造来略窥一二。</p><p><img src="/2019/08/16/splay/4.png" alt="4"></p><p><img src="/2019/08/16/splay/5.png" alt="5"></p><h4 id="伸展树上的更新操作"><a href="#伸展树上的更新操作" class="headerlink" title="伸展树上的更新操作"></a>伸展树上的更新操作</h4><p>使用伸展树，我们可以继承标准的二叉搜索树的操作。考虑如下几个操作：<br><em>access(i,t):</em> &emsp;如果i在树t中，返回一个指向i位置的指针；否则，返回一个指向空节点的指针。<br><em>insert(i,t):</em> &emsp;向树t中插入一个元素i，假设此前i不存在。<br><em>delete(i,t):</em> &emsp;从树t中删除元素i，假设i存在。<br><em>join(t1,t2):</em> &emsp;将树t1和t2合并成一棵新的树并返回新树的树根。该操作假设t1中所有元素都小于t2中的元素。合并后删除t1和t2。<br><em>split(i,t):</em> &emsp;将t分成两棵子树t1和t2，所有小于等于i的元素在t1，所有大于i的元素在t2。然后删除树t。</p><p><strong>access(i,t)实现方法：</strong><br>我们从树t的根开始，按照二叉搜索树的查找方式向下查找；如果当前节点x包含待查目标i，则算法完成，我们对x进行splaying操作并返回指向x的指针。如果搜索到达了空节点（即待查目标不存在），那么我们对搜索路径的最后一个节点进行splaying操作，并返回一个空指针。如果树为空，则取消splaying操作。（Figures 6）</p><p><strong>join(t1,t2)实现方法：</strong><br>我们首先在t1中执行一次access(i,t1)，其中i是t1中最大的元素。于是在access后，t1的根包含i，并且它没有右儿子。于是我们可以将t2作为t1的右儿子连接，并返回处理后的树，join操作完成。(Figures 7)</p><p><strong>split(i,t)实现方法：</strong><br>我们首先执行一次access(i,t)，然后断开t和左右儿子的链接，左子树作为t1，右子树作为t2，并且考虑根是否包含等于i的元素。返回t1或t2，split操作完成。(Figures 7)</p><p><strong>insert(i,t)实现方法</strong><br>我们先对t进行一次split(i,t)，得到了两个子树t1和t2，这时我们把i作为一个新的根节点，t1作为i的左子树，t2作为其右子树。(Figures 8)</p><p><strong>delete(i,t)实现方法</strong><br>我们先执行一次access(i,t)，此时得到根节点t，这个时候对t的两个子树t1和t2执行join(t1,t2)，就完成了删除i节点。(Figures 8)</p><p><strong>小结：</strong><br>通过上述操作的实现方法，我们可以发现，实现join和split时用到了access，实现insert和delete时我们又用到了split和join，由此可见我们可以通过已实现的操作来搭建未实现的操作，这样更加简洁且降低了编程难度。</p><p><img src="/2019/08/16/splay/6.png" alt="6"></p><p><img src="/2019/08/16/splay/7.png" alt="7"></p><p>另外，对于insert和delete操作还有另一种稍加优化的方法，这里省略，复杂度分析同样省略，具体可以参照原文[1]。</p><p><strong>参考文献：</strong></p><p>[1]  Daniel D.Sleator , Robert Endre Tarjan, <em>A data structure for dynamic trees</em>.</p>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树区间修改-延迟标记</title>
      <link href="/2019/08/16/interval-tree/"/>
      <url>/2019/08/16/interval-tree/</url>
      
        <content type="html"><![CDATA[<h4 id="延迟标记"><a href="#延迟标记" class="headerlink" title="延迟标记"></a>延迟标记</h4><p>在线段树中，单点修改时，我们是将信息从叶节点向上依次更新它的父节点，直到根节点。如果在区间修改仍然按照这个策略，那么修改的时间复杂度为O(N)。<br>为了降低时间复杂度，我们可以在更新时只更新大区间，不向下更新到叶子节点，等查询时再更新。举个例子：我们将1-5的位置上每个数+100，重复10000次上述操作。<strong>我们加10000次100和直接+1000000是相等的效果，但是一个执行了10000次，而另一个只执行1次。</strong> 我们又知道计算机的计算效率和计算次数是相关的，所以我们可以利用该原理，当区间修改时不向下更新，直至查询时再更新。</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>以POJ3468为例，我们使用线段树+延迟标记技巧 来实现快速区间修改与区间查询。<br>具体做法是，我们为每个节点增加一个延迟标记add，如果add为0，则说明该点的所有子区间都已更新完成，否则说明其子区间仍需要+add。请注意，如果一个节点被打上“延迟标记”，说明该节点曾经被修改过，但其子节点尚未被更新，即延迟标记说明的是子节点的待更新情况。<br>具体实现时，我们可以使用一个函数spread来实现延迟标记向下传递。<br><strong>代码示例：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll sum,add;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(x) t[x].add</span></span><br><span class="line">&#125;t[MAXN*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN],n,m;</span><br><span class="line"><span class="comment">//将延迟标记向下更新一层 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(add(p))&#123;</span><br><span class="line">sum(p*<span class="number">2</span>) += (r(p*<span class="number">2</span>) - l(p*<span class="number">2</span>) + <span class="number">1</span>)*add(p);</span><br><span class="line">sum(p*<span class="number">2</span>+<span class="number">1</span>) += (r(p*<span class="number">2</span>+<span class="number">1</span>) - l(p*<span class="number">2</span>+<span class="number">1</span>) + <span class="number">1</span>)*add(p);</span><br><span class="line">add(p*<span class="number">2</span>) += add(p);</span><br><span class="line">add(p*<span class="number">2</span>+<span class="number">1</span>) += add(p);</span><br><span class="line">add(p) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建树  l和r是当前节点所代表的区间的左右端点 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">l(p) = l,r(p) = r,add(p) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">t[p].sum = a[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">build(p*<span class="number">2</span>,l,mid);</span><br><span class="line">build(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">t[p].sum = t[p*<span class="number">2</span>].sum + t[p*<span class="number">2</span>+<span class="number">1</span>].sum; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间更新 如果当前区间被包含 则延迟标记 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(p) &amp;&amp; r(p) &lt;= r)&#123;</span><br><span class="line">sum(p) += (r(p)-l(p)+<span class="number">1</span>)*d;</span><br><span class="line">add(p) += d;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">int</span> mid = (l(p)+r(p))/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) change(p*<span class="number">2</span>,l,r,d);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) change(p*<span class="number">2</span>+<span class="number">1</span>,l,r,d);</span><br><span class="line">sum(p) = sum(p*<span class="number">2</span>) + sum(p*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间查询 当查询到该区间时顺便更新 </span></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">//printf("%d %d\n",l(p),r(p));</span></span><br><span class="line"><span class="keyword">if</span>(l &lt;= l(p) &amp;&amp; r(p) &lt;= r)&#123;</span><br><span class="line"><span class="keyword">return</span> sum(p);</span><br><span class="line">&#125;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">int</span> mid = (l(p) + r(p))/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) ans += ask(p*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) ans += ask(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'C'</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> l,r,d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;d);</span><br><span class="line">change(<span class="number">1</span>,l,r,d);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(<span class="number">1</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>参考书目：</strong><br>《算法竞赛进阶指南》李煜东.P209</p>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trie-字典树笔记</title>
      <link href="/2019/08/16/trie/"/>
      <url>/2019/08/16/trie/</url>
      
        <content type="html"><![CDATA[<p>Trie，又称字典树，是一种用于实现字符串快速检索的<strong>多叉树</strong>结构。Trie的每个节点都拥有若干个字符指针，若在插入或检索字符串时扫描到一个字符c，就沿着当前节点的c这个字符指针，走向该指针指向的节点。</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>一颗空Trie仅包含一个根节点，该节点的字符指针均指向空。</p><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p>若需要插入一个字符串S时，我们令一个指针P起初指向根节点。然后，依次扫描S中的每个字符c：</p><ul><li>若P的c字符指针指向一个已经存在的节点Q，则令 P = Q。</li><li>若P的c字符指针指向空，则新建一个节点Q，令P的c字符指针指向Q，然后令P = Q。</li></ul><p>当S的字符扫描完毕时，在当前节点P上标记它是一个字符串的末尾。</p><h5 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h5><p>当需要检索一个字符串S在Trie中是否存在时，我们令一个指针P起初指向根节点，然后依次扫描S中的每个字符c：</p><ul><li>若p的c字符指针指向空，则说明S没有被插入过Trie，结束检索。</li><li>若P的c字符指针指向一个已经存在的节点Q，则令P = Q</li></ul><p>若S中的字符扫描完毕时，当前节点P被标记为一个字符串的末尾，则说明S在Trie中存在，否则说明S没有被插入过。</p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><p>我们以一个简单的经典问题为例：有m次询问，每次询问给出一个操作符op和字符串S，若op = 1，则将S放入集合T，若op = 2，则回答T集合中是否有S字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">bool</span> End[SIZE];</span><br><span class="line"><span class="keyword">int</span> trie[SIZE][<span class="number">30</span>],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; len;k++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ch = str[k]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(trie[p][ch] == <span class="number">0</span>) trie[p][ch] = ++tot;</span><br><span class="line">        p = trie[p][ch];</span><br><span class="line">    &#125;</span><br><span class="line">    End[p] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str),p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; len;k++)&#123;</span><br><span class="line">        p = trie[p][str[k]-<span class="string">'0'</span>];</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> End[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> m,op;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>,&amp;op,s);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) insert(s);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(search(s)) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考书目：</strong></p><ul><li>《算法竞赛进阶指南》李煜东.P71</li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路径算法</title>
      <link href="/2019/08/16/dijkstra/"/>
      <url>/2019/08/16/dijkstra/</url>
      
        <content type="html"><![CDATA[<p><strong>前置知识：</strong> 图的相关定义、图的存储</p><p><strong>摘要：</strong><br>最短路径算法中常用的有4个：Floyed-Warshall、Dijkstra、Bellman-Ford、SPFA。这几种算法区别在于适用范围，以及对于不同构造的图效率不同。由于边的权值可以为负，在边权为负的情况下Dijkstra算法无法使用。而Bellman-Ford算法虽然可以处理负边权图，但却不能处理负权回路的情况（文中有介绍）。<br>进一步的，我们可以将最短路径问题分为单源最短路径和多源最短路径问题。在学会处理这两个问题后，我们还将探讨如何记录并输出最短路径而不仅仅是求值；在走最短路径的基础上，我们还应能对等效路径（即最终结果相同的两条路径，这里表现为权值相同）做约束选择（即有第二权值）。</p><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>我们假设图中顶点个数为N，编号依次为1~N，边的个数为M。</p><p><strong>最短路问题：</strong> 在图中，给定两个顶点，在以这两个点为起点和终点的路径中，边的权值和最小的路径。<br><strong>稀疏图：</strong> 符合|E| = O(V)的图称为稀疏图。<br><strong>稠密图：</strong> 符合|E| = O(V^2)的图称为稠密图。在算法竞赛中，若|E|比|V|大一个数量级以上则可认为是稠密图。</p><h4 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h4><p>源，即起点的意思。单源最短路径问题就是求从一个起点出发到其它顶点的最短路径。这里我们假设起点为1（图中顶点编号为1~N），dist[ i ] 为从起点1到顶点i的最短路径。<br>求单源最短路径有3个算法：Dijkstra、Bellman-Ford和SPFA。其中SPFA是Bellman-Ford的优化版本，于是我们通常依据情况挑选适合的算法使用。</p><h5 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h5><p><strong>适用范围与效率：</strong><br>Dijkstra算法适用于所有边权值非负情况，其运行效率为O(N^2)，优化后效率为O(M* LogN)，适用于稠密图。</p><p><strong>算法流程：</strong> </p><ol><li>初始化dist[1] = 0，其余节点的dist值设为无穷大。</li><li>找出一个未被标记的、dist[x]最小的节点x，然后标记节点x。</li><li>扫描节点x的所有出边（x,y,z），若dist[y] &gt; dist[x]+z，则适用dist[x]+z更新dist[y]。</li></ol><p><strong>算法思想：</strong><br>Dijkstra算法基于贪心的思想。我们的做法就是不断通过已求出的最短路径dist[x]来更新和其相连的点y（假设(x,y,z)分别为起点、终点、边权）。在这种情况下，每个点y有可能被多个点x更新，于是我们取dist[x]+z值最小的作为dist[y]。<br><strong>正确性证明：</strong><br>在上述算法流程步骤2中，我们找出未被标记的、dist[x]最小的节点x来更新和x相连的点，这里所指的dist[x]即<strong>全局最小值</strong>。为什么使用全局最小值来更新和其相连的点可以达到目的呢？<br>首先，由于除了节点1外所有点的dist初始值都为无穷大，因此dist不是无穷大的点一定是被更新过了的；另外，dist为全局最小值的点，其dist一定不会再被更新，因为<strong>没有比其dist更小的点</strong>可以用来更新它。至此，我们已经证明了dist为全局最小值的点x一定是被更新过了的，且一定是不能再被更新了的，因此dist[x]即为节点1到x的最短路径，所以我们可以用x来更新其它点。</p><p><strong>优化：</strong><br>上述算法，在找全局最小值时采取遍历的方法，其查找与删除的效率为O(N)，加之使用邻接矩阵存储，遍历边也是O(N)，所以时间复杂度为O(N^2)。但是我们可以采用堆+邻接表的方式来优化。我们可以在O(log N)的复杂度下获取和删除全局最小值，最终可在O(M log N)时间内完成算法。</p><p><strong>代码示例：</strong><br>见附录部分code-1：二叉堆优化的Dijkstra算法模板</p><h5 id="Bellman-Ford算法与SPFA算法"><a href="#Bellman-Ford算法与SPFA算法" class="headerlink" title="Bellman-Ford算法与SPFA算法"></a>Bellman-Ford算法与SPFA算法</h5><p><strong>适用范围与效率：</strong><br>能处理带负权边的情况，不能处理存在负权回路的情况。其中Bellman-Ford效率为O(NM)，SPFA效率为O(KE)，其中K为常数，平均值为2。适用于稀疏图。<br><strong>算法介绍：</strong><br>可以注意到我们将Bellman-Ford算法和SPFA算法放在了一起整理，因为实际上SPFA是“队列优化的Bellman-Ford算法”，因此本质上思想相同。<br><strong>算法流程：</strong> </p><ol><li>扫描所有边(x,y,z)，若dist[y] &gt; dist[x] + z，则用dist[x] + z更新dist[y]。</li><li>重复上述步骤，直到没有更新操作为止。</li></ol><p><strong>算法思想：</strong><br>Bellman-Ford算法是基于迭代思想的。我们每一次都对所有的边进行一次更新操作，直至没有更新操作发生为止。每一次的更新操作都使得我们更接近答案，这种通过若干次重复操作不断逼近答案的思想就是迭代思想。算法的正确性很显然，不予证明。</p><p><strong>SPFA：</strong></p><ol><li>建立一个队列，最初队列中只包含起点。</li><li>取出队头节点x，扫描它所有出边（x,y,z)，若dist[y] &gt; dist[x] + z，则使用dist[x] + z更新dist[y]。同时，若y不在队列中，则把y入队。</li><li>重复上述步骤，直到队列为空。</li></ol><p>在这个优化中，我们采用队列保存了待扩展节点。每次入队相当于完成一次对dist数组的更新操作，一个节点可能会入队、出队多次。这个队列避免了Bellman-Ford算法中对不需要扩展节点的冗余扫描。在稀疏图上SPFA效率较高，为O(KM)级别，其中k是一个较小的常数。但是在稠密图或者特殊的网格图上，仍有可能退化为O(NM)。</p><p><strong>代码示例：</strong><br>见附录部分code-2：SPFA模板</p><h4 id="多源最短路径问题"><a href="#多源最短路径问题" class="headerlink" title="多源最短路径问题"></a>多源最短路径问题</h4><p>与单源最短路径问题对应，多源最短路径问题不局限于某一固定起点，而是可能在一次算法中询问任意两个点之间的最短路径，于是之前的3个算法就捉襟见肘了，显然，我们需要一种新的算法来解决这类问题，这个算法就是Floyd算法。</p><h5 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h5><p><strong>适用范围：</strong> 适用于求多源最短路径问题，适用于稠密图，时间复杂度为O(N^3)。<br><strong>算法思想：</strong><br>Floyd算法基于动态规划。设D[k,i,j]表示“经过若干个编号不超过k的节点”从i到j的最短路径长度。该问题可以划分为两个子问题，经过编号不超过k-1的节点从i到j，或者从i先到k再到j。于是有状态转移方程：<br>&emsp;&emsp;D[k,i,j] = min( D[k-1,i,j] , D[k-1,i,k] + D[k-1,k,j] )<br>初值为D[0,i,j] = A[i,j]其中A[i,j]为自定义的邻接矩阵。<br>上述算法中，k是阶段，所以必须置于最外层循环。i和j是附加状态，因此可以置于内层循环。算法的正确等价于动态规划的正确性证明，此处不予证明。<br><strong>优化：</strong><br>Floyd算法可进行空间优化，我们可以注意到第一维完全可以向背包问题中一样省略。最初，我们可以直接用D保存邻接矩阵。在最外层循环到k层时，内层有状态转移：<br>&emsp;&emsp;D[i,j] = min(D[i,j] , D[i,k] + D[k,j])<br>最终D[i,j]就保存了i到j的最短路径。<br><strong>代码示例：</strong><br>见附录部分code-3：Floyd算法模板。</p><h4 id="未解决的问题"><a href="#未解决的问题" class="headerlink" title="未解决的问题"></a>未解决的问题</h4><p>以下问题将在另一篇笔记中整理：</p><ul><li>如何保存并输出最短路径。</li><li>最短路径的变形，如：求连通性、求传递闭包、求路径最大权值最小。</li><li>节点有约束的最短路径问题。</li><li>如何判断负环。</li></ul><h4 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h4><ul><li>《算法竞赛进阶指南》,李煜东,P322-331.</li><li>《信息学奥赛一本通》,董永建,科学技术文献出版社,P471-485.</li><li>《挑战程序设计竞赛(第二版)》,人民邮电出版社,秋叶拓哉,P99.</li></ul><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p>code-1：二叉堆优化的Dijkstra算法模板<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    《算法竞赛进阶指南》P324</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],Next[M],d[N];</span><br><span class="line"><span class="keyword">int</span> n,m,tot;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">priority_queue&lt; pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//pair 第一维是dist的相反数，利用相反数使得大根堆变成小根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y,edge[tot] = z;</span><br><span class="line">    Next[tot] = head[x],head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);    <span class="comment">//初始化dist数组</span></span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);   <span class="comment">//初始化标记数组</span></span><br><span class="line">    d[s] = <span class="number">0</span>;   </span><br><span class="line">    q.push(make_pair(<span class="number">0</span>,s));</span><br><span class="line">    <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.top().second;q.pop();<span class="comment">//x为全最最小值节点编号</span></span><br><span class="line">        <span class="keyword">if</span>(vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//遍历所有边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i;i = Next[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line">            <span class="keyword">if</span>(d[y] &gt; d[x] + z)&#123;</span><br><span class="line">                d[y] = d[x]+z;</span><br><span class="line">                q.push(make_pair(-d[y],y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>code-2：SPFA算法模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//《算法竞赛进阶指南》P326</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],edge[M],ver[M],Next[M],d[N];</span><br><span class="line"><span class="keyword">int</span> n,m,tot;</span><br><span class="line"><span class="keyword">bool</span> vis[N];    <span class="comment">//用来标记节点x是否在队列中</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;   <span class="comment">//辅助队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y,edge[tot] = z;</span><br><span class="line">    Next[tot] = head[x],head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();q.pop();</span><br><span class="line">        vis[x] = <span class="literal">false</span>;     <span class="comment">//表示x不在队列中了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i;i = Next[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">            <span class="keyword">if</span>(d[y] &gt; d[x]+z)&#123;</span><br><span class="line">                d[y] = d[x]+z;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y]) q.push(y),vis[y] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,z,s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        add(x,y,z);</span><br><span class="line">    &#125;</span><br><span class="line">    SPFA(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,d[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>code-3：Floyd算法模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> a&gt;b?b:a;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) d[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        d[x][y] = min(d[x][y],z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">                d[i][j] = min(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,d[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长上升子序列模板</title>
      <link href="/2019/08/16/lis/"/>
      <url>/2019/08/16/lis/</url>
      
        <content type="html"><![CDATA[<p>按照数据结构来划分的话，最长上升子序列(LIS)是属于线性DP，其作为动态规划经典入门模型，重要性也是不言而喻的。而LIS问题也有很多种变型，对于这些问题有的超过了动态规划的适用范围，有的需要对转移方程进行更改，需要具体问题具体分析。</p><p><strong>前置知识：</strong></p><ul><li>子序列的概念</li><li>动态规划一般步骤</li><li>二分查找</li></ul><blockquote><p>问题模型：给定一个长度为N的数列A，求数值单调递增的子序列长度最长是多少。</p></blockquote><p><strong>解题思路：</strong><br>状态表示：我们设F[i]表示以A[i]为结尾的“最长上升子序列”的长度。<br>阶段划分：子序列的结尾位置（数列A中的位置，从前到后）。<br>转移方程：F[i] = max{ f[j] + 1} (0 &lt;= j &lt; i 且 A[j] &lt; A[i])。<br>边界：F[0] = 0。<br>目标：max{F[i]} ( 0 &lt;= i &lt; = N)。</p><p>如此设计目标函数与转移方程，很显然可以得到正确结果，其效率是O(N^2)，代码实现也很简单。</p><p><strong>优化：</strong><br>首先考虑一下上述算法最耗时的地方在哪，显然我们每次都要用O(N)的时间遍历前i-1个位置上的元素来更新F[i]，而能更新F[i]的元素A[j]需要满足两个条件：A[j] &lt; A[i]且F[j] &gt;= F[i]，那么F[i]就可以被更新为F[j]+1。在这个过程中，A[j]也可以描述为“小于A[i]的所有元素中F的值最大的那个”，通过这个描述来找A[j]的效率是O(N)。<br>考虑另一种方式，我们新增一个辅助数组d，d[i] 表示“长度为i的最长上升子序列的最小结尾是多少”，那么很显然，d数组中的元素是严格递增的。且每当我们读取到A序列中的一个元素A[i]时，都有两种情况：</p><ol><li>A[i] &gt; d[len]，此时 d[++len] = A[i]。 </li><li>A[i] &lt;= d[len]，此时说明d数组中某个元素可以被A[i]更新，我们采用二分查找的方式更新d数组即可。</li></ol><p>其中len代表当前最长上升子序列的长度。<br>上述方法中，如果遇到情况1，那么效率是O(1)，情况2，效率就是O(log N)，总体来讲，对于大量数据，该优化效果还是很喜人的。</p><p><strong>优化的正确性说明：</strong><br>上述优化可以用堆栈思想来解释，也可以将其看作一个小技巧。借助于d数组，对于序列A中的每个元素A[i]，我们都可以快速找到“小于A[i]的所有元素中F的值最大的那个”，<strong>因为d[len]存放的就是最长上升子序列长度为len时的最小元素</strong> 。如果A[i] &lt;= d[len]，那么很显然当前的最长上升子序列长度len不能再增加了（因为A[i] 不能添加在A的子序列d[1] ~d[len] 的后面），且d数组可以被更新(再不济也可以将d[len] 更新为 A[i]，因为 A[i] &lt; d[len])。于是借助于d数组的特性，完成了优化，当然也有所牺牲。</p><p><strong>代码示例：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">b_search</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> s,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(s &lt; e)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = s+(e-s)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(d[mid] &gt;= x) e = mid;</span><br><span class="line">        <span class="keyword">else</span> s = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    d[<span class="number">1</span>] = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt;= d[len])  d[++len] = A[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> p = b_search(A[i],<span class="number">1</span>,len);</span><br><span class="line">            d[p] = A[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  for(int i = 0;i &lt; len;i++)  cout &lt;&lt; d[i+1]&lt;&lt;" ";</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ul><li>《算法竞赛进阶指南》,李煜东,P237.</li><li><a href="https://www.cnblogs.com/wxjor/p/5524447.html" target="_blank" rel="noopener">博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“拓展域”与“边带权”并查集</title>
      <link href="/2019/08/16/bingchaji/"/>
      <url>/2019/08/16/bingchaji/</url>
      
        <content type="html"><![CDATA[<h5 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h5><ul><li>并查集</li><li>路径压缩与按秩合并</li></ul><h5 id="“边带权”并查集"><a href="#“边带权”并查集" class="headerlink" title="“边带权”并查集"></a>“边带权”并查集</h5><p>并查集实际上是由若干棵树构成的森林，我们可以在树中的每条边上记录一个权值，即维护一个数组d，用d[x]保存节点x到父节点fa[x]之前的边权。在每次路径压缩后，每个访问过的节点都会直接指向树根，如果我们同时更新这些节点的d值，就可以利用路径压缩的过程来统计每个节点到树根之间的路径上的一些信息。这就是所谓“边带权” 的并查集。</p><h5 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h5><blockquote><p>POJ1773<br>题目描述：见《算法竞赛进阶指南》P190</p></blockquote><p><strong>解题思路1：边带权</strong><br>本题可作为“边带权”和“扩展域”模板题整理。与一般的并查集不同的是，本题传递关系不止一种：</p><ul><li>若x1和x2奇偶性相同，x2与x3奇偶性也相同，则x1与x3奇偶性相同。</li><li>若x1和x2奇偶性相同，x2与x3奇偶性不同，则x1与x3奇偶性不同。</li><li>若x1和x2奇偶性不同，x2与x3奇偶性不同，则x1与x3奇偶性相同。</li></ul><p>另外，本题的N太大，而M却很小，可以使用离散化方法，所以顺便复习一下离散化。<br>为了处理本题的多种传递关系，我们可以采用一种“边带权”的并查集。具体操作是用边权d[x] = 0 表示 x 与 par[x] 奇偶性相同；为1表示 x 与 par[x] 奇偶性不同。于是在路径压缩时，就可以通过对路径上边权做异或运算，即可得到 x 与树根的奇偶性关系。<br>于是对于每一个询问的(l , r , ans)，我们假设回答”odd”时，ans = 1，“even”时ans = 0，我们令 x 、 y 分别代表l-1和r离散化后的序号，如果x和y在同一个集合，则判断d[x] ^ d[y] 是否等于 ans，若不等则冲突；如果x和y不在同一个集合内，则合并 x 和 y ，此时需要注意如何更新d数组。（代码 code - 1 详解）</p><p><strong>解题思路2：扩展域</strong><br>本题还可以使用“扩展域”的并查集。<br>我们把每个变量x拆分成两个节点x_odd和x_even。其中用 x_odd 表示1~x有奇数个1，x_even表示有偶数个。我们把这两个节点称为x的“奇数域”与“偶数域”。<br>对于每个问题，假设在离散化后的 l-1 与 r 的值分别是x和y，设ans表示该问题的回答（0代表回答偶数个，1代表回答奇数个）。</p><ul><li>若ans = 0，x_odd 与 y_even在同一个集合，则与答案矛盾；否则合并x_odd与y_odd，x_even与y_even，这表示[l , r]中有偶数个1。</li><li>若ans = 1，x_odd与y_odd在同一个集合，则与答案矛盾；否则合并x_odd与y_even，x_even与y_odd。</li></ul><p>代码见code - 2.</p><h5 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h5><ul><li>《算法竞赛进阶指南》,李煜东,P190.</li></ul><p><strong>代码示例：code - 1</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">21000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,ans;</span><br><span class="line">&#125; q[MAXN];</span><br><span class="line"><span class="keyword">int</span> a[MAXN],par[MAXN],d[MAXN],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    a数组用来离散化，par[x]代表x的父节点编号，d[x]代表</span></span><br><span class="line"><span class="comment">    从x到根节点路径和，cnt也是用于离散化。</span></span><br><span class="line"><span class="comment">    这里根节点即集合的代表节点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x] == x) <span class="keyword">return</span> x;   <span class="comment">//找到根节点，返回</span></span><br><span class="line">    <span class="keyword">int</span> root = Find(par[x]);    <span class="comment">//临时存根节点</span></span><br><span class="line">    d[x] ^= d[par[x]];          <span class="comment">//路径压缩，距离数组d也应该更新</span></span><br><span class="line">    <span class="keyword">return</span> par[x] = root;       <span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">char</span> rs[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;q[i].l,&amp;q[i].r,rs);</span><br><span class="line">        <span class="keyword">if</span>(rs[<span class="number">0</span>] == <span class="string">'o'</span>) q[i].ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> q[i].ans = <span class="number">0</span>;</span><br><span class="line">        a[cnt++] = q[i].l<span class="number">-1</span>;    <span class="comment">//这里需要存l-1，为了使l也包含在内</span></span><br><span class="line">        a[cnt++] = q[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下两行代码离散化用</span></span><br><span class="line">    sort(a,a+cnt);</span><br><span class="line">    <span class="keyword">int</span> len = unique(a,a+cnt)-a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) par[i] = i; <span class="comment">//初始化爸爸数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;      </span><br><span class="line">        <span class="comment">//左右边界在离散化数组中的编号：</span></span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(a,a+len,q[i].l<span class="number">-1</span>)-a;</span><br><span class="line">        <span class="keyword">int</span> y = lower_bound(a,a+len,q[i].r)-a;  </span><br><span class="line">        <span class="comment">//左右边界的祖先分别为ta和tb</span></span><br><span class="line">        <span class="keyword">int</span> ta = Find(x),tb = Find(y);</span><br><span class="line">        <span class="keyword">if</span>(ta == tb)&#123;   <span class="comment">//如果已经在同一个集合内，则判断是否矛盾</span></span><br><span class="line">            <span class="keyword">if</span>((d[x]^d[y]) != q[i].ans)&#123;<span class="comment">//矛盾的条件就是事实和结果不同</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            par[ta] = tb;d[ta] = d[x]^d[y]^q[i].ans;</span><br><span class="line">            <span class="comment">//这里d[ta]的值需要推导一下。</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            我们将x所在的集合和y所在的集合合并，那么就需要更新d数组</span></span><br><span class="line"><span class="comment">            这里d[x]存放的是x到par[x]的距离，所以合并两个集合对于</span></span><br><span class="line"><span class="comment">            非根节点来说并无影响，关键是对于两个根d[ta]和d[tb]如何处理</span></span><br><span class="line"><span class="comment">            如果我们将ta代表的集合归于tb下，那么就需要更新d[ta],而已知</span></span><br><span class="line"><span class="comment">            ans = d[x]^d[y]^d[ta]，即x到y的总路径等于x到ta XOR y到tb XOR </span></span><br><span class="line"><span class="comment">            ta到tb；对上式变形，得：d[ta] = ans^d[x]^d[y],而后三者是已知，</span></span><br><span class="line"><span class="comment">            故可以求出d[ta]。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>代码示例：code - 2</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2</span>*<span class="number">21000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,ans;</span><br><span class="line">&#125;Q[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],par[N];    <span class="comment">//a用于离散化，par是爸爸数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> par[x] = Find(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;Q[i].l,&amp;Q[i].r,str);</span><br><span class="line">        Q[i].ans = str[<span class="number">0</span>] == <span class="string">'o'</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        a[++t] = Q[i].l<span class="number">-1</span>;</span><br><span class="line">        a[++t] = Q[i].r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+t);</span><br><span class="line">    n = unique(a+<span class="number">1</span>,a+<span class="number">1</span>+t) - a- <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span>*n;i++) par[i] = i;</span><br><span class="line">    <span class="comment">//因为每个节点有两个扩展域，所以n需要*2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(a+<span class="number">1</span>,a+<span class="number">1</span>+n,Q[i].l<span class="number">-1</span>)-a;</span><br><span class="line">        <span class="keyword">int</span> y = lower_bound(a+<span class="number">1</span>,a+<span class="number">1</span>+n,Q[i].r)-a;</span><br><span class="line">        <span class="keyword">int</span> x_odd = x,x_even = x+n;</span><br><span class="line">        <span class="keyword">int</span> y_odd = y,y_even = y+n;</span><br><span class="line">        <span class="keyword">if</span>(Q[i].ans == <span class="number">0</span>)&#123;      </span><br><span class="line">            <span class="keyword">if</span>(Find(x_odd) == Find(y_even))&#123;    <span class="comment">//答案与事实不符</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            par[Find(x_odd)] = Find(y_odd);</span><br><span class="line">            par[Find(x_even)] = Find(y_even);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(Find(x_odd) == Find(y_odd))&#123;     <span class="comment">//答案与事实不符</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i<span class="number">-1</span>); </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            par[Find(x_odd)] = Find(y_even);    <span class="comment">//合并x为奇，y为偶</span></span><br><span class="line">            par[Find(x_even)] = Find(y_odd);    <span class="comment">//合并x为偶和y为奇</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫队算法</title>
      <link href="/2019/08/16/modui/"/>
      <url>/2019/08/16/modui/</url>
      
        <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>莫队算法大概有基础莫队、树形莫队、带修（带修改的）莫队等类型，本文仅介绍基础莫队。可以看作莫队算法的入门。<br>莫队算法据说是2010年国家集训队的莫涛发明的一个优化类的算法，由于莫涛经常打比赛做队长，大家都叫他莫队，该算法也被称为莫队算法。它使用指针移动以及分块的思想对朴素算法进行优化。<br>莫队算法是离线算法，可以解决一类离线的区间问题，对于序列上的区间询问问题，如果从 [l,r] 的答案能够 O(1) 扩展到 [l−1,r],[l+1,r],[l,r+1],[l,r−1] 的答案，那么可以在 O(n√n) 的复杂度内求出所有询问的答案。</p><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p><strong>SPOJ D-query：</strong> 给定一个数组，每次询问一个区间内有多少个不同的元素。<br><strong>解题思路：</strong> </p><ol><li>朴素思想<br>注意到询问没有强制在线，因此我们可以使用离线的方法。首先我们考虑此类问题，如果我们已经计算出[L , R]的答案以及中间结果，那么我们显然可以在常数时间内计算出[L-1,R] , [L+1 , R] , [L , R-1] , [L , R+1]的答案，即便所给的询问并不一定是这样相差为1的区间，但这也启发了我们要尽可能将区间范围相近的放在一起计算。</li><li>为什么将询问区间相近的放在一起计算可以节省时间呢？<br>因为我们通过两个指针（p和q）的左右移动来统计区间信息，显然对于程序的每次运行，这两个指针的移动次数越少越好，要想移动的尽量少，显然区间相近的放在一起最好。</li><li>如何排序？<br>按照以上思路，我们要做的就是对区间进行排序，使得范围相近的询问区间尽量放在一起；但是区间有两个关键字（左端点和右端点），如果我们按照左端点严格升序，再按照右端点严格升序，那么很容易就想到一些反例来证明这种方法不是最优的，例如：(1, 100), (2, 2), (3, 99), (4, 4), (5, 102), (6, 7)。显然严格升序是不好的，很容易被出题人针对，如果能适当的减少右端点的移动次数，那么即使左端点的移动次数增加些许也是可以接受的。因此我们就要设计一种均衡的算法，使得左右端点并不一定严格有序，但总体复杂度（指针移动次数）尽量小。<br>利用分块思想，我们可以实现上述目标。我们将长度为n的序列分为长度为$\sqrt{n}$的若干块，将区间<strong>按照左端点所在的块的序号进行排序，如果块号相同则按照右端点排序。</strong> 当然我们只是概念上分块，并不一定需要严格存储块。之后我们只需要按照排序好是顺序挨个计算即可。</li></ol><p>总结起来一共三步：分块、排序、计算。算法复杂度为$O(N \sqrt{N})$</p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>可以发现本文是应用型的，对于算法的正确性证明以及复杂度证明都没有涉及，这方面的原因之一是由于这是入门文章，写太多证明反而令初学者害怕，如果学有余力自然可以找相关证明；然后就是拓展，掌握了基本思想再去拓展就轻松很多了，拓展方向可以向树形莫队、带修莫队等常见类型拓展，同时注意比较莫队和其他数据结构的异同以及优劣。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">31000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Q = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],m;</span><br><span class="line"><span class="keyword">int</span> ans,sum[<span class="number">1010000</span>];<span class="comment">//一个全局答案ans和标记数组sum是必要的 </span></span><br><span class="line"><span class="comment">//当然也可以离散化 </span></span><br><span class="line"><span class="keyword">int</span> len;<span class="comment">//块大小，在读入询问前需要先赋值 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,block,id;</span><br><span class="line">Query()&#123;&#125;</span><br><span class="line">Query(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> id):l(l),r(r),id(id)&#123;</span><br><span class="line">block = l/len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Query &amp;B) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(block == B.block) <span class="keyword">return</span> block&amp;<span class="number">1</span>? r &lt; B.r : r &gt; B.r;</span><br><span class="line"><span class="comment">//小优化，使得r呈波浪形 </span></span><br><span class="line"><span class="keyword">return</span> block &lt; B.block;</span><br><span class="line">&#125;</span><br><span class="line">&#125;query[Q];</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//增加或减少一个x位置上的数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">x = a[x]; </span><br><span class="line">sum[x] += v;</span><br><span class="line"><span class="keyword">if</span>(v &gt; <span class="number">0</span>) ans += sum[x] == <span class="number">1</span>;<span class="comment">//判等是为了防止重复计数 </span></span><br><span class="line"><span class="keyword">else</span> ans -= sum[x] == <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">len = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">query[i] = Query(x,y,i);</span><br><span class="line">&#125;</span><br><span class="line">sort(query+<span class="number">1</span>,query+<span class="number">1</span>+m);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>,r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l &lt; query[i].l) Move(l,<span class="number">-1</span>),l++;</span><br><span class="line"><span class="keyword">while</span>(l &gt; query[i].l) Move(l<span class="number">-1</span>,<span class="number">1</span>),l--;</span><br><span class="line"><span class="keyword">while</span>(r &gt; query[i].r) Move(r,<span class="number">-1</span>),r--;</span><br><span class="line"><span class="keyword">while</span>(r &lt; query[i].r) Move(r+<span class="number">1</span>,<span class="number">1</span>),r++;</span><br><span class="line">q.push(make_pair(-query[i].id,ans));<span class="comment">//大根堆变为小根堆 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.top().second;q.pop();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] 张瑯小强的<a href="https://www.cnblogs.com/CsOH/p/5904430.html" target="_blank" rel="noopener">博客</a>，2019.7.4<br>[2] 例题测试地址<a href="https://vjudge.net/problem/SPOJ-DQUERY" target="_blank" rel="noopener">SPOJ-DQUERY</a></p>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆元模板</title>
      <link href="/2019/08/16/inv/"/>
      <url>/2019/08/16/inv/</url>
      
        <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>本文主要介绍了几种求逆元的方法，但是对于证明并未给出，所以本文是偏于应用型的，其后附录部分的代码模板可以参考使用。其中最容易理解也最容易写的是费马小定理求逆元，然后更加常用的就是求阶乘的逆元了，通过O(N)的预处理，我们可以在常数时间内求出组合数C(n,m)在 mod P下的值。</p><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p><strong>1.1 定义：</strong> 逆元素是指一个可以取消另一给定元素运算的元素，在数学里，逆元素广义化了加法中的加法逆元和乘法中的倒数。</p><p><strong>1.2 数论中定义：</strong> 如果满足公式，a*b = 1（mod P），则a是b的逆元，同时b也是a的逆元。</p><p><strong>1.3 另一种定义：</strong> a*x  = 1 (mod P)，其中a与P互质，则称x的最小整数为a关于P的逆元。</p><h4 id="2-逆元的应用"><a href="#2-逆元的应用" class="headerlink" title="2.逆元的应用"></a>2.逆元的应用</h4><p><strong>2.1 除法模运算：</strong> 设c为b在对P取模状态下的逆元，在求(a/b)modP时，很可能会因为b过大而超过精度范围，这时候可以将除法转换成乘法来做，（a/b）mod P = (a <em> Invb) mod P = (a mod P)</em> (Invb mod P) mod P。</p><h4 id="3-求逆元的常用方法"><a href="#3-求逆元的常用方法" class="headerlink" title="3.求逆元的常用方法"></a>3.求逆元的常用方法</h4><h5 id="3-1-费马小定理"><a href="#3-1-费马小定理" class="headerlink" title="3.1 费马小定理"></a>3.1 费马小定理</h5><blockquote><p>费马小定理：若p为素数，则有$a^{P-1} \equiv 1(mod P)$<br>推论：$a * a^{P-2} \equiv 1(mod P)$<br>故$a^{P-2}$就是a关于P的一个逆元</p></blockquote><p><strong>3.1.1 代码实例：</strong> 见附录部分code-1。</p><p><strong>3.1.2 复杂度分析：</strong> 求单个逆元的时间复杂度是lg(Mod)。</p><h5 id="3-2-拓展欧几里得算法"><a href="#3-2-拓展欧几里得算法" class="headerlink" title="3.2 拓展欧几里得算法"></a>3.2 拓展欧几里得算法</h5><h5 id="3-3-逆元线性筛"><a href="#3-3-逆元线性筛" class="headerlink" title="3.3 逆元线性筛"></a>3.3 逆元线性筛</h5><blockquote><p>递推式：inv[i] = (Mod-Mod / i) <em> inv[Mod% i]%Mod<br>如果要保证结果为正： inv[i] = (Mod-Mod / i) </em> inv[Mod% i]%Mod<br>证明：</p></blockquote><p><strong>3.3.1 代码示例：</strong> 见附录部分code-2。<br><strong>3.3.2 复杂度分析：</strong> O(N)。</p><h5 id="3-4求阶乘的逆元"><a href="#3-4求阶乘的逆元" class="headerlink" title="3.4求阶乘的逆元"></a>3.4求阶乘的逆元</h5><blockquote><p>递推式：inv[i] = inv[i+1] * (i + 1) % Mod<br>证明：</p></blockquote><p><strong>3.4.1代码示例：</strong> 见附录部分code-3.。</p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p><strong>code-1：费马小定理求逆元</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 100010;</span><br><span class="line">const int P = 1e5+7;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll Finv[N];</span><br><span class="line">ll qpow(ll x,ll p,ll m)&#123;//快速幂算法 </span><br><span class="line">ll res = 1;</span><br><span class="line">while(p)&#123;</span><br><span class="line">if(p&amp;1)res =res*x%m;</span><br><span class="line">x = x*x%m;</span><br><span class="line">p &gt;&gt;= 1;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">void Init()&#123;//用来求逆元 </span><br><span class="line">Finv[1] = 1;</span><br><span class="line">for(int i = 2;i &lt; N;i++)</span><br><span class="line">Finv[i] = qpow(i,P-2,P);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Init();</span><br><span class="line">for(int i = 1;i &lt; N;i++)</span><br><span class="line">cout &lt;&lt; Finv[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>code-2：逆元线性筛</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int N = 100010;</span><br><span class="line">const int P = 1e5+7;</span><br><span class="line">ll inv[N];</span><br><span class="line">void Inv()&#123;</span><br><span class="line">inv[0] = inv[1] = 1;</span><br><span class="line">for(ll i = 2;i &lt; N;i++)&#123;</span><br><span class="line">inv[i] = (P - P/i)*inv[P%i]%P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Inv();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>code-3求阶乘的逆元</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll Finv[N],F[N];<span class="comment">//F存阶乘，Finv存对应逆元 </span></span><br><span class="line"><span class="function">ll <span class="title">Qpow</span><span class="params">(ll x,ll p,ll m)</span></span>&#123; </span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line"><span class="keyword">if</span>(p&amp;<span class="number">1</span>)res =res*x%m;</span><br><span class="line">x = x*x%m;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">F[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt; N;i++)</span><br><span class="line">F[i] = F[i<span class="number">-1</span>]*i%P; </span><br><span class="line">Finv[N<span class="number">-1</span>] = Qpow(F[N<span class="number">-1</span>],P<span class="number">-2</span>,P);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = N<span class="number">-1</span>;i &gt; <span class="number">0</span>;i--)</span><br><span class="line">Finv[i<span class="number">-1</span>] = Finv[i]*i%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; N;i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Finv[i]*F[i]%P &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/2019/08/16/bit-cal/"/>
      <url>/2019/08/16/bit-cal/</url>
      
        <content type="html"><![CDATA[<p><strong>需要掌握的知识：</strong></p><ul><li>原码、反码、补码</li><li>按位或</li><li>按位与</li><li>异或</li><li>非</li><li>移位运算</li><li>lowbit的实现</li><li>运算符优先级<h5 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h5><strong>原码：</strong> 是最简单的机器数表示法。用最高位表示符号位，‘1’表示负号，‘0’表示正号。其他位存放该数的二进制的绝对值。<blockquote><p>1010  ： 最高位为‘1’,表示这是一个负数，其他三位为‘010’，<br>即（0<em> 2^2）+（1</em> 2^1）+（0* 2^0）=2（‘^’表示幂运算符）<br>所以1010表示十进制数（-2）。</p></blockquote></li></ul><p><strong>面临问题：</strong> 原码下，正数相加所得结果正确，但是正数和负数相加出错。</p><hr><p><strong>反码：</strong> 正数的反码还是等于原码，负数的反码就是他的原码除符号位外，按位取反。</p><blockquote><p>3是正数，反码与原码相同，则可以表示为0011<br>-3的原码是1011，符号位保持不变，低三位（011）按位取反得（100）<br>所以-3的反码为1100</p></blockquote><p><strong>面临问题：</strong> 正数相加所得结果正确，正负相加所得结果正确，负负相加结果出错。</p><hr><p><strong>补码：</strong> 正数的补码等于他的原码，负数的补码等于反码+1。</p><p>上述给出的是补码的求法，补码的真正定义是什么？为什么要这样定义？</p><p>采用补码的表示方式的<strong>好处</strong>，一是可以将减法转化为加法运算，简化运算复杂度；二是可以让符号位作为数值直接参与运算，所得结果仍然是正确的，即符号位无需单独处理。</p><h5 id="按位或、与、异或、非"><a href="#按位或、与、异或、非" class="headerlink" title="按位或、与、异或、非"></a>按位或、与、异或、非</h5><p>在c语言中，是将一个十进制整数（一般情况下）转化为二进制位，然后再对二进制数的每一位对应进行或、与、异或、非操作。</p><h5 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h5><p>位移运算分为左移和算数右移，其中<strong>左移</strong>是指在二进制表示下把所有位数字同时向左移动一位，高位越界后舍弃，低位以0补充。其中越界是指，int型变量一般仅有32位，如果左移后超过了32位则舍弃超过的部分。<br><strong>算数右移</strong>是指在二进制补码表示下把数字同时向右移动，高位以符号位填充，低位越界后舍弃。算数右移等于除以2向下取整，（-5）&gt;&gt;1 = -3 , 3 &gt;&gt; 1 = 2。<br>可以发现算数右移并不等同于c语言中的整数/2，值得一提的是c语言中的整数/2是“除以2向0取整”。<br><strong>逻辑右移</strong>是在补码表示下把所有数字同时右移，高位以0补充，低位越界后舍弃，但是C++没有规定实现方式，一般编译器都会实现算数右移。</p><h5 id="lowbit的实现"><a href="#lowbit的实现" class="headerlink" title="lowbit的实现"></a>lowbit的实现</h5><p><strong>定义：</strong> lowbit( n )是取出非负整数 n 在二进制表示下最低位的 1 以及它后面的0所构成的十进制数值。<br><strong>实现：</strong><br>若 n &gt; 0，且第 k 位是1，第 0 ~ k-1 位都是0。<br>先将n按位取反，那么第 k 位变成了0，第 0 ~k 位变成了1。<br>再令n = n+1，那么显然通过一系列进位，第 0~k-1 位都变成了0，而第 k 位又变成了1。<br>我们注意到，最初的 n ，与最终的n只有第 0~k 位相同，更高的位都恰好相反（举个例子推导试试），于是将它们按位与就得到了 0~k 位的数值，这个值就是我们所求的答案。</p><h5 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h5><p>不确定就加括号！！位移运算最好加括号！<br><a href="https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/4752611?fr=aladdin" target="_blank" rel="noopener">百度百科，运算符优先级表</a></p>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维st表</title>
      <link href="/2019/08/16/st2/"/>
      <url>/2019/08/16/st2/</url>
      
        <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>我们知道一维的st表在经过预处理后可以在O(1)时间内查询任意区间的极值，虽然其是离线算法，但胜在代码短小易写。而在二维RMQ（区间最值查询）问题中，我们依然可以采用st算法解决问题，只不过我们需要从一维拓展到二维，当然适用范围依然是离线。二维st表仍然是用倍增思想，如果理解了一维的st表，那么对于二维的也不难理解。</p><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个n* n的矩阵以及一个整数b和k，共有k次询问，每次询问给出边长为b的子矩阵的左上角的行和列(r,c)，请回答该子矩阵内的最大值和最小值的差是多少。</p><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><p><strong>变量定义：</strong><br><code>st[r][c][k]</code> 存放以(r , c)为左上角的边长为$2^k$个元素的矩阵的最大值。<br><code>a[n][n]</code> 用来存放矩阵中的元素。</p><p><strong>查询操作：</strong><br>假设我们的st表已经更新完毕，此时<code>st[r][c][k]</code> 中存放的是以(r , c)为左上角的边长为$2^k$ 的矩阵内的最大值，那么对于一个查询(a , b , c) 即查询以(a , b)为左上角，边长为 c 的矩阵内的最大值该如何处理呢？<br>显然和一维一样，由于我们的st表中存放的区间长度是2的次方项，因此如果边长并不恰好是2的次方项，那么就无法通过一次访问st表求得，需要通过几个重叠区间得出结果。在二维RMQ中，就体现为将一个大矩阵查询分为4个小矩阵查询。<br>下面我们具体来讲一下如何划分查询区间。假设我们要查询的是以（a，b）为左上角，边长为 c 的矩阵内的最大值，那么假设 $k = log_2^c$ 向下取整，那么显然<code>st[a][b][k]</code>是一个如下图(a)中显示的一个小矩阵。</p><p><img src="/2019/08/16/st2/1.png" alt="1"></p><p>那么显而易见，<code>st[a][b+c-(1&lt;&lt;k)+1][k]</code>正如（b）中的蓝色矩形一样覆盖了以右上角为顶点的矩阵。同理，我们共需要四个矩形来覆盖整个大矩形，如（c）所示。因此对于任意边长的正方形，我们都可以计算出其覆盖面积的最大值。因为求极值操作是允许区间重叠的( [1 , 10] 的最大值可以由[1 , 6] 的最大值和[2 , 10]的最大值得出 )，因此上述划分方法虽有区间重叠，但对最终答案没有影响（求和则不行）。<br>总结起来，若设最终要求的答案为ans，则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">令t1 = st[a][b][c];</span><br><span class="line">令t2 = st[a][b+c-(1&lt;&lt;k)+1][c];</span><br><span class="line">令t3 = st[a+c-(1&lt;&lt;k)+1][b][c];</span><br><span class="line">令t4 = st[a+c-(1&lt;&lt;k)+1][b+c-(1&lt;&lt;k)+1][c];</span><br><span class="line">ans = max&#123;t1 , t2 , t3 , t4&#125;；</span><br></pre></td></tr></table></figure></p><p>因此我们得证了，利用上述定义的st表，确实可以在常数时间内求出目标矩阵的最大值。</p><p><strong>更新st表（预处理）</strong><br>我们在一开始就提到过，st表是离线算法， 即不支持修改操作，因此以此预处理之后便只能进行查询。预处理时间复杂度为$O(N^2log_2N)$。预处理用到了动态规划的思想。<br>更新也是同样的道理，更新一个大矩形，需要用到4个小矩形。状态转移方程如下：</p><p><code>st[i][j][k] = Max( st[i][j][k-1] , st[i+(1&lt;&lt;k-1)][j][k-1] , st[i][j+(1&lt;&lt;k-1)][k-1] , st[i+(1&lt;&lt;k-1)][j+(1&lt;&lt;k-1)][k-1]);</code></p><p>为什么这个式子成立呢？如果从式子上看，$2^{k-1} + 2^{k-1} = 2^k$，因此俩个小区间可以更新一个大区间，拓展到二维上呢，就是4个小矩阵更新一个大矩阵。如果用图来描述，就如（d）所示，四个小矩形构成一个大矩形，而大矩形的边长是小矩形的2倍。于是我们就可以通过四个小矩阵的值来更新大矩阵的值。<br><img src="/2019/08/16/st2/2.png" alt="2"></p><h4 id="例题-HAOI2007理想的正方形"><a href="#例题-HAOI2007理想的正方形" class="headerlink" title="例题 HAOI2007理想的正方形"></a>例题 <a href="https://www.luogu.org/problem/P2216" target="_blank" rel="noopener">HAOI2007理想的正方形</a></h4><p><strong>解题思路：</strong><br>本题就是一个二维RMQ问题的裸题，和上述模型不同的是，其是一个长a宽b的矩形，而非正方形。不管是矩形还是正方形，我们的更新和查询都是划分为4个子矩阵来更新或查询，因此只需对代码稍作改变即可，基本没太大变化，预处理都是$O(N^2logN)$，查询也都是O(1)。</p><p><strong>代码示例：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N],n,m,len,Log[N];</span><br><span class="line"><span class="keyword">int</span> st[<span class="number">3</span>][N][N][<span class="number">15</span>];<span class="comment">//0最小，1最大值 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mx = a;<span class="keyword">if</span>(mx &lt; b) mx = b;<span class="keyword">if</span>(mx &lt; c) mx = c;<span class="keyword">if</span>(mx &lt; d) mx = d;</span><br><span class="line"><span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mi = a;<span class="keyword">if</span>(mi &gt; b) mi = b;<span class="keyword">if</span>(mi &gt; c) mi = c;<span class="keyword">if</span>(mi &gt; d) mi = d;</span><br><span class="line"><span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++) </span><br><span class="line">st[<span class="number">0</span>][i][j][<span class="number">0</span>] = st[<span class="number">1</span>][i][j][<span class="number">0</span>] = a[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= <span class="number">12</span>;k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span> &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j + (<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span> &lt;= m;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> t1 = st[<span class="number">0</span>][i][j][k<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> t2 = st[<span class="number">0</span>][i+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][j][k<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> t3 = st[<span class="number">0</span>][i][j+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][k<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> t4 = st[<span class="number">0</span>][i+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][j+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][k<span class="number">-1</span>];</span><br><span class="line">st[<span class="number">0</span>][i][j][k] = min(t1,t2,t3,t4);</span><br><span class="line">t1 = st[<span class="number">1</span>][i][j][k<span class="number">-1</span>];</span><br><span class="line">t2 = st[<span class="number">1</span>][i+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][j][k<span class="number">-1</span>];</span><br><span class="line">t3 = st[<span class="number">1</span>][i][j+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][k<span class="number">-1</span>];</span><br><span class="line">t4 = st[<span class="number">1</span>][i+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][j+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][k<span class="number">-1</span>];</span><br><span class="line">st[<span class="number">1</span>][i][j][k] = max(t1,t2,t3,t4);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[len];</span><br><span class="line"><span class="keyword">int</span> t1 = st[<span class="number">0</span>][r][c][k];</span><br><span class="line"><span class="keyword">int</span> t2 = st[<span class="number">0</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c][k];</span><br><span class="line"><span class="keyword">int</span> t3 = st[<span class="number">0</span>][r][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line"><span class="keyword">int</span> t4 = st[<span class="number">0</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line"><span class="keyword">int</span> mi = min(t1,t2,t3,t4);</span><br><span class="line">t1 = st[<span class="number">1</span>][r][c][k];</span><br><span class="line">t2 = st[<span class="number">1</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c][k];</span><br><span class="line">t3 = st[<span class="number">1</span>][r][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line">t4 = st[<span class="number">1</span>][r+len-(<span class="number">1</span>&lt;&lt;k)][c+len-(<span class="number">1</span>&lt;&lt;k)][k];</span><br><span class="line"><span class="keyword">int</span> mx = max(t1,t2,t3,t4);</span><br><span class="line"><span class="comment">//printf("%d %d\n",mx,mi);</span></span><br><span class="line"><span class="keyword">return</span> mx - mi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n-len+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m-len+<span class="number">1</span>;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = ask(i,j,len);</span><br><span class="line">ans = ans &lt; tmp?ans:tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>大家可以发现我们的二维st表建立在正方形矩阵查询的基础上的，因此st表仅三个维度，即<code>st[r][c][k]</code> 代表以(r , c) 为左上角的边长为$2^k$的矩阵的极值；但如果所给矩阵以及所求矩阵并不是正方形而是普通矩形，那就要增加一个维度，即<code>st[r][c][k1][k2]</code> 表示以（r，c）为左上角，长为$2^{k1}$高为$2^{k2}$的矩阵的极值，其更新方法与本文所介绍的类似，都是通过4个子矩阵来更新，查询也是通过4个子矩阵来查询最终答案。</p>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求a的大幂对P取模</title>
      <link href="/2019/08/16/bigpow/"/>
      <url>/2019/08/16/bigpow/</url>
      
        <content type="html"><![CDATA[<blockquote><p>有如下问题：<br>求2^n mod (1e9+7)，其中1&lt; n &lt; 10^100000。</p></blockquote><p>首先明确一下此类问题的几种算法，首先朴素算法，即暴力循环求解，是O(N)复杂度，适用范围应该是n小于1000000；然后是快速幂算法，效率是O(log N)，适用于n小于2^100000级别的；然后就是上面的例题了，由于范围是10^100000，即使是快速幂也不可能在期望时间内解决，这时候需要另辟蹊径。</p><p><strong>费马小定理：</strong> 对于质数P，任意的整数a，若满足GCD(a,P) = 1，则有：$a^p \equiv a (mod \,p)$</p><p><strong>主要思路：</strong><br>回到上述例题，可知 P 即1e9+7，这是个素数。而 a 是 2 ，很明显 2 也是素数，所以GCD(a , P ) = 1，满足费马小定理的条件。那么我们想提高2^n计算的效率，就绕不开减小n的大小，我们接下来就利用费马小定理来减少幂n的大小。</p><p>首先费马小定理的一个小变形：$a^{(P-1)} \equiv 1 (mod \,P)$</p><p>接下来对2^n进行变形：<script type="math/tex">2^n = 2^{ x *  (P-1)}  * 2^k</script> ，而根据费马小定理，显然 $2^{x *  (P-1)} mod\,P = 1 mod \,P$ ，于是 $2^n mod\,P= 2^k$ ，其中k = n%(P-1)。此时k小于P，即小于1e9+7，可以使用快速幂解决。</p><p><strong>注意：</strong> 值得注意的是，10^100000 最大是1后面有100000个0，需要用字符串存，在转化为整数时利用模运算规则，边转化边取模。</p><p><strong>代码示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = res*a%M;</span><br><span class="line">a = a*a%M;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="built_in">string</span> x)</span></span>&#123;</span><br><span class="line">ll M1 = M<span class="number">-1</span>;</span><br><span class="line">ll k = x[<span class="number">0</span>]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;x[i];i++) k = (k*<span class="number">10</span>+x[i]-<span class="string">'0'</span>)%M1;</span><br><span class="line">ll ans = qpow(<span class="number">2</span>,k); </span><br><span class="line"><span class="keyword">return</span> ans%M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n != <span class="string">"0"</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,solve(n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强连通分量</title>
      <link href="/2019/08/16/tarjan/"/>
      <url>/2019/08/16/tarjan/</url>
      
        <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>强连通分量常用于<strong>缩点</strong>，是图论中一个重要的知识点。本文首先介绍了强连通分量的相关定义以及其应用范围，然后将着重介绍两种求强连通分量的算法：Kosaraju算法以及Tarjan算法，它们的时间复杂度都是O(n+m)（n：顶点数，m：边数）。<br>其中Kosaraju算法思想简单，操作方便，易于理解与代码实现，但是性能以及拓展性上比Tarjan略逊一筹；本文将会逐一介绍这两种算法的思想以及实现步骤，最后会以例题的形式给出代码模板。</p><h4 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h4><p>在有向图G中，如果两个顶点u，v间存在一条 u 到 v 的路径且也存在一条 v 到 u 的路径，则称这两个顶点u，v 是强连通的（strongly connected）。如果有向图G的任意两个顶点都强连通，则称G是一个强连通图。有向非强连通图的极大强连通子图，称为强连通分量（strongly connected components）。</p><p><strong>极大强连通子图：</strong> G是一个极大强连通子图，当且仅当G是一个强连通子图且不存在另一个强连通子图G’，使得 G 是 G’ 的真子集。</p><h4 id="强连通分量的应用"><a href="#强连通分量的应用" class="headerlink" title="强连通分量的应用"></a>强连通分量的应用</h4><p>若将有向图中的强连通分量都缩为一个点，则原图会形成一个DAG（有向无环图），如图1所示:<br><img src="/2019/08/16/tarjan/1.png" alt="图1"><br><em>图1：虚线部分构成一个强连通分量（图片来自<a href="https://blog.csdn.net/sinat_40872274/article/details/99344104#commentBox" target="_blank" rel="noopener">ccf的博客</a>）</em></p><p>强连通分量的<strong>常见用途</strong>有两个：</p><ul><li>有向图的缩点。</li><li>解决2-SAT问题。</li></ul><h4 id="Kosaraju-算法"><a href="#Kosaraju-算法" class="headerlink" title="Kosaraju 算法"></a>Kosaraju 算法</h4><p>Kosaraju算法的时间复杂度是O(n+m)，基于两次DFS的有向图强连通子图算法。<br>该算法共分为三步：</p><blockquote><p>第一步，对原有向图G进行DFS，记录节点访问完的顺序d[i] , d[i] 表示第 i 个访问完的节点是d[i]；<br>第二步，选择具有最晚访问完的顶点，对反向图GT 进行DFS，删除能够遍历到的顶点，这些顶点构成的一个强连通分量。<br>第三步，如果还有顶点没有删除，继续第二部，否则算法结束。</p></blockquote><h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><p>见附录部分 code-1：Kosaraju算法模板（POJ2186）</p><h4 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h4><p>Tarjan算法是 Robert Tarjan 发明的一个算法，其时间复杂度也是O(n+m)，但我们之所以在掌握了Kosaraju算法后仍要学习Tarjan算法的主要原因有以下三点：</p><ul><li>Tarjan算法效率比Kosaraju算法高大概30%，所以Kosaraju可能会被卡常。</li><li>Kosaraju算法利用递归实现，可能会爆栈；而Tarjan则不会（因为根本没递归）。</li><li>Tarjan算法还可以通过拓展解决求割点、割桥以及2-SAT等问题。</li></ul><p>实际上如果出题人有这个想法，那么就不是可能会超时，是一定会超时；不是可能会爆栈，是一定会爆栈，所以还是要掌握该算法的。</p><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>Tarjan算法是基于对图深度优先搜索（DFS）的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个栈，回溯时可以判断栈顶到栈中的节点是否构成一个强连通分量。<br>我们定义DFS过程中遇到的<strong>四种边</strong>：</p><ul><li>树枝边：DFS时经过的边，即DFS搜索树上的边。</li><li>前向边：与DFS方向一致，从某个节点指向其某个子孙的边。</li><li>后向边：与DFS方向相反，从某个节点指向其某个祖先的边。</li><li>横向边：从某个节点指向搜索树中另一子树中的某节点的边。</li></ul><p><strong>定义DFN(u)</strong> 为节点 u 的搜索次序编号（时间戳），Low(u) 为u 或者u 的子树能够回溯到的最早的栈中节点的DFN值。</p><p>根据定义我们可以得出：</p><ul><li>如果(u , v)为树枝边，u 为 v 的父节点，则 Low(u) = min{ Low(u) , Low(v) }。</li><li>如果(u , v)为后向边或指向栈中节点的横叉边，则Low(u) = min{ Low(u) , DFN(v) }。</li></ul><p>当节点u的搜索过程结束后，若DFN(u) = Low(u)，则以u为根的搜索子树上所有还在栈中的节点（即u和栈中在u之后的所有节点）是一个强连通分量，可退栈。通俗的说，若u为强连通分量的根，那么它的子孙中的最高最先应该就是它本身。</p><h5 id="算法的主要过程"><a href="#算法的主要过程" class="headerlink" title="算法的主要过程"></a>算法的主要过程</h5><p><strong>数组的初始化：</strong> 当首次搜索到点 u 时，DFN(u)为节点u的搜索次序编号（时间戳）。<br><strong>堆栈：</strong> 将u压入堆栈。<br><strong>更新Low(u)：</strong> </p><ol><li>如果（u，v）为树枝边（v不在栈中），u为v的父节点，则Low(u) = min{Low(u) , Low(v)}。</li><li>如果（u，v）为后向边或者指向栈中节点的横叉边（v在栈中），则Low(u) = min{ Low(u) DFN(v)}。</li><li>如果u的子树已经全部遍历后Low(u) = DFS(u)，则将u和<strong>栈中在u之后的所有节点</strong> 弹出栈。这些出栈的元素组成一个强连通分量。</li><li>继续搜索（或许会更换搜索的起点，因为整个有向图可能分为多个不连通的部分），直到所有点被遍历。</li></ol><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>见附录部分code-2：POJ2182（Tarjan算法）</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>董永建，信息学竞赛一本通提高版，福州：福建教育出版社，2018.6，155-178</li><li>秋叶拓哉，挑战程序设计竞赛第2版，北京：人民邮电出版社，2013.6，320-324</li></ul><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p><strong>code-1：Kosaraju算法模板（POJ2182）</strong><br>求所有“红牛”总数。（红牛即所有牛的偶像）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span>*N;</span><br><span class="line"><span class="comment">//建立有向图的同时建立它的反图</span></span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],edge[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> rhead[N],rver[M],rnex[M],redge[M],rtot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">rver[++rtot] = x,rnex[rtot] = rhead[y]; rhead[y] = rtot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* co[x]:节点x所属强连通的id,col则是用于计数</span></span><br><span class="line"><span class="comment">ts[x]:结束时间为x的节点编号,clk用于计数 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,cnt[N],deg[N];</span><br><span class="line"><span class="keyword">int</span> co[N],col,ts[N],clk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">co[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])</span><br><span class="line"><span class="keyword">if</span>(!co[ver[i]]) dfs(ver[i]);</span><br><span class="line">ts[++clk] = x;<span class="comment">//第 clk 个结束的是x</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rdfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">co[x] = col; ++cnt[col];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = rhead[x]; i ;i = rnex[i])</span><br><span class="line"><span class="keyword">if</span>(!co[rver[i]]) rdfs(rver[i],col);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Korasaju</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!co[i]) dfs(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) co[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i ;--i) </span><br><span class="line"><span class="keyword">if</span>(!co[ts[i]]) rdfs(ts[i],++col);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">Korasaju();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>;x &lt;= n;x++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])</span><br><span class="line"><span class="keyword">if</span>(co[x] != co[ver[i]]) deg[co[x]]++;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++)</span><br><span class="line"><span class="keyword">if</span>(!deg[i] &amp;&amp; ans)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"0"</span>); <span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!deg[i]) ans = cnt[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>code-2：POJ2182（Tarjan算法模板）</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],nex[M],edge[M],tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y; edge[tot] = z;</span><br><span class="line">nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* co[x]:节点x所属强连通的id,col则是用于计数</span></span><br><span class="line"><span class="comment">dfn[x]:为x的dfs序,clk用于计数</span></span><br><span class="line"><span class="comment">low[x]:节点x所能到达的所有节点中最小的dfs序 */</span></span><br><span class="line"><span class="keyword">int</span> co[M],col,dfn[N],clk,low[N];</span><br><span class="line"><span class="keyword">int</span> deg[N],Stack[N],top,cnt[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">low[x] = dfn[x] = ++clk;<span class="comment">//首先初始化low = dfn</span></span><br><span class="line">Stack[++top] = x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[y]) Tarjan(y), low[x] = min(low[x],low[y]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!co[y]) low[x] = min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[x] == dfn[x])<span class="comment">//找到一个以x为根的强连通分量</span></span><br><span class="line"><span class="keyword">for</span>(++col;Stack[top+<span class="number">1</span>] != x;top--)</span><br><span class="line">co[Stack[top]] = col,cnt[col]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>;x &lt;= n;x++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])</span><br><span class="line"><span class="keyword">if</span>(co[x] != co[ver[i]]) deg[co[x]]++;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= col;i++)</span><br><span class="line"><span class="keyword">if</span>(!deg[i] &amp;&amp; ans)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"0"</span>); <span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!deg[i]) ans = cnt[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">addEdge(x,y,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 强连通分量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差分约束系统</title>
      <link href="/2019/08/12/chafen/"/>
      <url>/2019/08/12/chafen/</url>
      
        <content type="html"><![CDATA[<h4 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h4><p>差分约束系统是一种特殊的N元一次不等式组，它包含N个变量$X_1 - X_N$以及M个约束条件，每个约束条件都是由两个变量作差构成的，形如$X_i - X_j &lt;= C_k$，其中$C_k$是常数（可以为负），1&lt;= i , j &lt;= N, 1 &lt;= k &lt;= M。我们要解决的问题是：求一组解，$X_1 = a_1, X_2 = a_2 ,… , X_N = a_N$使得所有约束条件都得到满足。</p><p>差分约束系统的每个约束条件$X_i - X_j &lt;= C_k$ 可以变形为$X_i &lt;= X_j + C_k$，这与单源最短路中的三角不等式 dis[ y ] &lt;= dis[ x ] + z非常类似，因此可以把每个变量X_i 看作有向图中的一个节点 i ，对于每个约束条件$X_i - X_j &lt;= C_k$ ， 从节点j 向节点 i 连一条长度为 $C_k$ 的有向边。</p><p>注意到如果集合A是一组解，那么A+d也是一组解（作差后d被消掉）。</p><p>设dis[0] = 0，以0为起点求单源最短路，若图中存在负环则差分约束系统无解。否则，$X_i = dis[i]$ 就是差分约束系统的一组解。</p><p>在某些题目中，$X_i - X_j &gt;= C_k$，仍可以看作是从 j 到 i 连成长度为 $C_k$的有向边，只是改为计算单源<strong>最长路径</strong>，若图中存在正环则无解。当然也可以不等式两边同时取负，使得变换成标准形式。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>差分约束是基于三角不等式的一个推广。关键在于根据题意构造出恰当的状态，建立状态间的不等关系，并证明满足不等式的一个解与原问题一一对应，然后便可以利用SPFA算法求解。其优点是不等式关系明显，易于理解，缺点是适用性窄。</p><h4 id="例题模板"><a href="#例题模板" class="headerlink" title="例题模板"></a>例题模板</h4><p><a href="http://ybt.ssoier.cn:8088/index.php" target="_blank" rel="noopener">Zju1420 出纳员问题</a><br><strong>题意简述：</strong><br>有一家24小时营业的超市，需要雇佣一批出纳员。一天中每个小时需要出纳员的最少数量为R0,R1,R2,…,R23。有N个人申请这项工作，每个申请者，从一个特定时刻Ti,开始连续工作恰好8个小时。(Ti为整数，且0&lt;=Ti&lt;=23 )。你的任务是计算出需要雇佣出纳员的最少数目，满足在每一时刻k，至少有Ri名出纳员在工作。</p><p><strong>解题思路：</strong><br>真的有点难想啊，首先我们要假设num[i] 为 i 时刻能够开始工作的人数，x[i] 为实际雇佣人数，那么x[i] &lt;= num[i] 。而R[i]是i 时刻至少需要的人数，这由题目给出。<br>我们令s[i] = x[i] + x[i-1] + … + x[1] ，显然我们就会得到关于 s 和 num 的一组不等式，如果想要答案正确，需要找到所有隐含的条件：</p><p>s[i] - s[i-1] &gt;= 0     //(0 &lt;= i &lt;= 23)<br>s[i-1] - s[i] &gt;= -num[i] //  (0&lt;=i&lt;=23)<br>s[i] - s[i-8] &gt;= r[i]    //(8&lt;=i&lt;=23)<br>s[i] - s[i+16] &gt;= r[i] - s[23] //  (0 &lt;= i &lt;= 7)</p><p>注意到，s[23]本是未知数，但是我们将它作为常数处理，具体做法是我们遍历s[23]的所有可能的值，并依次进行一次SPFA，尝试找寻雇佣最小人数 且使得不等式组成立的可能。 注意如果 i 从0开始，那么邻接表存有向图，head节点就不能初始化为0，防止死循环超时。</p><p><strong>代码示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,R[<span class="number">30</span>],num[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N],edge[N],nex[N],tot;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">100</span>],vis[<span class="number">100</span>],ts[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y,edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x],head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 返回此时是否有解 */</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(ts,<span class="number">0</span>,<span class="keyword">sizeof</span> ts);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++) dis[i] = -INF;</span><br><span class="line">    q.push(<span class="number">0</span>);dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    vis[<span class="number">0</span>] = <span class="literal">true</span>;ts[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">        vis[x] = <span class="literal">false</span>;ts[x]++;</span><br><span class="line">        <span class="keyword">if</span>(ts[x] &gt; <span class="number">24</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i ;i = nex[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> y = ver[i], z = edge[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[y] &lt; dis[x] + z)&#123;</span><br><span class="line">                dis[y] = dis[x] + z;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y]) q.push(y),vis[y] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//printf("%d %d %d\n",x,y,dis[x]);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[<span class="number">24</span>] == s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 返回当s[24] = z时是否有解*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head);tot = <span class="number">1</span>;</span><br><span class="line">    addEdge(<span class="number">0</span>,<span class="number">24</span>,z);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">24</span>;i++)</span><br><span class="line">        addEdge(i<span class="number">-1</span>,i,<span class="number">0</span>), addEdge(i,i<span class="number">-1</span>,-num[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">9</span>;i &lt;= <span class="number">24</span>;i++) addEdge(i<span class="number">-8</span>,i,R[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">8</span>;i++) addEdge(i+<span class="number">16</span>,i,R[i]-z);</span><br><span class="line">    <span class="keyword">return</span> SPFA(z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span> num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">24</span>;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,R+i);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x),num[x+<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)</span><br><span class="line">            <span class="keyword">if</span>(solve(i))&#123;</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i),flag = <span class="literal">false</span>; </span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">puts</span>(<span class="string">"No Solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>董永建，信息学竞赛一本通提高版，福州：福建教育出版社，2018.6，155-161</li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pollard_rho算法</title>
      <link href="/2019/08/11/pollard-rho/"/>
      <url>/2019/08/11/pollard-rho/</url>
      
        <content type="html"><![CDATA[<h3 id="Pollard’s-rho算法"><a href="#Pollard’s-rho算法" class="headerlink" title="Pollard’s rho算法"></a>Pollard’s rho算法</h3><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>Pollar’s Rho算法是一种用于分解质因数的算法，对于一个被分解的数N，假设N的最小质因数为p（$p \neq N$），那么Pollar’s Rho算法能够在$O(\sqrt N * α(N))$的期望时间复杂度内将N分解为两个不是1的数的乘积，其中α(N)是求解两个数的gcd时间复杂度，并且该算法对于空间要求很低。</p><p>首先要明确的是，Pollar’s Rho 算法是随机算法，其基于Miller-Rabin算法，一般在求大整数的唯一分解时会用到，因为 <em>试除法</em> $^{[1]}$的$O(\sqrt N)$复杂度太高。</p><p>本文将首先从算法的适用模型讲起，详细介绍算法流程，最后会给出一道例题以及详细注释了的代码模板，当然还有模板的使用说明。</p><p><em>[1]试除法：一种将整数唯一分解成质因数乘积的方法，时间复杂度为$O(\sqrt N)$</em></p><h4 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h4><p>该算法最早于1975年由John M. Pollard提出，而Richard Brent于1980年提出了改进版本。虽然不是目前最快的算法，但它要比试除法快上多个量级。实现它的思想同样可以用于其他地方。</p><p><strong>问题模型：</strong> 给定一个整数n，试着将n分解为若干素数相乘的形式。n小于$2^{60}$。</p><p><strong>分析：</strong> 如果用试除法，显然时间复杂度过高，现在我们希望得到一个快速的方法；类比大素数判断的Miller-Rabin算法，Miller-Rabin算法依靠着费马小定理以及二次检测定理实现了快速判断一个大整数是否为素数的算法，实际上对于大整数的唯一分解也同样有着类似的巧妙的算法，就是本文介绍的Pollard’s rho算法。</p><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><p><strong>基本思路：</strong><br>对于给定的一个整数n，显然如果n为素数（Miller-Rabin算法判断），那么算法结束，返回唯一素因子n。</p><p>否则，pollard’s rho算法会试着找到当然数n的一个因子a（a并不一定是素数），然后递归 Pollard_rho( a ) 和 Pollard_rho( n/a ) ，即将n分为了两个部分，将原问题变成了规模更小的两个子问题。</p><p><strong>如何求因子a？</strong><br>一般情况下可能会本能的想到枚举，但这样过于耗时。寻找因子是该算法中最重要的一步，该算法中采用随机化算法来查找因子a。假设此时n仅有2个因子 p 和 q，那么如果我们用随机数来找n的因子，成功率为1/n。接下来我们思路是如何提升成功率。</p><p>寻找一个因子a，等价于寻找是否存在k个数，使得其中有$x_i - x_j = a$，由于<strong>生日悖论</strong> 我们可以得知当k = $\sqrt N$时，该概率是50%，所以我们将可能性从$\frac{1}{n}$提升到了$\sqrt{\frac{1}{n}}$。</p><p>但不幸的是对于10位的整数，k = 1e5时，仍要做$k^2 = 10^{10}$次比较，幸运的是，还有更好的方法。</p><p>我们仍然选取k个数：$x_1,x_2,…,x_k$，但我们不再询问是否存在$x_i - x_j$可以整除n，转而询问是否存在 $gcd( x_i - x_j , n) &gt; 1$ 的情况。换句话说，我们问$x_i - x_j$和n是否存在一个平凡的最大公约数。</p><p>如果我们询问有多少个整数能整除n，那么答案显然只有两个：p和q。<br>但是如果我们问有多少个数使得gcd($x_i-x_j$) &gt; 1，答案便很多了，如：p, 2p, 3p, 4p, … , (q-1)p , q , 2q ,…,(p-1)q。准确的说，有p+q-2个。</p><p><strong>所以，一个简单的策略如下：</strong></p><ul><li>在区间[2 , n-2]中随机选 k 个数，$x_1,x_2,x_3,…,x_k$。</li><li>判断是否存在gcd($x_i - x_y$,n) &gt; 1，若存在，gcd($x_i - x_y$,n) 是n的一个因子（p或q）。</li></ul><p>但是这样还有一个问题，就是我们大约要选取$n^{1/4}$个数，数量还是太大，以至于不能存放在内存中。</p><p><strong>Pollard’s rho算法的解决策略：</strong><br>为了解决无法储存太多数的问题，Pollard’s rho Algorithm只将两个数存放在内存中。具体思路是：我们并不随机生成k个数并两两比较，而是一个一个地生成并检查连续的两个数。反复执行这个步骤并希望能够得到我们想要的数。</p><p>我们使用一个函数来生成伪随机数。<br>换句话说，我们不断使用一个函数f来生成（可以这样形容）随机数。当然并不是所有的函数都能这样做，但是有一个函数可以：<br>&emsp;&emsp;&emsp;&emsp;$f(x) = (x^2 + a) mod N$<br>（其中的 a 可以用随机数生成，当然这不是讨论的重点。）<br>我们从$x_1 = 2$开始，让$x_2 = f(x_1) , x_3 = f(x_2),…….$，通项为：$x_{n+1} = f(x_n)$<br>于是顺着这个策略，依据上述分析，不断判断gcd($x_n - x_{n-1}$, n)是否大于1即可。</p><p><strong>存在的问题：</strong><br>大多情况下，这种算法是可以正常运行的，但是对于某些数据，会出现无线的死循环，原因在于函数f存在自环。<br>于是问题变成了“如何判断环的出现”。一种方法是记录所有出现过的数，当然这会耗费大量内存，故舍弃；另一种方法是Floyd发明的算法，这里可以举一个有趣的例子说明“假设A和B在一个很长的圆形轨道上走，那么我们如何判断B是否走完一圈呢？我们可以让B的速度是A的二倍，他们同时出发，当B第一次追上A，就知道B至少已经走了一圈”，同样的道理运用到该算法中，框架如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = 2;</span><br><span class="line">b = 2;</span><br><span class="line">while(b != a)&#123;</span><br><span class="line">a = f(a);//一倍速 </span><br><span class="line">b = f(f(b));//二倍速</span><br><span class="line">p = GCD(|b-a| , n);</span><br><span class="line">if(p &gt; 1) return &quot;Found factor: p&quot;; </span><br><span class="line">&#125;</span><br><span class="line">return &quot;Failed&quot;;</span><br></pre></td></tr></table></figure></p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>简单梳理一下，给出主要框架而不涉及理论证明。<br>假设 n 为待分解的数，我们将分解出来的所有因子存放在factors[110]数组中，当然存放的是无序的素因子。<br><strong>findFac( long long n) 函数：</strong><br>负责将 n 分解成素因子相乘的形式，并将结果存放在factors数组中。</p><ul><li>如果n本身就是素数，那么将n存放在factor便可结束并返回。</li><li>如果n不是素数，那么通过 pollard_rho()函数 找到n的一个因子p(不一定是素因子)，递归findFac(p)和findFac(n/p)</li></ul><p><strong>pollard_rho(long long x, long long a)函数：</strong><br>返回x的一个因子（不一定是素数），若失败则返回x。<br>利用Floyd发明的类似“二倍速的算法”，具体参考上述伪代码。</p><p><strong>注：</strong> 当然还有一些辅助函数，例如快速幂、Miller-Rabin算法、欧几里得算法等。</p><h4 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------------------------------------</span></span><br><span class="line"><span class="comment"> POJ 1811 </span></span><br><span class="line"><span class="comment"> 最后更新：2019/8/11</span></span><br><span class="line"><span class="comment"> 说明：该代码包含了取随机值函数rand()以及求最小值函数min()</span></span><br><span class="line"><span class="comment"> 注：适用范围是2^61,至少要保证中间结果不会溢出long long</span></span><br><span class="line"><span class="comment"> (中间结果最多是2*n)</span></span><br><span class="line"><span class="comment"> ----------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">/*---------------------------------------------</span></span><br><span class="line"><span class="comment"> 利用 Miller-Rabin进行素性测试</span></span><br><span class="line"><span class="comment"> ----------------------------------------------*/</span></span><br><span class="line"><span class="keyword">int</span> testnum[] = &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">61</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">19</span>&#125;;</span><br><span class="line"><span class="function">ll <span class="title">fmul</span><span class="params">(ll a,ll b,ll p)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*返回a * b % p*/</span></span><br><span class="line">    a %= p,b %= p;          <span class="comment">//防止超出精度</span></span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res += a, res %= p;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;            <span class="comment">//a = a*2</span></span><br><span class="line">        <span class="keyword">if</span>(a &gt;= p) a %= p;  </span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;            <span class="comment">//b = b/2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b,ll p)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*返回a^b % p*/</span></span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = fmul(res,a,p);</span><br><span class="line">        a = fmul(a,a,p);</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*Miller-Rabin判定x是否为素数*/</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span> || n%<span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ll d = n<span class="number">-1</span>, a, x, y;<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((d&amp;<span class="number">1</span>) == <span class="number">0</span>) d &gt;&gt;= <span class="number">1</span>,t++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">7</span>;i++)&#123;</span><br><span class="line">        a = testnum[i];</span><br><span class="line">        <span class="keyword">if</span>(n == a) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        x = qpow(a,d,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; t;j++)&#123;</span><br><span class="line">            y = fmul(x,x,n);</span><br><span class="line">            <span class="keyword">if</span>(y == <span class="number">1</span> &amp;&amp; x != <span class="number">1</span> &amp;&amp; x != n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            x = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*---------------------------------------------</span></span><br><span class="line"><span class="comment"> 利用 pollard rho 算法进行质因数分解 </span></span><br><span class="line"><span class="comment"> ----------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">ll factors[<span class="number">110</span>];    <span class="comment">//用来存放被分解的因数(无序)</span></span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;        <span class="comment">//因子个数</span></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 返回a和b的最大公约数 */</span></span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; <span class="number">0</span>) <span class="keyword">return</span> gcd(-a,b);</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        ll t = a%b;</span><br><span class="line">        a = b; b = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">pollard_rho</span><span class="params">(ll x,ll c)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 返回 x 的一个因子或 x 本身 */</span></span><br><span class="line">    ll i = <span class="number">1</span>,k = <span class="number">2</span>;</span><br><span class="line">    ll tx = rand()%x;</span><br><span class="line">    ll y = tx;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        tx = (fmul(tx,tx,x)+c)%x;</span><br><span class="line">        ll d = gcd(y-tx,x);</span><br><span class="line">        <span class="keyword">if</span>(d != <span class="number">1</span> &amp;&amp; d != x) <span class="keyword">return</span> d;</span><br><span class="line">        <span class="keyword">if</span>(y == tx) <span class="keyword">return</span> x;       <span class="comment">//寻找失败</span></span><br><span class="line">        <span class="keyword">if</span>(i == k) y = tx, k += k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findFac</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 对 n 进行质因数分解 */</span></span><br><span class="line">    <span class="keyword">if</span>(isPrime(n))&#123;</span><br><span class="line">        factors[++tot] = n;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll p = n;</span><br><span class="line">    <span class="comment">/* 通过pollard_rho算法找到 n 的一个因子 p */</span></span><br><span class="line">    <span class="keyword">while</span>(p &gt;= n) p = pollard_rho(p,rand()%(n<span class="number">-1</span>)+<span class="number">1</span>);</span><br><span class="line">    findFac(p);     <span class="comment">//递归分解</span></span><br><span class="line">    findFac(n/p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;ll n,ans;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">if</span>(isPrime(n)) <span class="built_in">puts</span>(<span class="string">"Prime"</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tot = <span class="number">0</span>; ans = <span class="number">1e18</span>; findFac(n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot;i++) ans = <span class="built_in">std</span>::min(ans,factors[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>划分树模板</title>
      <link href="/2019/08/11/hfs/"/>
      <url>/2019/08/11/hfs/</url>
      
        <content type="html"><![CDATA[<h3 id="划分树笔记"><a href="#划分树笔记" class="headerlink" title="划分树笔记"></a>划分树笔记</h3><h4 id="问题模型："><a href="#问题模型：" class="headerlink" title="问题模型："></a>问题模型：</h4><blockquote><p>对于给定的n个元素的序列A，有m次询问，每次询问给L ，R，K，请求出位于[L,R]内第K大的数。</p></blockquote><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p><strong>朴素算法：</strong><br>用快速排序。由于我们有m次询问，而每次询问区间左右端点是不同的，故如果对每个询问进行排序，我们在得到答案后还需要将序列恢复原状。按照快速排序的效率O(nlgn)，m次询问就是O(mnlgn)。如果m和n都很大，效率就低的可怜。<br><strong>划分树：</strong><br>由于划分树是基于线段树的一种数据结构，所以先回忆一下线段树。线段树是将一个区间划分成若干单元区间，并用二叉树结构储存，因而可以快速修改和查询。划分树是对一个序列进行划分，每个序列有两个子序列，左子序列中的元素不大于右子序列所有元素。<br>如果我们用一个数组tree[25][MAXN]来存放每层对应位置的元素；创建toLeft[25][MAXN]，其中toLeft[dep][i]表示第dep层第1~i个元素有多少个进入左子序列。假设我们原始序列区间为[L,R]（初始时是[1,n]），而我们要找到[l,r]中第k大的数; <strong>设cnt = toLeft[r] - toLeft[l-1]，那么说明[l,r]区间内前cnt小的数都在左子序列，所以我们下一步就可以根据k和cnt的大小关系选择走左子序列或右子序列，直至找到该元素。</strong> </p><h4 id="建树："><a href="#建树：" class="headerlink" title="建树："></a>建树：</h4><p><strong>建树思路：</strong><br>建树过程很简单，和线段树类似，将一个大区间划分成若干单位区间，这里单位区间是只有一个元素时。加上我们之前说了，划分树的 左子区间所有元素 小于 右区间的元素，而为了树的平衡（平衡才是效率的保证！），所以我们可以取一个<strong>中位数</strong>，将当前区间中所有小于中位数的放在左子序列，反之放在右子序列。如此反复二分递归直至当前区间只有一个元素终止。<br>之前我们开数组时，只开了25层，即tree[25][MAXN]，因为如果我们的树构建的足够好（左右子树元素个数相近），那么1e5规模下树顶多20层。（这里我将树的术语和序列、区间混用，因为我们是用数组模拟建树，所以本质上没什么不同，重要的是逻辑结构而不是物理结构）<br><strong>中位数不唯一：</strong><br>我们说了左右子树元素个数相近的树才是最够好的树，因为这样树的深度最小，而我们查询操作和树的深度成正比。如果中位数唯一，那么很显然左右子区间元素个数最多相差1；如果不唯一，根据我们的定义，左子区间放小于中位数的数，这样可能造成左右子区间元素个数相差过大（考虑1，2，2，2，2，2，2，2，3），所以我们需要一个策略来在这种情况下保证数仍然平衡。<br>想要树平衡，只需让左右子树元素个数相近就行了，假设当前区间有N个元素，那么就要分给左子区间N/2个，剩下的分给右区间。所以我们设same = N/2，如果我们将当前区间所有小于中位数的元素都分给了左子区间，但是same仍不为0，那么我们就要再分same个中位数给左子区间，然后再将剩下的数分给右子区间。如此一来左子区间元素个数为same，右子区间也为N-same，最大相差1。</p><h4 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h4><p>对于查询，我们需要知道6个信息：当前区间的左右端点[L,R]，需要查询的区间[l,r]，当前区间所在的层数dep，以及k。<strong>我们想知道在区间[L,R]内的小区间[l,r]内第k大的数是谁。</strong><br>设cnt = toLeft[dep][r] - toLeft[dep][l-1]，那么说明[l,r]区间内前cnt小的数都在左子序列，所以我们下一步就可以根据k和cnt的大小关系选择走左子序列或右子序列，直至找到该元素。具体实现时，我们还需要考虑L和R如何变化，以及子区间内l和r以及k如何变化（即如何缩小可行区间），详情请参照代码理解。</p><h4 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">划分树模板</span></span><br><span class="line"><span class="comment">创建于：2019/4/10</span></span><br><span class="line"><span class="comment">最后更新：2019/4/10 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">20</span>][MAXN];<span class="comment">//表示每层每个位置的值 </span></span><br><span class="line"><span class="keyword">int</span> toLeft[<span class="number">20</span>][MAXN]; <span class="comment">//已经排好序的数 </span></span><br><span class="line"><span class="comment">//toLeft[dep][i]为dep层[1,i]有几个节点分到左子区间 </span></span><br><span class="line"><span class="keyword">int</span> sorted[MAXN];</span><br><span class="line"><span class="comment">//当前序列的左右端点、层数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> same = mid - l + <span class="number">1</span>;<span class="comment">//用于处理多个中位数相等 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt;= r;i++) </span><br><span class="line"><span class="keyword">if</span>(tree[dep][i]  &lt; sorted[mid]) same--;</span><br><span class="line"><span class="keyword">int</span> lpos = l;</span><br><span class="line"><span class="keyword">int</span> rpos = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt;= r;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[dep][i] &lt; sorted[mid]) tree[dep+<span class="number">1</span>][lpos++] = tree[dep][i];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tree[dep][i] == sorted[mid] &amp;&amp; same &gt; <span class="number">0</span>)&#123;</span><br><span class="line">tree[dep+<span class="number">1</span>][lpos++] = tree[dep][i];</span><br><span class="line">same--;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">tree[dep+<span class="number">1</span>][rpos++] = tree[dep][i];</span><br><span class="line">&#125;</span><br><span class="line">toLeft[dep][i] = toLeft[dep][l<span class="number">-1</span>] + lpos - l;</span><br><span class="line">&#125;</span><br><span class="line">build(l,mid,dep+<span class="number">1</span>);</span><br><span class="line">build(mid+<span class="number">1</span>,r,dep+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询区间第K大的数，[L,R]是大区间，[l,r]是要查询的小区间 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> dep,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span> tree[dep][l];</span><br><span class="line"><span class="keyword">int</span> mid = (L+R)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = toLeft[dep][r] - toLeft[dep][l<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(cnt &gt;= k)&#123;</span><br><span class="line"><span class="keyword">int</span> newl = L + toLeft[dep][l<span class="number">-1</span>] - toLeft[dep][L<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> newr = newl + cnt - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> query(L,mid,newl,newr,dep+<span class="number">1</span>,k);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> newr = r + toLeft[dep][R] - toLeft[dep][r];</span><br><span class="line"><span class="keyword">int</span> newl = newr - (r-l-cnt);</span><br><span class="line"><span class="keyword">return</span> query(mid+<span class="number">1</span>,R,newl,newr,dep+<span class="number">1</span>,k-cnt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//n个元素，m次询问 </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tree[<span class="number">0</span>][i]);</span><br><span class="line">sorted[i] = tree[<span class="number">0</span>][i];</span><br><span class="line">&#125; </span><br><span class="line">sort(sorted+<span class="number">1</span>,sorted+n+<span class="number">1</span>);</span><br><span class="line">build(<span class="number">1</span>,n,<span class="number">0</span>);<span class="comment">//左闭右闭 </span></span><br><span class="line"><span class="keyword">int</span> s,t,k;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;s,&amp;t,&amp;k);</span><br><span class="line"><span class="comment">//在1~n位置中找到s~t位置内第k大的数 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(<span class="number">1</span>,n,s,t,<span class="number">0</span>,k));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cdq分治</title>
      <link href="/2019/08/11/cdq/"/>
      <url>/2019/08/11/cdq/</url>
      
        <content type="html"><![CDATA[<h2 id="CDQ分治笔记"><a href="#CDQ分治笔记" class="headerlink" title="CDQ分治笔记"></a>CDQ分治笔记</h2><h3 id="1-结论"><a href="#1-结论" class="headerlink" title="1.结论"></a>1.结论</h3><ul><li>CDQ分治可以用来解决偏序问题，尤其对于三维偏序问题适用。</li><li>CDQ分治重要思想：计算一个子问题对另一个子问题的贡献。</li><li>CDQ分治的优劣：写起来较为简单，对时空有很大的优化；缺点是必须离线操作。</li></ul><h3 id="2-二维偏序问题"><a href="#2-二维偏序问题" class="headerlink" title="2.二维偏序问题"></a>2.二维偏序问题</h3><h4 id="2-1逆序对"><a href="#2-1逆序对" class="headerlink" title="2.1逆序对"></a>2.1逆序对</h4><p><strong>逆序对:</strong> </p><blockquote><p>&emsp;&emsp;设 A 为一个有 n 个数字的有序集 (n&gt;1)，其中所有数字各不相同。如果存在正整数 i, j 使得 1 ≤ i &lt; j ≤ n 而且 A[i] &gt; A[j]，则 <a[i], a[j]> 这个有序对称为 A 的一个逆序对，也称作逆序数。</a[i],></p><p>例如，数组（3，1，4，5，2）的逆序对有(3,1),(3,2),(4,2),(5,2)，共4个。<br>所谓逆序对的问题，即对给定的数组序列，求其逆序对的数量。</p></blockquote><p><strong>逆序对求解:</strong><br>&emsp;&emsp;正如我们在归并排序章节所接触的那样，我们可以通过模仿归并排序来求解逆序对，具体请复习归并排序相关内容。<br>&emsp;&emsp;在用归并排序过程中，我们求逆序对的过程可以看作：找到一对数，使得 i  &lt; j , 且 a[i] &gt; a[j]。这里实际上是二位偏序问题，因为我们涉及到两个维度的比较，即下标大小（默认升序）和值。在用归并思想求逆序对，我们是根据”左区间的下标必然小于右区间的下标“这个结论来归并统计逆序对的，也就是说我们忽略了“下标”这个维度的影响，将二维偏序问题降到了一维。<br><strong>逆序对问题的启发:</strong><br>&emsp;&emsp;现在我们将问题给出：“求所有满足a &lt; a0 且 b &gt; b0的有序对<a,b>和<a0,b0>”。<br>&emsp;&emsp;我们可以发现上述问题和逆序对有相似处也有不同之处。相似在于他们都是求偏序问题，具体说都是求二维偏序问题；不同之处在于逆序对问题中，数组下标是默认升序的，故可以直接归并求解，而上述问题并没有说所有数对按照什么规则排序，说白了其就是乱序的。<br>&emsp;&emsp;但实际上我们考虑到二维偏序问题，由于我们是在一个数对集合（假设为S）中找所有满足a &lt; a0 且 b &gt; b0的有序对<a,b>和<a0,b0>的集合T，那么S集合内元素的排序规则实际上对最终结果集合T毫无影响，所以我们可以将S集合内的数对按照a升序排列，这样就将二维比较降到一维，接下来就可以类似求逆序对一样使用归并思想求解了。<br><strong>如下表所示，一个是按照a升序排列，一个是乱序，其最终结果相同</strong><br>表1：S集合中数对<a,b>按照a升序排列</a,b></a0,b0></a,b></a0,b0></a,b></p><div class="table-container"><table><thead><tr><th>a</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>b</td><td>4</td><td>3</td><td>2</td><td>5</td><td>1</td></tr></tbody></table></div><p>表2：S集合中数对<a,b>乱序排列</a,b></p><div class="table-container"><table><thead><tr><th>a</th><th>1</th><th>3</th><th>5</th><th>4</th><th>2</th></tr></thead><tbody><tr><td>b</td><td>4</td><td>2</td><td>1</td><td>5</td><td>3</td></tr></tbody></table></div><p>结果集合T:</p><div class="table-container"><table><thead><tr><th>a</th><th>b</th><th>a0</th><th>b0</th></tr></thead><tbody><tr><td>1</td><td>4</td><td>2</td><td>3</td></tr><tr><td>1</td><td>4</td><td>3</td><td>2</td></tr><tr><td>2</td><td>3</td><td>3</td><td>2</td></tr><tr><td>1</td><td>4</td><td>5</td><td>1</td></tr><tr><td>2</td><td>3</td><td>5</td><td>1</td></tr><tr><td>3</td><td>2</td><td>5</td><td>1</td></tr><tr><td>4</td><td>5</td><td>5</td><td>1</td></tr></tbody></table></div><h4 id="2-2-CDQ分治求二维偏序"><a href="#2-2-CDQ分治求二维偏序" class="headerlink" title="2.2 CDQ分治求二维偏序"></a>2.2 CDQ分治求二维偏序</h4><p>&emsp;&emsp;如果上面的问题你看懂了，那么其实二维的CDQ分治你就已然了解了。将上述问题的解题思路总结起来，就是：<strong>先按照一维排序，再按照另一维归并求结果集合T。</strong> 在上述做法中，我们的核心思想是使得一个维度（假设为a）对最终结果变得毫无影响，这样我们就只需要在另一维（假设为b）考虑比较即可，此时就可以用归并了。</p><h4 id="2-3-二维偏序问题的拓展"><a href="#2-3-二维偏序问题的拓展" class="headerlink" title="2.3 二维偏序问题的拓展"></a>2.3 二维偏序问题的拓展</h4><p>&emsp;&emsp;我们在上述讨论的是求满足条件的有序对集合T的问题。但我们可以拓展一下，如果我们将一个有序对<a,b>看作某个数据的下标，（一个数据有俩个属性组成码）那么我们是不是就可通过求解满足条件的集合T，并通过集合T中的所有有序对，找到对应的数据呢？是的，我们可以通过归并的方法来快速找到我们想要的数据集合。<br><strong>考虑如下问题：</strong> </a,b></p><blockquote><p>给定一个N个元素的序列A，初始值全部为0，对这个序列进行以下两种操作：<br>　　操作1：格式为1 x k，把位置x的元素加上k（位置从1标号到N）。<br>　　操作2：格式为2 x y，求出区间[x,y]内所有元素的和。</p></blockquote><p><strong>解题思路：</strong><br>&emsp;&emsp;上述问题是树状数组的裸题，但我们用来练习CDQ分治，并进一步了解其思想。考虑到给我们的操作集合（设为Q）是有先后顺序的（例如先修改，再查询，那么我们就要先修改值再查询），<strong>我们假设其到来的时间为time，那么Q集合中所有元素就都是按照time属性默认升序的了。</strong> 但是仅仅一个time属性还不足以表示所有操作，我们再考虑给每个操作加一个属性：pos来代表操作的位置。<strong>那么每个操作就可由time和pos来唯一标识，</strong> 至于操作是什么操作（是操作1还是操作2？）暂不探究。<br>&emsp;&emsp;<strong>如此一来每个操作q，都有一个下标<time,pos>来唯一标识它。</time,pos></strong> 那么我们就只需先执行time小的，pos靠前的操作，就可以得到答案。（举个例子：假设有俩个操作，1.修改位置2上的值为4，2.求位于区间[1,3]所有数的和。那么我们肯定要先执行1，再执行2）而此时我们又遇到了一个麻烦，操作2区间查询，涉及到两个位置，所以我们可以考虑将操作2区间查询操作分为两个部分，一个是操作a：减去当前位置前缀和；另一个是操作b：加上当前位置的前缀和。<br>&emsp;&emsp;那么我们新建一个结构体Node{ int type,pos,val; } 来代表Q集合中的一个操作。其可能有三种情况，type = 1时代表修改操作，此时将pos位置上的元素+val。type = 2时代表减去pos位置上前缀和的操作，type = 3时表示加上当前位置上前缀和的操作；而对于2、3两种操作，val为着查询答案所在的下标，如此一来就可以将减去前缀和操作和加上前缀和操作结果累加在同一个位置。如此一来我们就可以通过归并来快速求解。<br><strong>代码示例：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">500050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXQ = MAXN*<span class="number">3</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> type,pos;</span><br><span class="line">    ll val;</span><br><span class="line">    Node(<span class="keyword">int</span> type,<span class="keyword">int</span> pos,ll val):type(type),pos(pos),val(val)&#123;&#125;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == b.pos) <span class="keyword">return</span> type &lt; b.type;</span><br><span class="line">        <span class="keyword">return</span> pos &lt; b.pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> aidx = <span class="number">0</span>,qidx = <span class="number">0</span>;</span><br><span class="line">Node query[MAXQ];</span><br><span class="line">Node tmp[MAXQ];</span><br><span class="line">ll ans[MAXQ];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r<span class="number">-1</span>) <span class="keyword">return</span>;<span class="comment">//左闭右开嘛</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    CDQ(l,mid);</span><br><span class="line">    CDQ(mid,r);</span><br><span class="line">    <span class="keyword">int</span> p = l,q = mid,k = <span class="number">0</span>;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; mid &amp;&amp; q &lt; r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(query[p] &lt; query[q])&#123;</span><br><span class="line">            <span class="keyword">if</span>(query[p].type == <span class="number">1</span>)</span><br><span class="line">                sum += query[p].val;</span><br><span class="line">            tmp[k++] = query[p++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> x = query[q].val;</span><br><span class="line">            <span class="keyword">if</span>(query[q].type == <span class="number">2</span>)</span><br><span class="line">                ans[x] -= sum;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(query[q].type == <span class="number">3</span>)</span><br><span class="line">                ans[x] += sum;</span><br><span class="line">            tmp[k++] = query[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; mid) tmp[k++] = query[p++];<span class="comment">//这里不用再累加修改的值，因为用不到了啊 </span></span><br><span class="line">    <span class="keyword">while</span>(q &lt; r)&#123;</span><br><span class="line">    <span class="comment">//这里还需将我们累加的结果进行运算，我们规定就是要累加左区间，查询右区间嘛 </span></span><br><span class="line">        <span class="keyword">int</span> x = query[q].val;</span><br><span class="line">        <span class="keyword">if</span>(query[q].type == <span class="number">2</span>)</span><br><span class="line">            ans[x] -= sum;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(query[q].type == <span class="number">3</span>)</span><br><span class="line">            ans[x] += sum;</span><br><span class="line">        tmp[k++] = query[q++];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++)</span><br><span class="line">        query[i+l] = tmp[i]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        query[qidx++] = Node(<span class="number">1</span>,i,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span>)&#123;</span><br><span class="line">            query[qidx++] = Node(a,b,c);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            query[qidx++] = Node(<span class="number">2</span>,b<span class="number">-1</span>,aidx);</span><br><span class="line">            query[qidx++] = Node(<span class="number">3</span>,c,aidx);</span><br><span class="line">            aidx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CDQ(<span class="number">0</span>,qidx);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; aidx;i++) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-三维偏序问题"><a href="#3-三维偏序问题" class="headerlink" title="3.三维偏序问题"></a>3.三维偏序问题</h3><h4 id="3-1-例题"><a href="#3-1-例题" class="headerlink" title="3.1 例题"></a>3.1 例题</h4><blockquote><p>&emsp;&emsp;已知有n个元素，每个元素有三个属性（ai,bi,ci），现在问存在多少个元素，使得ai &lt; aj 且 bi &lt; bj 且 ci &lt; cj？设f(i) 为对于每个i，满足条件的j的个数。</p><p><strong>解题思路：</strong><br>&emsp;&emsp;和之前的二维偏序问题不同的是，此时我们需要对三个维度进行比较，回想一下对于二维我们的处理方法：先对其中一个维度进行排序，然后采用归并的方法来对第二个维度进行统计。<br>&emsp;&emsp;如果我们还像之前那样操作如何呢？我们按照a进行排序，然后再利用归并对左边区间和右边区间进行合并（我们这里用归并里的说法），在合并的过程中，我们用和求逆序对类似的方法，比较第二个元素（即b）的大小，此时遇到了一个问题：如何处理c。这里我介绍的方法是在处理c时用树状数组，树状数组是用来快速求前缀和，并支持快速单点修改的一个数据结构，所以我们可以<strong>用树状数组来存放小于c的元素的个数，如此一来每次在对右区间进行查找所有小于ci的cj的个数即可。</strong> （因为aj默认小于ai，所以当bj<bi时，找到所有cj<ci即可） &emsp;&emsp;**总结：** 如果理解了cdq处理二维偏序和树状数组，反而觉得三维偏序问题用cdq+树状数组是自然而然。再来归纳一下cdq的特点， 即区间间会相互影响，在上述例题中具体体现是左边的b和c与右边区间的b和c组成最终答案。 **代码示例：** <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">洛谷P3810</span></span><br><span class="line"><span class="comment">CDQ分治写法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,c,val,id;</span><br><span class="line">    <span class="comment">//a,b,c为三维数对的三个元素</span></span><br><span class="line"><span class="comment">//val为出现次数 </span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;B) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == B.a)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b == B.b) <span class="keyword">return</span> c &lt; B.c;</span><br><span class="line">            <span class="keyword">return</span> b &lt; B.b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a &lt; B.a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Node&amp; B) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a == B.a &amp;&amp; b == B.b &amp;&amp; c == B.c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node nodes[maxn];<span class="comment">//进行归并排序时用的数组 </span></span><br><span class="line">Node tmp[maxn];<span class="comment">//归并时用的临时数组 </span></span><br><span class="line">Node aa[maxn];<span class="comment">//读入数组，此数组有重复元素 </span></span><br><span class="line"><span class="keyword">int</span> stree[<span class="number">2</span>*maxn];<span class="comment">//树状数组辅助数组 </span></span><br><span class="line"><span class="keyword">int</span> par[maxn];<span class="comment">//去重时使用的辅助数组 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[maxn],ans[maxn],ts[maxn],ff[maxn];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f数组是用来记录nodes归并的结果，即去重后的结果，其他几个用来辅助求最终答案 </span></span><br><span class="line"><span class="comment">ans是最终答案数组</span></span><br><span class="line"><span class="comment">ts[i]存放id为i的数对重复出现了几次（值相等）</span></span><br><span class="line"><span class="comment">par[i]是id为i的数去重后所在nodes数组中的"代表"的id </span></span><br><span class="line"><span class="comment">ff数组记录了有重复的数据的偏序结果，ff可由f、ts和par得到 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;x &lt; <span class="number">2</span>*maxn;x += x&amp;-x) stree[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x -= x&amp;-x) ans += stree[x];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//我们规定左闭右开，取不到 r </span></span><br><span class="line">    <span class="keyword">if</span>(r-l &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    solve(l,mid);<span class="comment">//递归左区间 </span></span><br><span class="line">    solve(mid,r);<span class="comment">//递归右区间 </span></span><br><span class="line">    <span class="keyword">int</span> p = l,q = mid,k = l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p &lt; mid &amp;&amp; q &lt; r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nodes[p].b &lt;= nodes[q].b)&#123;</span><br><span class="line">            add(nodes[p].c,nodes[p].val);</span><br><span class="line">            tmp[k++] = nodes[p++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nodes[p].b &gt; nodes[q].b)&#123;</span><br><span class="line">            f[nodes[q].id] += ask(nodes[q].c);</span><br><span class="line">            tmp[k++] = nodes[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span>(q &lt; r)&#123;</span><br><span class="line">        f[nodes[q].id] += ask(nodes[q].c);</span><br><span class="line">        tmp[k++] = nodes[q++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt; p;i++) add(nodes[i].c,-nodes[i].val);</span><br><span class="line">    <span class="comment">//用这种方法来清空树状数组，因为memset是O(n^2)，会超时 </span></span><br><span class="line">    <span class="keyword">while</span>(p &lt; mid) tmp[k++] = nodes[p++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt; r;i++)</span><br><span class="line">        nodes[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;aa[i].a,&amp;aa[i].b,&amp;aa[i].c);</span><br><span class="line">        aa[i].id = i,aa[i].val = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(aa+<span class="number">1</span>,aa+n+<span class="number">1</span>);<span class="comment">//先按照a排序，这样就可以忽略a的影响了 </span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    nodes[++cnt] = aa[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//以下代码块是用来去重，并记录必要信息 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(aa[i] == aa[i<span class="number">-1</span>])&#123;</span><br><span class="line">    par[aa[i].id] = nodes[cnt].id;</span><br><span class="line">    ts[nodes[cnt].id]++;</span><br><span class="line">    nodes[cnt].val++;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="keyword">else</span> nodes[++cnt] = aa[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    solve(<span class="number">1</span>,cnt+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//通过去重后CDQ分治得到的结果数组f，来推出没去重的结果并存放在ff中 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[i]) ff[i] = f[par[i]] + ts[par[i]];</span><br><span class="line">    <span class="keyword">else</span> ff[i] = f[i] + ts[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按照题意要求输出答案 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)ans[ff[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></bi时，找到所有cj<ci即可）></p></blockquote><h4 id="3-2-三维偏序问题拓展"><a href="#3-2-三维偏序问题拓展" class="headerlink" title="3.2 三维偏序问题拓展"></a>3.2 三维偏序问题拓展</h4><p>&emsp;&emsp;在二维偏序问题拓展中，我们利用二维有序当作索引，来查找想要的结果。类似的，我们可不可以用三维有序对来当下标，找寻想要的答案集合T呢？<br><strong>例题：</strong> </p><blockquote><p>&emsp;&emsp;平面上有N个点，每个点的横纵坐标在[0,1e7]之间，有M个询问，每个询问为查询在指定矩形之内有多少个点，矩形用(x1,y1,x2,y2)的方式给出，其中(x1,y1)为左下角坐标，(x2,y2)为右上角坐标。</p></blockquote><p><strong>解题思路：</strong><br>&emsp;&emsp;我们同样将查询区间内点数量分成四个求前缀和操作（这里需要用容斥原理）。将平面上点看成插入操作，查询矩形内点个数看成查询操作。那么对于每个操作，有<time , x y>三个维度作为索引（或者下标），又因为time是默认有序的，所以我们需要根据x归并，同时用树状数组维护y的前缀和。我们按照CDQ分治的思想，统计左边区间节点对右边区间查询的贡献。（这里所说的左右区间概念引自归并排序）详细思想请对照代码。<br><strong>代码示例：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BZOJ1935</span></span><br><span class="line"><span class="comment">单点修改，区间查询</span></span><br><span class="line"><span class="comment">CDQ+树状数组 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span>+<span class="number">50</span>;<span class="comment">//最大节点数量 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> op,x,y,val;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">op = 1是修改值操作，2是减去前缀和操作，3是加上前缀和操作</span></span><br><span class="line"><span class="comment">x、y代表坐标</span></span><br><span class="line"><span class="comment">val有两重用法， 当是修改值操作时，val代表要修改的值； </span></span><br><span class="line"><span class="comment">当表示求前缀和操作时，val代表答案数组ans的下标（因为最终结果要累加） </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node &amp;B) <span class="keyword">const</span>&#123; </span><br><span class="line"><span class="comment">//x为第一关键字，y为第二关键字，op为第三关键字，升序排序 </span></span><br><span class="line"><span class="keyword">if</span>(x == B.x)&#123;</span><br><span class="line"><span class="keyword">if</span>(y == B.y) <span class="keyword">return</span> op &lt; B.op;</span><br><span class="line"> <span class="keyword">return</span> y &lt; B.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x &lt; B.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数，无参的用来创建数组，有参的用来快速赋值 </span></span><br><span class="line">Node()&#123;&#125;</span><br><span class="line">Node(<span class="keyword">int</span> op,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> val):op(op),x(x),y(y),val(val)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node Q[<span class="number">7</span>*maxn];<span class="comment">//为啥是7倍，因为每个查询操作被分成四个子操作了嘛 </span></span><br><span class="line">Node tmp[<span class="number">7</span>*maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn],st[<span class="number">10100000</span>];<span class="comment">//树状数组没开离散化，当然如果范围再大点就要开了 </span></span><br><span class="line"><span class="keyword">int</span> qidx = <span class="number">0</span>,aidx = <span class="number">2</span>;<span class="comment">//分别代表查询集合Q和答案集合ans的下标 </span></span><br><span class="line"><span class="comment">//以下俩个函数是树状数组的函数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;x &lt; maxn;x += x&amp;-x) st[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x) sum += st[x];</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CDQ分治的用法 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(r-l &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">solve(l,mid);</span><br><span class="line">solve(mid,r);</span><br><span class="line"><span class="keyword">int</span> p = l,q = mid,k = l;</span><br><span class="line"><span class="keyword">while</span>(p &lt; mid &amp;&amp; q &lt; r)&#123;</span><br><span class="line"><span class="keyword">if</span>(Q[p] &lt; Q[q])&#123;</span><br><span class="line"><span class="keyword">if</span>(Q[p].op == <span class="number">1</span>) add(Q[p].y,Q[p].val);</span><br><span class="line">tmp[k++] = Q[p++];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q[q].op == <span class="number">2</span>)  ans[Q[q].val] -= ask(Q[q].y);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Q[q].op == <span class="number">3</span>)ans[Q[q].val] += ask(Q[q].y);</span><br><span class="line">tmp[k++] = Q[q++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(q &lt; r)&#123;</span><br><span class="line"><span class="keyword">if</span>(Q[q].op == <span class="number">2</span>)  ans[Q[q].val] -= ask(Q[q].y);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Q[q].op == <span class="number">3</span>) ans[Q[q].val] += ask(Q[q].y);</span><br><span class="line">tmp[k++] = Q[q++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们用这种方法来清空树状数组，可以节省时间 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt; p;i++)</span><br><span class="line"><span class="keyword">if</span>(Q[i].op == <span class="number">1</span>) add(Q[i].y,-Q[i].val);</span><br><span class="line"><span class="keyword">while</span>(p &lt; mid) tmp[k++] = Q[p++];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt; r;i++) Q[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">Q[qidx++] = Node(<span class="number">1</span>,x+<span class="number">1</span>,y+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">Q[qidx++] = Node(<span class="number">3</span>,x1,y1,aidx);</span><br><span class="line">Q[qidx++] = Node(<span class="number">2</span>,x1,y2+<span class="number">1</span>,aidx);</span><br><span class="line">Q[qidx++] = Node(<span class="number">2</span>,x2+<span class="number">1</span>,y1,aidx);</span><br><span class="line">Q[qidx++] = Node(<span class="number">3</span>,x2+<span class="number">1</span>,y2+<span class="number">1</span>,aidx++);</span><br><span class="line">&#125;</span><br><span class="line">solve(<span class="number">0</span>,qidx);<span class="comment">//依旧左闭右开 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; aidx;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></time></p><h5 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h5><ul><li><p><a href="http://www.cnblogs.com/mlystdcall/p/6219421.html" target="_blank" rel="noopener">博客</a></p></li><li><p>《算法竞赛进阶指南》-李煜东.P197(树状数组)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>st表（一维）</title>
      <link href="/2019/08/11/st/"/>
      <url>/2019/08/11/st/</url>
      
        <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>ST表是一个用来处理区间最值查询（Range Maximum/Minimum Query）的离线算法。该算法分为离线预处理O(n log n)和查询O(1)两个部分，其用到了倍增的思想。<br>某个区间查询问题是否适用ST表，关键在于其进行的操作是否允许区间重叠，例如max(a,b,c) = max{max(a,b),max(b,c)}就可以用ST表维护，而区间和问题则不能维护。</p><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个长度为n的序列，有m次询问，每次给定区间[L , R]，求区间内最大值。</p><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><p><strong>定义st表</strong><br>我们设 st[i][j] 为从 i 开始的 2^j 个数中的最大值。假设这n个数存放的序列a中，根据定义 st[i][j] = max{a[k] | i &lt;= k &lt;= i+2^j - 1}。<br><strong>查询操作</strong><br>假设我们已经更新完st表（下文会讲如何在O(n log n)时间内更新），那么我们应该如何利用上述定义的st表查询[L , R]内的最大值呢？<br>根据我们上述st表的定义，我们发现，我们能在st表中查询的区间（假设为[a,b]）都只能从某个位置a开始向后$2^k-1$个区间（k是自然数），所以如果a-b 并不恰好等于 $2^k$，那么多出来的部分（即$[a+2^k , b]$）我们并不能直接求出来，只能用类似的方法求出$[b-2^k+1,b]$的最大值，那么最终[a,b]的最大值不就是以上两段区间的max吗？当然这里的k要取使得$a+2^k &lt; b$成立的最大值，即$log_2^{b-a+1}$。<br>举个例子，求[2 , 10]的最大值可以拆分为求[2 , 9]的最大值和[3 , 10]的最大值。<br>于是查询操作（查询[L , R] ）就顺利成章的是max(st[L][k] , st[R-(1&lt;&lt;k) + 1][k])。<br><strong>预处理</strong><br>我们在上述证明了查询操作确实是O(1)的，所以如果我们真的能按照st表定义的那样去更新它，那么该算法就真正的完成了。更新st表用到了动态规划的思想。<br>更新中仍然用到了倍增的思想，使得更新操作从O(n^2)优化到了O(n log n)，初始状态st[x][0] = a[x]，st[x][j] = max(st[x][j-1] , st[x + (1&lt;&lt;(j-1)) ][j-1])。其思想和上述重叠查询类似，不再赘述。但是要注意更新顺序，因为其中 j （第二维）才是阶段，而第一维 x 是状态，所以对于 j 的循环要放在最外层。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],st[N][<span class="number">25</span>],Log[N];<span class="comment">//2^20就过一百万了，完全够用 </span></span><br><span class="line"><span class="comment">//初始化st表 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">Log[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//预处理log函数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n+<span class="number">1</span>;i++) Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)&#123;<span class="comment">//涉及到位运算多加括号! </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)) &lt;= n;i++)&#123;</span><br><span class="line">st[i][j] = max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> mx = max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"><span class="comment">//printf("%d %d\n",k,mx);</span></span><br><span class="line"><span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,l,r;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(l,r));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A* 与 IDA*</title>
      <link href="/2019/08/11/IDA/"/>
      <url>/2019/08/11/IDA/</url>
      
        <content type="html"><![CDATA[<h4 id="IDA"><a href="#IDA" class="headerlink" title="IDA*"></a>IDA*</h4><p>虽然剪枝在较快找到接近最优解的解时能够有效减少状态数，但是在尚未找到较好的解时，依然会尝试许多不必要的状态。虽然我们在下界比最优解更大时可以剪枝，但是不知道最优解的话就没法做到了。因此，我们可以不直接去求最优解，而是改成通过搜索判断是否有不超过某个x的解。把x从0开始每次增加1，那么首次找到解时的x就是最优解。这样，搜索过程中就不会访问那些下界比最优解更大的状态了。<br>将程序改成判断是否有不超过某个x的解，只需要在下界超过x时，停止搜索就好了，代码几乎没有什么变动。<br>考虑平凡下界的情况（即使得所有状态都满足的下界），此时，程序就会像宽度优先搜索一样，按照距离初始状态的远近顺序访问各个状态。这被称为迭代加深搜索（IDDFS，Interative Deepening Depth-First Search）。<br>而像这样通过估算下界提前剪枝优化后的算法则称为IDA* 。它通常可以表述如下：</p><ol><li>给出状态v到目标状态的距离下界的估算函数h（v）。</li><li>令x = 0。</li><li>堆满足d（v） + h（v） &lt;= x的状态进行深度优先搜索，判断是否有不超过x的解（d(v) 表示初始状态到目标状态的距离）。</li><li>如果找到解，则x就是最优解，程序结束。</li><li>否则，将x增加1并回到第3步。</li></ol><p>IDA* 中所访问的状态总是满足d(v) + h(v) &lt;= 最优解，而h(v)的估值越接近到目标状态的实际距离，则搜索所经过的状态数就越少。</p><p>可能会有一个疑问，就是上述x不断+1再判断是否有解的过程和二分搜索很类似，那能否用二分搜索来做呢？不能，因为随着x的增大，搜索状态是指数级上升，所以x要越小越好（即使搜索了x从1~1000，也比搜索一次x = 1100要快）。</p><h4 id="A"><a href="#A" class="headerlink" title="A *"></a>A *</h4><p>正如深度优先算法可以利用下界优化一样，宽度优先搜索和 Dijkstra 算法也可以利用下界优化。只要将优先队列中的键改成 d(v) + h(v) 就可以了，其中 d(v) 是初始状态到状态 v 的距离，h(v) 是到目标状态的距离下界。这种算法称为A *  。</p><p>需要注意的是，与宽度优先搜索和 Dijkstra 算法不同，在选用某些下界进行估算的情况下，优先队列顶端的元素对应的 d(v) 未必已经是初始状态到 v 的最短距离。</p><p>如果对于所有的边（u，v）都有cost(u , v)+h(u) - h(v) &gt;= 0成立，那么第一次取出某个节点时，对应的 d(v) 就一定是最短距离。</p><h4 id="A-与-IDA-的比较"><a href="#A-与-IDA-的比较" class="headerlink" title="A  与 IDA  的比较"></a>A <em> 与 IDA </em> 的比较</h4><p>A <em>  和IDA </em>  分别是针对宽度优先搜索和深度优先搜索的算法。我们可也i很容易地把深度优先搜索改写成IDA <em>  ，同样也可以很容易的把宽度优先搜索或者Dijkstra改写成A </em>  。</p><p>当然，不仅在代码上改写容易，它们也各自继承了一些改写前算法的特点。例如，IDA <em>  基本不怎么花费内存，而A </em> 则要花费关于搜索空间的线性的内存。另一方面，可以通过不同路径达到同一状态时，IDA <em> 可能会重复多次经过某些状态而导致效率一落千丈，而A</em> 通过选取合适的下界则可以保证每个状态至多检查一次。</p><p>通常来说，随着搜索深度的增加，搜索空间的大小呈指数级别增长。所以，虽然IDA * 不断增加递归深度限制的过程重复搜索了很多状态，但总的访问状态数和最后一次访问状态数还是同一数量级的。</p>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笛卡尔树</title>
      <link href="/2019/08/11/cartesin/"/>
      <url>/2019/08/11/cartesin/</url>
      
        <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>笛卡尔树（Cartesian Tree）是一种树形数据结构。由于其具有二叉搜索树和堆的性质，如果以一棵笛卡尔树对应一段区间的话，那么整段区间的极值就是根节点A，同时又满足A的左子树对应极值左边区间，右子树对应右边区间。这样递归定义，就会将一个区间划分若干段。而笛卡尔树之所以具有上述性质我们会在接下来讲解。<br>本文首先介绍笛卡尔树的概念以及它具有的性质，然后介绍如何来构造一棵笛卡尔树，当然，对笛卡尔树结构的分析也是必不可少的。</p><h4 id="笛卡尔树的概念"><a href="#笛卡尔树的概念" class="headerlink" title="笛卡尔树的概念"></a>笛卡尔树的概念</h4><p>笛卡尔树（Cartesian Tree）是一种同时满足堆性质和二叉搜索树性质的一棵二叉树。因此笛卡尔树的树根对应着该树的极值（堆性质），并且对其中序遍历得到的是原序列一段连续的区间（二叉搜索树性质）。<br>我们假设利用一个整数序列A：a1~an 建立笛卡尔树，那么树上每个节点有2个键值，idx（下标）和 val（值）。我们使树上每个节点的idx满足二叉搜索树性质，而val满足堆性质，于是笛卡尔树就建成了。</p><h4 id="笛卡尔树具有的性质"><a href="#笛卡尔树具有的性质" class="headerlink" title="笛卡尔树具有的性质"></a>笛卡尔树具有的性质</h4><p>如果我们以A序列建立一棵笛卡尔树的话，显然笛卡尔树具有如下性质：</p><ul><li>父亲节点的键值val均小于（或大于）其左右子节点的键值。</li><li>节点的左儿子idx比其小，右儿子的idx比其大。中序遍历即为原序列A。</li></ul><p>上述两条性质分别是堆和二叉搜索树的性质，而我们通过对两个键值进行不同约束，使得这两种数据结构结合在了一起，使得我们可以很轻松的求出一段区间的极值。</p><p>类似笛卡尔树的数据结构有树堆（Treap），它也是将二叉搜索树和堆结合在一起，只不过其是利用堆来维持搜索树不至于退化严重，并没有利用其来求极值。因此，我们可以对比理解。</p><h4 id="如何建立笛卡尔树"><a href="#如何建立笛卡尔树" class="headerlink" title="如何建立笛卡尔树"></a>如何建立笛卡尔树</h4><p>对于给定序列A，建立一棵笛卡尔树的时间复杂度为O(N)。首先，如果类似于Treap中插入操作来建立一棵笛卡尔树的话，时间复杂度是O(N* log N)，但是由于给定序列的下标idx是递增的，因此我们可以利用单调栈在线性时间内建树。</p><p>首先考虑对于一棵已经建好的子树$T_i$，对于新来的节点x = Node(idx = i+1，val = value)，其一定是要沿着当前节点的根一路向右走，直至找到合适的位置。假设我们把节点x插入到最右边，那么首先可知在idx维度是合法的，但是其val并不一定比起父亲节点要大（假设这颗笛卡尔树是小根堆），因此如果x.val 小于其父亲的val，那么就需要交换位置，同理，就像在Treap中一样一直交换到合适的位置。</p><p>而如果我们栈S中存放的是当前最右边子树（实际上就是一个节点）的根节点y，那么如果x位置合法，则将x压入S，作为y的右子树，此时x成为了新的根节点；如果x不合法，则将栈顶元素弹出，再与下一个节点比较，直至找到合法位置再将x压入，而弹出的节点则应该放在节点x的左边。（如果弹出不止一个节点，则应该作为x节点的左子树）</p><p>而每个点进栈和出栈至多一次，因此时间复杂度是O(N)。</p><p><strong>建立一棵保存区间最小值的笛卡尔树具体步骤如下：</strong></p><ol><li>将待插入节点 x 与当前栈顶元素比较，若其val大于当前栈顶元素，则作为栈顶元素的右儿子，并入栈，插入下一个元素，否则转2。</li><li>若待插入节点 x 的 val 小于当前栈顶元素，则将栈顶元素弹出，不断重复直至栈顶元素的 val 小于节点 x 的val，此时最后一个弹出的栈顶元素作为节点 x 的左儿子。</li><li>当所有节点插入完毕后，栈底节点则为这颗笛卡尔树的根节点。</li></ol><p>当然上述判断栈是否为空的步骤并未加上，实际书写代码时应该注意这点。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>我们以HDU1506为例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],tot = <span class="number">0</span>,n;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function">ll <span class="title">max</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b?b:a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> idx,val;<span class="comment">//下标、权值 </span></span><br><span class="line"><span class="keyword">int</span> l,r,par;<span class="comment">//左儿子、右儿子、父亲节点的编号 </span></span><br><span class="line">Node()&#123;&#125;</span><br><span class="line">Node(<span class="keyword">int</span> idx,<span class="keyword">int</span> val)</span><br><span class="line">:idx(idx),val(val)&#123;</span><br><span class="line">l = r = par = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BuildTree</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> k = i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(t[k].val &gt; t[i].val) k = t[k].par;</span><br><span class="line">t[i].l = t[k].r;<span class="comment">//k的右子树作为i的左子树 </span></span><br><span class="line">t[k].r = i;<span class="comment">//i作为k的右子树 </span></span><br><span class="line">t[i].par = k;<span class="comment">//i的父亲是k </span></span><br><span class="line">t[t[i].l].par = i;<span class="comment">//i的左子树的父亲是i </span></span><br><span class="line"><span class="comment">//printf("%d %d\n",i,k);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t[<span class="number">0</span>].r;<span class="comment">//最终树的根节点的编号 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="comment">//printf("%d\n",rt);</span></span><br><span class="line"><span class="keyword">if</span>(rt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">ll sz = <span class="number">1</span>;</span><br><span class="line">sz += dfs(t[rt].l);</span><br><span class="line">sz += dfs(t[rt].r);</span><br><span class="line">ans = max(ans,sz*(t[rt].val));</span><br><span class="line"><span class="keyword">return</span> sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)</span><br><span class="line">t[i] = Node(i,a[i]);</span><br><span class="line">tot = ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> rt = BuildTree();</span><br><span class="line">dfs(rt);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组区间修改+区间查询</title>
      <link href="/2019/08/11/BIT2/"/>
      <url>/2019/08/11/BIT2/</url>
      
        <content type="html"><![CDATA[<h3 id="数组数组区间修改-区间查询"><a href="#数组数组区间修改-区间查询" class="headerlink" title="数组数组区间修改+区间查询"></a>数组数组区间修改+区间查询</h3><p>在之前整理树状数组笔记时，已经将单点修改以及区间查询写的很清楚了。树状数组本质上就是一个可以在线 快速查询前缀和，并可以快速更新数值并维护的数据结构。我们喜欢用树状数组是因为其代码简单易记，出错率低，并且效率还不错。</p><h4 id="理论推导"><a href="#理论推导" class="headerlink" title="理论推导"></a>理论推导</h4><p>如果涉及单点修改、区间查询，那么代码很简单。但是如果是区间修改，就需要做一些改变了。首先进行如下推导：（前置知识：前缀和、差分数组）<br><strong>假设数组a是存放初始数据，sum存放a数组的前缀和，而b数组为差分数组</strong>，即每当为[l,r]位置所有元素+val时，b[l]+= val,b[r] -= val。而sumb为b数组的前缀和数组，这样sumb[i]就存放着a[i]修改值。那么很显然最后a[i]的值为a[i]+sumb[i]，即初始值+修改值。此时再来考察a数组的前缀和，sum[i]存放的是a[1]+a[2]+…+a[i]，（请注意a数组始终未作改变，其改变的值存放在sumb数组中），很显然我们要求的结果(数组a的最终前缀和)</p><script type="math/tex; mode=display">ans = sum[ i ]+\sum_{j = 1}^i sumb[ j ]</script><p>又由于</p><script type="math/tex; mode=display">sumb[i] = \sum_{ j = 1}^i b[j]</script><p>所以</p><script type="math/tex; mode=display">ans = sum[i] + \sum_{j = 1}^i \sum_{k = 1}^j b[k]</script><p>至此我们已经抛弃了sumb这个保存b数组前缀和的数组，ok吗？我们得到的公式是根据一个常量数组sum和一个不断被修改的b数组来求ans的。<strong>（注：这里ans为a数组的最终前缀和）</strong><br>如果上面的公式没有问题，接下来我们的目标就是<strong>求b数组的二重和式。</strong> 来变形：</p><script type="math/tex; mode=display">\sum_{j = 1}^i \sum_{k = 1}^j b[k] = \sum_{j = 1}^i (i - j + 1)* b[j] = (i +1)\sum_{j = 1}^ib[j] - \sum_{j = 1}^i j* b[j]</script><p>首先，这个公式变换是常用套路，如果有问题可以自己用矩阵求和来推一下。其次，变换成这个公式的好处是我们<strong>只需维护 j * b[j] 的前缀和</strong>就可以直接求出a数组修改后的前缀和了。</p><h4 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h4><p>具体操作是，我们建立两个树状数组c0和c1。其中c0是用来求b[j]前缀和的，而c1是用来求j * b[j]前缀和的。那么对于每个区间修改（为[l,r]上所有数字+val），我们执行4个操作：</p><ol><li>在树状数组c0中，把位置l上的数 + val。</li><li>在树状数组c0中，把位置r+1上的数 - val。</li><li>在树状数组c1中，把位置l上的数 + l* val。</li><li>在树状数组c1中，把位置r+1上的数 -（r+1）* val</li></ol><p>另外，sum数组存放序列a的原始前缀和。所以每次查询[l,r]前缀和，当然还是拆分成求[1,r]和[1,l-1]的前缀和，二者相减。写成式子如下：</p><script type="math/tex; mode=display">(sum[r] + (r+1) * ask(c0,r) - ask(c1,r) ) - (sum[l-1] + l * ask(c0,l-1) - ask(c1,l-1) )</script><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>这里以POJ3468为例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll c[<span class="number">2</span>][MAXN];</span><br><span class="line">ll a[MAXN],sum[MAXN];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;x &lt;= n;x += x&amp;-x) c[k][x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x) ans += c[k][x];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,a+i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) sum[i] += sum[i<span class="number">-1</span>] + a[i];</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> l,r,val;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'C'</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;val);</span><br><span class="line">add(<span class="number">0</span>,l,val);</span><br><span class="line">add(<span class="number">0</span>,r+<span class="number">1</span>,-val);</span><br><span class="line">add(<span class="number">1</span>,l,l*val);</span><br><span class="line">add(<span class="number">1</span>,r+<span class="number">1</span>,-(r+<span class="number">1</span>)*val);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">ll ans = sum[r] + (r+<span class="number">1</span>)*ask(<span class="number">0</span>,r) - ask(<span class="number">1</span>,r);</span><br><span class="line">ans -= sum[l<span class="number">-1</span>] + l*ask(<span class="number">0</span>,l<span class="number">-1</span>) - ask(<span class="number">1</span>,l<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>参考书目：</strong></p><ul><li>《算法竞赛进阶指南》.李煜东.P200</li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组模板1</title>
      <link href="/2019/08/11/BIT/"/>
      <url>/2019/08/11/BIT/</url>
      
        <content type="html"><![CDATA[<h4 id="测试地址：洛谷P3374"><a href="#测试地址：洛谷P3374" class="headerlink" title="测试地址：洛谷P3374"></a>测试地址：洛谷P3374</h4><h4 id="模板说明书："><a href="#模板说明书：" class="headerlink" title="模板说明书："></a>模板说明书：</h4><ul><li>本模板仅使用单点修改以及查询前缀和，其他用途需按需修改。</li><li>本模板建树采用了将初始值当成修改值插入的方法，复杂度O（NlgN）<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500050</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[MAXN],c[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="comment">//初始化函数，顺便离线以下lowbit数组</span></span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a);</span><br><span class="line"><span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span> c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;x &lt;= n;x += x&amp;-x) c[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x -= x&amp;-x) ans += c[x];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) add(i,a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span>) add(b,c);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(c)-ask(b<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分算法模板</title>
      <link href="/2019/08/11/erfen/"/>
      <url>/2019/08/11/erfen/</url>
      
        <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>之前整理的二分搜索模板在对找x的前驱、后继以及实数域上的二分都有各自不同的代码，其中一些小细节需要我们不断去测试修改最终得以实现不遗漏且保证答案正确性。而现在我们可以将上述几种不同的二分搜索代码整合在一起，对于不同的使用情况只需稍微修改一下“精度”即可。</p><h4 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>,high = n;</span><br><span class="line"><span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) low = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> high = mid<span class="number">-1</span>;<span class="comment">//EPS</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> high;</span><br></pre></td></tr></table></figure><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><p>当循环退出时，一定是low &gt; high，或者说low = high + EPS。<br>若是求大于x的最小值，由于每次是mid位置的数大于x时收缩high的值，于是最终一定是high不满足条件时退出，故答案应该在low。<br>若是求小于x的最大值，由于每次是mid位置的数小于x时收缩low的值，因此最后一定是low偏离正确答案，即high上是答案。<br>而对于实数域上的问题，对EPS进行精度约束即可，一般比所求精度小10倍即可。</p>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>倍增求LCA</title>
      <link href="/2019/08/11/lca/"/>
      <url>/2019/08/11/lca/</url>
      
        <content type="html"><![CDATA[<p>LCA：即求一棵有根树中两个节点的最近公共祖先。</p><h4 id="树上倍增法"><a href="#树上倍增法" class="headerlink" title="树上倍增法"></a>树上倍增法</h4><p>树上倍增法是一个很重要的算法。除了求LCA外，在很多问题中都有广泛应用。设F[x,k]表示x的2^k倍祖先，即从x向根节点走2^k步到达的节点。特别的，若该节点不存在，则令F[x,k] = 0。F[x,0]就是x的父节点，除此之外，对于任意的1 &lt;= k &lt;= log n，F[x,k] = F[F[x,k-1],k-1]。<br>这就类似于一个动态规划的过程，“阶段”就是节点的深度。因此，我们可以对树进行广度优先遍历，按照层次顺序，在节点入队之前，计算它在F数组中相应的位置。<br>以上部分是预处理，时间复杂度为O(N log N)，之后可以多次对不同的x，y计算LCA，每次询问的时间复杂度为O(log N)。<br><strong>算法步骤：</strong></p><ol><li>设d[x] 表示 x 的深度。设 d[x] &gt;= d[y] （否则可以交换x，y）。</li><li>用二进制拆分思想，把 x 向上调整到与 y 同一深度。</li><li>若此时 x = y，说明已经找到了LCA，LCA就等于y。</li><li>用二进制拆分思想，把x，y同时向上调整，并保持深度一致且二者不相会。</li><li>此时x，y必定只差一步就相会了，他们的父节点F[x,0]就是LCA。</li></ol><p><strong>代码模板：</strong> HDU2586</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2</span>*<span class="number">41000</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N],nex[N],edge[N],tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> deep[N],anc[N][<span class="number">25</span>],dis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;x ^= y;y^=x;x^=y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y,edge[tot] = z;</span><br><span class="line">    nex[tot] = head[x],head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.初始化anc数组，</span></span><br><span class="line"><span class="comment">        2.初始化deep数组</span></span><br><span class="line"><span class="comment">        3.初始化dis数组</span></span><br><span class="line"><span class="comment">        以上三个都可以通过dfs来实现</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">22</span>;i++)</span><br><span class="line">        anc[x][i] = anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i;i = nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i],z = edge[i];</span><br><span class="line">        <span class="keyword">if</span>(dis[y] || y == <span class="number">1</span>) <span class="keyword">continue</span>;<span class="comment">//防止重复访问</span></span><br><span class="line">        deep[y] = deep[x]+<span class="number">1</span>;</span><br><span class="line">        dis[y] = dis[x] + z;</span><br><span class="line">        anc[y][<span class="number">0</span>] = x;</span><br><span class="line">        dfs(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        先把深度调到一致，再按照二进制拆分思想找寻最近公共祖先</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(deep[u] &lt; deep[v]) swap(u,v);    <span class="comment">//u是较深的节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[anc[u][i]] &gt;= deep[v]) u = anc[u][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(anc[u][i] != anc[v][i])&#123;</span><br><span class="line">            u = anc[u][i];</span><br><span class="line">            v = anc[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> anc[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dis[u] + dis[v] <span class="number">-2</span>*dis[Lca(u,v)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">        <span class="built_in">memset</span>(deep,<span class="number">0</span>,<span class="keyword">sizeof</span> deep);</span><br><span class="line">        <span class="built_in">memset</span>(anc,<span class="number">0</span>,<span class="keyword">sizeof</span> anc);</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head);<span class="comment">//head也要初始化</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y,z;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            addEdge(x,y,z);</span><br><span class="line">            addEdge(y,x,z);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,x,y;i &lt;= m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(x,y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高度数组与最长公共前缀</title>
      <link href="/2019/08/10/lcp/"/>
      <url>/2019/08/10/lcp/</url>
      
        <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>本文是关于后缀数组的一个拓展，问题模型来自于最长公共前缀（Longest Common Prefix Array）问题，我们为解决该模型，在后缀数组的基础上设计了一个精巧的数组——高度数组（lcp），同时由于该数组在处理各类字符串相关问题时有着较好的用途，因此值得掌握。</p><p>本文将直接从高度数组讲起，假设读者具有后缀数组的基础知识。首先本文会介绍高度数组的定义以及用途，接着讲解如何在O(N)时间内求出高度数组，最后将介绍高度数组的应用。</p><h4 id="高度数组（LCP-Array-，Longest-Common-Prefix-Array）"><a href="#高度数组（LCP-Array-，Longest-Common-Prefix-Array）" class="headerlink" title="高度数组（LCP Array ，Longest Common Prefix Array）"></a>高度数组（LCP Array ，Longest Common Prefix Array）</h4><p>所谓的高度数组，指的是由后缀数组中相邻两个后缀的最长公共前缀（LCP）的长度组成的数组。记后缀数组为sa，高度数组为lcp，则有后缀S[ sa[i]… ] 与 S[sa[i+1] … ] 的最长公共前缀的长度为lcp[i] 。我们可以在O(n)时间内高效地求得高度数组，有了高度数组，后缀数组将成为一个更加有力的工具。高度数据虽然计算简单，但非常巧妙，使用了类似尺取法的技巧。记rank[i] 为位置 i 开始的后缀在后缀数组中的顺序，即有rank[ sa[i] ] = i。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>我们从位置0的后缀开始，从前往后依次计算后缀S[i…]与后缀S[sa[rank[i]-1]…]（即后缀数组中的前一个后缀）的最长公共前缀的长度。此时，假设我们已经求得了位置 i 对应的高度<script type="math/tex">h_i</script>，<strong>那么我们可以证明位置 i+1 对应的高度应该不小于<script type="math/tex">h_i-1</script>。</strong></p><p>为什么呢？记k = sa[rank[i] - 1] ，已知后缀S[i…]和S[k…]的头部<script type="math/tex">h_i</script>个字符是相等的，那么后缀S[i+1…]和S[k+1…]分别是二者去除首字符的结果，所以它们头部<script type="math/tex">h_i-1</script>个字符是相等的。虽然在后缀数组中，S[i+1…]前面一个元素未必就是S[k+1…]，但即便如此，公共前缀的长度也是只增不减的。因此，只要从<script type="math/tex">h_i-1</script>开始检查，计算最长公共前缀的长度就好了。</p><h4 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h4><p>因为高度最多增加n次，所以总的时间复杂度为O(n)。如果把这个问题当作位置i对应的区间是[i,i+h)的尺取法来看，就很容易理解。区间的左右端点始终不会向左移，并且是不超过n的整数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sa[i]表示排名为i的后缀起始位置是多少</span></span><br><span class="line"><span class="comment">rank[i]表示起始位置是i的串排名是多少</span></span><br><span class="line"><span class="comment">rank[sa[i] ] = i , sa[rank[i] ] = i,rank与sa互逆 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">int</span> sa[N],rank[N],tmp[N],lcp[N];</span><br><span class="line"><span class="comment">//比较(rank[i],rank[i+k])和(rank[j],rank[j+k]) </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rank[i] != rank[j]) <span class="keyword">return</span> rank[i] &lt; rank[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n ? rank[i+k] : <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n ? rank[j+k] : <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算字符串S的后缀数组 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line">n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="comment">//初始长度为1，rank直接取字符的编码</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rank[i] = i &lt; n ? S[i] : <span class="number">-1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//利用对长度为k的排序结果对长度为2k的排序</span></span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+n+<span class="number">1</span>,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + (compare_sa(sa[i<span class="number">-1</span>],sa[i])?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rank[i] = tmp[i];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最长公共前缀模板,其中sa为后缀数组,求得结果存放在lcp </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">int</span> sa[],<span class="keyword">int</span> lcp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(S);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rank[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>;lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*lcp[i] 表示起始位置为sa[i]与</span></span><br><span class="line"><span class="comment">起始位置为sa[i+1]的串的最长公共前缀长度*/</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = sa[rank[i]<span class="number">-1</span>];</span><br><span class="line"><span class="comment">/*此处j表示排在"以i开始的后缀"前面一名的子串的起始位置*/</span> </span><br><span class="line"><span class="keyword">if</span>(h &gt; <span class="number">0</span>) h--;</span><br><span class="line"><span class="keyword">for</span>(;j + h &lt; n &amp;&amp; i+h &lt; n;h++)&#123;</span><br><span class="line"><span class="keyword">if</span>(S[j+h] != S[i+h]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*h为以i开头的后缀与以j开头的后缀的"最长公共前缀"的长度*/</span> </span><br><span class="line">lcp[rank[i]<span class="number">-1</span>] = h;</span><br><span class="line"><span class="comment">/*于是以j开头的后缀 与以i开头的后缀 的 最长公共前缀的长度</span></span><br><span class="line"><span class="comment">被存放在lcp[rank[i]-1]中,因为lcp定义的就是: </span></span><br><span class="line"><span class="comment">lcp[k] 为排名为i的后缀与排名为i+1的后缀的最长公共前缀的长度*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str) != EOF)&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line">construct_lcp(str,sa,lcp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,lcp[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>秋叶拓哉，挑战程序设计竞赛第2版，北京：人民邮电出版社，2013.6，378-381</li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀数组笔记</title>
      <link href="/2019/08/10/sa/"/>
      <url>/2019/08/10/sa/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是后缀数组"><a href="#什么是后缀数组" class="headerlink" title="什么是后缀数组"></a>什么是后缀数组</h4><p>字符串后缀（Suffix）指的是从字符串的某个位置开始到其末尾的字符串子串。我们认为原串和空串也是后缀。反之，从字符串开头到某个位置的字符串子串则称为前缀。</p><p>后缀数组（Suffix Array）指的是将某个字符串的所有后缀按字典序排序后得到的数组。不过数组中并不需要直接保存所有的后缀字符串，只要记录对应的起始位置就好了。</p><h4 id="后缀数组的计算"><a href="#后缀数组的计算" class="headerlink" title="后缀数组的计算"></a>后缀数组的计算</h4><p>假设我们要计算长度为n的字符串S的后缀数组。最朴素的做法就是直接把所有后缀进行排序，将n个长度为O(n)的字符串进行排序的时间复杂度为<script type="math/tex">O(N^2logN)</script>。而如果灵活运用所有的字符串都是S的后缀这一性质，就可以得到更高效的算法。下面介绍一种由Manver和Myers发明的O(N log N)复杂度的算法。</p><p>该算法的基本思想是倍增。首先计算从每个位置开始的长度为2的子串的顺序，再利用这个结果计算长度为4的子串的顺序，接下来计算长度为8的子串的顺序，不断倍增，直到长度大于等于n就得到了后缀数组。下面，<strong>我们用 S[i , k] 表示从位置i开始的长度为k的字符串子串。</strong> 其中，剩余字符不足k个时，表示的是从位置 i 开始到字符串末尾的子串。</p><p>要计算长度为 2 的子串顺序，只要排序两个字符组成的数对就好了。现在假设已经求得了长度为 k 的字串的顺序，要求长度为 2k 的子串顺序。记$rank_k$为S[i , k] 在所有排好序的长度为k的子串中是第几小的。要计算长度为 2k 的子串的顺序，就只要对两个rank组成的数对进行排序就好了。我们通过对<script type="math/tex">rank_k(i)</script> 与 <script type="math/tex">rank_k(j+k)</script> 的数对的比较来 替代对 S[i , 2k] 和 S[j , 2k] ，比较<script type="math/tex">randk_k(i+k)</script>和<script type="math/tex">rank_j(j+k)</script>就相当于比较S[i+k , k] 和 S[j+k , k] 。所以，我们可以这样高效的比较长度为 2k 的<strong>子串</strong> ，并将它们排序。</p><h4 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h4><p>该代码共用到了三个数组，tmp , sa  ,  rank；其中tmp数组是用来临时存放新计算的rank的，而 sa[i] 则存放的当前长度为k时字典序第 i 小的字符起始位置是sa[i]。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> sa[N],rank[N],tmp[N];</span><br><span class="line"><span class="comment">//比较(rank[i],rank[i+k])和(rank[j],rank[j+k]) </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rank[i] != rank[j]) <span class="keyword">return</span> rank[i] &lt; rank[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n ? rank[i+k] : <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n ? rank[j+k] : <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算字符串S的后缀数组 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">char</span>* S,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line">n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="comment">//初始长度为1，rank直接取字符的编码</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rank[i] = i &lt; n ? S[i] : <span class="number">-1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//利用对长度为k的排序结果对长度为2k的排序</span></span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+n+<span class="number">1</span>,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + (compare_sa(sa[i<span class="number">-1</span>],sa[i])?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rank[i] = tmp[i];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str) != EOF)&#123;</span><br><span class="line">construct_sa(str,sa);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,sa[i]+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><strong>POJ3518：Sequence</strong><br><a href="http://poj.org/problem?id=3581" target="_blank" rel="noopener">测试地址</a><br><strong>题意简述：</strong><br>给定 N 个数字组成的序列$A_1 , A_2 , … , A_n$。其中$A_1$比其它数字都大。现在要把这个序列分成三个子段，并将每段分别反转，求能得到的字典序最小的序列是什么？要求分得的每段都不为空。<br><strong>解题思路：</strong><br>确定第一段是很简单的，因为第一个数最大，所以肯定旋转后要在末尾，所以只要把A数组倒置后求后缀数组，取字典序最小且合法的后缀，即为第一段的答案。这里的合法是指剩下的元素个数要大于2，不然没法分成3段。</p><p>然后要想把剩余的部分分成两段。不过这次的两端并不是独立的，不能简单的比较前半部分的字典序取最小者。不过，将序列分割成两端再分别反转得到的序列，可以看作是两个原序列拼接后得到的新序列中的某个子串反转后得到的序列。因此，只需要计算拼接后的序列的后缀数组，从中选择字典序尽量小并且合法的即可。</p><p>比如：从ABCDE中选俩段反转后字典序最小。等同于从EDCBAEDCBA中选择一个字典序最小的合法子串。</p><p><strong>代码示例：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> A[N],rev[<span class="number">2</span>*N],sa[<span class="number">2</span>*N];</span><br><span class="line"><span class="keyword">int</span> n,k,m,tmp[<span class="number">2</span>*N],rank[<span class="number">2</span>*N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rank[i] != rank[j]) <span class="keyword">return</span> rank[i] &lt; rank[j];</span><br><span class="line"><span class="keyword">int</span> ri = i+k &lt;= n ? rank[i+k]:-INF<span class="number">-1</span>;<span class="comment">//这里不要搞错 </span></span><br><span class="line"><span class="keyword">int</span> rj = j+k &lt;= n ? rank[j+k]:-INF<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意A的下标是[0,len)的 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> len,<span class="keyword">int</span> sa[])</span></span>&#123;</span><br><span class="line">n = len;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">sa[i] = i;</span><br><span class="line">rank[i] = i &lt; n ? A[i] : -INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>)&#123;</span><br><span class="line">sort(sa,sa+n+<span class="number">1</span>,compare_sa);</span><br><span class="line">tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">tmp[sa[i]] = tmp[sa[i<span class="number">-1</span>]] + (compare_sa(sa[i<span class="number">-1</span>],sa[i])?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) rank[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">reverse_copy(A,A+m,rev);</span><br><span class="line">construct_sa(rev,m,sa);</span><br><span class="line"><span class="keyword">int</span> p1,p2;</span><br><span class="line"><span class="comment">//考虑一下p1需要满足的条件 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">p1 = m-sa[i];</span><br><span class="line"><span class="keyword">if</span>(p1 &gt;= <span class="number">1</span> &amp;&amp; m-p1 &gt;= <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br><span class="line">reverse_copy(p1+A,A+m,rev);</span><br><span class="line">reverse_copy(p1+A,A+m,rev+m-p1); </span><br><span class="line">construct_sa(rev,<span class="number">2</span>*(m-p1),sa);</span><br><span class="line"><span class="comment">//考虑p2的范围 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span>*(m-p1);i++)&#123;</span><br><span class="line">p2 = sa[i];</span><br><span class="line"><span class="keyword">if</span>(p2 &gt; <span class="number">0</span> &amp;&amp; p2 &lt; m-p1) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">reverse(A,A+p1);</span><br><span class="line"><span class="comment">//输出答案 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; p1;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,A[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = p2;i &lt; p2+m-p1;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,rev[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,A+i);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>秋叶拓哉，挑战程序设计竞赛第2版，北京：人民邮电出版社，2013.6，378-381</li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Miller_Rabin模板</title>
      <link href="/2019/08/08/Miller-Rabin/"/>
      <url>/2019/08/08/Miller-Rabin/</url>
      
        <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>Miller-Rabin素性测试是一种用来检验一个数  Q  是否为素数的随机算法。其时间复杂度为$O(log^3Q)$。其正确性为 $1-4^{-k}$ 其中 k 为检验次数。<br>该算法原本是由Gary Lee Miller 基于广义黎曼猜想发明，后经由Micheal O.Rabin改为不依赖该假设的随机化算法。<br>该算法的高效基于<strong>费马小定理</strong> 以及 <strong>二次探测法</strong> ，本文将首先简单介绍这两个基本理论，而后给出算法流程以及代码模板。</p><h4 id="问题模型"><a href="#问题模型" class="headerlink" title="问题模型"></a>问题模型</h4><p>例1：给定一个数Q，请判断其是否为素数(1e10 &lt; Q &lt; 1e14)。</p><p><strong>解题思路：</strong><br>判断一个数是否为素数，我们有在此之前是有$O(\sqrt{N})$的解题策略的，当然也有O(N)求出1~N所有素数的线性筛法，但是对于在1e10级别的待测数Q，这两者都显得过于低效，难以达到我们期望的效果。<br>Miller-Rabin算法是一种快速的大素数判断算法，判断每个素数仅需$O(log^3Q)$的时间，对于判断大素数而言有着令人满意的效率，因此我们可以采用该算法。</p><h4 id="费马小定理与二次探测法"><a href="#费马小定理与二次探测法" class="headerlink" title="费马小定理与二次探测法"></a>费马小定理与二次探测法</h4><p><strong>费马小定理：</strong> $a^{p-1} \equiv 1(mod p)$<br>其中 p 是素数时费马小定理才一定成立。于是得以得到“ p 是素数”是“费马小定理成立”的充分不必要条件。即存在一个数 p ，使得$a^{p-1} \equiv 1(mod p)$，但p不是素数。<br>本来我们是仅根据“p 是否能使得费马小定理成立”来判断 p 是否为素数，但这样错误率有点高，于是便有了二次探测法。</p><p><strong>二次探测法：</strong> 如果 p 是一个素数，且 0 &lt; x &lt; p，则方程$a^2 \equiv1(mod p)$的解为 a = 1 或 a = p - 1。</p><p><strong>证明：</strong><br>易得：$a^2 - 1 \equiv 0(mod p)$<br>所以 $(a+1)(a-1)\equiv0(mod p)$<br>所以 $p|(a-1)(a+1)$<br>又因为p是质数<br>所以 a = 1 或 a = p-1</p><p><em>注：其中 | 为整除符号，代表 p 能整数(a-1)(a+1)或者(a-1)(a+1)能被 p 整除。</em></p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>有了费马小定理，我们的算法模型就初步成型了，即测试一个数是否满足费马小定理来判断其是否可能为素数。假设这个数通过了费马小定理的测试，那么其有可能为素数，于是对其进行二次探测，如果仍然通过，则是素数的可能就很大（就可以基本认定其为素数），有效的提高了正确率。<br>但是由于我们的费马小定理对于底 a 是没有要求的，因此我们需要多挑几个底来做测试，提高算法正确性。网上有些结论，对于4,759,123,141以内的数，都可以通过以2，7，61为底的Miller-Rabin算法来进行判断。<br>不过常用的还是取随机数，取k次正确率就是$1-4^{-k}$，在出题人不知道你的随机数是多少的情况下，还是很难hack掉你的。</p><p>现在，如果有一个大于 2 的质数 n，令<script type="math/tex">n-1 = 2^s *  d</script>，其中 d 为奇数，则根据费马小定理，如果a不能被素数 n 整除，则<script type="math/tex">a^{n-1} \equiv 1 (mod n)</script>。于是可以推出：</p><p><script type="math/tex">a^d\equiv1(mod n)</script> 或者 <script type="math/tex">a^2 \equiv 1 (mod n)</script>，<script type="math/tex">a^{2^r  * d}\equiv n-1(mod \:n)</script>，0 &lt;= r &lt; s，其中a为任意自然数。<br>于是我们只需找到一个a，满足<script type="math/tex">a^{n-1} \neq1(modn)</script>或者存在一个自然数r(0&lt;= r &lt;s)，使得<script type="math/tex">a^{2^r  * d} \neq n-1(modn)</script>，就可以说明 n 一定不是素数。</p><p><strong>伪代码：</strong><br>isPrime(n):<br>&emsp;1.如果n为偶数，返回false；<br>&emsp;2.求出d、t，d为n-1去掉所有因子2后的值，同样的，t为n-1中因子2的个数；<br>&emsp;3.取一个随机数a，令x = <script type="math/tex">a^d mod n</script>；<br>&emsp;4.对于所有的 r (0 &lt;= r &lt; t)，令<script type="math/tex">y = a^{2^r * d} mod n</script>，即<script type="math/tex">y = x *  x mod n</script>，若y = 1，则根据二次探测定理，x必须为1或n-1，否则n不是素数，返回false；<br>&emsp;5.若x != 1，则不满足费马小定理，返回false，否则走3或返回true。</p><h4 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">API：</span></span><br><span class="line"><span class="comment">fuml(a,b,p)返回 a*b%p 的值,在中间结果溢出longlong时使用</span></span><br><span class="line"><span class="comment">qpow(a,b,p)返回 a^b%p 的快速幂函数 </span></span><br><span class="line"><span class="comment">isPrime(n)将在O(log^3 n)时间内判断出n是否为素数，并返回结果</span></span><br><span class="line"><span class="comment">typedef long long ll</span></span><br><span class="line"><span class="comment">头文件：cstdilb, </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> testnum[] = &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">61</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>&#125;;</span><br><span class="line"><span class="function">ll <span class="title">fmul</span><span class="params">(ll a,ll b,ll p)</span></span>&#123;</span><br><span class="line"><span class="comment">/*return a*b%p*/</span></span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = (res+a)%p;</span><br><span class="line">        a = (a+a)%p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b,ll m)</span></span>&#123;</span><br><span class="line"><span class="comment">/*return a^b %m*/</span></span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>)res = fmul(res,a,m);</span><br><span class="line">a = fmul(a,a,m);</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(n &lt; <span class="number">2</span> || n%<span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">ll d = n<span class="number">-1</span> , a, x, y; <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((d&amp;<span class="number">1</span>) == <span class="number">0</span>) d &gt;&gt;= <span class="number">1</span>,t++;</span><br><span class="line"><span class="comment">//此时b为没有因子2的奇数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">a = testnum[i];</span><br><span class="line"><span class="keyword">if</span>(n == a) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/*以本身为底是一定不成立的哦,需特判*/</span></span><br><span class="line">x = qpow(a,d,n);</span><br><span class="line"><span class="comment">/*我们要使得所有的a(^(2^r)*d)都满足二次探测定理*/</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; t;j++)&#123;</span><br><span class="line">y = fmul(x,x,n);</span><br><span class="line"><span class="keyword">if</span>(y == <span class="number">1</span> &amp;&amp; x != <span class="number">1</span> &amp;&amp; x != n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x = y;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(x != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/*不满足费马小定理*/</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/*当x=n-1，或b为奇数时返回true*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>算法设计编程实验，吴永辉，北京：机械工业出版社，2013，79-80</li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性基</title>
      <link href="/2019/07/26/xxj/"/>
      <url>/2019/07/26/xxj/</url>
      
        <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>线性基类似于线性空间中基底的一个概念。而在这里，线性基特指用来处理“集合为非负整数，运算为异或”的一类问题。在线性代数中有线性无关和极大线性无关组的概念，这里的线性基与之类似。<br>首先本文会从理论上介绍线性基所具有的性质以及其构造方法，接着会介绍线性基的常见操作以及其适用的问题范围。最终以例题讲解结束。</p><h4 id="什么是线性基"><a href="#什么是线性基" class="headerlink" title="什么是线性基"></a>什么是线性基</h4><p>线性基是一种特殊的基，它通常出现在异或运算中，它的意义为：通过原集合的某一最小子集S1使得S1内元素相互异或得到的值域与原集合S相互异或得到的值域相同。<br>如果按照线性代数中的说法，也可以表述为：通过S1内元素的组合异或可以得到原集合S中所有的元素。<br>那么S-S1其实就是冗余元素了，因为这些元素都可以通过线组合异或S1中的元素得到。</p><h4 id="线性基的性质"><a href="#线性基的性质" class="headerlink" title="线性基的性质"></a>线性基的性质</h4><p>下文中“最高位”若无特殊说明，皆指二进制下所有值为1的最高位，如10110的最高位就是第4位（从右向左是第0~4位）。</p><ol><li>线性基没有异或和为0的子集。</li><li>线性基的异或集合中每个元素的异或方案唯一（与性质1等价）。</li><li>线性基中的元素通过组合异或得到的值域和原集合组合异或得到的值域相同。</li><li>线性基中每个基的二进制最高位不同。</li><li>如果线性基是满线性基，则它的异或集合为区间$[1,2^n-1]$（n个基）。</li></ol><p>性质5很好证明，就像8个二进制位可以表示的范围是$[0,2^8-1]$，而我们这里的线性基不包含0，因此就是$[1 , 2^n-1]$。</p><p>性质4也是显而易见的。根据我们线性基的定义，其是原集合的最小子集，若有俩个最高位p（二进制从右向左第p位）上为1，那么它们对值域的贡献重复了，就不符合最小子集这一性质了。</p><p>性质3不需要解释了吧。性质1也很简单，我们线性基中是没有0向量的，而又由于性质4，所以不可能组合出0向量。</p><p>对于性质2的证明：如果我们要从线性基中挑若干个基异或得到x，那么假设$a_1$ xor $a_2$ xor … xor $a_p$ =$b_1$ xor $b_2$ xor … xor $b_q$ = x，那么显然$a_1$ xor $a_2$ xor … xor $a_p$ xor$b_1$ xor $b_2$ xor … xor $b_q$ = 0。与性质1矛盾，故性质2成立。</p><p>至此我们简单却正确的证明了上述5个性质的正确性。</p><h4 id="线性基的构造方法"><a href="#线性基的构造方法" class="headerlink" title="线性基的构造方法"></a>线性基的构造方法</h4><p>要给出个<strong>结论①：</strong> 若向量组中有a和b，那么若把b替换为a xor b，替换前后向量组中的向量线性组合得到的空间相同。<br><strong>证明：</strong><br>若c = a xor b，用c替代b，这样原向量组从 a、b 变成了 a 、c；<br>而a、c可以得到a、a xor c，即 a、b，因此a、c向量组实际等于a、b。</p><p>我们知道二进制位从右向左是低位到高位，现在我们从左向右遍历每一个数x的二进制位，下同。假设待插入线性基集合中的元素为x。</p><p>由于性质4，所以若 x 当前位置p上为1，它要么作为最高位为 p 的基，要么就乖乖的把第p位消为0，转而看看能不能当最高位为 p-1的基。而这里消掉 x 第 p 位的方法是与当前最高位为 p 的元素异或，依据上述结论①，显然这样消正确的，不会影响最终结果。</p><p>假设我们已经有基：1010、101，那么如果想插入1110，首先已经有1010了，所以其不能做最高位为3的基，于是消掉变为0110，又发现不能作为最高位为2的基，转而看看第1位，发现可以，于是他就成了10。这样我们就有了最高位是1、2、3 的基。</p><p>于是我们又发现我们只需根据性质4，记录最高位为 p 的数是多少就可以了，于是用一维数组P[ i ]来表示最高位为 i 的数是多少。</p><p><strong>伪代码：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for( j = 最高位; j &gt;= 0 ; j-- )&#123;</span><br><span class="line">    if(x的第j位为1)&#123;</span><br><span class="line">        if(线性基中有最高位为第 j 位的元素P[ j ])&#123;</span><br><span class="line">             x = P[j] xor x;</span><br><span class="line">             break;</span><br><span class="line">        &#125;else P[j] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线性基的常用操作"><a href="#线性基的常用操作" class="headerlink" title="线性基的常用操作"></a>线性基的常用操作</h4><p><strong>插入：</strong><br>正如上述伪代码所述，插入一个数x，其时间复杂度为O(log x)。</p><p><strong>删除：</strong> 首先我们可以注意到上述做法构造出来的线性基很难支持删除操作。<br><strong>合并线性基：</strong> 将一个线性基中的所有基用<strong>插入操作</strong>插入另一个线性基。时间复杂度为O(log n)。<br><strong>存在性查询：</strong> 可以发现，如果 x 无法插入，那么显然说明线性基可以构造出来x。O(log n)。<br><strong>求线性基能够组成的最大值：</strong> 从高位到低位扫描，如果异或该位的基后可以使得答案变大，则异或。O(log n)。<br><strong>求线性基表出的最小值：</strong> 从低位向高位找，第一个基就是答案。<br><strong>求第k小值：</strong> 我们之所以无法用上述构造方法构造出的线性基解决这题的原因在于，我们只保证了每个线性基最高位不同，却并未保证每个位上都有唯一的一个1，即<br>10000001<br>00000001<br>是合法的线性基，但是00000001是最小的，而次小的却不是10000001，而是00000001 xor 10000001。<br>于是我们可以考虑用类似高斯消元的方法来使得其满足“只要存在最高位为 p 的基，那么其它基的第 p 位都不能为1。”这样就可以通过 <strong>将k拆分成二进制位</strong>，如果拆分后第 i 位为1，就将ans与线性基中最高位为 i 的基异或，这样就能求出第 k 小。</p><h4 id="例题练习"><a href="#例题练习" class="headerlink" title="例题练习"></a>例题练习</h4><h5 id="2019-Multi-University-Training-Contest-1-—-Operation"><a href="#2019-Multi-University-Training-Contest-1-—-Operation" class="headerlink" title="2019 Multi-University Training Contest 1 — Operation"></a>2019 Multi-University Training Contest 1 — Operation</h5><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6579" target="_blank" rel="noopener"><strong>测试地址</strong></a></p><p><strong>题意简述：</strong> 给定一个具有 n 个元素的数组，有两种操作：</p><ol><li>在[l , r] 中选择一些数，使之异或和最大，输出最大值。</li><li>在数组最后添加一个数。</li></ol><p><strong>解题思路：</strong><br>首先如果不看操作2，那么显然操作1就是求区间内最大异或和问题。对于这样的问题，我们可以对于每个位置p记录最靠近其的前30个位置的线性基，当然这样并不能保证记录的线性基一定在[p - 30 , p ]内，所以在查询时也要筛掉位置在[l , r]外的基。说到这儿自然就又引入了一个记录每个基在原数组中的位置的数组pos。于是通过pos[N][30]和f[N][30]我们就可以在O(30)时间内查询，完成操作1。<br>对于操作2呢，我们要想的是如何更新 f 和 pos 数组。那么当插入一个新的元素 x 时，显然其所在位置为n+1（n为插入前元素总数），那么f[n+1][0~30]和f[n][0~30]不同之处就在于新元素 x 要更新原有线性基，使得最靠左的基被靠右（因为我们求最大异或和，一定是靠右位置的基优先被选择，所以如果俩个基的贡献相同，就用靠右的替代靠左的）的基更新即可。</p><p><strong>代码示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> t,n,m,lastans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],f[N][<span class="number">40</span>],pos[N][<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos[r][i] &gt;= l)&#123;</span><br><span class="line">            <span class="comment">//并不是f[r][30]所有元素都是在[l,r]内的</span></span><br><span class="line">            <span class="keyword">if</span>((ans^f[r][i]) &gt; ans) ans ^= f[r][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    lastans = ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Append</span><span class="params">(<span class="keyword">int</span> tot,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nex = tot;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">30</span>;i++)</span><br><span class="line">        f[tot][i] = f[tot<span class="number">-1</span>][i],pos[tot][i] = pos[tot<span class="number">-1</span>][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;i--) <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[tot][i])&#123;f[tot][i] = x;pos[tot][i] = nex;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(pos[tot][i] &lt; nex)&#123;</span><br><span class="line">        <span class="comment">/*找到最左边的那个基，</span></span><br><span class="line"><span class="comment">        这样不断替换最终最左边的基被挤出去</span></span><br><span class="line"><span class="comment">        nex是目前最靠左的位置*/</span></span><br><span class="line">            <span class="built_in">std</span>::swap(x,f[tot][i]);</span><br><span class="line">            <span class="built_in">std</span>::swap(nex,pos[tot][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        x ^= f[tot][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        lastans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i),Append(i,a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,op,l,r,x;i &lt;= m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op);</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">                l ^= lastans;r ^= lastans;</span><br><span class="line">                l %= n;r %= n;</span><br><span class="line">                l++;r++;</span><br><span class="line">                <span class="keyword">if</span>(l &gt; r) <span class="built_in">std</span>::swap(l,r);</span><br><span class="line">                Query(l,r);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">                x ^= lastans;</span><br><span class="line">                Append(++n,x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.lmlphp.com/user/56/article/item/1173/" target="_blank" rel="noopener">小蜜蜂的博客</a></li><li><a href="https://www.cnblogs.com/vb4896/p/6149022.html" target="_blank" rel="noopener">lzw4896s的博客</a></li><li><a href="https://ouuan.github.io/%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">ouuan的博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Treap</title>
      <link href="/2019/07/25/Treap/"/>
      <url>/2019/07/25/Treap/</url>
      
        <content type="html"><![CDATA[<p>Treap是是英文Tree和Heap的合成词，又称树堆。树堆是指具有随机附加域，且附加域满足堆性质的二叉搜索树。它属于平衡树的一种，主要是为了克服二叉搜索树易退化的情况。Treap利用“随机”来创造平衡条件，我们在插入每个节点时，除了其值val，我们还给它随机附加一个权值dat，使得权值val满足BST性质，而dat满足二叉堆性质。如此一来我们就保证了树的深度，使得检索、插入、求前驱、后继以及删除节点的时间复杂度都是O(log N)。<br><strong>例题：</strong></p><blockquote><p>普通平衡树BZOJ3224<br>您需要写一种数据结构，来维护一些数，其中需要提供以下操作：</p><ul><li>插入数值x</li><li>删除数值x（若有多个相同的数，应只删除一个）</li><li>查询数值x的排名（若有多个相同的数，应输出最小的排名）</li><li>查询排名为x的数值</li><li>求数值x的前驱（前驱定义为小于x的最大的数）</li><li>求数值x的后继（后继定义为大于x的最小的数）</li></ul></blockquote><p><strong>解题思路：</strong><br>这是一道平衡树的模板题，我们需要做的操作是在线的增删查，且查询分为四种。我们采用Treap解决。<br>根据题意，数据种可能有相同的数值，我们可以给每个节点增加一个域cnt，用来记录该节点的“副本数“，初始为1。若插入已存在是数值，就直接把该”副本数“加1。在删除时，减少该副本数，当减为0时删除该节点。如此就解决了关键码相同的问题。<br>对于查询排名，我们可以给每个节点新增一个域size，记录以该节点为根的子树中所有节点的”副本数“之和。<br>与线段树一样，我们需要在插入或者删除时从下往上更新size。另外，在发生旋转操作时，也需要修改size。最后，在检索BST基础上，通过判断左右子树size的大小，选择适当的一侧递归，就很容易查询排名了。</p><p><strong>代码示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Treap</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r; <span class="comment">// 左右子节点在数组中的下标</span></span><br><span class="line"><span class="keyword">int</span> val, dat; <span class="comment">// 节点关键码、权值</span></span><br><span class="line"><span class="keyword">int</span> cnt, size; <span class="comment">// 副本数、子树大小</span></span><br><span class="line">&#125; a[SIZE]; <span class="comment">// 数组模拟链表</span></span><br><span class="line"><span class="keyword">int</span> tot, root, n, INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">New</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">a[++tot].val = val;</span><br><span class="line">a[tot].dat = rand();</span><br><span class="line">a[tot].cnt = a[tot].size = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">a[p].size = a[a[p].l].size + a[a[p].r].size + a[p].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">New(-INF), New(INF);</span><br><span class="line">root = <span class="number">1</span>, a[<span class="number">1</span>].r = <span class="number">2</span>;</span><br><span class="line">Update(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetRankByVal</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (val == a[p].val) <span class="keyword">return</span> a[a[p].l].size + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (val &lt; a[p].val) <span class="keyword">return</span> GetRankByVal(a[p].l, val);</span><br><span class="line"><span class="keyword">return</span> GetRankByVal(a[p].r, val) + a[a[p].l].size + a[p].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetValByRank</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> rank)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">if</span> (a[a[p].l].size &gt;= rank) <span class="keyword">return</span> GetValByRank(a[p].l, rank);</span><br><span class="line"><span class="keyword">if</span> (a[a[p].l].size + a[p].cnt &gt;= rank) <span class="keyword">return</span> a[p].val;</span><br><span class="line"><span class="keyword">return</span> GetValByRank(a[p].r, rank - a[a[p].l].size - a[p].cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zig</span><span class="params">(<span class="keyword">int</span> &amp;p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> q = a[p].l;</span><br><span class="line">a[p].l = a[q].r, a[q].r = p, p = q;</span><br><span class="line">Update(a[p].r), Update(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zag</span><span class="params">(<span class="keyword">int</span> &amp;p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> q = a[p].r;</span><br><span class="line">a[p].r = a[q].l, a[q].l = p, p = q;</span><br><span class="line">Update(a[p].l), Update(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">p = New(val);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (val == a[p].val) &#123;</span><br><span class="line">a[p].cnt++, Update(p);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (val &lt; a[p].val) &#123;</span><br><span class="line">Insert(a[p].l, val);</span><br><span class="line"><span class="keyword">if</span> (a[p].dat &lt; a[a[p].l].dat) zig(p); <span class="comment">// 不满足堆性质，右旋</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Insert(a[p].r, val);</span><br><span class="line"><span class="keyword">if</span> (a[p].dat &lt; a[a[p].r].dat) zag(p); <span class="comment">// 不满足堆性质，左旋</span></span><br><span class="line">&#125;</span><br><span class="line">Update(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetPre</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>; <span class="comment">// a[1].val==-INF</span></span><br><span class="line"><span class="keyword">int</span> p = root;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (val == a[p].val) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[p].l &gt; <span class="number">0</span>) &#123;</span><br><span class="line">p = a[p].l;</span><br><span class="line"><span class="keyword">while</span> (a[p].r &gt; <span class="number">0</span>) p = a[p].r; <span class="comment">// 左子树上一直向右走</span></span><br><span class="line">ans = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[p].val &lt; val &amp;&amp; a[p].val &gt; a[ans].val) ans = p;</span><br><span class="line">p = val &lt; a[p].val ? a[p].l : a[p].r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a[ans].val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">2</span>; <span class="comment">// a[2].val==INF</span></span><br><span class="line"><span class="keyword">int</span> p = root;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (val == a[p].val) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[p].r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">p = a[p].r;</span><br><span class="line"><span class="keyword">while</span> (a[p].l &gt; <span class="number">0</span>) p = a[p].l; <span class="comment">// 右子树上一直向左走</span></span><br><span class="line">ans = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[p].val &gt; val &amp;&amp; a[p].val &lt; a[ans].val) ans = p;</span><br><span class="line">p = val &lt; a[p].val ? a[p].l : a[p].r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a[ans].val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Remove</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (val == a[p].val) &#123; <span class="comment">// 检索到了val</span></span><br><span class="line"><span class="keyword">if</span> (a[p].cnt &gt; <span class="number">1</span>) &#123; <span class="comment">// 有重复，减少副本数即可</span></span><br><span class="line">a[p].cnt--, Update(p);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[p].l || a[p].r) &#123; <span class="comment">// 不是叶子节点，向下旋转</span></span><br><span class="line"><span class="keyword">if</span> (a[p].r == <span class="number">0</span> || a[a[p].l].dat &gt; a[a[p].r].dat)</span><br><span class="line">zig(p), Remove(a[p].r, val);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">zag(p), Remove(a[p].l, val);</span><br><span class="line">Update(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> p = <span class="number">0</span>; <span class="comment">// 叶子节点，删除</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">val &lt; a[p].val ? Remove(a[p].l, val) : Remove(a[p].r, val);</span><br><span class="line">Update(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Build();</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line"><span class="keyword">int</span> opt, x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;opt, &amp;x);</span><br><span class="line"><span class="keyword">switch</span> (opt) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">Insert(root, x);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">Remove(root, x);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, GetRankByVal(root, x) - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, GetValByRank(root, x + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, GetPre(x));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, GetNext(x));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考书目：</strong></p><ul><li>《算法竞赛进阶指南》李煜东.P229</li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
