<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CodeForces Round]]></title>
    <url>%2F2019%2F09%2F21%2Fcf-586%2F</url>
    <content type="text"><![CDATA[A. Cards测试地址题意简述：给定一个长度为 n 的字符串，该字符串可以组合出来几个one和几个zero，每个字符只能用一次。 代码示例：1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e5+10;char str[N];int nn;void solve()&#123; int n,z,e,r,o; n = z = e = r = o = 0; for(int i = 1;i &lt;= nn;i++)&#123; if(str[i] == 'o') o++; else if(str[i] == 'z') z++; else if(str[i] == 'r') r++; else if(str[i] == 'e') e++; else n++; &#125; int one,zero; one = min(n,min(o,e)); n -= one, o -= one, e -= one; zero = min(o,min(e,min(z,r))); for(int i = 1;i &lt;= one;i++) printf("1 "); for(int i = 1;i &lt;= zero;i++) printf("0 ");&#125;int main()&#123; scanf("%d",&amp;nn); scanf("%s",str+1); solve(); return 0;&#125; B. Multiplication Table测试地址题意简述：给定一个n n表格，其中$M_{i,j} = a_i a_j$，现在有个坏蛋把序列a给扔了，同时把M_{i,i}都给扣走了，现在请你利用剩下的信息求出a序列。 解题思路：不是高斯消元题，其实是个找规律题。如果我们能求出来$a_1$，那么我们就可以根据第一列求出所有答案。而我们又可以根据$a_1a_2 = x$ , $a_1a_3 = y$ , $a_2a_3 = z$来求出$a_1$，于是就可以在求出其他所有结果了。代码示例： 1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;cmath&gt;int n;const int N = 1e3+10;typedef __int64 ll;ll mat[N][N],ans[N];void solve()&#123; ans[1] = mat[1][2]*mat[1][3]/mat[2][3]; ans[1] = (ll)sqrt(ans[1]); for(int i = 2;i &lt;= n;i++) ans[i] = mat[1][i]/ans[1]; for(int i = 1;i &lt;= n;i++) printf("%I64d ",ans[i]);&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= n;j++) scanf("%I64d",&amp;mat[i][j]); solve(); return 0;&#125; C. Substring Game in the Lesson测试地址题意简述：Ann和Mike在玩游戏，有一个字符串s，初始时有l = r = k ，每个人轮流操作： 选择l’ &lt; l , r’ &lt; r，且s[l’,r’] 字典序小于 s[l,r]，然后令l = l’, r = r’。 若不能做任何操作，则失败。 Ann先手，对于每个位置k，输出谁必胜。 题意简述：简单的博弈论，首先必败态是“在 l 之前不存在l’ &lt; l ， 且s[l’ , r] 字典序小于 s[l ,r] ”，而若当前不是必败态，则一定可以使得下一个状态一定是必败态，于是只需要判断每个位置前面是否有字典序比其小的字符即可。 代码示例：1234567891011121314151617181920212223#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N = 5e5+10;const int INF = 0x3f3f3f3f;char str[N];int vis[N];void solve()&#123; int mi = (int)str[0],n = strlen(str); for(int i = 1;i &lt; n;i++)&#123; if(mi &lt; (int)str[i]) vis[i] = 1; mi = min(mi,(int)str[i]); &#125; for(int i = 0;i &lt; n;i++) if(vis[i]) printf("Ann\n"); else puts("Mike");&#125;int main()&#123; scanf("%s",str); solve(); return 0;&#125; D. Alex and Julian测试地址题意简述：给定一个正整数集合B，令全集Z(所有整数)内的元素作为无向图的顶点，对于图中内任意两点i 和 j，若abs(i - j)属于集合B，则 i 和 j 之间有一条无向边。现在请问最少删除B中几个顶点可以使得剩下的图是二分图。 解题思路：不是二分图问题，只用到了“一张图是二分图，当且仅当图中不存在奇环”这一二分图判定定理。至于为啥不能用二分图算法来解决呢，从问题规模就可以猜到，因为要构造图需要$O((1e18)^2)$，显然n的规模不允许这样做。 那么从数学角度考虑（找规律），若有节点0和节点a，那么0 到 a有边，若还存在节点2a ，那么a 和2a也有边，且2a与 0也有边，这就是奇环了（哪怕还有3a，也还是奇环+一个偶环），因此不能有2a，同理也不能有4a，因此若想保留a，那么2a，4a， 8a， … 都要删去。但是这样做法复杂度过高，因为顶点集合是[1, 1e18]，挨个计算显然不现实，因此我们可以对集合B中每个元素b，B中有哪些元素可以和b一起被保留。 若a中有x个因数2，b中有y个因数2（x != y），那么a和b一定不能同时存在；假设c = lcm(a ,b)那么0 -&gt; a -&gt; 2a -&gt; … -&gt; c -&gt; … -&gt; 2b -&gt; b -&gt; 0一定可以构成一个奇环 ，因此a和b不能同时存在。所以若是x != y，则a和b不能同时存在（a和b都是集合B内元素）。 若是x = y，那么a和b可以同时存在，因为它们不存在a是b的倍数，或者b是a的倍数这种情况，也就不能删去0，因此若有环则一定是偶环。 综上所述，我们通过统计B集合中每个元素有多少个因子2即可判断最多同时存在多少个元素，即最少删去多少个元素。代码示例：123456789101112131415161718192021222324#include&lt;cstdio&gt;const int N = 2e5+10;typedef __int64 ll;ll a[N];int tc[N],num[N],n;void solve()&#123; for(int i = 1;i &lt;= n;i++)&#123; ll tmp = a[i]; while(tmp &amp;&amp; tmp%2 == 0) tc[i]++,tmp/=2; num[tc[i]]++; &#125; int p = 0; for(int i = 1;i &lt;= 64;i++) if(num[p] &lt; num[i]) p = i; printf("%d\n",n-num[p]); for(int i = 1;i &lt;= n;i++) if(tc[i] != p) printf("%I64d ",a[i]);&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;i++) scanf("%I64d",a+i); solve(); return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5 连续内存分配]]></title>
    <url>%2F2019%2F09%2F20%2Fos5%2F</url>
    <content type="text"><![CDATA[计算机体系结构和内存层次 计算机体系结构 内存层次 操作系统的内存管理方式 计算机体系结构基本的分配和释放的管理要求。cpu高速缓存，存储管理单元（MMU），内存最小访问单位8bit；32位的意思是一次可以读写32位；高速缓存用来存放会重复使用的数据，用来提高效率； 内存层次缓存速度最快，首先去缓存找数据，若未命中则去内存中找，若仍未命中则去外存（虚拟内存）中找，这三者速度差别很大。 操作系统的内存管理知识点：我们希望的理想状态。逻辑存储单元。存储管理要达到的效果： 抽象：逻辑地址空间 保护：独立地址空间 共享：访问相同内存 虚拟化：更大的地址空间 操作系统中采用的内存管理方式： 重定位（relocation） 分段（segmentation） 分页（paging） 虚拟存储（目前多数系统，如Linux，采用按需页式虚拟存储） 实现高度依赖硬件： 与计算机存储架构紧耦合 MMU（内存管理单元）：处理CPU存储访问请求的硬件 地址空间和地址生成地址空间的定义逻辑地址生成地址生成时机和限制地址生成过程地址检查]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
      <tags>
        <tag>内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dudu's maze 解题报告]]></title>
    <url>%2F2019%2F09%2F15%2Fdudu-maze%2F</url>
    <content type="text"><![CDATA[测试地址题意简述：在一个无向图中，有 k 个怪物点，n-k个糖果点，每个糖果点有1个糖果，且可以移动到相邻的点，但是每个点的糖果只能拿一次（但是可以经过多次）。而每个怪物点没糖果，但是可以随机传送到相邻的点，只能传送一次（即只能进一次怪物房），请问最终拿到糖果的最优期望是多少？解题思路：dfs求连通块+染色，我现在还是不明白我单独染色为什么一直超时，无语了，就按照下面的代码写吧，用标记数组单独存放被染色的连通块糖果数，相当于记忆化。当然节点1所在的连通块糖果都能拿到，然后再选择走和1相连的且期望最大的怪物点即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 2e5+10;int head[N],ver[2*N],nex[2*N],tot = 1;int n,m,t,k;int vis[N],mst[N];void addEdge(int x,int y)&#123; ver[++tot] = y;nex[tot] = head[x]; head[x] = tot;&#125;int ans = 0;int vm[N],cnt = 0;int num[N];int tc[N];void dfs1(int x)&#123; vis[x] = 1; ans++; tc[x]++; for(int i = head[x];i != -1;i = nex[i])&#123; int y = ver[i]; if(vis[y]) continue; if(mst[y])&#123; vm[++cnt] = y; continue; &#125; dfs1(y); &#125;&#125;double dfs2(int x,int col)&#123; if(num[col]) return num[col]; if(vis[x] || mst[x]) return 0; double res = 1; vis[x] = col; for(int i = head[x];i != -1;i = nex[i])&#123; int y = ver[i]; if(vis[y] || mst[y]) continue; res += dfs2(y,col); &#125; return res;&#125;void solve()&#123; ans = 0; cnt = 0; memset(vis,0,sizeof vis); memset(num,0,sizeof num); dfs1(1); double mx = 0; int col = 1; for(int i = 1;i &lt;= cnt;i++)&#123; double pp = 0,ecnt = 0; for(int j = head[vm[i]] ;j != -1;j = nex[j]) ecnt++; //printf("ecnt: %f\n",ecnt); for(int j = head[vm[i]] ;j != -1;j = nex[j])&#123; int y = ver[j]; double tmp; if(vis[y]) tmp = num[vis[y]]; else&#123; tmp = dfs2(y,++col); num[col] = tmp; &#125; pp += tmp; //printf("%d %f\n",ver[j] ,tmp); &#125; pp /= ecnt; if(mx - pp &lt; 0) mx = pp; &#125; printf("%.7f\n",mx+ans);&#125;int getInt() &#123; int ans = 0; bool neg = false; char c = getchar(); while (c!='-' &amp;&amp; (c&lt;'0' || c&gt;'9')) c = getchar(); if (c == '-') neg = true, c = getchar(); while (c&gt;='0' &amp;&amp; c&lt;='9') ans = ans*10 + c-'0', c = getchar(); return neg ? -ans : ans; &#125;int main()&#123; t = getInt(); while(t--)&#123; tot = 1; memset(mst,0,sizeof mst); memset(head,-1,sizeof head); n = getInt(), m = getInt(),k = getInt(); for(int i = 1,x,y;i &lt;= m;i++)&#123; x = getInt(); y = getInt(); addEdge(x,y);addEdge(y,x); &#125; for(int i = 1,x;i &lt;= k;i++) x = getInt() , mst[x] = 1; solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>dfs连通块</tag>
        <tag>染色</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 72 解题报告]]></title>
    <url>%2F2019%2F09%2F10%2Fcf-r72%2F</url>
    <content type="text"><![CDATA[题集链接 A.Creating a Character题意简述：有三个数a，b，c，将c分配在a和b上，使得a&gt;b，请问有多少种分配方案？两个方案不同，当且仅当它们对应的a或b不相等。 解题思路：假设将c分配给a和b后使得a = b = res，那么显然若原始的a &gt; res，就说明b+c &lt; a，那么答案就是c+1（当然特判b+c&lt;a也行）；否则a &lt;= res，此时分配给a的值一定要大于res - a，所以共c - (res-a) = c-res + a 种不同方案。 代码示例：12345678910111213141516#include&lt;cstdio&gt;int a,b,c,t,d;int solve()&#123; if(a+c &lt;= b) return 0; int res = a+b+c&gt;&gt;1; if(a &gt; res) return c+1; return c-res+a; &#125;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); printf("%d\n",solve()); &#125; return 0;&#125; B.Zmei Gorynich题意简述：一条恶龙共 x 滴血，勇士有n件武器，每件武器有伤害值 d 和 副作用 h，表示着将会给恶龙造成 d 点伤害，之后会给恶龙回 h 点血。当某一时刻恶龙血量低于0时则会死亡，请问勇者最少砍多少次才能杀死恶龙？如果杀不死输出-1，一个武器可以重复使用。解题思路：如果当前有一个武器能杀死恶龙（d &gt;= x），那么就可以忽略他的副作用 h ，直接秒杀恶龙；否则我们就要选择一个d-h最大的来砍恶龙，所以我们最多用两把武器，一把用来消耗，一把用来终结恶龙。当无法秒杀恶龙，也无法消耗恶龙时，说明无法杀死恶龙。否则就可以通过计算最少需要消耗多少次来O(1)计算答案。 特别注意是否能一刀秒杀恶龙等特殊情况。 代码示例：1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int t,n,x;const int N = 110;int t1,t2;int solve()&#123; if(x &lt;= 0) return 0; //恶龙本来就死了 if(t1 &gt;= x) return 1; //秒杀恶龙 if(t2 &lt;= 0) return -1; //无法杀死恶龙 x -= t1; int res = 1; if(x%t2) res++; res += x/t2; return res;&#125;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;x); t1 = t2 = 0; for(int i = 1,ta,tb;i &lt;= n;i++)&#123; scanf("%d%d",&amp;ta,&amp;tb); t1 = max(t1,ta); t2 = max(t2,ta-tb); &#125; printf("%d\n",solve()); &#125; return 0;&#125; C.The Number Of Good Substrings题意简述：给定一个01串 s ，假设 sub 是 s 的子串，定义f(sub) = “sub十进制的值”。若f(sub) = len(sub)，f(sub) = 子串sub的长度，那么称sub为“优秀的子串”。现在给定字符串s，试求出s的“优秀的子串”的数量。 解题思路：刚开始想用KMP算法：对于每一可能的长度（共2e5种可能的情况）转化为二进制的01串，再用KMP计算该串在 s 中出现的次数，将所有情况累加即为答案。但是KMP超时了，还是对KMP不太熟悉，上述算法复杂度应该是$O(N^2)$，是不行的。 再考虑由于$2^{20} &gt; 2e5$ 所以我们其实可以通过将 s 所有长度为 [1 , 20] 的子串挨个判断是否为“优秀的子串”，如此O(20N)时间内求出结果。具体做法是从左向右，将上一个 1 作为子串左端点，然后依次向右延申，长度+1，并将其转化为十进制，如果该十进制要大于区间长度，则后续肯定也不可能是“优秀子串”，故退出。能这样做是因为左边的0不影响十进制数的大小，而右边的0影响。 代码示例：123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N = 2e5+10;char str[N];typedef __int64 ll;int t;ll solve()&#123; int last = 0,x,l,len = strlen(str); ll ans = 0; for(int i = 0;str[i];i++)&#123; if(str[i] == '0') continue; x = 0; for(int j = i;j &lt; len &amp;&amp; j &lt;= i+25;j++)&#123; x = x*2+str[j]-'0'; l = j-x+2; if(l &lt;= last) break; ans++; &#125; last = i+1; &#125; return ans;&#125;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; scanf("%s",str); printf("%I64d\n",solve()); &#125; return 0;&#125; D.Coloring Edges题意简述：给定一个有 n 个点 m 条边的有向图，该有向图无自环无重边。我们对该有向图进行染色，一个好的染色方案当且仅当图中没有一个环是同一个颜色。请问要想使得该染色方案是好的，最少需要多少种不同的颜色？并输出每条边的颜色。解题思路：首先通过手画几种样例可以得出，我们最多只需要2种不同的颜色就可以完成图的着色。因此若图中有环，则k = 2，否则k = 1。而当k = 2时，即图中有环，需要2种不同颜色染色时，我们知道有向图中，若存在环，则必然有从编号小的点指向编号大的点，也有编号大的点指向编号小的点。因此，若边u-&gt;v，若u &lt; v则染颜色1，否则染颜色2，这样可以保证该环被拆分成两种颜色。 注：若有向图中不存在环，则不一定有 “从编号小的点指向编号大的点，同时也有从编号大的点指向编号小的点。” 代码示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;cstring&gt;const int N = 5e3+10;int head[N],edge[N],ver[N],nex[N];int tot = 0;void addEdge(int x,int y)&#123; ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;&#125;int n,m,xx[N],yy[N];bool flag = false;int vis[N]; void dfs(int x)&#123; if(flag) return; vis[x] = 1; for(int i = head[x];i ;i = nex[i])&#123; int y = ver[i]; if(vis[y] == 1)&#123; flag = true; return; &#125;else if(!vis[y]) dfs(y); &#125; vis[x] = 2;&#125;void solve()&#123; for(int i = 1;i &lt;= n;i++) if(!vis[i]) dfs(i); if(flag) &#123; puts("2"); for(int i = 1;i &lt;= m;i++)&#123; if(xx[i] &gt; yy[i]) printf("2 "); else printf("1 "); &#125; &#125; else &#123; puts("1"); for(int i = 1;i &lt;= m;i++) printf("1 "); &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1;i &lt;= m;i++)&#123; scanf("%d%d",&amp;xx[i],&amp;yy[i]); addEdge(xx[i],yy[i]); &#125; solve(); return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu6629 string matching（拓展KMP）]]></title>
    <url>%2F2019%2F09%2F06%2Fhdu6629-String-Match%2F</url>
    <content type="text"><![CDATA[hdu6629string matchingDescription:给出一个字符串S，我们执行“求出S所有后缀与S的最长公共前缀长度”这个操作，我们采取暴力算法(算法流程见题面)，请问我们在该算法中共执行了多少次比较操作？Input:第一行一个整数t，接下来共t组测试用例，每个测试用例输入一个长度小于1e6的字符串S。解题思路：可以用拓展KMP做，其中S是原串，T也是原串。暴力算法的比较次数就等同于所有后缀的最长公共前缀长度和，若没有比到字符串末尾，则还要加上一次失配的操作比较。由于本题T也是S，故可以在计算nex数组的同时便统计答案。 代码示例：12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;cstring&gt;int t;const int N = 1e6+10; int nex[N]; //nex[i] = T[i,n-1]与T[0,n-1]最长公共前缀 char S[N];//S为目标串,T为模式串 typedef long long ll;ll ans = 0;void getNex(char* str)&#123; int len = strlen(str) ,i = 0,j,p0 ; nex[0] = len; while(i+1 &lt; len &amp;&amp; str[i] == str[i+1]) i++; nex[1] = i; p0 = 1; ans += nex[1]; if(nex[1] != len-1) ans++; for(int i = 2;i &lt; len;i++)&#123; if(nex[i-p0]+i &lt; nex[p0]+p0) nex[i] = nex[i-p0]; else &#123; j = nex[p0]+p0-i; if(j &lt; 0) j = 0; while(i+j &lt; len &amp;&amp; str[j] == str[j+i]) j++; nex[i] = j; p0 = i; &#125; ans += nex[i]; if(nex[i] != len-i) ans++; &#125;&#125; ll solve()&#123; /*计算并返回答案*/ ans = 0; getNex(S); return ans;&#125;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; scanf("%s",S); printf("%lld\n",solve()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>拓展KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓展KMP算法]]></title>
    <url>%2F2019%2F09%2F06%2Fexkmp%2F</url>
    <content type="text"><![CDATA[问题模型：给定字符串S和子串T，S的长度为n，T的长度为m；求字符串T与字符串S的每一个后缀d的最长公共前缀。 拓展KMP算法假设 extend[] 数组： extend[i] 表示 T 与 S[i, n] 的最长公共前缀，目的是求出所有的 extend[0~n-1]。（注意到，如果存在extend[i] = m，则说明 T 在 S 中完全出现过，那么问题就变成标准KMP算法了。）我们下面的目标就是如何在较短的时间内更新extend数组；与KMP算法类似，我们通过利用next数组来阻止指针的回退。 下面先通过一般的例子来看我们是如何更新extend数组的： S = “aaaabaa” , T = “aaaaa”。 显然extend[0] = 4，显然当匹配到第5个时失配，共匹配了5次。我们考虑利用已知的信息来计算extend[1]，已知S[1 , 3] = T[1 , 3]，现在要用S[1 , n-1]和T[0 , n-1]进行匹配，如果我们设 nex[1] 存放 T[1 , n-1] 与 T[0 , n-1] 的最长公共前缀，nex[1] = 4，这就说明对于S[1, n-1]，T[1 , n-1]能匹配上的字符，T[0,n-1]的前nex[1]个也能匹配的上，由于T[1,n-1]只能匹配S[1 , 3]共3个字符，那么显然前 3 个字符都可以成功匹配，我们直接匹配下一位即可；于是extend[1] = 3。 算法步骤定义extend[]数组： extend[i] 表示字符串 T 与字符串 S[i , n] 的最长公共前缀长度。定义nex[]数组： nex[i] 表示 T[i , n] 与 T[1 , n] 的最长公共前缀的长度。 首先我们从左到右计算extend数组，假设在某一时刻 extend[0 , k] 已经计算完毕，并且之前匹配过程中所达到的最远距离为p，所谓最远距离即 p = MAX{ i+extend[i] (0 &lt;= i &lt;= k) } 的最大值，p’ 为达到最远距离时的 i 。 现在来利用已知的信息求extend[k+1]：已知S[p’ , p] = T[0, p-p’]，即S[k+1 , p] = T[k+1 - p’ , p-p’]。设 len = nex[k+1 - p’] ，即 len 为 T[k+1 - p’ , n-1] 与 T[0 , n-1]的最长公共前缀。 如果k+len &lt; p，则extend[k+1] = len：此时由于已知条件 以及 nex数组性质，可以知道前 len 个字符一定是匹配的。若S[k+ len+1] = T[len]，则说明 nex 是len+1而非len，于是与nex数组矛盾，故不成立；因此若k+len &lt; p，则extend[k+1] = len。 (图1：当k+len&lt;p时情形，其中po = p’，图片来自 dyx心心 的博客) 若k+len &gt;= p：此时已知的是S[k+1 , p] = T[0 , p-k-1]，但是 S[p+1] 是否等同于 T[p-k] 尚且未知，因此需要向后遍历判断，同时更新p与p’。 (图2：当k+len &gt;= p时情形，其中po = p’，图片来自 dyx心心 的博客) 对于nex数组，其求法和extend数组类似，详情参考代码中getNex()函数实现方法。 例题模板洛谷P5410拓展KMP模板题意简述：给定字符串S和T，输出next数组以及extend数组。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;cstring&gt;const int N = 1e6+10; int nex[N]; //nex[i] = T[i,n-1]与T[0,n-1]最长公共前缀 char S[N],T[N]; //S为目标串,T为模式串 int extend[N]; void getNex(char* str)&#123; /*计算nex数组*/ int len = strlen(str) ,i = 0, j, p0 ; nex[0] = len; while(i+1 &lt; len &amp;&amp; str[i] == str[i+1]) i++; nex[1] = i; p0 = 1; for(int i = 2;i &lt; len;i++)&#123; if(nex[i-p0]+i &lt; nex[p0]+p0) nex[i] = nex[i-p0]; else &#123; j = nex[p0]+p0-i; if(j &lt; 0) j = 0; while(i+j &lt; len &amp;&amp; str[j] == str[j+i]) j++; nex[i] = j; p0 = i; &#125; &#125;&#125; void exKMP(char* str1,char *str2)&#123; /*计算str2与str1的所有后缀的最长公共前缀长度,存放在extend数组中*/ int i = 0,j,p0,l1 = strlen(S), l2 = strlen(T); getNex(str2); while(i &lt; l1 &amp;&amp; i &lt; l2 &amp;&amp; str1[i] == str2[i]) i++; extend[0] = i;p0 = 0; for(int i = 1;i &lt; l1;i++)&#123; if(nex[i-p0]+i &lt; extend[p0]+p0) extend[i] = nex[i-p0]; else&#123; j = extend[p0]+p0-i; if(j &lt; 0) j = 0; while(i+j &lt; l1 &amp;&amp; j &lt; l2 &amp;&amp; str1[j+i] == str2[j]) j++; extend[i] = j; p0 = i; &#125; &#125;&#125;void solve()&#123; /*计算并输出答案*/ int l1 = strlen(S), l2 = strlen(T); exKMP(S,T); for(int i = 0;i &lt; l2;i++) printf("%d ",nex[i]); puts(""); for(int i = 0;i &lt; l1;i++) printf("%d ",extend[i]);&#125;int main()&#123; scanf("%s%s",S,T); solve(); return 0;&#125; 参考资料 dyx心心的博客]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>拓展KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu6638 Snowy Smile-线段树维护最大子矩阵]]></title>
    <url>%2F2019%2F09%2F03%2Fhdu6638-Snowy-Smile%2F</url>
    <content type="text"><![CDATA[题目链接 Snowy Smile题意简述：给出平面上n(n &lt;= 2000)个点，点的坐标在-1e9~1e9之间，试求出最大子矩阵的和是多少。 解题思路：考虑数据范围，2e3个点离散化后可能会有2e3个，本题中各个点是离散的，所以用普通的动态规划比较麻烦，因此本题采用$O(N^2log_2N)$的线段树+枚举。我们对x，枚举所有可能的x[i]和x[j]其中x[i]为上界，x[j]为下界，这个枚举花费时间为$O(N^2)$，而对于每一种可能的组合，再利用线段树$O(log_2N)$求出最大连续子段和，因此总时间$O(N^2log_2N)$。代码示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;const int N = 3010;int t,n;int tmp[N]; //离散化用typedef long long ll;struct Chest&#123; int x,y,val; bool operator &lt;(const Chest &amp; B) const&#123; return x &lt; B.x; &#125;&#125;cs[N];struct SegmentTree&#123; /*分别为区间和,区间最大子段和, 从左侧开始的最大子段和,从右侧开始的最大子段和*/ ll sum,mx,lx,rx; #define sum(x) tr[x].sum #define mx(x) tr[x].mx #define lx(x) tr[x].lx #define rx(x) tr[x].rx &#125;tr[N*4];void BuildTree(int rt,int l,int r)&#123; /*在区间[l,r]上建立一棵线段树*/ sum(rt) = mx(rt) = lx(rt) = rx(rt) = 0; if(l == r) return; int mid = l+r&gt;&gt;1; BuildTree(rt*2,l,mid); BuildTree(rt*2+1,mid+1,r);&#125;void spread(int rt)&#123; /*用于根据rt的子节点更新rt的4个数据*/ sum(rt) = sum(rt*2)+sum(rt*2+1); mx(rt) = max(rx(rt*2)+lx(rt*2+1),max(mx(rt*2),mx(rt*2+1))); lx(rt) = max(lx(rt*2),sum(rt*2)+lx(rt*2+1)); rx(rt) = max(rx(rt*2+1),sum(rt*2+1)+rx(rt*2));&#125; void Insert(int rt,int p,int val,int l,int r)&#123; /*将线段树p位置的值设为val;l,r是辅助作用哦*/ if(l == r)&#123; sum(rt) += val; lx(rt) = rx(rt) = mx(rt) = sum(rt); return; &#125; int mid = l+r&gt;&gt;1; if(p &lt;= mid) Insert(rt*2,p,val,l,mid); else Insert(rt*2+1,p,val,mid+1,r); spread(rt); //在回溯时更新节点的值 &#125;ll ask()&#123; /*返回当前最大连续子段和*/ return tr[1].mx;&#125;void solve()&#123; sort(tmp+1,tmp+1+n); int cnt = unique(tmp+1,tmp+1+n)-tmp-1; sort(cs+1,cs+1+n); ll ans = 0; /*我们对每一个x[i]上限,枚举所有可能x[j]的下限, 并利用线段树求出x[i]~x[j]最大字段和*/ for(int i = 1;i &lt;= n;i++)&#123; if(cs[i].x == cs[i-1].x &amp;&amp; i != 1) continue; BuildTree(1,1,cnt); for(int j = i;j &lt;= n;j++)&#123; if(cs[j].x != cs[j-1].x &amp;&amp; i != j) ans = max(ans,ask()); int y = lower_bound(tmp+1,tmp+1+cnt,cs[j].y)-tmp; Insert(1,y,cs[j].val,1,cnt); &#125; ans = max(ans,ask());//如果全部相等,在此处特判 &#125; printf("%lld\n",ans);&#125; int main()&#123; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;i++)&#123; scanf("%d%d%d",&amp;cs[i].x,&amp;cs[i].y,&amp;cs[i].val); tmp[i] = cs[i].y; &#125; solve(); &#125;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>最大子矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019航电多校7部分题解]]></title>
    <url>%2F2019%2F09%2F02%2Fhdu7%2F</url>
    <content type="text"><![CDATA[A. A + B = C有空再写，麻烦死了。 F. Final Exam题意简述题意有点绕，一份考试总分为m分n道题，每道题可能为 n 类科目中的一类。如果我们想做出一道分值为 a 的题，那么我们至少要复习该题所在的科目 a+1 分钟以上。请问如果我们要想最少做出k题，需要花多长时间？ 解题思路:首先搞清题意，就是我们目标是最少做出k题需要花费的最少时间，那么最坏情况就是老师针对我们，出我们复习时间最少的n - k + 1道题，令每道题都等于该学生复习的时间（因为总分确定，这样才最优）。那么如果我想通过，那就要令自己复习时间最少的n-k+1门科目复习总时间 &gt; m，这样老师就无论如何也针对不了我了。代码示例：123456789101112131415161718#include&lt;cstdio&gt;typedef long long ll;int t;ll n,m,k;void solve()&#123; int tmp = n-k+1; int b = m/tmp + 1; ll ans = (k-1)*b + m+1; printf("%lld\n",ans);&#125;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k); solve(); &#125; return 0;&#125; K. Kejin Player题意简述：满级为n+1级，从第 i 级升到 i+1 级需要a[i]金币，成功几率为r[i] / s[i] ，如果成功则等级从i变为i+1，失败则等级从 i 变为 x[i] （x[i] &lt;= i）。请问从l升到r级，需要多少金币？解题思路：这是一道概率dp题，且概率可以加减，设f[ x ] 为从1级升到x级需要的金币，那么从l级升到r级需要f[r] - f[l]金币。这是因为升到某一级需要的金币数是固定的，所以满足加减原则。加速我们当前在 i 级，有 p 的概率花费a[i]金币升到 i+1 级，假设我们尝试了t次才升级成功，即： f[i+1] = f[i] + a[i] + (t - 1) * a[i] + (t - 1) * (f[ i ] - f[ x[i] ])又因为$\frac{t-1}{t} = p$，得$t = \frac{s[i]}{r[i]}$，带入得： f[i+1] = f[i] + \frac{s[i]}{r[i]} * a[i] + (\frac{s[i]}{r[i]} - 1) * (f[ i ] - f[ x[i] ])遇到这种概率题，设试了t次才成功，然后用概率表示 t 即可得出递推公式。 代码示例：123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;const int N = 5e5+10;typedef long long ll;ll r[N],s[N],x[N],a[N];//p = r/sint t,n,q;const ll P = 1e9+7;ll f[N];ll qpow(ll a,ll b,ll m)&#123; ll res = 1; while(b)&#123; if(b&amp;1) res = res*a%m; a = a*a%m; b &gt;&gt;= 1; &#125; return res;&#125; void solve()&#123; /*预处理出所有答案*/ for(int i = 1;i &lt;= n;i++)&#123; ll pp = s[i]*qpow(r[i],P-2,P)%P; //s[i]/r[i]的逆元 f[i+1] = (f[i] + pp*a[i]%P + (pp-1)*(f[i]-f[x[i]])%P+P)%P; //printf("%lld\n",f[i+1]); &#125;&#125; int main()&#123; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;q); for(int i = 1;i &lt;= n;i++) scanf("%lld%lld%lld%lld",r+i,s+i,x+i,a+i); solve();//离线 for(int i = 1,tl,tr;i &lt;= q;i++)&#123; scanf("%d%d",&amp;tl,&amp;tr); printf("%lld\n",(f[tr]-f[tl]+P)%P); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>概率dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓展欧拉定理+幂塔函数]]></title>
    <url>%2F2019%2F09%2F02%2Fexphi%2F</url>
    <content type="text"><![CDATA[拓展欧拉定理与幂塔函数欧拉定理： 若gcd(a,p) = 1，则 $a^p \equiv a^{b \% \varphi (p)}(mod \: p)$，其中gcd(a,p) = 1。拓展欧拉定理： 假设a为任意数，b和m为正整数，且$b &gt; \varphi(m)$，a和m不一定要互质，那么有如下公式： a^b~\equiv~\begin{cases}a^{b~Mod~\phi(m)} &\gcd(a,m)~=~1 \\a^b &\gcd(a,m)~\neq~1~\land~b~]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>幂塔函数</tag>
        <tag>拓展欧拉定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018南京icpc网络赛]]></title>
    <url>%2F2019%2F08%2F30%2F2018nanjing%2F</url>
    <content type="text"><![CDATA[有嗲难，还有些卡时，思路还有些难想，虽然都是经典模型。 A. An Olympian Math Problem原题链接解题思路：如果是比赛时我估计会推公式，但在这通过率面前，我猜了个公式就交了，然后过了。答案就是n-1。 E. AC Challenge原题链接解题思路：状压dp，这类题做的很少，没忘这方面想。开始用的拓扑排序，但是很明显没有考虑到所有情况。用状压的话，就这题而言，是需要先判断当前状态是否合法，判断完之后再更新答案数组dp，最终答案是dp[(1&lt;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>状压dp</tag>
        <tag>线性筛</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019航电暑期多校10部分题解]]></title>
    <url>%2F2019%2F08%2F30%2Fhdu10%2F</url>
    <content type="text"><![CDATA[1005 Welcome Party测试地址题意简述：一共有n名同学，每位同学都会唱歌和跳舞，第 i 位同学的唱歌和跳舞的能力值分别为$x_i,y_i$，现在将这些同学分为唱歌队和跳舞队，每队的价值等于该队中该能力值最高的同学的能力值，请问两队价值差最小是多少呢？ 解题思路：这题其实不算太难，但是思路容易乱。首先由于每队的价值等于该队中最高的能力值，所以可以从高到低枚举每一位同学的x，并更新ans；对当前枚举到的x，我们在所有其他同学中找到最接近 x 的 y （即abs(x-y)最小），这个y必须是 比所有被枚举过的同学的y要大。 否则该同学就不是跳舞队中最大能力值（因为被枚举过的同学一定去跳舞了），该y就不能更新答案了。当然细节在于如何找寻最接近x的y。 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e5+10;int t,n;typedef long long ll;pair&lt;ll,ll&gt; a[N];#define x first#define y secondmultiset&lt;ll&gt; s2;void solve()&#123; s2.clear(); sort(a+1,a+1+n); ll ans = 1ll&lt;&lt;60, mx = 0; for(int i = 1;i &lt;= n;i++) s2.insert(a[i].y); for(int i = n;i &gt;= 1;i--)&#123; //先把当前同学的y删掉,防止选到同一位同学 s2.erase(s2.find(a[i].y)); //要么比mx大的值更新ans,要么就mx更新ans if(mx) ans = min(ans,abs(mx-a[i].x)); multiset&lt;ll&gt;::iterator it = s2.lower_bound(a[i].x); if(it == s2.end()) it--; if(*it &gt;= mx) ans = min(ans,abs(*it-a[i].x)); if(it != s2.begin()) it--; if(*it &gt;= mx) ans = min(ans,abs(*it-a[i].x)); mx = max(mx,a[i].y); //printf("%lld %lld %lld %lld %lld\n",mx,a[i].x,a[i].y,*it,ans); s2.insert(a[i].y); &#125; printf("%lld\n",ans);&#125;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;i++) scanf("%lld%lld",&amp;a[i].x,&amp;a[i].y); solve(); &#125; return 0;&#125; 1011 Make Rounddog Happy测试地址 题意简述：给出一个包含n个元素的序列a，其中 $1 &lt;= a_i &lt;= n$，友好子串的定义如下： [l , r]位置上的所有元素各不相同。 $Max(a_l, a_{l+1} , … , a_r) - (r - l + 1) &lt;= k$。 给出一个序列，请问该序列中有多少友好子串。 解题思路：这题是启发式分治，所谓启发式算法主要是指基于直观或经验而构造的算法，它不一定是最优的，但一定是可行的，并且时间要在可接受范围内。现阶段的启发式算法主要以仿自然算法（模拟）为主。假设一个区间[l,r]内最大的元素下标为p，那么对于a[p]，在[l,r]内有多少个子区间包含p，且满足a[p] - k &lt;= r-l+1，这是子问题。我们可以将该问题分为[l , p]与[p , r]来看，我们对于这两个区间任选其一统计即可，于是我们可以选元素较少的那一个区间，这样元素最多不超过(r-l+1)/2。假设左区间 [l , p] 元素较少，我们在本次统计中（对[l , r]上以a[p]为最大值的子区间个数）对于每个位置 i （i 属于[l , p]）来计算以 i 为左端点，有多少个子区间满足要求；而满足要求的子区间个数等于tr-tl+1，因为[tl , tr]中任意一个位置都可以作为右端点，因为其满足a[p] - k &lt;= R-L（R为[tl ,tr]内一点，L为 i ）。 代码示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int N = 3e5+10;typedef long long ll;int a[N],st[N][25],Log[N]; int t,n,k;int L[N],R[N];//记录每个位置左右最远 不重复 且比其小的数的数量 void init()&#123; /*初始化st表*/ for(int i = 2;i &lt; N;i++) Log[i] = Log[i/2]+1; for(int i = 1;i &lt;= n;i++) st[i][0] = i; for(int j = 1;(1&lt;&lt;j) &lt;= n;j++)&#123; for(int i = 1;i+(1&lt;&lt;(j-1)) &lt;= n;i++)&#123; int t1 = st[i][j-1],t2 = st[i+(1&lt;&lt;(j-1))][j-1]; st[i][j] = a[t1] &lt; a[t2]?t2:t1; &#125; &#125;&#125;int ask(int l,int r)&#123; /*返回[l,r]内最大的数的下标*/ int kk = Log[r-l+1]; int t1 = st[l][kk], t2 = st[r-(1&lt;&lt;kk)+1][kk]; return a[t1] &lt; a[t2]?t2:t1;&#125; ll ans = 0;void cal(int l,int r)&#123; /*递归统计答案*/ if(l &gt; r) return; int p = ask(l,r); int tt = a[p]-k; if(p-l &lt; r-p)&#123; //左边点更少 for(int i = l;i &lt;= p;i++)&#123; int tr = min(R[i],r), tl = max(p,i+tt-1); if(tl &gt; tr) continue; ans += tr-tl+1; &#125; &#125;else&#123; for(int i = r;i &gt;= p;i--)&#123; int tl = max(l,L[i]), tr = min(i-tt+1,p); if(tl &gt; tr) continue; ans += tr-tl+1; &#125; &#125; cal(l,p-1); cal(p+1,r);&#125; int vis[N];//记录i最后一次出现的位置 ll solve()&#123; /*返回答案*/ init(); ans = 0; memset(vis,0,sizeof vis); /*以下代码用于更新L与R数组,通过简单的尺取法思想*/ int pre = 1; for(int i = 1;i &lt;= n;i++)&#123; if(vis[a[i]]) pre = max(pre,vis[a[i]]+1); L[i] = pre; vis[a[i]] = i; &#125; pre = n; for(int i = 1;i &lt;= n;i++) vis[i] = n+1; for(int i = n;i &gt;= 1;i--)&#123; if(vis[a[i]] != n+1) pre = min(vis[a[i]]-1,pre); R[i] = pre; vis[a[i]] = i; &#125; cal(1,n); //递归分治计算 return ans;&#125;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;k); for(int i = 1;i &lt;= n;i++) scanf("%d",a+i); printf("%lld\n",solve()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>启发式分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可持久化线段树（主席树）]]></title>
    <url>%2F2019%2F08%2F28%2Fdynamic-zx%2F</url>
    <content type="text"><![CDATA[摘要主席树，又称可持久化线段树，属于可持久化数据结构。“主席”这一名词是由于发明者缩写为HJT，和某位主席拼音缩写相同（有些牵强），故将该数据结构称为主席树。主席树既保留了线段树的灵活，也拥有了可持久化数据结构的特点，在处理某些特定问题时有着其它数据结构不具有的优势。本文将首先介绍什么是“可持久化数据结构”，随后介绍主席树的思想，关于代码实现将结合例题讲解。 可持久化数据结构可持久数据结构主要指的是我们可以查询历史版本的情况并支持插入，利用使用之前历史版本的数据结构来减少对空间的消耗（能够对历史进行修改的是函数式编程 [1]）。 我们经常会遇到这样的问题：我们需要维护一个数据结构，我们可以修改单一结点的值，查询单一结点的值，但是最关键的是我们可能还需要回退之前做过的某些操作。这里回退是指回到未做这些操作之前的状态。 在无回退操作的情况下，我们有大把的数据结构可供选择来解决这些问题。但是一旦涉及到回退操作，选择就少的多了。我们将支持回退操作的数据结构称为可持久化数据结构。 稍微思考一下如何可以在原来数据结构的基础上使其变得可持久化，有一个很简单的方案。我们每次操作都将重新建立一个新的数据结构，并将之前的操作都先在其上执行一次，之后执行该次操作。我们按操作执行顺序将这些数据结构维护成一个序列S，此时S[0]表示未经任何操作的初始数据结构。对于i&gt;0，S[i]表示在S[0]的基础上执行过序号1到i的所有操作后得到的新的数据结构。在这样的做法下，我们称S[i]为版本i，回退操作等价于切换到某个特定版本。若操作i表示切换为版本j，那么我们可以直接将S[i]设置为S[j]的克隆。 上面提到的做法下很容易发现可以使得任意数据结构都可以支持回退操作，但是缺点也是非常明显，空间和时间的复杂度都奇高。每一次操作都需要累加之前操作的时间复杂度，空间也是，我们为了保存各个版本需要耗费大量的内存。 先说明时间复杂度的优化，对于i号操作，我们完全可以直接克隆版本S[i-1]并在其上执行i号操作，这样时间复杂度基本上就向空间复杂度看齐了。下面我们就可以专注于空间复杂度的优化（对应的也就是时间复杂度的优化）。 数据结构是用于保存数据的，我们将其保存数据的单元称为结点，我们可以利用结点来刻画整个数据结构的骨架。数据结构基本分为两类，一类是稳定的，一类是不稳定的。稳定的数据结构，其特定是在修改的结点的值之后不会改变结点之间的关系，而不稳定的数据结构在结点值变更后需要重新维护结点之间的关联。稳定的数据结构有线段树，后缀数组，前缀树等等，不稳定的数据结构主要就是各种二叉平衡树。对于稳定的树状结构，若孩子没有保存指向父结点的指针，即由父亲负责记录所有的孩子，我们很容易发现，当我们对某个结点更改时（修改值，新增，删除等操作），我们只需要同时修改该结点的所有祖先结点即可，那我们是不是也可以只克隆这些结点而非整个数据结构呢？答案是肯定的。由于父亲维护孩子，因此一个孩子允许有多个父亲，故所有没有被直接影响的结点都可以继续复用。我们将部分树状数据结构（特定是稳定和父亲维护父子关系）的一次操作的空间复杂度优化到了O(h)，其中h是树状数据结构的高度。 当我们将上面的想法作用到线段树时，就得到了常说的主席树。其高度为$O(log_2(n))$，其中n为线段树维护的区间大小，同时其时间和空间复杂度均为$O(log_2(n)^2)$。 引用自：陶无语的博客 静态主席树我们按照“是否支持修改”来将主席树划分为静态和动态。静态主席树一旦建树成功，就不再支持修改，只能够用于查询。静态主席树维护元素出现次数的前缀和。 例题：洛谷P3834，查询区间第k大值给定n个元素，共m个询问，每次询问给出[l ,r]和k，回答区间[l , r]内第k大元素值是多少。 建树：考虑用主席树解决上述问题，给出如下建树步骤： 新建一棵完整的空树，其根节点编号存放在root[0]内。 依次将n个元素插入到“版本0”的空树中，他们的“版本号”（根节点）存放在root[i]中。 对于每一个“新版本”，我们都在原来基础上新增“需要修改的节点”，并将其根节点记录在root数组中。如此我们的时空花费都与修改的路径成正比，即每次$O(log_2N)$。 当然这些都是从理论思想上来讲的，比较抽象；具体到这一题，我们令线段树维护区间内元素数量，每个节点有三个变量，分别是 ls , rs , sum，即左儿子编号，右儿子编号，区间内元素个数。初始时sum都为0，随后将n个元素依次插入形成n棵新的线段树，而这n+1棵（包括编号为0的空树）构成了一棵静态主席树。所以建树操作其实分为两步：BuildTree()建立一棵空树并返回根节点编号；updata()在原树基础上“增加一棵新树”，并返回该版本的根节点编号。 虽然不同历史版本的线段树节点之间有交叉以重复利用，但每个历史版本都有唯一且独立的根节点 查询：由于线段树维护的是区间内元素的数量，所以不同版本的线段树的对应节点是可以加减的，那么root[i] - root[j]意义就是“第 i 个版本的线段树比第 j 个版本的线段树多几个元素”。如果我们再加上区间范围限制[l , r]，那么我们也可以查询“第 i 个版本比第 j 个版本，在[l , r]上多几个元素”。 具体到本题，我们需要查询区间[l , r]内第k大的元素，已知线段树可以加减，那么对于询问(l , r , k)，我们就需要在root[l-1] 与 root[r]两棵线段树上找寻答案，不要忘记了这颗线段树是根据权值建立的，也就是所谓的权值线段树。那么在res个数中找第k个，显然二分（树上），参见代码。 代码模板见附录部分code-1：洛谷P3834静态主席树模板-求区间第k大值 动态主席树静态主席树虽然支持历史查询，但其功能还是不太强大，因为其不支持更改。我们将支持修改的主席树称为动态主席树，但是这个功能添加起来并不容易。静态主席树还可以看作是线段树通过小修改得到，而动态主席树则是树套树。 思想依旧是维护元素出现次数的前缀和，可以类比差分数组，我们都知道前缀和数组是不支持修改的，如果要修改，就需要用 树状数组/线段树 来维护，这里也是类似。 我们考虑“外层用树状数组，内层用记录区间内数值出现次数的线段树”来实现支持修改的可持久化线段树，也即动态主席树。 在静态主席树上，可以通过两个权值线段树相减来求得区间第k大值，在这里我们仍旧是通过这种方法求区间第k大，不同的是我们需要保证所有线段树的数据是正确的（维护修改）。如果我们用树状数组来维护不同版本的权值线段树的编号，那么对于“将位置 p 的 x 修改为 y”这一操作，我们需要修改共logN个版本的权值线段树，如此修改操作的时间复杂度是$O((log_2N)^2)$。值得注意的是，此时空间复杂度 = 树状数组空间 * 权值线段树空间 = $N^2$，但是树状数组实际上只保存权值线段树的“版本号”而已，因此实际上用到的空间也就只有权值线段树上的$O(N(log_2N)^2)$个节点的空间，因此动态开点即可。 例题2：洛谷P2617代码模板： 见附录部分code-2 注释：[1] 函数式编程：“函数式编程”是一种“编程范式”(programming paradigm)，也就是如何编写程序的方法论。它属于“结构化编程”的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。 引用自：aezero的博客 附录code-1：洛谷P3834静态主席树模板-求区间第k大值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 2e5+10;int n,m,a[N];struct zxTree&#123; int ls,rs,sum;//左右儿子,区间内元素个数 #define ls(x) tr[x].ls #define rs(x) tr[x].rs #define sum(x) tr[x].sum&#125; tr[N*40];//注意数组大小int sz = 0;//不同版本的树的总数 int root[N];//root[i]存放第i棵树的树根的编号int BuildTree(int l,int r)&#123; /*建树,和普通线段树相同*/ int rt = ++sz;sum(rt) = 0; if(l == r) return rt; int mid = l+r&gt;&gt;1; ls(rt) = BuildTree(l,mid); rs(rt) = BuildTree(mid+1,r); return rt;&#125;int updata(int pre,int l,int r,int x)&#123; /*新建一棵树,其比pre树多一个元素x*/ int rt = ++sz; tr[rt] = tr[pre]; sum(rt)++; if(l == r) return rt; int mid = l+r&gt;&gt;1; if(x &lt;= mid) ls(rt) = updata(ls(pre),l,mid,x); else rs(rt) = updata(rs(pre),mid+1,r,x); return rt;&#125;int ask(int pre,int rt,int l,int r,int k)&#123; /* 依次是:上一个树根,当前树根,区间左右端点,所求区间第k大 返回该区间第k大数的下标 */ if(l &gt;= r) return l; int res = sum(ls(rt)) - sum(ls(pre)); int mid = l+r&gt;&gt;1; if(res &gt;= k) return ask(ls(pre),ls(rt),l,mid,k); else return ask(rs(pre),rs(rt),mid+1,r,k-res);&#125;int tmp[N];int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1;i &lt;= n;i++) scanf("%d",a+i),tmp[i] = a[i]; //离散化 sort(tmp+1,tmp+1+n); int tot = unique(tmp+1,tmp+1+n)-tmp-1; root[0] = BuildTree(1,tot); for(int i = 1;i &lt;= n;i++)&#123; int x = lower_bound(tmp+1,tmp+1+tot,a[i])-tmp; root[i] = updata(root[i-1],1,tot,x); &#125; //利用主席树可以加减原理计算 for(int i = 1,l,r,k;i &lt;= m;i++)&#123; scanf("%d%d%d",&amp;l,&amp;r,&amp;k); int x = ask(root[l-1],root[r],1,tot,k); printf("%d\n",tmp[x]); &#125; return 0;&#125; code2-洛谷P2617动态主席树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e5+10;/*线段树节点,要存放左右儿子编号,区间内元素个数*/struct SegmentTree&#123; int ls,rs,sum; #define ls(x) tr[x].ls #define rs(x) tr[x].rs #define sum(x) tr[x].sum&#125;tr[N*400];//空间要N(logN)^2大小/*因为要离散化,所以要提前读取所有操作*/struct Query&#123; int l,r,k;//查询操作,询问区间[l,r]内第k大数的值 int p,x; //修改操作,修改位置p位置上的元素为x&#125;qy[N];int sz = N;/*不同版本的线段树总数,即动态申请节点编号,初始值要为N,因为前n个节点被使用*/int a[N],n,m,tot = 0;//tot离散化用char op[10];void Insert(int rt,int l,int r,int p,int d)&#123; /*对以rt为根的线段树,区间[l,r]内新增一个元素x*/ sum(rt) += d; if(l == r) return; int mid = l+r&gt;&gt;1; if(!ls(rt)) ls(rt) = ++sz;//如果该子树没有子节点则新建 if(!rs(rt)) rs(rt) = ++sz;//动态申请节点 if(p &lt;= mid) Insert(ls(rt),l,mid,p,d); else Insert(rs(rt),mid+1,r,p,d);&#125;void add(int l,int p,int y)&#123; /*向树状数组中的 线段树中 位置p值+d,要从l开始哦*/ for(int x = l;x &lt;= n;x += x&amp;-x) Insert(x,1,tot,p,y); &#125;int t1[N],t2[N],c1,c2;//临时记录遍历路径int ask(int l,int r,int k)&#123; /*返回区间[l,r]内第k大元素的值(离散化后的)*/ if(l == r) return l; int res = 0, mid = l+r&gt;&gt;1; for(int i = 1;i &lt;= c1;i++) res -= sum(ls(t1[i])); for(int i = 1;i &lt;= c2;i++) res += sum(ls(t2[i])); if(res &gt;= k)&#123; for(int i = 1;i &lt;= c1;i++) t1[i] = ls(t1[i]); for(int i = 1;i &lt;= c2;i++) t2[i] = ls(t2[i]); return ask(l,mid,k); &#125;else&#123; for(int i = 1;i &lt;= c1;i++) t1[i] = rs(t1[i]); for(int i = 1;i &lt;= c2;i++) t2[i] = rs(t2[i]); return ask(mid+1,r,k-res); &#125; &#125;int tmp[N*2];//离散化用int query(int l,int r,int k)&#123; c1 = c2 = 0; /*我们将树状数组上待查询的线段树的左儿子编号先存储*/ for(int i = l;i;i -= i&amp;-i) t1[++c1] = i; for(int i = r;i;i -= i&amp;-i) t2[++c2] = i; int x = ask(1,tot,k); //注意查询区间是[1,tot] return tmp[x];&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1;i &lt;= n;i++) scanf("%d",a+i),tmp[++tot] = a[i]; for(int i = 1;i &lt;= m;i++)&#123; scanf("%s",op); if(op[0] == 'C')&#123; scanf("%d%d",&amp;qy[i].p,&amp;qy[i].x); tmp[++tot] = qy[i].x;//先存储,方便离散化 &#125;else scanf("%d%d%d",&amp;qy[i].l,&amp;qy[i].r,&amp;qy[i].k); &#125; //离散化 sort(tmp+1,tmp+1+tot); tot = unique(tmp+1,tmp+1+tot)-tmp-1; for(int i = 1;i &lt;= n;i++)&#123; int p = lower_bound(tmp+1,tmp+1+tot,a[i])-tmp; add(i,p,1); &#125; for(int i = 1;i &lt;= m;i++)&#123; if(qy[i].l)&#123; int l = qy[i].l, r = qy[i].r; printf("%d\n",query(l-1,r,qy[i].k)); &#125;else&#123; int p = lower_bound(tmp+1,tmp+1+tot,qy[i].x)-tmp; int pre = lower_bound(tmp+1,tmp+1+tot,a[qy[i].p])-tmp; add(qy[i].p,pre,-1); add(qy[i].p,p,1); a[qy[i].p] = qy[i].x; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[权值线段树]]></title>
    <url>%2F2019%2F08%2F27%2Fqz-tree%2F</url>
    <content type="text"><![CDATA[摘要权值线段树是在普通线段树的基础上进行更改，利用值域建树而非定义域（下标）；这使得线段树具有了一些新的功能，本文就将从权值线段树的来历，用途以及算法流程方面来介绍该数据结构。最终我们会用两个例题来体现权值线段树的用途，当然该代码也作为参考模板。 简介线段树是将下标不断二分，使得树上每个节点对应一段区间，从而将区间操作拆分成有关若干节点的操作。权值线段树与之类似，都是将一段区间不断二分，并令树上每个节点对应一段区间，以此实现“将区间操作变为对树上某条路径的操作”，只不过这里划分的区间不再是下标，而是权值。 至此其实权值线段树的特点已经很明显了，一般的线段树对下标建树，而权值线段树对权值建树；普通线段树对下标上的值进行操作（加减乘除），而权值线段树对值所对应的下标进行操作。 权值线段树的用途这就好比一个是对 定义域 建树，而另一个是对 值域 建树，所以权值线段树具有如下用途： 统计范围内元素的个数（这里的范围是指值域上的范围，例如：求逆序对）。 查询序列中，下标大于r的 第一个大于 k 的数。 只是对线段树进行简单的更改，就使其拥有了这些功能（虽然这些功能其它数据结构也能实现），可见线段树的灵活性。 算法流程第一步：通常元素的值域范围很大，但是个数很少，所以一般会先对这n个数离散化处理，处理之后就只有tot个不同的值([1 , tot])。 第二步：对区间[1, tot]建立线段树。 第三步：按照题意进行操作。 例题1：求逆序对测试地址：洛谷P1908虽然我们有更好的求逆序对的方法，例如归并、CDQ分治、树状数组等，但是这题其实也很好的体现权值线段树的思路，作为入门还是很好理解的。 首先我们将较为分散的n个元素按照权值离散化，离散化之后这n个元素取值范围（映射集合）就在[1,tot]之间，而若 i &gt; j，那么 i 代表的元素一定比 j 代表的元素大。 接下来从前向后遍历原数组的n个元素，找到其离散化后的标号i，再统计线段树中&gt;i的元素个数有多少个，累加到答案即可。代码示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* 权值线段树模板 最后修改:2019/8/25 洛谷P1908:给出n个数求逆序对数量 由于值域过于分散,且数字太大,采用离散化方法 */ #include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 5e5+10;typedef long long ll;ll a[N];struct SegmentTree&#123; int l,r,sum; /* 左端点,右端点,[l,r]内元素总数 */ #define l(x) tr[x].l #define r(x) tr[x].r #define sum(x) tr[x].sum&#125;tr[N*4];struct Node&#123; ll val;int id; /*元素的值,序号,用于离散化*/ bool operator &lt; (const Node&amp; rhs)const&#123; return val &lt; rhs.val; &#125;&#125;tmp[N]; int n,tot;void BuildTree(int rt,int l,int r)&#123; /*对[l,r]建立一棵子树,该子树根节点是rt*/ l(rt) = l, r(rt) = r, sum(rt) = 0; if(l == r) return; int mid = l+r&gt;&gt;1; BuildTree(rt*2,l,mid); BuildTree(rt*2+1,mid+1,r); &#125;ll ask(int rt,int y)&#123; /*查询大于等于y的数的个数*/ if(l(rt) == r(rt)) return sum(rt); int mid = l(rt)+r(rt)&gt;&gt;1, res = 0; if(y &lt;= mid) return ask(rt*2,y)+sum(rt*2+1); //加上整段右区间 return ask(rt*2+1,y); //答案在右子树 &#125;void updata(int rt,int p)&#123; /*将p位置+1*/ if(l(rt) &lt;= p &amp;&amp; p &lt;= r(rt)) sum(rt)++; if(l(rt) == r(rt)) return; int mid = l(rt)+r(rt)&gt;&gt;1; if(p &lt;= mid) updata(rt*2,p); else updata(rt*2+1,p);&#125; void solve()&#123; //首先离散化 for(int i = 1;i &lt;= n;i++) tmp[i].val = a[i],tmp[i].id = i; sort(tmp+1,tmp+1+n); tot = 0; for(int i = 1;i &lt;= n;i++)&#123; if(i == 1 || tmp[i].val != tmp[i-1].val) ++tot; a[tmp[i].id] = tot; &#125; //离散化之后值域[1,tot],以此为区间建树 BuildTree(1,1,tot); //下一步就是查询与更新了 ll ans = 0; for(int i = 1;i &lt;= n;i++)&#123; ans += ask(1,a[i]+1);//在前i-1个数中,比a[i]大的有多少 updata(1,a[i]); //值为a[i]的数+1 &#125; printf("%lld\n",ans);&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;i++) scanf("%lld",a+i); solve(); return 0;&#125; 例题2：2019CCPC网络赛 B.array测试地址题意简述：给定1~n共n个数组成的序列，有m次操作，每次操作有两种可能： (1,pos)令 $a_{pos} = a_{pos}+1,000,000$。 (2, r , k) 回答不在$a_i(1&lt;= i &lt;= r)$内的，大于等于k的最小值。 强制在线。解题思路：首先是理解题意，然后如果按照题目要求来解题，我们需要每次都通过遍历来排除[1,r]内的元素，显然会超时。由于题目中$a_i$是各不相同的，又是小于n的，因此我们可以将原问题转化为求“大于等于k的所有元素中，第一个下标大于r的元素的值”。对于这个问题我们每次需要询问所有值在[k,n+10]内，第一个下标大于r的即可。 于是我们可以通过建立权值线段树，线段树的下标是值$a_i$，值是下标i，对于每个操作1，就相当于把pos位置上的数删掉了。加上一些小剪枝就可以过。 代码示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;algorithm&gt; using namespace std;const int N = 2e5+10;const int INF = 0x3f3f3f3f;typedef long long ll;struct SegmentTree&#123; /*区间[l,r]内元素个数为sum*/ int l,r,sum,mx; #define l(x) tr[x].l #define r(x) tr[x].r #define mx(x) tr[x].mx&#125;tr[N*4];/* a数组存放序列,b数组离散化用 tot是离散化后不同元素个数 */ll a[N],b[N];int n,m,tot,t;void BuildTree(int rt,int l,int r)&#123; /*对[l,r]建立一棵根为rt的子树*/ l(rt) = l, r(rt) = r , mx(rt) = 0; if(l == r) return; int mid = l+r&gt;&gt;1; BuildTree(rt*2,l,mid); BuildTree(rt*2+1,mid+1,r);&#125;void Insert(int rt,int p,int d)&#123; /*p位置值+1(值为p的元素的数量+1)*/ //printf("%d %d %d %d %d\n",rt,l(rt),r(rt),p,d); if(l(rt) == r(rt))&#123; mx(rt) = d; return; &#125; int mid = l(rt)+r(rt)&gt;&gt;1; if(p &lt;= mid) Insert(rt*2,p,d); else Insert(rt*2+1,p,d); mx(rt) = max(mx(rt*2),mx(rt*2+1));&#125;ll ask(int rt,int k,int r)&#123; //printf("%d %d %d %d %d %d\n",rt,l(rt),r(rt),k,r,mx(rt)); /*返回[k,n]中第一个大于r的值*/ if(l(rt) == r(rt))&#123; if(mx(rt) &lt;= r) return -INF; return l(rt); &#125; int mid = l(rt)+r(rt)&gt;&gt;1, res = 0; if(k &lt;= mid &amp;&amp; mx(rt*2) &gt; r) res = ask(rt*2,k,r); if(res &lt;= 0) return ask(rt*2+1,k,r); return res;&#125;int ans = 0;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; ans = 0; scanf("%d%d",&amp;n,&amp;m); BuildTree(1,1,n+10); for(int i = 1;i &lt;= n;i++)&#123; scanf("%lld",a+i); Insert(1,a[i],i);//a[i]下标为 i &#125; for(int i = n+1;i &lt;= n+10;i++) Insert(1,i,INF); for(int i = 1,op,pos,r,k;i &lt;= m;i++)&#123; scanf("%d",&amp;op); if(op == 1)&#123; scanf("%d",&amp;pos); pos ^= ans; Insert(1,a[pos],INF); &#125;else&#123; scanf("%d%d",&amp;r,&amp;k); k ^= ans, r ^= ans; ans = ask(1,k,r); printf("%d\n",ans); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数据结构域算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019CCPC网络赛部分题解]]></title>
    <url>%2F2019%2F08%2F25%2F2019ccpc%2F</url>
    <content type="text"><![CDATA[1001 ^&amp;^题意简述：给定正整数a和b，找到一个最小的正整数c，使得(a^c)&amp;(b^c)最小。解题思路：两个数按位与最小结果肯定是0啊，所以对于a和b，如果它们对应二进制位上有0，则c置为0即可，因为0^0 = 0 , 这就保证了异或之后肯定有一个是0，再&amp;之后还是0；若它们对应二进制位都是1，则只能置c的对应二进制位为1了，因为1^1 = 0。 值得注意的是，所求结果c是正整数，所以如果当c = 0时，则需要从低位向高位，将0-1或1-0位时，c对应二进制位 = 1。代码示例：12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;iostream&gt;typedef long long ll;int t;ll a,b;void solve()&#123; ll c = 0; for(int i = 0;i &lt;= 32;i++)&#123; if((a&amp;(1ll&lt;&lt;i)) &amp;&amp; (b&amp;(1ll&lt;&lt;i))) c = c|(1ll&lt;&lt;i); &#125; if(c == 0)&#123; for(int i = 0;i &lt;= 32;i++)&#123; if((a&amp;(1ll&lt;&lt;i)) != (b&amp;(1ll&lt;&lt;i)))&#123; c = c|(1ll&lt;&lt;i); break; &#125; &#125; &#125; printf("%lld\n",c);&#125;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; scanf("%lld%lld",&amp;a,&amp;b); solve(); &#125; return 0;&#125; 1002 array测试地址题意简述：给定1~n共n个数组成的序列，有m次操作，每次操作有两种可能： (1,pos)令 $a_{pos} = a_{pos}+1,000,000$。 (2, r , k) 回答不在$a_i(1&lt;= i &lt;= r)$内的，大于等于k的最小值。 强制在线。解题思路：首先是理解题意，然后如果按照题目要求来解题，我们需要每次都通过遍历来排除[1,r]内的元素，显然会超时。由于题目中$a_i$是各不相同的，又是小于n的，因此我们可以将原问题转化为求“大于等于k的所有元素中，第一个下标大于r的元素的值”。对于这个问题我们每次需要询问所有值在[k,n+10]内，第一个下标大于r的即可。 于是我们可以通过建立权值线段树，线段树的下标是值$a_i$，值是下标i，对于每个操作1，就相当于把pos位置上的数删掉了。加上一些小剪枝就可以过。 代码示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;algorithm&gt; using namespace std;const int N = 2e5+10;const int INF = 0x3f3f3f3f;typedef long long ll;struct SegmentTree&#123; /*区间[l,r]内元素个数为sum*/ int l,r,sum,mx; #define l(x) tr[x].l #define r(x) tr[x].r #define mx(x) tr[x].mx&#125;tr[N*4];/* a数组存放序列,b数组离散化用 tot是离散化后不同元素个数 */ll a[N],b[N];int n,m,tot,t;void BuildTree(int rt,int l,int r)&#123; /*对[l,r]建立一棵根为rt的子树*/ l(rt) = l, r(rt) = r , mx(rt) = 0; if(l == r) return; int mid = l+r&gt;&gt;1; BuildTree(rt*2,l,mid); BuildTree(rt*2+1,mid+1,r);&#125;void Insert(int rt,int p,int d)&#123; /*p位置值+1(值为p的元素的数量+1)*/ //printf("%d %d %d %d %d\n",rt,l(rt),r(rt),p,d); if(l(rt) == r(rt))&#123; mx(rt) = d; return; &#125; int mid = l(rt)+r(rt)&gt;&gt;1; if(p &lt;= mid) Insert(rt*2,p,d); else Insert(rt*2+1,p,d); mx(rt) = max(mx(rt*2),mx(rt*2+1));&#125;ll ask(int rt,int k,int r)&#123; //printf("%d %d %d %d %d %d\n",rt,l(rt),r(rt),k,r,mx(rt)); /*返回[k,n]中第一个大于r的值*/ if(l(rt) == r(rt))&#123; if(mx(rt) &lt;= r) return -INF; return l(rt); &#125; int mid = l(rt)+r(rt)&gt;&gt;1, res = 0; if(k &lt;= mid &amp;&amp; mx(rt*2) &gt; r) res = ask(rt*2,k,r); if(res &lt;= 0) return ask(rt*2+1,k,r); return res;&#125;int ans = 0;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; ans = 0; scanf("%d%d",&amp;n,&amp;m); BuildTree(1,1,n+10); for(int i = 1;i &lt;= n;i++)&#123; scanf("%lld",a+i); Insert(1,a[i],i);//a[i]下标为 i &#125; for(int i = n+1;i &lt;= n+10;i++) Insert(1,i,INF); for(int i = 1,op,pos,r,k;i &lt;= m;i++)&#123; scanf("%d",&amp;op); if(op == 1)&#123; scanf("%d",&amp;pos); pos ^= ans; Insert(1,a[pos],INF); &#125;else&#123; scanf("%d%d",&amp;r,&amp;k); k ^= ans, r ^= ans; ans = ask(1,k,r); printf("%d\n",ans); &#125; &#125; &#125; return 0;&#125; 1004 Path测试地址题意简述：一共有n个点m条边和q次询问，每次询问给出一个整数k，请问在图中的所有路径中第k短的路径长度是多少？ 解题思路：刚开始思路有些不对，其实这题并不是求最短路或者A * 或怎样，据说是常见套路。首先前m短的边就是这m条边，我们可以利用优先队列维护 路径，而一条路径由“起点，终点，路径长度，上一个点的编号，该边在上一个点所有边中的排名”构成。 这样每次从最小堆中弹出一条路径，该路径就是剩下所有路径中最短的一条；而且该路径只有“从当前终点出发走下一条最短边”和“返回到上一个节点par，然后从par走次短边”这两种可能会对最终答案有贡献，所以将这两条路径再压入最小堆即可，如此反复操作直至求得所有最短路径。代码示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;typedef long long ll;struct Node&#123; /* x:边的起点,y:终点,par:上一个点的编号, rk:在上一个点的所有出边中名次,d:路径长度 */ int x,y,par,rk; ll d; Node(int x,int y,ll d,int par,int rk):x(x),y(y),d(d),par(par),rk(rk)&#123;&#125; bool operator &lt; (const Node&amp; B)const&#123; return d &gt; B.d; &#125;&#125;;const int N = 1e5+10;const int INF = 0x3f3f3f3f;ll dis[N];priority_queue&lt;Node&gt; q;int t,n,m,qq,k;int a[N],ord[N];typedef pair&lt;int,ll&gt; pa;vector&lt;pa&gt; G[N];//存储点的所有出边,按权值升序 void solve()&#123; int cnt = 0; while(!q.empty())&#123; Node e = q.top();q.pop(); dis[++cnt] = e.d; if(cnt &gt; k) break;//统计出来前k个即可 /*只有两种情况可能更新答案*/ if(G[e.par].size() &gt; e.rk+1)&#123; int x = e.x,y = G[e.x][e.rk+1].second , par = x, rk = e.rk+1; ll z = e.d - G[e.x][e.rk].first+G[e.x][rk].first; q.push(Node(x,y,z,par,rk)); &#125; if(G[e.y].size()) q.push(Node(e.y,G[e.y][0].second,e.d+G[e.y][0].first,e.y,0)); &#125;&#125;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;qq); k = 0; for(int i = 1;i &lt;= n;i++) G[i].clear(),ord[i] = 0; while(!q.empty()) q.pop(); for(int i = 1,x,y,z;i &lt;= m;i++)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); G[x].push_back(make_pair(z,y)); q.push(Node(x,y,z,0,0)); &#125; for(int i = 1;i &lt;= n;i++) sort(G[i].begin(),G[i].end()); for(int i = 1;i &lt;= qq;i++) scanf("%d",a+i),k = k&gt;a[i]?k:a[i]; solve();//预处理 for(int i = 1;i &lt;= qq;i++) printf("%lld\n",dis[a[i]]); &#125; return 0;&#125; 1006 Shuffle Card解题思路：队友一发过了，听说是个模拟题，ccfnb。代码示例：12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#include &lt;queue&gt;#define ll long longusing namespace std;const int Max = 1e5 + 10;int n,q,s;int bk[Max];int val[Max];deque &lt;int&gt; deq;int main()&#123; scanf("%d %d",&amp;n,&amp;q); for(int i = 1; i &lt;= n; i++)&#123; scanf("%d",&amp;val[i]); deq.push_back(val[i]); &#125; while(q--)&#123; scanf("%d",&amp;s); deq.push_front(s); &#125; while(!deq.empty())&#123; if(!bk[deq.front()])&#123; printf("%d ",deq.front()); bk[deq.front()] = 1; &#125; deq.pop_front(); &#125; return 0;&#125; 1007 Windows Of CCPC题意简述：输出CCPC，当然是2 2矩阵输出，此为单元。如果n &gt; 1，那么就递归n - 1次，每次递归都把C替换成一个标准单元，把P替换为一个“反单元”（反单元即将标准单元中的C替换为P，P替换为C，即PPCP，也是2 2矩阵形式）作为新的矩阵。给定n，输出结果。解题思路：就是简单的模拟，用数组，当然最好用putchar，否则可能会超时，还有就是n最大是10，可以输出到txt文件中肉眼观察一下是否正确再提交。 代码示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;#include&lt;iostream&gt;using namespace std;int t,k;const int N = 3400;char G[N][N];char tmp[N][N]; void solve()&#123; G[1][1] = G[1][2] = G[2][2] = 'C'; G[2][1] = 'P'; for(int i = 1;i &lt;= k;i++)&#123; for(int j = 1;j &lt;= (1&lt;&lt;i);j++)&#123; for(int z = 1;z &lt;= (1&lt;&lt;i);z++)&#123; int r = 2*(j-1)+1; int c = 2*(z-1)+1; if(G[j][z] == 'C')&#123; tmp[r][c] = tmp[r][c+1] = tmp[r+1][c+1] = 'C'; tmp[r+1][c] = 'P'; &#125;else&#123; tmp[r][c] = tmp[r][c+1] = tmp[r+1][c+1] = 'P'; tmp[r+1][c] = 'C'; &#125; &#125; &#125; for(int j = 1;j &lt;= (1&lt;&lt;i);j++) for(int z = 1;z &lt;= (1&lt;&lt;i);z++) G[j][z] = tmp[j][z]; &#125; for(int i = 1;i &lt;= 1&lt;&lt;k;i++)&#123; for(int j = 1;j &lt;= 1&lt;&lt;k;j++) putchar(G[i][j]); puts(""); &#125;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;k); solve(); &#125; return 0;&#125; 1008 Fishing Master测试地址题意简述：一共有n条鱼，钓任意一条鱼需要花费时间k，而煮熟一条鱼需要花费$t_i$ 时间，这n条鱼的顺序不固定，即我们每次可以钓我们想要的那条。在钓鱼的k时间内不能中断，即我们不能在钓鱼的时间内去煮或者拿出，当然一次只能煮一条鱼。请问煮熟这n条鱼最少花费多少时间？tip：在钓上来一条鱼后，我们可以选择等锅里的鱼煮熟（如果需要的话），或者直接去钓鱼，回来再说，因为同一时刻我们手里可以有任意多条鱼，不局限于一条。极限情况就是我们先钓完n条鱼，再一条一条煮。 解题思路：这题细节很多，题意很多地方稍不注意就会有歧义，所以做这种题之前一定要先了解清楚题意到底是什么规则以及要求什么。搞清楚了之后算法的设计就并不难想了，是贪心策略。如果极限情况，我们花费的最多时间就是“先把n条鱼全部钓上来，再挨个煮”，花费的时间是$sum = n * k+\sum_{i = 1}^nt_i$，而我们能减少花费的时间，当且仅当我们在钓鱼的同时去煮鱼；而又由于钓鱼的时间段不能终止，所以就相当于我们有n-1段时间，每段时间大小为k，那么对于任意煮一条鱼的时间$t_i$： 若$t_i$ 是 k 的倍数，$\frac{t_i}{k} = cnt$ 那么这cnt份时间完全被利用了，即sum -= cnt * k 若$t_i &gt; k$，那么说明我们可以先煮几段k，而剩下的部分再考虑是等待还是继续钓鱼，$\frac{t_i}{k} = cnt$，sum -= cnt k , $t_i$ -= cnt k 经过上面的操作之后，剩下的$t_i$就都是小于k的了，那么如果此时我们还剩res段时间，则挑最大的res个$t_i$来煮，这样就能最大化利用时间了，如果res = 0，则算法结束。 代码示例：1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e5+10;int tt,n;typedef long long ll;ll t[N],k,a[N];ll solve()&#123; ll ans = n*k;int res = n-1,tot = 0; int cnt = 0; for(int i = 1;i &lt;= n;i++)&#123; if(t[i]%k == 0 &amp;&amp; res) ans -= t[i],res -= t[i]/k; else a[++tot] = t[i]%k, cnt += t[i]/k; ans += t[i]; &#125; if(cnt &gt;= res)&#123; ans -= k*res; return ans; &#125; ans -= cnt*k;res -= cnt; sort(a+1,a+1+tot); for(int i = tot;i &gt;= 1 &amp;&amp; res;i--)&#123; // printf("%lld %d %lld\n",b[i],res,ans); ans -= a[i];res--; &#125; return ans;&#125;int main()&#123; scanf("%d",&amp;tt); while(tt--)&#123; scanf("%d%lld",&amp;n,&amp;k); for(int i = 1;i &lt;= n;i++) scanf("%lld",t+i); printf("%lld\n",solve()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>权值线段树</tag>
        <tag>贪心策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JZOJ4920降雷皇(最长上升子序列数量)]]></title>
    <url>%2F2019%2F08%2F24%2FJZOJ4920%2F</url>
    <content type="text"><![CDATA[测试地址 题意简述哈蒙有n条导线排成一排，每条导线有一个电阻值，神奇的电光只能从一根导线传到电阻比它大的上面，而且必须从左边向右传导，当然导线不必是连续的。 哈蒙想知道电光最多能通过多少条导线，还想知道这样的方案有多少。 解题思路第一问就是简单的LIS问题，即询问最长上升子序列的长度。第二问是询问最长上升子序列的数量，如果用暴力做法，只需要多开一个数组记录数量即可，时间复杂度O(N^2)；实际上我们可以利用BIT来代替枚举，使得时间复杂度至O(NlogN)。 我们用一个结构体Node{v,s}来表示当最长上升子序列长度为v时，方案数是s。那么对于每一个新元素x，我们只需要找出所有 电阻值小于x的 最长上升子序列的长度v以及数量s即可（符合BIT维护前缀和功能）。 当我们求出当前元素 x 的 v(最长上升子序列长度) 和 s(方案数) 后，用来更新ans，并将其插入树状数组第x个位置。由于题目保证x小于1e5，所以树状数组开到1e5即可。 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*代码参考：信息学奥赛一本通P263*/#include&lt;cstdio&gt;const int N = 1e5+10;typedef long long ll;const ll P = 123456789;struct Node&#123; ll v,s; Node()&#123; v = 0, s = 0; &#125;&#125;tr[N],tmp,ans;int n,ty;inline void updata(int x,Node y)&#123; /*更改电阻值为x时的长度和方案数*/ while(x &lt;= N)&#123; if(y.v &gt; tr[x].v) tr[x] = y;//如果长度变长,直接更新答案 else if(y.v == tr[x].v) tr[x].s = (tr[x].s+y.s)%P; x += x&amp;-x; &#125;&#125;inline Node ask(int x)&#123; /*返回当电阻 &lt;= x时,最长上升子序列的长度和方案数*/ Node res;res.s = 1; while(x)&#123; if(tr[x].v &gt; res.v) res = tr[x]; else if(tr[x].v == res.v) res.s = (res.s + tr[x].s)%P; x -= x&amp;-x; &#125; return res;&#125;inline void ckmax(Node &amp;x,const Node&amp; y)&#123; /*更新最终答案,即最长上升子序列以及个数*/ if(x.v &lt; y.v) x = y; else if(x.v == y.v) x.s = (x.s+y.s)%P;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;ty); for(int i = 1,x;i &lt;= n;i++)&#123; scanf("%d",&amp;x); tmp = ask(x-1);//因为这里保证x不超过1e5,所以不需要离散化 tmp.v++; ckmax(ans,tmp); //更新答案 updata(x,tmp); //更新树状数组 &#125; printf("%lld\n",ans.v); if(ty == 1) printf("%lld\n",ans.s); return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>LIS</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rikka with Coin 解题报告]]></title>
    <url>%2F2019%2F08%2F22%2Fhdu6685%2F</url>
    <content type="text"><![CDATA[测试地址本题为2019航电icpc暑期多校训练第9场的第6题。 题意简述有10分，20分，50分，100分的硬币若干（反正够用），商店有n件商品（n&lt;101），每件商品的价格给出；请问要想可以买下任意一件商品，最少带多少个硬币？ 解题思路我一开始思路是背包，然后觉得w（商品的价值）太大了，可能用大背包，就放弃了。原来这题需要转化一下思维，并不是用背包而是简单的遍历。首先我们需要明白，就是如若我们买一件物品需要用2个10分的硬币，那么我们换成一个10分一个20分的肯定是可以的，而且反而能买的价格更多了（从10,20变为10,20,30），同理： 如果有4个20分的，就可以用1个10分，2个20分，1个50分的硬币代替。因为原来可以表示20,40,60,80,现在可以表示10,20,30,40,50,60,70,80,90,100。 如果有2个50分的，同理，可以用1个50，1个100替代。 于是我们知道了10分，20分，50分的硬币最多需要1个，3个，1个，所以三层循环遍历所有可能的情况，对于每种情况，判断是否可以表出所有物品（当然不足的用100分的硬币替代）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int t,n;const int INF = 0x3f3f3f3f;const int N = 110;int w[N];int check2(int x,int a,int b,int c)&#123; int res = INF; for(int i = 0;i &lt;= a;i++) for(int j = 0;j &lt;= b;j++) for(int k = 0;k &lt;= c;k++)&#123; if((x-i*10-j*20-k*50)%100 == 0) res = min((x-i*10-j*20-k*50)/100,res); &#125; return res;&#125;int check(int a,int b,int c)&#123; int res = 0; for(int i = 1;i &lt;= n;i++)&#123; int tmp = check2(w[i],a,b,c); if(tmp == INF) return INF; else res = max(res,tmp); &#125; //printf("%d %d %d %d\n",res,a,b,c); return res+a+b+c;&#125;void solve()&#123; int ans = INF; for(int i = 1;i &lt;= n;i++) if(w[i]%10)&#123;puts("-1");return; &#125; for(int i = 0;i &lt;= 1;i++) for(int j = 0;j &lt;= 3;j++) for(int k = 0;k &lt;= 1;k++) ans = min(ans,check(i,j,k)); printf("%d\n",ans);&#125;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;i++) scanf("%d",w+i); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018徐州icpc网络赛A、B题解]]></title>
    <url>%2F2019%2F08%2F21%2F2018xuzhou-icpc%2F</url>
    <content type="text"><![CDATA[A. Hard to prepare测试地址抱怨一下，这题目真的是长，题意理解起来有点费劲，当然费劲的只是因为题面长而不是表述不清。题意简述：从$[1,2^k-1]$中选出n个数，将n个数围成一圈，要求相邻的两个数NXOR大于0，即异或后按位取反的值大于0。问共有多少种不同的方案。 解题思路：通过简单证明，我们会发现只有1按位取反的值才是0，所以两个数 异或 != 1 就可以相邻；而与x异或 = 1 的数，有且仅有一个。 首先如果不是环形，而是一条直线，那么一共 $2 ^ k * (2 ^ k - 1) ^ {n-1}$​ 种不同的方案，这里设A = ​2^k​。环形和直线不同之处在于，直线首尾的值异或可能 = 1，即我们之前的答案多算了首尾异或=1的情况。那么我们接下来就需要设法减去这些值。 我们通过动态规划思想来计算这些多加上的值。假设当前位置为 i ，直线首元素是a，尾元素是b，且a^b = 1；设x是位置 i 元素 = a时的方案数，y是位置 i 元素 = b时的方案数，z是位置 i 不等于a和b时的方案数。 那么我们初始状态（第2个位置时）x = 1 , y = 0 , z = A - 2；目标是求第n-1 位时的 y + z（首位是a，末位是b时，中间2~n-1位的不同排列情况数）。那么易得：x = x + z;y = y + z;z = z(A-3)+(x+y) (A-2).于是我们从第3位递推到第n-1位即可。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;typedef long long ll;const ll P = 1e9+7;int t,n,k;ll qpow(ll a,ll b)&#123; ll res = 1; while(b)&#123; if(b&amp;1) res = res*a%P; a = a*a%P; b &gt;&gt;= 1; &#125; return res%P;&#125;void solve()&#123; ll A = qpow(2,k); ll ans = A*qpow(A-1,n-1)%P; ll x = 1,y = 0,z = A-2; /* x:当前位置数和A相同方案数, y:当前位置数和B相同方案数, z:当前位置的数和AB都不同的方案数。 */ for(int i = 3;i &lt; n;i++)&#123; ll t1 = x+z,t2 = y+z; z = z*(A-3)%P+(x+y)*(A-2)%P; z = z%P; x = t1%P, y = t2%P; &#125; // printf("%lld %lld %lld\n",ans,y,z); if(n &gt; 2) ans = (ans - A*(y+z)%P+P)%P; printf("%lld\n",ans);&#125;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;k); solve(); &#125; return 0;&#125; B. BE,GE or NE测试地址题意简述：这是一个博弈论题。有两个人，小K和小S在玩游戏，该游戏一共有n次操作，俩人轮流进行。初始给定一个数值m，每次操作有三种选择：加上a；减去b；若c为1，则m = -1。每次三选一，其中小K想使得最终值&gt;= k，而小S想使得最终值&lt;= l，否则两人平局。给定这n次操作的a,b,c值，请问两人都采取最优策略，最终结果是谁胜出或是平局？ 解题思路：首先每个决策的选举会影响之后的决策，即不满足无后效，因此我们不能单纯的从后向前推（从动态规划角度）。而从博弈论来看，如果当前局面可以转移到必胜态，则当前选手必胜，换到这题，就是使得当前选手得分最大或最小。由于得分只有200种可能，于是可能的状态只有1000 * 200 = 200,000种，记忆化搜索即可。 代码示例：1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1100;const int INF = 0x3f3f3f3f;int f[N][250];int a[N],b[N],c[N];int n,m,k,l;int dfs(int pos,int sum)&#123; if(pos &gt; n) return sum; if(f[pos][sum+100] != INF) return f[pos][sum+100]; if(pos&amp;1)&#123; int x = -INF; if(a[pos]) x = max(x,dfs(pos+1,min(100,sum+a[pos]))); if(b[pos]) x = max(x,dfs(pos+1,max(-100,sum-b[pos]))); if(c[pos]) x = max(x,dfs(pos+1,-sum)); f[pos][sum+100] = x; &#125;else&#123; int x = INF; if(a[pos]) x = min(x,dfs(pos+1,min(sum+a[pos],100))); if(b[pos]) x = min(x,dfs(pos+1,max(-100,sum-b[pos]))); if(c[pos]) x = min(x,dfs(pos+1,-sum)); f[pos][sum+100] = x; &#125; return f[pos][sum+100];&#125;int main()&#123; memset(f,0x3f,sizeof f); scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;l); for(int i = 1;i &lt;= n;i++) scanf("%d%d%d",a+i,b+i,c+i); int ans = dfs(1,m); if(ans &gt;= k) puts("Good Ending"); else if(ans &lt;= l) puts("Bad Ending"); else puts("Normal Ending"); return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一章 基础数据结构模板]]></title>
    <url>%2F2019%2F08%2F20%2Fchapter1%2F</url>
    <content type="text"><![CDATA[基础数据结构目录 并查集 求最近公共祖先LCA 平方分割法 莫队算法（一维，二维） st表（一维，二维） 二叉堆（优先队列） 单调栈与笛卡尔树 CDQ分治 1 并查集1.1 并查集“拓展域”123456789101112131415161718192021222324252627282930313233343536373839//关押罪犯#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 100100;int n,m;int par[N];struct Node&#123; int a,b,c; bool operator &lt; (const Node &amp;B) const&#123; return c &gt; B.c; &#125;&#125; nodes[N];int Find(int x)&#123; if(x == par[x]) return x; return par[x] = Find(par[x]);&#125;void Merge(int x,int y)&#123; par[Find(x)] = Find(y);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1;i &lt;= m;i++)&#123; scanf("%d%d%d",&amp;nodes[i].a,&amp;nodes[i].b,&amp;nodes[i].c); par[i] = i; &#125; sort(nodes+1,nodes+1+m); for(int i = 1;i &lt;= m;i++)&#123; int x = nodes[i].a,y = nodes[i].b,d = nodes[i].c; int x_en = x+n, y_en = y+n; if(Find(x) == Find(y))&#123; printf("%d\n",d); return 0; &#125; Merge(x,y_en);Merge(x_en,y); &#125; printf("0"); return 0;&#125; 1.2 并查集“边带权”1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//POJ1773#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 21000;struct Query&#123; int l,r,ans;&#125; q[N];int a[N],par[N],d[N],cnt = 0;/* a数组用来离散化，par[x]代表x的父节点编号，d[x]代表 从x到根节点路径和，cnt也是用于离散化。 这里根节点即集合的代表节点。*/int n,m;int Find(int x)&#123; if(par[x] == x) return x; //找到根节点，返回 int root = Find(par[x]); //临时存根节点 d[x] ^= d[par[x]]; //路径压缩，距离数组d也应该更新 return par[x] = root; //路径压缩&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); char rs[10]; for(int i = 1;i &lt;= m;i++)&#123; scanf("%d%d%s",&amp;q[i].l,&amp;q[i].r,rs); if(rs[0] == 'o') q[i].ans = 1; else q[i].ans = 0; a[cnt++] = q[i].l-1; //这里需要存l-1，为了使l也包含在内 a[cnt++] = q[i].r; &#125; //以下两行代码离散化用 sort(a,a+cnt); int len = unique(a,a+cnt)-a; for(int i = 0;i &lt;= len;i++) par[i] = i; //初始化爸爸数组 for(int i = 1;i &lt;= m;i++)&#123; //左右边界在离散化数组中的编号： int x = lower_bound(a,a+len,q[i].l-1)-a; int y = lower_bound(a,a+len,q[i].r)-a; //左右边界的祖先分别为ta和tb int ta = Find(x),tb = Find(y); if(ta == tb)&#123; //如果已经在同一个集合内，则判断是否矛盾 if((d[x]^d[y]) != q[i].ans)&#123;//矛盾的条件就是事实和结果不同 printf("%d\n",i-1); return 0; &#125; &#125;else&#123; par[ta] = tb;d[ta] = d[x]^d[y]^q[i].ans; //这里d[ta]的值需要推导一下。 /* 我们将x所在的集合和y所在的集合合并，那么就需要更新d数组 这里d[x]存放的是x到par[x]的距离，所以合并两个集合对于 非根节点来说并无影响，关键是对于两个根d[ta]和d[tb]如何处理 如果我们将ta代表的集合归于tb下，那么就需要更新d[ta],而已知 ans = d[x]^d[y]^d[ta]，即x到y的总路径等于x到ta XOR y到tb XOR ta到tb；对上式变形，得：d[ta] = ans^d[x]^d[y],而后三者是已知， 故可以求出d[ta]。 */ &#125; &#125; printf("%d\n",m); return 0;&#125; 2 倍增法求 LCA123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//HDU2586求树上任意两个节点的路径的边权和 #include&lt;cstdio&gt;#include&lt;cstring&gt;const int N = 2*41000;int head[N],ver[N],nex[N],edge[N],tot = 0;void swap(int &amp;x,int &amp;y)&#123;x ^= y;y^=x;x^=y;&#125;void addEdge(int x,int y,int z)&#123; ver[++tot] = y,edge[tot] = z; nex[tot] = head[x],head[x] = tot;&#125;/* deep[x]表示x的深度,anc[x][i]为x向上走2^i步的祖先 dis[x]为节点到根节点的距离,即边权或点权和 */ int deep[N],anc[N][25],dis[N];void dfs(int x)&#123; /* 1.初始化anc数组， 2.初始化deep数组 3.初始化dis数组 以上三个都可以通过dfs来实现 */ for(int i = 1;i &lt;= 22;i++) anc[x][i] = anc[anc[x][i-1]][i-1]; for(int i = head[x]; i;i = nex[i])&#123; int y = ver[i],z = edge[i]; if(dis[y] || y == 1) continue;//防止重复访问 deep[y] = deep[x]+1; dis[y] = dis[x] + z; anc[y][0] = x; dfs(y); &#125;&#125;int Lca(int u,int v)&#123; /* 先把深度调到一致，再按照二进制拆分思想找寻最近公共祖先 */ if(deep[u] &lt; deep[v]) swap(u,v); //u是较深的节点 for(int i = 22;i &gt;= 0;i--)&#123; if(deep[anc[u][i]] &gt;= deep[v]) u = anc[u][i]; &#125; if(u == v) return u; for(int i = 22;i &gt;= 0;i--)&#123; if(anc[u][i] != anc[v][i])&#123; u = anc[u][i]; v = anc[v][i]; &#125; &#125; return anc[u][0];&#125;int ask(int u,int v)&#123; /*返回u到v的距离*/ return dis[u] + dis[v] -2*dis[Lca(u,v)];&#125;int main()&#123; int t,n,m; scanf("%d",&amp;t); while(t--)&#123; memset(dis,0,sizeof dis); memset(deep,0,sizeof deep); memset(anc,0,sizeof anc); memset(head,0,sizeof head);//head也要初始化 scanf("%d%d",&amp;n,&amp;m);tot = 0; for(int i = 1,x,y,z;i &lt; n;i++)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); addEdge(x,y,z); addEdge(y,x,z); &#125; dfs(1); for(int i = 1,x,y;i &lt;= m;i++)&#123; scanf("%d%d",&amp;x,&amp;y); printf("%d\n",ask(x,y)); &#125; &#125; return 0;&#125; 3 平方分割法问题模型： 给定一个数列$a_1,a_2,…,a_n$，目标是在O（&radic;n）复杂度内实现以下两个功能： 给定s，t，求$a_s,a_{s+1},…a_t$的最小值 给定i，x，把$a_i$的值变为x。 基于平方分割的RMQ的复杂度：在更新值时，由于每个桶内有b个元素，所以复杂度是O(b) = O(&radic;n)而查询为：O(n/b+b) = O(&radic;n+&radic;n) = O(&radic;n) 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;const int N = 100010;const int INF = 0x3f3f3f3f;int a[N];const int B = 1000;int mi[N/B];int n,m;void updata(int pos,int y)&#123; a[pos] = y; mi[pos/B] = min(mi[pos/B],y);&#125;int query(int l,int r)&#123; int ans = INF; while(l &lt;= r &amp;&amp; l%B) ans = min(ans,a[l++]); while(l &lt;= r &amp;&amp; r%B) ans = min(ans,a[--r]); while(l &lt; r)&#123; int b = l/B; ans = min(ans,mi[b]); l += B; &#125; return ans;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1;i &lt;= n;i++) scanf("%d",a+i); for(int i = 0;i &lt; N/B;i++) mi[i] = INF; for(int i = 1;i &lt;= n;i++)&#123; mi[i/B] = min(mi[i/B],a[i]); &#125; while(m--)&#123; int op,x,y; scanf("%d%d%d",&amp;op,&amp;x,&amp;y); if(op == 1) updata(x,y); else cout &lt;&lt; query(x,y) &lt;&lt; endl; &#125;&#125; 4 莫队算法SPOJ D-query： 给定一个数组，每次询问一个区间内有多少个不同的元素。 复杂度分析： 莫队算法是离线算法，可以解决一类离线的区间问题，对于序列上的区间询问问题，如果从 [l,r] 的答案能够 O(1) 扩展到 [l−1,r],[l+1,r],[l,r+1],[l,r−1] 的答案，那么可以在 $O(n\sqrt n)$ 的复杂度内求出所有询问的答案。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int N = 31000;const int Q = 2e5+10;int n,a[N],m;int ans,sum[1010000];//一个全局答案ans和标记数组sum是必要的 //当然也可以离散化 int len; //块大小，在读入询问前需要先赋值 struct Query&#123; int l,r,block,id; Query()&#123;&#125; Query(int l,int r,int id):l(l),r(r),id(id)&#123; block = l/len; &#125; bool operator &lt;(const Query &amp;B) const&#123; if(block == B.block) return block&amp;1? r &lt; B.r : r &gt; B.r; //小优化，使得r呈波浪形 return block &lt; B.block; &#125;&#125;query[Q];priority_queue&lt;pair&lt;int,int&gt; &gt; q;//增加或减少一个x位置上的数 void Move(int x,int v)&#123; x = a[x]; sum[x] += v; if(v &gt; 0) ans += sum[x] == 1;//判等是为了防止重复计数 else ans -= sum[x] == 0; &#125;int main()&#123; scanf("%d",&amp;n); len = sqrt(n); for(int i = 1;i &lt;= n;i++) scanf("%d",a+i); scanf("%d",&amp;m); for(int i = 1,x,y;i &lt;= m;i++)&#123; scanf("%d%d",&amp;x,&amp;y); query[i] = Query(x,y,i); &#125; sort(query+1,query+1+m); int l = 1,r = 0; for(int i = 1;i &lt;= m;i++)&#123; while(l &lt; query[i].l) Move(l,-1),l++; while(l &gt; query[i].l) Move(l-1,1),l--; while(r &gt; query[i].r) Move(r,-1),r--; while(r &lt; query[i].r) Move(r+1,1),r++; q.push(make_pair(-query[i].id,ans));//大根堆变为小根堆 &#125; while(!q.empty())&#123; int x = q.top().second;q.pop(); printf("%d\n",x); &#125; return 0;&#125; 5 st表5.1一维st表问题模型： 给定一个长度为n的序列，有m次询问，每次给定区间[L , R]，求区间内最大值。 我们设 st[i][j] 为从 i 开始的 $2^j$ 个数中的最大值。假设这n个数存放的序列a中，根据定义 st[i][j] = max{a[k] | $i &lt;= k &lt;= i+2^j - 1$}。 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;int n,m;const int N = 1e5+10;int a[N],st[N][25],Log[N];//2^20就过一百万了，完全够用 //初始化st表 void init()&#123; Log[1] = 0;//预处理log函数 for(int i = 2;i &lt;= n+1;i++) Log[i] = Log[i/2]+1; for(int i = 1;i &lt;= n;i++) st[i][0] = a[i]; for(int j = 1; (1&lt;&lt;j) &lt;= n;j++)&#123; //涉及到位运算多加括号! for(int i = 1;i + (1&lt;&lt;(j-1)) &lt;= n;i++)&#123; st[i][j] = max(st[i][j-1],st[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125;&#125;int ask(int l,int r)&#123; int k = Log[r-l+1]; int mx = max(st[l][k],st[r-(1&lt;&lt;k)+1][k]); //printf("%d %d\n",k,mx); return mx;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1;i &lt;= n;i++) scanf("%d",a+i); init(); for(int i = 1,l,r;i &lt;= m;i++)&#123; scanf("%d%d",&amp;l,&amp;r); printf("%d\n",ask(l,r)); &#125;&#125; 5.2 二维st表12345令t1 = st[a][b][c];令t2 = st[a][b+c-(1&lt;&lt;k)+1][c];令t3 = st[a+c-(1&lt;&lt;k)+1][b][c];令t4 = st[a+c-(1&lt;&lt;k)+1][b+c-(1&lt;&lt;k)+1][c];ans = max&#123;t1 , t2 , t3 , t4&#125;； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;const int N = 1010;int a[N][N],n,m,len,Log[N];int st[3][N][N][15];//0最小，1最大值 int max(int a,int b,int c,int d)&#123; int mx = a;if(mx &lt; b) mx = b;if(mx &lt; c) mx = c;if(mx &lt; d) mx = d; return mx;&#125;int min(int a,int b,int c,int d)&#123; int mi = a;if(mi &gt; b) mi = b;if(mi &gt; c) mi = c;if(mi &gt; d) mi = d; return mi;&#125;void init()&#123; for(int i = 2;i &lt; N;i++) Log[i] = Log[i/2]+1; for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) st[0][i][j][0] = st[1][i][j][0] = a[i][j]; for(int k = 1;k &lt;= 12;k++)&#123; for(int i = 1;i + (1&lt;&lt;k)-1 &lt;= n;i++)&#123; for(int j = 1;j + (1&lt;&lt;k)-1 &lt;= m;j++)&#123; int t1 = st[0][i][j][k-1]; int t2 = st[0][i+(1&lt;&lt;(k-1))][j][k-1]; int t3 = st[0][i][j+(1&lt;&lt;(k-1))][k-1]; int t4 = st[0][i+(1&lt;&lt;k-1)][j+(1&lt;&lt;k-1)][k-1]; st[0][i][j][k] = min(t1,t2,t3,t4); t1 = st[1][i][j][k-1]; t2 = st[1][i+(1&lt;&lt;(k-1))][j][k-1]; t3 = st[1][i][j+(1&lt;&lt;(k-1))][k-1]; t4 = st[1][i+(1&lt;&lt;k-1)][j+(1&lt;&lt;k-1)][k-1]; st[1][i][j][k] = max(t1,t2,t3,t4); &#125; &#125; &#125;&#125;int ask(int r,int c,int len)&#123; int k = Log[len]; int t1 = st[0][r][c][k]; int t2 = st[0][r+len-(1&lt;&lt;k)][c][k]; int t3 = st[0][r][c+len-(1&lt;&lt;k)][k]; int t4 = st[0][r+len-(1&lt;&lt;k)][c+len-(1&lt;&lt;k)][k]; int mi = min(t1,t2,t3,t4); t1 = st[1][r][c][k]; t2 = st[1][r+len-(1&lt;&lt;k)][c][k]; t3 = st[1][r][c+len-(1&lt;&lt;k)][k]; t4 = st[1][r+len-(1&lt;&lt;k)][c+len-(1&lt;&lt;k)][k]; int mx = max(t1,t2,t3,t4); //printf("%d %d\n",mx,mi); return mx - mi;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;len); for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) scanf("%d",&amp;a[i][j]); init(); int ans = 0x3f3f3f3f; for(int i = 1;i &lt;= n-len+1;i++)&#123; for(int j = 1;j &lt;= m-len+1;j++)&#123; int tmp = ask(i,j,len); ans = ans &lt; tmp?ans:tmp; &#125; &#125; printf("%d\n",ans); return 0;&#125; 6 二叉堆1234567891011121314151617181920212223242526272829303132333435363738//左儿子：2*rt+1, 右儿子: 2*rt+2,时间复杂度O(N)const int N = 1e5+10;int heap[N];int sz = 0;void push(int x)&#123; //i是自己节点的编号 int i = sz++; while(i &gt; 0)&#123; //p是父亲节点的编号 int p = (i-1)/2; if(heap[p] &lt;= x) break; heap[i] = heap[p]; i = p; &#125; heap[i] = x;&#125; int pop()&#123; int ret = heap[0]; //要提到根的数值x int x = heap[--sz]; //从根开始向下交换 int i = 0; while(i*2 + 1 &lt; sz)&#123; //左右儿子 int a = i*2+1,b = i*2+2; if(b &lt; sz &amp;&amp; heap[b] &lt; heap[a]) a = b; if(heap[a] &gt;= x) break; heap[i] = heap[a]; i = a; &#125; heap[i] = x; return ret;&#125; 7 单调栈与笛卡尔树笛卡尔树（Cartesian Tree）是一种同时满足堆性质和二叉搜索树性质的一棵二叉树。因此笛卡尔树的树根对应着该树的极值（堆性质），并且对其中序遍历得到的是原序列一段连续的区间（二叉搜索树性质）。我们假设利用一个整数序列A：a1~an 建立笛卡尔树，那么树上每个节点有2个键值，idx（下标）和 val（值）。我们使树上每个节点的idx满足二叉搜索树性质，而val满足堆性质，于是笛卡尔树就建成了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;const int N = 1e5+10;int a[N],tot = 0,n;typedef long long ll;ll ans;ll max(ll a,ll b)&#123; return a &lt; b?b:a;&#125;struct Node&#123; int idx,val; //下标、权值 int l,r,par; //左儿子、右儿子、父亲节点的编号 Node()&#123;&#125; Node(int idx,int val) :idx(idx),val(val)&#123; l = r = par = 0; &#125;&#125;t[N];int BuildTree()&#123; for(int i = 1;i &lt;= n;i++)&#123; int k = i-1; while(t[k].val &gt; t[i].val) k = t[k].par; t[i].l = t[k].r;//k的右子树作为i的左子树 t[k].r = i; //i作为k的右子树 t[i].par = k; //i的父亲是k t[t[i].l].par = i;//i的左子树的父亲是i // printf("%d %d\n",i,k); &#125; return t[0].r;//最终树的根节点的编号 &#125;int dfs(int rt)&#123; //printf("%d\n",rt); if(rt == 0) return 0; ll sz = 1; sz += dfs(t[rt].l); sz += dfs(t[rt].r); ans = max(ans,sz*(t[rt].val)); return sz;&#125;void solve()&#123; for(int i = 0;i &lt;= n;i++) t[i] = Node(i,a[i]); tot = ans = 0; int rt = BuildTree(); dfs(rt); printf("%lld\n",ans);&#125;int main()&#123; while(scanf("%d",&amp;n) &amp;&amp; n)&#123; for(int i = 1;i &lt;= n;i++) scanf("%d",a+i); solve(); &#125; return 0;&#125; 8 CDQ分治8.2 二维CDQ分治 给定一个N个元素的序列A，初始值全部为0，对这个序列进行以下两种操作： 操作1：格式为1 x k，把位置x的元素加上k（位置从1标号到N）。 操作2：格式为2 x y，求出区间[x,y]内所有元素的和。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N = 500050;const int M = 500050;const int Q = N*3;typedef long long ll;struct Node&#123; int type,pos; ll val; Node(int type,int pos,ll val):type(type),pos(pos),val(val)&#123;&#125; Node()&#123;&#125; bool operator &lt; (Node b) const &#123; if(pos == b.pos) return type &lt; b.type; return pos &lt; b.pos; &#125;&#125;;int n,m;int aidx = 0,qidx = 0;Node query[Q];Node tmp[Q];ll ans[Q];void CDQ(int l,int r)&#123; if(l &gt;= r-1) return; //左闭右开嘛 int mid = (l+r)/2; CDQ(l,mid); CDQ(mid,r); int p = l,q = mid,k = 0; ll sum = 0; while(p &lt; mid &amp;&amp; q &lt; r)&#123; if(query[p] &lt; query[q])&#123; if(query[p].type == 1) sum += query[p].val; tmp[k++] = query[p++]; &#125;else&#123; int x = query[q].val; if(query[q].type == 2) ans[x] -= sum; else if(query[q].type == 3) ans[x] += sum; tmp[k++] = query[q++]; &#125; &#125; while(p &lt; mid) tmp[k++] = query[p++]; //这里不用再累加修改的值，因为用不到了啊 while(q &lt; r)&#123; //这里还需将我们累加的结果进行运算，我们规定就是要累加左区间，查询右区间嘛 int x = query[q].val; if(query[q].type == 2) ans[x] -= sum; else if(query[q].type == 3) ans[x] += sum; tmp[k++] = query[q++]; &#125; for(int i = 0;i &lt; k;i++) query[i+l] = tmp[i]; &#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int x; for(int i = 1;i &lt;= n;i++)&#123; scanf("%d",&amp;x); query[qidx++] = Node(1,i,x); &#125; for(int i = 0;i &lt; m;i++)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); if(a == 1)&#123; query[qidx++] = Node(a,b,c); &#125;else&#123; query[qidx++] = Node(2,b-1,aidx); query[qidx++] = Node(3,c,aidx); aidx++; &#125; &#125; CDQ(0,qidx); for(int i = 0;i &lt; aidx;i++) printf("%lld\n",ans[i]); return 0;&#125; 8.2 三维CDQ分治&emsp;&emsp;在二维偏序问题拓展中，我们利用二维有序当作索引，来查找想要的结果。类似的，我们可不可以用三维有序对来当下标，找寻想要的答案集合T呢？例题： &emsp;&emsp;平面上有N个点，每个点的横纵坐标在[0,1e7]之间，有M个询问，每个询问为查询在指定矩形之内有多少个点，矩形用(x1,y1,x2,y2)的方式给出，其中(x1,y1)为左下角坐标，(x2,y2)为右上角坐标。 解题思路：&emsp;&emsp;我们同样将查询区间内点数量分成四个求前缀和操作（这里需要用容斥原理）。将平面上点看成插入操作，查询矩形内点个数看成查询操作。那么对于每个操作，有三个维度作为索引（或者下标），又因为time是默认有序的，所以我们需要根据x归并，同时用树状数组维护y的前缀和。我们按照CDQ分治的思想，统计左边区间节点对右边区间查询的贡献。（这里所说的左右区间概念引自归并排序）详细思想请对照代码。代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/*BZOJ1935单点修改，区间查询CDQ+树状数组 */#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int N = 5e5+50; //最大节点数量 struct Node&#123; int op,x,y,val; /* op = 1是修改值操作，2是减去前缀和操作，3是加上前缀和操作 x、y代表坐标 val有两重用法， 当是修改值操作时，val代表要修改的值； 当表示求前缀和操作时，val代表答案数组ans的下标（因为最终结果要累加） */ bool operator &lt;(const Node &amp;B) const&#123; //x为第一关键字，y为第二关键字，op为第三关键字，升序排序 if(x == B.x)&#123; if(y == B.y) return op &lt; B.op; return y &lt; B.y; &#125; return x &lt; B.x; &#125; //构造函数，无参的用来创建数组，有参的用来快速赋值 Node()&#123;&#125; Node(int op,int x,int y,int val):op(op),x(x),y(y),val(val)&#123;&#125;&#125;;Node Q[7*N]; //为啥是7倍，因为每个查询操作被分成四个子操作了嘛 Node tmp[7*N];int ans[N],st[10100000]; //树状数组没开离散化，当然如果范围再大点就要开了 int qidx = 0,aidx = 2; //分别代表查询集合Q和答案集合ans的下标 //以下俩个函数是树状数组的函数 void add(int x,int y)&#123; for(;x &lt; N;x += x&amp;-x) st[x] += y;&#125;int ask(int x)&#123; int sum = 0; for(;x;x -= x&amp;-x) sum += st[x]; return sum;&#125;//CDQ分治的用法 void solve(int l,int r)&#123; if(r-l &lt;= 1) return; int mid = (l+r)/2; solve(l,mid); solve(mid,r); int p = l,q = mid,k = l; while(p &lt; mid &amp;&amp; q &lt; r)&#123; if(Q[p] &lt; Q[q])&#123; if(Q[p].op == 1) add(Q[p].y,Q[p].val); tmp[k++] = Q[p++]; &#125;else&#123; if(Q[q].op == 2) ans[Q[q].val] -= ask(Q[q].y); else if(Q[q].op == 3)ans[Q[q].val] += ask(Q[q].y); tmp[k++] = Q[q++]; &#125; &#125; while(q &lt; r)&#123; if(Q[q].op == 2) ans[Q[q].val] -= ask(Q[q].y); else if(Q[q].op == 3) ans[Q[q].val] += ask(Q[q].y); tmp[k++] = Q[q++]; &#125; //我们用这种方法来清空树状数组，可以节省时间 for(int i = l;i &lt; p;i++) if(Q[i].op == 1) add(Q[i].y,-Q[i].val); while(p &lt; mid) tmp[k++] = Q[p++]; for(int i = l;i &lt; r;i++) Q[i] = tmp[i];&#125;int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i = 0;i &lt; n;i++)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); Q[qidx++] = Node(1,x+1,y+1,1); &#125; for(int i = 0;i &lt; m;i++)&#123; int x1,y1,x2,y2; scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); Q[qidx++] = Node(3,x1,y1,aidx); Q[qidx++] = Node(2,x1,y2+1,aidx); Q[qidx++] = Node(2,x2+1,y1,aidx); Q[qidx++] = Node(3,x2+1,y2+1,aidx++); &#125; solve(0,qidx); //依旧左闭右开 for(int i = 2;i &lt; aidx;i++) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>ValenShi的ACM模板</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu6681 Rikka with Cake]]></title>
    <url>%2F2019%2F08%2F19%2Fhdu6681%2F</url>
    <content type="text"><![CDATA[测试地址 题意简述直接看样例其实就明白了，看图说话，就是给出一个左下角坐标为(0,0)，右上角为(n,m)的矩形；然后有k条线段，这些线段不重叠，都是从矩形内某一点出发到矩形某一边为止，这些线段共四种，都与坐标轴平行。请问这些线段将矩形分为了几个不连通的面？（图一是3个，图二是5个） 解题思路首先考虑到任意两条直线的x，y坐标都是不同的，所以不会出现重叠现象。观察得，肯定是相交的线段才能分割出新的面（一条横的线与几条竖线相交就会增加几个面）。所以我们只需考虑，假设先将所有与y轴平行的线加入，然后对于每一条与x轴平行的线，有几条与其相交，最终答案就是这些交点个数再+1。 现在的问题就是对于每个与x轴平行的线，有多少与y轴平行的线与其相交。如果挨个计算并累加，计算完所有线段需要O(N^2)时间。其实我们会发现，找与(x , y)至左边界（L）的横线相交的线段，只需要找出 x’ &lt;= x &amp;&amp; y’ &lt;= y的向上方(U) 的线段以及 x’ &lt;= x &amp;&amp; y’ &gt;= y的向下 (D) 的线段的数量即可。这是二维偏序问题，是4个二维偏序问题。而二维偏序问题可以在$O(Nlog_2^N)$时间内用CDQ分治解决，写起来也不是很麻烦（还好不是三维）。 PS：呜呜呜正解是欧拉定理呜呜呜呜呜 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e5+10;struct Node&#123; int x,y,t; Node()&#123;&#125; Node(int x,int y):x(x),y(y)&#123;t = 0;&#125; bool operator &lt; (const Node&amp; B)const&#123; return x &lt; B.x; &#125;&#125;;Node U[N],D[N],R[N],L[N],tmp[N];Node TU[N];int cu,cd,cr,cl,cnt;int n,m,t,k;void cdq1(int l,int r)&#123; if(l &gt;= r-1) return; int mid = l+r&gt;&gt;1; cdq1(l,mid); cdq1(mid,r); int p = l,q = mid,tk = 0,tt = 0; while(p &lt; mid &amp;&amp; q &lt; r)&#123; if(TU[p].y &lt;= TU[q].y)&#123; if(!TU[p].t) tt++; tmp[tk++] = TU[p++]; &#125; else&#123; if(TU[q].t) cnt += tt; tmp[tk++] = TU[q++]; &#125; &#125; while(p &lt; mid) tmp[tk++] = TU[p++]; while(q &lt; r)&#123; if(TU[q].t) cnt += tt; tmp[tk++] = TU[q++]; &#125; for(int i = 0;i &lt; tk;i++) TU[i+l] = tmp[i];&#125;bool cmp2(Node a,Node b)&#123; return a.x &gt; b.x;&#125;void solve()&#123;/* 对于L[i],有多少U中x &lt; L[i].x &amp;&amp; y &lt; L[i].y, 有多少D中x &lt; L[i].x &amp;&amp; y &gt; L[i].y; 对于R[i]有多少U中x &gt; R[i].x &amp;&amp; y &lt; R[i].y, 有多少D中x &gt; R[i].x &amp;&amp; y &gt; R[i].y;*/ cnt = 0; for(int i = 0;i &lt; cu;i++) TU[i] = U[i]; for(int i = 0;i &lt; cl;i++) TU[i+cu] = L[i],TU[i+cu].t = 1; stable_sort(TU,TU+cu+cl); cdq1(0,cl+cu); for(int i = 0;i &lt; cd;i++) TU[i] = D[i]; for(int i = 0;i &lt; cl;i++) TU[i+cd] = L[i],TU[i+cd].t = 1; for(int i = 0;i &lt; cl+cd;i++) TU[i].y *= -1; stable_sort(TU,TU+cd+cl); cdq1(0,cl+cd); for(int i = 0;i &lt; cu;i++) TU[i] = U[i]; for(int i = 0;i &lt; cr;i++) TU[i+cu] = R[i],TU[i+cu].t = 1; stable_sort(TU,TU+cr+cu,cmp2); //for(int i = 0;i &lt; cr+cu;i++) printf("%d %d\n",TU[i].x,TU[i].y); cdq1(0,cr+cu); for(int i = 0;i &lt; cd;i++) TU[i] = D[i]; for(int i = 0;i &lt; cr;i++) TU[i+cd] = R[i],TU[i+cd].t = 1; for(int i = 0;i &lt; cd+cr;i++) TU[i].y *= -1; stable_sort(TU,TU+cr+cd,cmp2); cdq1(0,cr+cd); printf("%d\n",cnt+1);&#125;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); cu = cd = cr = cl = 0; for(int i = 1;i &lt;= k;i++)&#123; int x,y;char dir[5]; scanf("%d%d%s",&amp;x,&amp;y,dir); if(dir[0] == 'U') U[cu++] = Node(x,y); else if(dir[0] == 'D') D[cd++] = Node(x,y); else if(dir[0] == 'L') L[cl++] = Node(x,y); else R[cr++] = Node(x,y); &#125; solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1093最大半连通子图]]></title>
    <url>%2F2019%2F08%2F18%2Fbzoj1093%2F</url>
    <content type="text"><![CDATA[测试地址 问题简述给出一个有向图，求其最大半连通子图的节点个数，以及不同的最大半连通子图的数目。（子图、半连通图、最大半连通子图等定义请参照原题） 解题思路本题是《信息学奥赛一本通·提高篇》中，强连通分量章节的一道例题。本题思路其实很清晰也很明确，就是求最大半连通子图的节点数，以及有多少个这样的子图。可以得知，如果一个子图是强连通的，那么他一定是半连通的，所以对于所有的强连通分量，我们都缩为一个点，这样就得到了一个有向无环图（DAG）。我们对得到的DAG进行建图得到G’，每个节点的“权值”就等于该强连通分量的顶点数；于是原问题就成了在 G’ 上找到权值最大的链（因为我们可以保证对于链上任意两点u和v，都单向或双向可达）。找到了“最长链”之后，下一步是找不同的最长链的个数 ，这一步用到类似DP的思想，即设f[i]为到节点 i 时，达到局部最长链时不同方案数，我们只需要在进行拓扑排序求最长链 的同时递推更新f[] 即可。 代码示例虽然写代码时的思路很清晰，但是代码还是写的很乱，可读性很差；因为涉及变量太多、太乱，所以每个变量或数组的作用是什么并不是一目了然，但我也懒得写注释了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e5+10;const int M = 1e6+10;int head[N],ver[M],nex[M],tot = 1;void addEdge(int x,int y)&#123; ver[++tot] = y;nex[tot] = head[x];head[x] = tot;&#125;int head2[N],ver2[M],nex2[M],tot2 = 1;void addEdge2(int x,int y)&#123; ver2[++tot2] = y; nex2[tot2] = head2[x];head2[x] = tot2;&#125;int Stack[N],top;int dfn[N],low[N],num,co[N],col;void Tarjan(int u)&#123; dfn[u] = low[u] = ++num; Stack[++top] = u; for(int i = head[u];i ;i = nex[i])&#123; int v = ver[i]; if(!dfn[v])&#123; Tarjan(v); low[u] = min(low[u],low[v]); &#125;else if(!co[v]) low[u] = min(low[u],dfn[v]); &#125; if(low[u] == dfn[u])&#123; co[u] = ++col; while(Stack[top] != u)&#123; co[Stack[top]] = col; top--; &#125; top--; &#125;&#125;int n,m,P;pair&lt;int,int&gt; e[M];int du[N],dis[N],si[N];//si[col]记录强连通分量col节点个数queue&lt;int&gt; q;int mxnum,mxcol;int f[N];//到i距离为最长的方案数void topo()&#123; memset(si,0,sizeof si); memset(dis,0,sizeof dis); for(int i = 1;i &lt;= n;i++) si[co[i]]++,f[co[i]] = 1; for(int i = 1;i &lt;= col;i++) if(!du[i]) q.push(i),dis[i] = si[i]; while(!q.empty())&#123; int x = q.front();q.pop(); for(int i = head2[x];i ;i = nex2[i])&#123; int y = ver2[i];du[y]--; if(!du[y]) q.push(y); if(dis[y] &lt; dis[x]+si[y])&#123; dis[y] = dis[x] + si[y]; f[y] = 0; if(dis[mxcol] &lt; dis[y]) mxcol = y; &#125; if(dis[y] == dis[x]+si[y]) f[y] = (f[y]+f[x])%P; &#125; &#125; for(int i = 1;i &lt;= col;i++) if(dis[i] == dis[mxcol]) mxnum = (mxnum+f[i])%P;&#125;void solve()&#123; num = col = top = 0; memset(dfn,0,sizeof dfn); memset(co,0,sizeof co); for(int i = 1;i &lt;= n;i++) if(!dfn[i]) Tarjan(i); int cnt = 0; for(int i = 1;i &lt;= n;i++)&#123; for(int j = head[i];j ;j = nex[j])&#123; int y = ver[j]; e[++cnt] = make_pair(co[i],co[y]); //printf("%d %d %d %d\n",co[i],co[y],i,y); &#125; &#125; //printf("cnt %d\n",cnt); sort(e+1,e+1+cnt);tot2 = 1; memset(du,0,sizeof du); memset(head2,0,sizeof head2); for(int i = 1;i &lt;= cnt;i++)&#123; if(e[i].first != e[i].second &amp;&amp; (e[i].first != e[i-1].first || e[i].second != e[i-1].second)) addEdge2(e[i].first,e[i].second), du[e[i].second]++; //printf("%d %d\n",e[i].first,e[i].second); &#125; topo();//拓扑排序找出最长链 printf("%d\n%d\n",dis[mxcol],mxnum);&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;P); for(int i = 1,a,b;i &lt;= m;i++)&#123; scanf("%d%d",&amp;a,&amp;b); addEdge(a,b); &#125; solve(); return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大整数开方根模板]]></title>
    <url>%2F2019%2F08%2F18%2Fbigsqrt%2F</url>
    <content type="text"><![CDATA[例1： 试判断n是否为完全平方数(Perfect square)，$n &lt;=10^{200}$。 本来想写一篇关于牛顿迭代法+高精度运算的C++版本的模板，但是涉及到高精度加减乘除，动辄300行代码以上，还是在网上找个JAVA的大整数开方根的模板凑合用吧。 用JAVA书写代码，需要注意的是时间和空间，内存超限很常见。 大数开平方根模板1234567891011121314151617181920212223242526public static BigInteger sqrt(String x) &#123; int mlen = x.length(); //被开方数的长度 int len; //开方后的长度 BigInteger beSqrtNum = new BigInteger(x);//被开方数 BigInteger sqrtOfNum; //存储开方后的数 BigInteger sqrtOfNumMul; //开方数的平方 String sString;//存储sArray转化后的字符串 if(mlen%2 == 0) len = mlen/2; else len = mlen/2+1; char[] sArray = new char[len]; Arrays.fill(sArray, &apos;0&apos;);//开方数初始化为0 for(int pos=0; pos&lt;len; pos++)&#123; //从最高开始遍历数组，每一位都转化为开方数平方后刚好不大于被开方数的程度 for(char num=&apos;1&apos;; num&lt;=&apos;9&apos;; num++)&#123; sArray[pos] = num; sString = String.valueOf(sArray); sqrtOfNum = new BigInteger(sString); sqrtOfNumMul = sqrtOfNum.multiply(sqrtOfNum); if(sqrtOfNumMul.compareTo(beSqrtNum) == 1)&#123; sArray[pos]-=1; break; &#125; &#125; &#125; return new BigInteger(String.valueOf(sArray));&#125; 判断n是否为Perfect square123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Scanner;import java.math.BigInteger;class Main &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int T = cin.nextInt(); for (int cas = 1; cas &lt;= T; ++cas) &#123; String str = cin.next(); BigInteger n = new BigInteger(str); BigInteger m = n.multiply(n.subtract(BigInteger.ONE)).shiftRight(1); //System.out.println(n); //System.out.println(m); boolean nIsSquare = isSquare(n); boolean mIsSquare = isSquare(m); if (nIsSquare &amp;&amp; mIsSquare) &#123; System.out.println("Arena of Valor"); &#125; else if (nIsSquare &amp;&amp; !mIsSquare) &#123; System.out.println("Hearth Stone"); &#125; else if (!nIsSquare &amp;&amp; mIsSquare) &#123; System.out.println("Clash Royale"); &#125; else &#123; System.out.println("League of Legends"); &#125; &#125; &#125; public static boolean isSquare(BigInteger n) &#123; BigInteger low = BigInteger.ZERO; BigInteger high = n; while (low.compareTo(high) &lt;= 0) &#123; BigInteger mid = low.add(high).shiftRight(1); BigInteger square = mid.multiply(mid); int result = square.compareTo(n); if (result == 0) &#123; return true; &#125; else if (result &gt; 0) &#123; high = mid.subtract(BigInteger.ONE); &#125; else &#123; low = mid.add(BigInteger.ONE); &#125; &#125; return false; &#125;&#125; 参考资料 Molex的博客 2019焦作网络赛 J 题Participate in E-sports]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国剩余定理（拓展）]]></title>
    <url>%2F2019%2F08%2F18%2Frealchina%2F</url>
    <content type="text"><![CDATA[摘要在《孙子算经》中有这样一个问题：“今有物不知其数，三三数之剩二（除以3余2），五五数之剩三（除以5余3），七七数之剩二（除以7余2），问物几何？”这个问题称为“孙子问题”，该问题的一般解法国际上称为“中国剩余定理”。 中国剩余定理是数论四大定理之一，其重要性不容置疑，本文主要介绍中国剩余定理问题的经典模型，然后再对更一般的情况进行拓展，得到拓展中国剩余定理，当然最重要的是给出模板并附上模板使用说明书。 中国剩余定理若$m_1,m_2,…,m_n$是两两互质的正整数，M = $\prod_{i = 1}^{n} m_i$, $M_i = M/m_i$，$t_i$是线性同余方程$M_it_i \equiv1(mod\: m_i)$的一个解。对于任意的n个整数$a_1,a_2,…,a_n$，则同余方程组 有整数解，方程组的解为$x = a_1M_1t_1 + a_2M_2t_2 + … + a_nM_nt_n$。并且在模M意义下有唯一解。 证明因为$M_i = M/m_i$是除$m_i$之外所有模数的倍数，所以$\forall k \neq i, a_iM_it_i \equiv 0(mod\:m_k)$。又因为$a_iM_it_i \equiv a_i(mod\: m_i)$，所以带入$x = \sum_{i = 1}^n a_iM_it_i$，原方程组成立。证毕。 应用中国剩余定理给出了模数两两互质的线性同余方程组的一个特殊解。方程组的通解可以表示为$x + kM(k \in Z)$。有些题目要求我们求出最小的非负整数解，只需把 x 对M取模，并让 x 落在0~M-1的范围内即可。 另外，即使模数不满足两两互质，我们也有办法判断线性同余方程组是否有解，并求出方程组的解。 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* * 代码出自:洛谷用户sumijie 2019/8/18 * 使用说明: * 1.ll为自定义类型,视题目数据而定,并不一定是__int128 * 2.N为方程组中方程个数,视数据而定 * 输入： * 输入第一行包含整数 n. * 接下来 n 行,每行两个非负整数 ai,bi * 输出: * 输出一行,为满足条件的最小非负整数x. */#include&lt;iostream&gt;typedef __int128 ll;using namespace std;void exgcd(ll a,ll b,ll &amp;g,ll &amp;x,ll &amp;y) &#123; if (b == 0) &#123; g = a; x = 1; y = 0; return; &#125; exgcd(b,a%b,g,y,x); y-=(a/b)*x;&#125;bool flag = false;ll a1,a2,n1,n2;ll abs(ll x) &#123; return x&gt;0?x:-x;&#125; void china() &#123; ll d = a2 - a1; ll g,x,y; exgcd(n1,n2,g,x,y); if (d % g == 0) &#123; x = ((x*d/g)%(n2/g)+(n2/g))%(n2/g); a1 = x*n1 + a1; n1 = (n1*n2)/g; &#125; else flag = true;&#125;int n; //方程个数const int N = 1e5+10;long long as[N];//余数long long ns[N];//模数ll realchina() &#123; /*返回线性同余方程组的最小非负整数解*/ a1 = as[0]; n1 = ns[0]; for (ll i = 1;i&lt;n;i++) &#123; a2 = as[i]; n2 = ns[i]; china(); if (flag) return -1; &#125; return a1;&#125;int main() &#123; cin&gt;&gt;n; flag = false; for (ll i = 0;i&lt;n;i++) cin&gt;&gt;ns[i]&gt;&gt;as[i];//输入模数和余数 cout&lt;&lt;(long long)realchina()&lt;&lt;endl; &#125; 参考资料 董永建，信息学竞赛一本通提高篇，福州：福建教育出版社，2018.6，401-403 洛谷网用户sumijie的博客]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数据结构与算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵快速幂模板]]></title>
    <url>%2F2019%2F08%2F17%2FMatrix%2F</url>
    <content type="text"><![CDATA[矩阵快速幂常用于动态规划中的“矩阵加速链乘”里，可以将线性的递归式优化为$O(log_2N)$，是一种很常用的技巧。由于矩阵快速幂不像普通的整数快速幂一样方便记忆，因此整理模板以便需要时参考。123456789101112131415161718192021222324252627282930313233343536373839/********************************************* 最后修改：2019/8/17 ValenShi 使用说明： 1.注意矩阵是在Mod P下相乘 2.矩阵为nn*nn的方阵,使用前需对nn赋值 3.矩阵有效行列下标是1~nn 4.注意memset头文件以及 long long *********************************************/#include&lt;cstdio&gt;#include&lt;cstring&gt;typedef long long ll;const int P = 1e9+7;int nn; //nn 为矩阵大小 nn*nnstruct Mat&#123; ll v[20][20]; Mat()&#123;memset(v,0,sizeof v);&#125;&#125;;Mat Mul(const Mat&amp; a,const Mat&amp; b)&#123; /* 返回矩阵a*矩阵b的结果 */ Mat c; for(int i = 1;i &lt;= nn;i++) for(int j = 1;j &lt;= nn;j++) for(int k = 1;k &lt;= nn;k++) c.v[i][j] = (c.v[i][j]+a.v[i][k]*b.v[k][j]%P)%P; return c;&#125;Mat qpow(Mat A,int b)&#123; /* 返回矩阵A^b后的结果(矩阵) */ Mat c; for(int i = 1;i &lt;= nn;i++) c.v[i][i] = 1; while(b)&#123; if(b&amp;1) c = Mul(c,A); A = Mul(A,A); b &gt;&gt;= 1; &#125; return c;&#125;]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树笔记]]></title>
    <url>%2F2019%2F08%2F16%2Fsplay%2F</url>
    <content type="text"><![CDATA[简介前置知识： 树-&gt;二叉搜索树-&gt;平衡树-&gt;AVL树-&gt;Treap-&gt;伸展树 左单(双)旋、右单(双)旋、左右双旋 伸展树(Splay Tree) 是平衡二叉查找树的一种，具有二叉查找树的所有性质；伸展树又称Self-Adjusting Search Trees，即自调整的二叉搜索树 。与普通的二叉查找树相比，其维护更少的节点额外信息，空间性能更优且编程复杂度更低。它由Daniel Sleator 和 Robert Tarjan创造。在伸展树上的一般操作都基于伸展操作。 需要伸展树的原因：各种查找树都有各自的优缺点以及适用范围。例如，对于一棵具有n个节点的平衡树，虽然其查找的时间复杂度不超过O(log n)，但是如果访问模式不均匀（询问点不随机），平衡树的效率就会受影响，此时我们需要额外的空间记录平衡信息，同时也加大了编程复杂度。这些查找树的设计目标都是减少最坏情况下单次操作时间，但是如果我们的目标是使一系列查找操作的总时间最少，那我们更好的目标就是降低操作的摊平时间。此处的摊平时间指的是在一系列最坏情况下的操作序列中单次操作的平均时间。而伸展树就是为实现这一目标而设计的。 和其他平衡树或具有明确限制的数据结构相比，伸展树的优点： 从摊平角度讲，它们忽略常量因子，因此绝对不会比有明确限制的数据结构差。而且它们可以依据适用情况进行调整，于是在使用模式不均匀的情况下更加有效。 由于无需存储限制信息，它们所需空间更小，实现起来也更加简洁。 它们的查找和更新算法概念简单，易于实现。 潜在的两个缺点： 它们需要更多的局部调整，尤其是在查找期间。（而其他有明确限制的查找树仅需要在更新期间进行调整，查找期间则不用） 一系列查找操作中的某一个可能会耗时较长。这在实际应用中需要作为是否选用的参考依据。 什么是伸展树：假设要对一个二叉搜索树执行一系列查找操作，为了使得总时间最小，那么被查找频率高的节点自然就要放在靠近根的位置。于是想到一个简单的设计方案，在每次查找之后对树进行重构，把被查找的条目搬到离树根近一点的位置。 顺着这个思路，splay诞生了。splay是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列旋转把该节点搬移到树根，同时使得该条路径上的点尽量靠近树根。 构建方法两种可能的重构方法： 单旋：在查找完位于节点x中的条目之后，旋转链接x和其父节点的边。（除非x是根） 搬移至树根：在查找完位于节点x中的条目后，旋转链接x和其父节点的边，然后重复这个操作直至x成为树根。 注：上述两个方法是不一样的，一种是查找x后仅交换一次，另一个是将被查询的节点x旋转至树根。旋转示意图：其中三角形代表子树，而图示的树也可能是一棵更大的树的子树。 上述两种重构方法的示意图：其中被查询节点是a。 注： 若x为p(x)的左孩子，交换x和p(x)的位置，称为右旋。 若x为p(x)的右孩子，交换x和p(x)的位置，称为左旋。 不幸的是，上述两个重构方法在摊分效率方面表现的都不太好。 如果有很长的随机查询序列，那么上述两种重构方法的查询时间复杂度是O(N)。显然我们需要一种性能更强大的重构方法。 伸展操作我们采取的重构方法叫做splaying，即伸展，它和上述“搬移至树根”相似。它们都是沿着查询路径 做旋转倒置，将被查询的节点通过此方法移动到根节点。不同的是，伸展操作是按照该结构上的查找顺序成对旋转 。对于伸展树中的一个节点x，我们重复如下操作直到 x 成为树的根节点。 Splaying StepCase 1(zig)： 如果p(x)是x的父节点，并且p(x)是树的根，那么旋转x和p(x)间的边。（此为最终步骤）Case 2(zig-zig)： 如果p(x)不是根节点，并且x和p(x)都是左儿子或者右儿子，那么旋转链接p(x)和g(x)的边，然后旋转链接x和p(x)的边。Case 3(zig-zag)： 如果p(x)不是根，并且x是左儿子 p(x)是右儿子，或者相反，那么旋转链接x和p(x)的边，然后旋转链接x和p(x)的新边。 注：其中我们假设p(x)为x的父节点，g(x)为p(x)的父节点。下图三个操作a、b、c分别对应上述的zig、zig-zig、zig-zag。 分析：对于深度为d的节点x做伸展操作，需要花费的时间和d成比例，即和查找x的时间成比例。伸展操作并不仅仅是将x移动到根节点，而是将查找路径上的节点的深度都粗略减少了一半。 如此一来使得伸展树的效率非同凡响。效率证明略，不过我们依然可以根据如下1种常规情况(Figures 4)及2种极端情况(Figures 5)下进行splaying操作后 树的构造来略窥一二。 伸展树上的更新操作使用伸展树，我们可以继承标准的二叉搜索树的操作。考虑如下几个操作：access(i,t): &emsp;如果i在树t中，返回一个指向i位置的指针；否则，返回一个指向空节点的指针。insert(i,t): &emsp;向树t中插入一个元素i，假设此前i不存在。delete(i,t): &emsp;从树t中删除元素i，假设i存在。join(t1,t2): &emsp;将树t1和t2合并成一棵新的树并返回新树的树根。该操作假设t1中所有元素都小于t2中的元素。合并后删除t1和t2。split(i,t): &emsp;将t分成两棵子树t1和t2，所有小于等于i的元素在t1，所有大于i的元素在t2。然后删除树t。 access(i,t)实现方法：我们从树t的根开始，按照二叉搜索树的查找方式向下查找；如果当前节点x包含待查目标i，则算法完成，我们对x进行splaying操作并返回指向x的指针。如果搜索到达了空节点（即待查目标不存在），那么我们对搜索路径的最后一个节点进行splaying操作，并返回一个空指针。如果树为空，则取消splaying操作。（Figures 6） join(t1,t2)实现方法：我们首先在t1中执行一次access(i,t1)，其中i是t1中最大的元素。于是在access后，t1的根包含i，并且它没有右儿子。于是我们可以将t2作为t1的右儿子连接，并返回处理后的树，join操作完成。(Figures 7) split(i,t)实现方法：我们首先执行一次access(i,t)，然后断开t和左右儿子的链接，左子树作为t1，右子树作为t2，并且考虑根是否包含等于i的元素。返回t1或t2，split操作完成。(Figures 7) insert(i,t)实现方法我们先对t进行一次split(i,t)，得到了两个子树t1和t2，这时我们把i作为一个新的根节点，t1作为i的左子树，t2作为其右子树。(Figures 8) delete(i,t)实现方法我们先执行一次access(i,t)，此时得到根节点t，这个时候对t的两个子树t1和t2执行join(t1,t2)，就完成了删除i节点。(Figures 8) 小结：通过上述操作的实现方法，我们可以发现，实现join和split时用到了access，实现insert和delete时我们又用到了split和join，由此可见我们可以通过已实现的操作来搭建未实现的操作，这样更加简洁且降低了编程难度。 另外，对于insert和delete操作还有另一种稍加优化的方法，这里省略，复杂度分析同样省略，具体可以参照原文[1]。 参考文献： [1] Daniel D.Sleator , Robert Endre Tarjan, A data structure for dynamic trees.]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树区间修改-延迟标记]]></title>
    <url>%2F2019%2F08%2F16%2Finterval-tree%2F</url>
    <content type="text"><![CDATA[延迟标记在线段树中，单点修改时，我们是将信息从叶节点向上依次更新它的父节点，直到根节点。如果在区间修改仍然按照这个策略，那么修改的时间复杂度为O(N)。为了降低时间复杂度，我们可以在更新时只更新大区间，不向下更新到叶子节点，等查询时再更新。举个例子：我们将1-5的位置上每个数+100，重复10000次上述操作。我们加10000次100和直接+1000000是相等的效果，但是一个执行了10000次，而另一个只执行1次。 我们又知道计算机的计算效率和计算次数是相关的，所以我们可以利用该原理，当区间修改时不向下更新，直至查询时再更新。 例题以POJ3468为例，我们使用线段树+延迟标记技巧 来实现快速区间修改与区间查询。具体做法是，我们为每个节点增加一个延迟标记add，如果add为0，则说明该点的所有子区间都已更新完成，否则说明其子区间仍需要+add。请注意，如果一个节点被打上“延迟标记”，说明该节点曾经被修改过，但其子节点尚未被更新，即延迟标记说明的是子节点的待更新情况。具体实现时，我们可以使用一个函数spread来实现延迟标记向下传递。代码示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;cstdio&gt;const int MAXN = 1e5+50;typedef long long ll;struct SegmentTree&#123; int l,r; ll sum,add; #define l(x) t[x].l #define r(x) t[x].r #define sum(x) t[x].sum #define add(x) t[x].add&#125;t[MAXN*4];int a[MAXN],n,m;//将延迟标记向下更新一层 inline void spread(int p)&#123; if(add(p))&#123; sum(p*2) += (r(p*2) - l(p*2) + 1)*add(p); sum(p*2+1) += (r(p*2+1) - l(p*2+1) + 1)*add(p); add(p*2) += add(p); add(p*2+1) += add(p); add(p) = 0; &#125;&#125;//建树 l和r是当前节点所代表的区间的左右端点 void build(int p,int l,int r)&#123; l(p) = l,r(p) = r,add(p) = 0; if(l == r)&#123; t[p].sum = a[l]; return; &#125; int mid = (l+r)/2; build(p*2,l,mid); build(p*2+1,mid+1,r); t[p].sum = t[p*2].sum + t[p*2+1].sum; &#125;//区间更新 如果当前区间被包含 则延迟标记 void change(int p,int l,int r,int d)&#123; if(l &lt;= l(p) &amp;&amp; r(p) &lt;= r)&#123; sum(p) += (r(p)-l(p)+1)*d; add(p) += d; return; &#125; spread(p); int mid = (l(p)+r(p))/2; if(l &lt;= mid) change(p*2,l,r,d); if(r &gt; mid) change(p*2+1,l,r,d); sum(p) = sum(p*2) + sum(p*2+1);&#125;//区间查询 当查询到该区间时顺便更新 ll ask(int p,int l,int r)&#123;// printf("%d %d\n",l(p),r(p)); if(l &lt;= l(p) &amp;&amp; r(p) &lt;= r)&#123; return sum(p); &#125; ll ans = 0; spread(p); int mid = (l(p) + r(p))/2; if(l &lt;= mid) ans += ask(p*2,l,r); if(r &gt; mid) ans += ask(p*2+1,l,r); return ans;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1;i &lt;= n;i++) scanf("%d",a+i); build(1,1,n); while(m--)&#123; char op[5]; scanf("%s",op); if(op[0] == 'C')&#123; int l,r,d; scanf("%d%d%d",&amp;l,&amp;r,&amp;d); change(1,l,r,d); &#125;else&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); printf("%lld\n",ask(1,l,r)); &#125; &#125; return 0;&#125; 参考书目：《算法竞赛进阶指南》李煜东.P209]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie-字典树笔记]]></title>
    <url>%2F2019%2F08%2F16%2Ftrie%2F</url>
    <content type="text"><![CDATA[Trie，又称字典树，是一种用于实现字符串快速检索的多叉树结构。Trie的每个节点都拥有若干个字符指针，若在插入或检索字符串时扫描到一个字符c，就沿着当前节点的c这个字符指针，走向该指针指向的节点。 初始化一颗空Trie仅包含一个根节点，该节点的字符指针均指向空。 插入若需要插入一个字符串S时，我们令一个指针P起初指向根节点。然后，依次扫描S中的每个字符c： 若P的c字符指针指向一个已经存在的节点Q，则令 P = Q。 若P的c字符指针指向空，则新建一个节点Q，令P的c字符指针指向Q，然后令P = Q。 当S的字符扫描完毕时，在当前节点P上标记它是一个字符串的末尾。 检索当需要检索一个字符串S在Trie中是否存在时，我们令一个指针P起初指向根节点，然后依次扫描S中的每个字符c： 若p的c字符指针指向空，则说明S没有被插入过Trie，结束检索。 若P的c字符指针指向一个已经存在的节点Q，则令P = Q 若S中的字符扫描完毕时，当前节点P被标记为一个字符串的末尾，则说明S在Trie中存在，否则说明S没有被插入过。 代码示例我们以一个简单的经典问题为例：有m次询问，每次询问给出一个操作符op和字符串S，若op = 1，则将S放入集合T，若op = 2，则回答T集合中是否有S字符串。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;cstring&gt;const int SIZE = 10000;bool End[SIZE];int trie[SIZE][30],tot = 1;void insert(char *str)&#123; int len = strlen(str); int p = 1; for(int k = 0;k &lt; len;k++)&#123; int ch = str[k]-'0'; if(trie[p][ch] == 0) trie[p][ch] = ++tot; p = trie[p][ch]; &#125; End[p] = true;&#125;bool search(char *str)&#123; int len = strlen(str),p = 1; for(int k = 0;k &lt; len;k++)&#123; p = trie[p][str[k]-'0']; if(p == 0) return false; &#125; return End[p];&#125;int main()&#123; char s[100]; int m,op; scanf("%d",&amp;m); while(m--)&#123; scanf("%d%s",&amp;op,s); if(op == 1) insert(s); else&#123; if(search(s)) printf("Yes\n"); else printf("No\n"); &#125; &#125; return 0;&#125; 参考书目： 《算法竞赛进阶指南》李煜东.P71]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路径算法]]></title>
    <url>%2F2019%2F08%2F16%2Fdijkstra%2F</url>
    <content type="text"><![CDATA[前置知识： 图的相关定义、图的存储 摘要：最短路径算法中常用的有4个：Floyed-Warshall、Dijkstra、Bellman-Ford、SPFA。这几种算法区别在于适用范围，以及对于不同构造的图效率不同。由于边的权值可以为负，在边权为负的情况下Dijkstra算法无法使用。而Bellman-Ford算法虽然可以处理负边权图，但却不能处理负权回路的情况（文中有介绍）。进一步的，我们可以将最短路径问题分为单源最短路径和多源最短路径问题。在学会处理这两个问题后，我们还将探讨如何记录并输出最短路径而不仅仅是求值；在走最短路径的基础上，我们还应能对等效路径（即最终结果相同的两条路径，这里表现为权值相同）做约束选择（即有第二权值）。 相关概念我们假设图中顶点个数为N，编号依次为1~N，边的个数为M。 最短路问题： 在图中，给定两个顶点，在以这两个点为起点和终点的路径中，边的权值和最小的路径。稀疏图： 符合|E| = O(V)的图称为稀疏图。稠密图： 符合|E| = O(V^2)的图称为稠密图。在算法竞赛中，若|E|比|V|大一个数量级以上则可认为是稠密图。 单源最短路径源，即起点的意思。单源最短路径问题就是求从一个起点出发到其它顶点的最短路径。这里我们假设起点为1（图中顶点编号为1~N），dist[ i ] 为从起点1到顶点i的最短路径。求单源最短路径有3个算法：Dijkstra、Bellman-Ford和SPFA。其中SPFA是Bellman-Ford的优化版本，于是我们通常依据情况挑选适合的算法使用。 Dijkstra算法适用范围与效率：Dijkstra算法适用于所有边权值非负情况，其运行效率为O(N^2)，优化后效率为O(M* LogN)，适用于稠密图。 算法流程： 初始化dist[1] = 0，其余节点的dist值设为无穷大。 找出一个未被标记的、dist[x]最小的节点x，然后标记节点x。 扫描节点x的所有出边（x,y,z），若dist[y] &gt; dist[x]+z，则适用dist[x]+z更新dist[y]。 算法思想：Dijkstra算法基于贪心的思想。我们的做法就是不断通过已求出的最短路径dist[x]来更新和其相连的点y（假设(x,y,z)分别为起点、终点、边权）。在这种情况下，每个点y有可能被多个点x更新，于是我们取dist[x]+z值最小的作为dist[y]。正确性证明：在上述算法流程步骤2中，我们找出未被标记的、dist[x]最小的节点x来更新和x相连的点，这里所指的dist[x]即全局最小值。为什么使用全局最小值来更新和其相连的点可以达到目的呢？首先，由于除了节点1外所有点的dist初始值都为无穷大，因此dist不是无穷大的点一定是被更新过了的；另外，dist为全局最小值的点，其dist一定不会再被更新，因为没有比其dist更小的点可以用来更新它。至此，我们已经证明了dist为全局最小值的点x一定是被更新过了的，且一定是不能再被更新了的，因此dist[x]即为节点1到x的最短路径，所以我们可以用x来更新其它点。 优化：上述算法，在找全局最小值时采取遍历的方法，其查找与删除的效率为O(N)，加之使用邻接矩阵存储，遍历边也是O(N)，所以时间复杂度为O(N^2)。但是我们可以采用堆+邻接表的方式来优化。我们可以在O(log N)的复杂度下获取和删除全局最小值，最终可在O(M log N)时间内完成算法。 代码示例：见附录部分code-1：二叉堆优化的Dijkstra算法模板 Bellman-Ford算法与SPFA算法适用范围与效率：能处理带负权边的情况，不能处理存在负权回路的情况。其中Bellman-Ford效率为O(NM)，SPFA效率为O(KE)，其中K为常数，平均值为2。适用于稀疏图。算法介绍：可以注意到我们将Bellman-Ford算法和SPFA算法放在了一起整理，因为实际上SPFA是“队列优化的Bellman-Ford算法”，因此本质上思想相同。算法流程： 扫描所有边(x,y,z)，若dist[y] &gt; dist[x] + z，则用dist[x] + z更新dist[y]。 重复上述步骤，直到没有更新操作为止。 算法思想：Bellman-Ford算法是基于迭代思想的。我们每一次都对所有的边进行一次更新操作，直至没有更新操作发生为止。每一次的更新操作都使得我们更接近答案，这种通过若干次重复操作不断逼近答案的思想就是迭代思想。算法的正确性很显然，不予证明。 SPFA： 建立一个队列，最初队列中只包含起点。 取出队头节点x，扫描它所有出边（x,y,z)，若dist[y] &gt; dist[x] + z，则使用dist[x] + z更新dist[y]。同时，若y不在队列中，则把y入队。 重复上述步骤，直到队列为空。 在这个优化中，我们采用队列保存了待扩展节点。每次入队相当于完成一次对dist数组的更新操作，一个节点可能会入队、出队多次。这个队列避免了Bellman-Ford算法中对不需要扩展节点的冗余扫描。在稀疏图上SPFA效率较高，为O(KM)级别，其中k是一个较小的常数。但是在稠密图或者特殊的网格图上，仍有可能退化为O(NM)。 代码示例：见附录部分code-2：SPFA模板 多源最短路径问题与单源最短路径问题对应，多源最短路径问题不局限于某一固定起点，而是可能在一次算法中询问任意两个点之间的最短路径，于是之前的3个算法就捉襟见肘了，显然，我们需要一种新的算法来解决这类问题，这个算法就是Floyd算法。 Floyd算法适用范围： 适用于求多源最短路径问题，适用于稠密图，时间复杂度为O(N^3)。算法思想：Floyd算法基于动态规划。设D[k,i,j]表示“经过若干个编号不超过k的节点”从i到j的最短路径长度。该问题可以划分为两个子问题，经过编号不超过k-1的节点从i到j，或者从i先到k再到j。于是有状态转移方程：&emsp;&emsp;D[k,i,j] = min( D[k-1,i,j] , D[k-1,i,k] + D[k-1,k,j] )初值为D[0,i,j] = A[i,j]其中A[i,j]为自定义的邻接矩阵。上述算法中，k是阶段，所以必须置于最外层循环。i和j是附加状态，因此可以置于内层循环。算法的正确等价于动态规划的正确性证明，此处不予证明。优化：Floyd算法可进行空间优化，我们可以注意到第一维完全可以向背包问题中一样省略。最初，我们可以直接用D保存邻接矩阵。在最外层循环到k层时，内层有状态转移：&emsp;&emsp;D[i,j] = min(D[i,j] , D[i,k] + D[k,j])最终D[i,j]就保存了i到j的最短路径。代码示例：见附录部分code-3：Floyd算法模板。 未解决的问题以下问题将在另一篇笔记中整理： 如何保存并输出最短路径。 最短路径的变形，如：求连通性、求传递闭包、求路径最大权值最小。 节点有约束的最短路径问题。 如何判断负环。 参考书目 《算法竞赛进阶指南》,李煜东,P322-331. 《信息学奥赛一本通》,董永建,科学技术文献出版社,P471-485. 《挑战程序设计竞赛(第二版)》,人民邮电出版社,秋叶拓哉,P99. 附录code-1：二叉堆优化的Dijkstra算法模板1234567891011121314151617181920212223242526272829303132333435// 《算法竞赛进阶指南》P324#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N = 1e5+10;const int M = 1e6+10;int head[N],ver[M],edge[M],Next[M],d[N];int n,m,tot;bool vis[N];priority_queue&lt; pair&lt;int,int&gt; &gt; q;//pair 第一维是dist的相反数，利用相反数使得大根堆变成小根堆void add(int x,int y,int z)&#123; ver[++tot] = y,edge[tot] = z; Next[tot] = head[x],head[x] = tot;&#125;void dijkstra(int s)&#123; memset(d,0x3f,sizeof d); //初始化dist数组 memset(vis,false,sizeof vis); //初始化标记数组 d[s] = 0; q.push(make_pair(0,s)); while(q.size())&#123; int x = q.top().second;q.pop();//x为全最最小值节点编号 if(vis[x]) continue; vis[x] = true; //遍历所有边 for(int i = head[x]; i;i = Next[i])&#123; int y = ver[i],z = edge[i]; if(d[y] &gt; d[x] + z)&#123; d[y] = d[x]+z; q.push(make_pair(-d[y],y)); &#125; &#125; &#125;&#125; code-2：SPFA算法模板 12345678910111213141516171819202122232425262728293031323334353637383940414243//《算法竞赛进阶指南》P326#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int N = 1e5+10;const int M = 1e6+10;int head[N],edge[M],ver[M],Next[M],d[N];int n,m,tot;bool vis[N]; //用来标记节点x是否在队列中queue&lt;int&gt; q; //辅助队列void add(int x,int y,int z)&#123; ver[++tot] = y,edge[tot] = z; Next[tot] = head[x],head[x] = tot;&#125;void SPFA(int s)&#123; memset(d,0x3f,sizeof d); memset(vis,false,sizeof vis); d[s] = 0; q.push(s); while(q.size())&#123; int x = q.front();q.pop(); vis[x] = false; //表示x不在队列中了 for(int i = head[x]; i;i = Next[i])&#123; int y = ver[i], z = edge[i]; if(d[y] &gt; d[x]+z)&#123; d[y] = d[x]+z; if(!vis[y]) q.push(y),vis[y] = true; &#125; &#125; &#125;&#125;int main()&#123; int x,y,z,s; scanf("%d%d%d",&amp;n,&amp;m,&amp;s); for(int i = 1;i &lt;= m;i++)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); add(x,y,z); &#125; SPFA(s); for(int i = 1;i &lt;= n;i++) printf("%d ",d[i]); return 0;&#125; code-3：Floyd算法模板 12345678910111213141516171819202122232425#include&lt;cstdio&gt;#include&lt;cstring&gt;const int N = 1010;int d[N][N];int n,m;int min(int a,int b)&#123; return a&gt;b?b:a;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); memset(d,0x3f,sizeof d); for(int i = 1;i &lt;= n;i++) d[i][i] = 0; for(int i = 1,x,y,z;i &lt;= m;i++)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); d[x][y] = min(d[x][y],z); &#125; for(int k = 1;k &lt;= n;k++)&#123; for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= n;j++) d[i][j] = min(d[i][j],d[i][k]+d[k][j]); &#125; for(int i = 1;i &lt;= n;i++)&#123; for(int j = 1;j &lt;= n;j++) printf("%d ",d[i][j]); puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长上升子序列模板]]></title>
    <url>%2F2019%2F08%2F16%2Flis%2F</url>
    <content type="text"><![CDATA[按照数据结构来划分的话，最长上升子序列(LIS)是属于线性DP，其作为动态规划经典入门模型，重要性也是不言而喻的。而LIS问题也有很多种变型，对于这些问题有的超过了动态规划的适用范围，有的需要对转移方程进行更改，需要具体问题具体分析。 前置知识： 子序列的概念 动态规划一般步骤 二分查找 问题模型：给定一个长度为N的数列A，求数值单调递增的子序列长度最长是多少。 解题思路：状态表示：我们设F[i]表示以A[i]为结尾的“最长上升子序列”的长度。阶段划分：子序列的结尾位置（数列A中的位置，从前到后）。转移方程：F[i] = max{ f[j] + 1} (0 &lt;= j &lt; i 且 A[j] &lt; A[i])。边界：F[0] = 0。目标：max{F[i]} ( 0 &lt;= i &lt; = N)。 如此设计目标函数与转移方程，很显然可以得到正确结果，其效率是O(N^2)，代码实现也很简单。 优化：首先考虑一下上述算法最耗时的地方在哪，显然我们每次都要用O(N)的时间遍历前i-1个位置上的元素来更新F[i]，而能更新F[i]的元素A[j]需要满足两个条件：A[j] &lt; A[i]且F[j] &gt;= F[i]，那么F[i]就可以被更新为F[j]+1。在这个过程中，A[j]也可以描述为“小于A[i]的所有元素中F的值最大的那个”，通过这个描述来找A[j]的效率是O(N)。考虑另一种方式，我们新增一个辅助数组d，d[i] 表示“长度为i的最长上升子序列的最小结尾是多少”，那么很显然，d数组中的元素是严格递增的。且每当我们读取到A序列中的一个元素A[i]时，都有两种情况： A[i] &gt; d[len]，此时 d[++len] = A[i]。 A[i] &lt;= d[len]，此时说明d数组中某个元素可以被A[i]更新，我们采用二分查找的方式更新d数组即可。 其中len代表当前最长上升子序列的长度。上述方法中，如果遇到情况1，那么效率是O(1)，情况2，效率就是O(log N)，总体来讲，对于大量数据，该优化效果还是很喜人的。 优化的正确性说明：上述优化可以用堆栈思想来解释，也可以将其看作一个小技巧。借助于d数组，对于序列A中的每个元素A[i]，我们都可以快速找到“小于A[i]的所有元素中F的值最大的那个”，因为d[len]存放的就是最长上升子序列长度为len时的最小元素 。如果A[i] &lt;= d[len]，那么很显然当前的最长上升子序列长度len不能再增加了（因为A[i] 不能添加在A的子序列d[1] ~d[len] 的后面），且d数组可以被更新(再不济也可以将d[len] 更新为 A[i]，因为 A[i] &lt; d[len])。于是借助于d数组的特性，完成了优化，当然也有所牺牲。 代码示例：1234567891011121314151617181920212223int d[100005];int b_search(int x,int s,int e)&#123; while(s &lt; e)&#123; int mid = s+(e-s)/2; if(d[mid] &gt;= x) e = mid; else s = mid+1; &#125; return s;&#125;int LIS(int A[],int n)&#123; memset(d,0,sizeof d); int len = 1; d[1] = A[0]; for(int i = 1;i &lt; n;i++)&#123; if(A[i] &gt;= d[len]) d[++len] = A[i]; else&#123; int p = b_search(A[i],1,len); d[p] = A[i]; &#125; &#125;// for(int i = 0;i &lt; len;i++) cout &lt;&lt; d[i+1]&lt;&lt;" "; return len;&#125; 参考资料 《算法竞赛进阶指南》,李煜东,P237. 博客]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“拓展域”与“边带权”并查集]]></title>
    <url>%2F2019%2F08%2F16%2Fbingchaji%2F</url>
    <content type="text"><![CDATA[前置知识 并查集 路径压缩与按秩合并 “边带权”并查集并查集实际上是由若干棵树构成的森林，我们可以在树中的每条边上记录一个权值，即维护一个数组d，用d[x]保存节点x到父节点fa[x]之前的边权。在每次路径压缩后，每个访问过的节点都会直接指向树根，如果我们同时更新这些节点的d值，就可以利用路径压缩的过程来统计每个节点到树根之间的路径上的一些信息。这就是所谓“边带权” 的并查集。 例题： POJ1773题目描述：见《算法竞赛进阶指南》P190 解题思路1：边带权本题可作为“边带权”和“扩展域”模板题整理。与一般的并查集不同的是，本题传递关系不止一种： 若x1和x2奇偶性相同，x2与x3奇偶性也相同，则x1与x3奇偶性相同。 若x1和x2奇偶性相同，x2与x3奇偶性不同，则x1与x3奇偶性不同。 若x1和x2奇偶性不同，x2与x3奇偶性不同，则x1与x3奇偶性相同。 另外，本题的N太大，而M却很小，可以使用离散化方法，所以顺便复习一下离散化。为了处理本题的多种传递关系，我们可以采用一种“边带权”的并查集。具体操作是用边权d[x] = 0 表示 x 与 par[x] 奇偶性相同；为1表示 x 与 par[x] 奇偶性不同。于是在路径压缩时，就可以通过对路径上边权做异或运算，即可得到 x 与树根的奇偶性关系。于是对于每一个询问的(l , r , ans)，我们假设回答”odd”时，ans = 1，“even”时ans = 0，我们令 x 、 y 分别代表l-1和r离散化后的序号，如果x和y在同一个集合，则判断d[x] ^ d[y] 是否等于 ans，若不等则冲突；如果x和y不在同一个集合内，则合并 x 和 y ，此时需要注意如何更新d数组。（代码 code - 1 详解） 解题思路2：扩展域本题还可以使用“扩展域”的并查集。我们把每个变量x拆分成两个节点x_odd和x_even。其中用 x_odd 表示1~x有奇数个1，x_even表示有偶数个。我们把这两个节点称为x的“奇数域”与“偶数域”。对于每个问题，假设在离散化后的 l-1 与 r 的值分别是x和y，设ans表示该问题的回答（0代表回答偶数个，1代表回答奇数个）。 若ans = 0，x_odd 与 y_even在同一个集合，则与答案矛盾；否则合并x_odd与y_odd，x_even与y_even，这表示[l , r]中有偶数个1。 若ans = 1，x_odd与y_odd在同一个集合，则与答案矛盾；否则合并x_odd与y_even，x_even与y_odd。 代码见code - 2. 参考书目 《算法竞赛进阶指南》,李煜东,P190. 代码示例：code - 112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN = 21000;struct Query&#123; int l,r,ans;&#125; q[MAXN];int a[MAXN],par[MAXN],d[MAXN],cnt = 0;/* a数组用来离散化，par[x]代表x的父节点编号，d[x]代表 从x到根节点路径和，cnt也是用于离散化。 这里根节点即集合的代表节点。*/int n,m;int Find(int x)&#123; if(par[x] == x) return x; //找到根节点，返回 int root = Find(par[x]); //临时存根节点 d[x] ^= d[par[x]]; //路径压缩，距离数组d也应该更新 return par[x] = root; //路径压缩&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); char rs[10]; for(int i = 1;i &lt;= m;i++)&#123; scanf("%d%d%s",&amp;q[i].l,&amp;q[i].r,rs); if(rs[0] == 'o') q[i].ans = 1; else q[i].ans = 0; a[cnt++] = q[i].l-1; //这里需要存l-1，为了使l也包含在内 a[cnt++] = q[i].r; &#125; //以下两行代码离散化用 sort(a,a+cnt); int len = unique(a,a+cnt)-a; for(int i = 0;i &lt;= len;i++) par[i] = i; //初始化爸爸数组 for(int i = 1;i &lt;= m;i++)&#123; //左右边界在离散化数组中的编号： int x = lower_bound(a,a+len,q[i].l-1)-a; int y = lower_bound(a,a+len,q[i].r)-a; //左右边界的祖先分别为ta和tb int ta = Find(x),tb = Find(y); if(ta == tb)&#123; //如果已经在同一个集合内，则判断是否矛盾 if((d[x]^d[y]) != q[i].ans)&#123;//矛盾的条件就是事实和结果不同 printf("%d\n",i-1); return 0; &#125; &#125;else&#123; par[ta] = tb;d[ta] = d[x]^d[y]^q[i].ans; //这里d[ta]的值需要推导一下。 /* 我们将x所在的集合和y所在的集合合并，那么就需要更新d数组 这里d[x]存放的是x到par[x]的距离，所以合并两个集合对于 非根节点来说并无影响，关键是对于两个根d[ta]和d[tb]如何处理 如果我们将ta代表的集合归于tb下，那么就需要更新d[ta],而已知 ans = d[x]^d[y]^d[ta]，即x到y的总路径等于x到ta XOR y到tb XOR ta到tb；对上式变形，得：d[ta] = ans^d[x]^d[y],而后三者是已知， 故可以求出d[ta]。 */ &#125; &#125; printf("%d\n",m); return 0;&#125; 代码示例：code - 21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,m,t = 0;const int N = 2*21000;struct Query&#123; int l,r,ans;&#125;Q[N];int a[N],par[N]; //a用于离散化，par是爸爸数组int Find(int x)&#123; if(par[x] == x) return x; return par[x] = Find(par[x]);&#125;int main()&#123; char str[10]; scanf("%d%d",&amp;n,&amp;m); for(int i = 1;i &lt;= m;i++)&#123; scanf("%d%d%s",&amp;Q[i].l,&amp;Q[i].r,str); Q[i].ans = str[0] == 'o'?1:0; a[++t] = Q[i].l-1; a[++t] = Q[i].r; &#125; sort(a+1,a+1+t); n = unique(a+1,a+1+t) - a- 1; for(int i = 1;i &lt;= 2*n;i++) par[i] = i; //因为每个节点有两个扩展域，所以n需要*2 for(int i = 1;i &lt;= m;i++)&#123; int x = lower_bound(a+1,a+1+n,Q[i].l-1)-a; int y = lower_bound(a+1,a+1+n,Q[i].r)-a; int x_odd = x,x_even = x+n; int y_odd = y,y_even = y+n; if(Q[i].ans == 0)&#123; if(Find(x_odd) == Find(y_even))&#123; //答案与事实不符 printf("%d\n",i-1); return 0; &#125; par[Find(x_odd)] = Find(y_odd); par[Find(x_even)] = Find(y_even); &#125;else&#123; if(Find(x_odd) == Find(y_odd))&#123; //答案与事实不符 printf("%d\n",i-1); return 0; &#125; par[Find(x_odd)] = Find(y_even); //合并x为奇，y为偶 par[Find(x_even)] = Find(y_odd); //合并x为偶和y为奇 &#125; &#125; printf("%d\n",m); return 0;&#125;]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫队算法]]></title>
    <url>%2F2019%2F08%2F16%2Fmodui%2F</url>
    <content type="text"><![CDATA[摘要莫队算法大概有基础莫队、树形莫队、带修（带修改的）莫队等类型，本文仅介绍基础莫队。可以看作莫队算法的入门。莫队算法据说是2010年国家集训队的莫涛发明的一个优化类的算法，由于莫涛经常打比赛做队长，大家都叫他莫队，该算法也被称为莫队算法。它使用指针移动以及分块的思想对朴素算法进行优化。莫队算法是离线算法，可以解决一类离线的区间问题，对于序列上的区间询问问题，如果从 [l,r] 的答案能够 O(1) 扩展到 [l−1,r],[l+1,r],[l,r+1],[l,r−1] 的答案，那么可以在 O(n√n) 的复杂度内求出所有询问的答案。 问题描述SPOJ D-query： 给定一个数组，每次询问一个区间内有多少个不同的元素。解题思路： 朴素思想注意到询问没有强制在线，因此我们可以使用离线的方法。首先我们考虑此类问题，如果我们已经计算出[L , R]的答案以及中间结果，那么我们显然可以在常数时间内计算出[L-1,R] , [L+1 , R] , [L , R-1] , [L , R+1]的答案，即便所给的询问并不一定是这样相差为1的区间，但这也启发了我们要尽可能将区间范围相近的放在一起计算。 为什么将询问区间相近的放在一起计算可以节省时间呢？因为我们通过两个指针（p和q）的左右移动来统计区间信息，显然对于程序的每次运行，这两个指针的移动次数越少越好，要想移动的尽量少，显然区间相近的放在一起最好。 如何排序？按照以上思路，我们要做的就是对区间进行排序，使得范围相近的询问区间尽量放在一起；但是区间有两个关键字（左端点和右端点），如果我们按照左端点严格升序，再按照右端点严格升序，那么很容易就想到一些反例来证明这种方法不是最优的，例如：(1, 100), (2, 2), (3, 99), (4, 4), (5, 102), (6, 7)。显然严格升序是不好的，很容易被出题人针对，如果能适当的减少右端点的移动次数，那么即使左端点的移动次数增加些许也是可以接受的。因此我们就要设计一种均衡的算法，使得左右端点并不一定严格有序，但总体复杂度（指针移动次数）尽量小。利用分块思想，我们可以实现上述目标。我们将长度为n的序列分为长度为$\sqrt{n}$的若干块，将区间按照左端点所在的块的序号进行排序，如果块号相同则按照右端点排序。 当然我们只是概念上分块，并不一定需要严格存储块。之后我们只需要按照排序好是顺序挨个计算即可。 总结起来一共三步：分块、排序、计算。算法复杂度为$O(N \sqrt{N})$ 结束语可以发现本文是应用型的，对于算法的正确性证明以及复杂度证明都没有涉及，这方面的原因之一是由于这是入门文章，写太多证明反而令初学者害怕，如果学有余力自然可以找相关证明；然后就是拓展，掌握了基本思想再去拓展就轻松很多了，拓展方向可以向树形莫队、带修莫队等常见类型拓展，同时注意比较莫队和其他数据结构的异同以及优劣。 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int N = 31000;const int Q = 2e5+10;int n,a[N],m;int ans,sum[1010000];//一个全局答案ans和标记数组sum是必要的 //当然也可以离散化 int len; //块大小，在读入询问前需要先赋值 struct Query&#123; int l,r,block,id; Query()&#123;&#125; Query(int l,int r,int id):l(l),r(r),id(id)&#123; block = l/len; &#125; bool operator &lt;(const Query &amp;B) const&#123; if(block == B.block) return block&amp;1? r &lt; B.r : r &gt; B.r; //小优化，使得r呈波浪形 return block &lt; B.block; &#125;&#125;query[Q];priority_queue&lt;pair&lt;int,int&gt; &gt; q;//增加或减少一个x位置上的数 void Move(int x,int v)&#123; x = a[x]; sum[x] += v; if(v &gt; 0) ans += sum[x] == 1;//判等是为了防止重复计数 else ans -= sum[x] == 0; &#125;int main()&#123; scanf("%d",&amp;n); len = sqrt(n); for(int i = 1;i &lt;= n;i++) scanf("%d",a+i); scanf("%d",&amp;m); for(int i = 1,x,y;i &lt;= m;i++)&#123; scanf("%d%d",&amp;x,&amp;y); query[i] = Query(x,y,i); &#125; sort(query+1,query+1+m); int l = 1,r = 0; for(int i = 1;i &lt;= m;i++)&#123; while(l &lt; query[i].l) Move(l,-1),l++; while(l &gt; query[i].l) Move(l-1,1),l--; while(r &gt; query[i].r) Move(r,-1),r--; while(r &lt; query[i].r) Move(r+1,1),r++; q.push(make_pair(-query[i].id,ans));//大根堆变为小根堆 &#125; while(!q.empty())&#123; int x = q.top().second;q.pop(); printf("%d\n",x); &#125; return 0;&#125; 参考资料[1] 张瑯小强的博客，2019.7.4[2] 例题测试地址SPOJ-DQUERY]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆元模板]]></title>
    <url>%2F2019%2F08%2F16%2Finv%2F</url>
    <content type="text"><![CDATA[摘要本文主要介绍了几种求逆元的方法，但是对于证明并未给出，所以本文是偏于应用型的，其后附录部分的代码模板可以参考使用。其中最容易理解也最容易写的是费马小定理求逆元，然后更加常用的就是求阶乘的逆元了，通过O(N)的预处理，我们可以在常数时间内求出组合数C(n,m)在 mod P下的值。 1.概念1.1 定义： 逆元素是指一个可以取消另一给定元素运算的元素，在数学里，逆元素广义化了加法中的加法逆元和乘法中的倒数。 1.2 数论中定义： 如果满足公式，a*b = 1（mod P），则a是b的逆元，同时b也是a的逆元。 1.3 另一种定义： a*x = 1 (mod P)，其中a与P互质，则称x的最小整数为a关于P的逆元。 2.逆元的应用2.1 除法模运算： 设c为b在对P取模状态下的逆元，在求(a/b)modP时，很可能会因为b过大而超过精度范围，这时候可以将除法转换成乘法来做，（a/b）mod P = (a Invb) mod P = (a mod P) (Invb mod P) mod P。 3.求逆元的常用方法3.1 费马小定理 费马小定理：若p为素数，则有$a^{P-1} \equiv 1(mod P)$推论：$a * a^{P-2} \equiv 1(mod P)$故$a^{P-2}$就是a关于P的一个逆元 3.1.1 代码实例： 见附录部分code-1。 3.1.2 复杂度分析： 求单个逆元的时间复杂度是lg(Mod)。 3.2 拓展欧几里得算法3.3 逆元线性筛 递推式：inv[i] = (Mod-Mod / i) inv[Mod% i]%Mod如果要保证结果为正： inv[i] = (Mod-Mod / i) inv[Mod% i]%Mod证明： 3.3.1 代码示例： 见附录部分code-2。3.3.2 复杂度分析： O(N)。 3.4求阶乘的逆元 递推式：inv[i] = inv[i+1] * (i + 1) % Mod证明： 3.4.1代码示例： 见附录部分code-3.。 附录code-1：费马小定理求逆元12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int N = 100010;const int P = 1e5+7;typedef long long ll;ll Finv[N];ll qpow(ll x,ll p,ll m)&#123;//快速幂算法 ll res = 1; while(p)&#123; if(p&amp;1) res =res*x%m; x = x*x%m; p &gt;&gt;= 1; &#125; return res;&#125;void Init()&#123;//用来求逆元 Finv[1] = 1; for(int i = 2;i &lt; N;i++) Finv[i] = qpow(i,P-2,P);&#125;int main()&#123; Init(); for(int i = 1;i &lt; N;i++) cout &lt;&lt; Finv[i] &lt;&lt; &quot; &quot;; return 0;&#125; code-2：逆元线性筛123456789101112131415161718#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int N = 100010;const int P = 1e5+7;ll inv[N];void Inv()&#123; inv[0] = inv[1] = 1; for(ll i = 2;i &lt; N;i++)&#123; inv[i] = (P - P/i)*inv[P%i]%P; &#125;&#125;int main()&#123; Inv(); return 0;&#125; code-3求阶乘的逆元12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int N = 100010;const int P = 1e9+7;typedef long long ll;ll Finv[N],F[N];//F存阶乘，Finv存对应逆元 ll Qpow(ll x,ll p,ll m)&#123; ll res = 1; while(p)&#123; if(p&amp;1) res =res*x%m; x = x*x%m; p &gt;&gt;= 1; &#125; return res;&#125;void Init()&#123; F[0] = 1; for(ll i = 1;i &lt; N;i++) F[i] = F[i-1]*i%P; Finv[N-1] = Qpow(F[N-1],P-2,P); for(int i = N-1;i &gt; 0;i--) Finv[i-1] = Finv[i]*i%P;&#125;int main()&#123; Init(); for(int i = 1;i &lt; N;i++) cout &lt;&lt; Finv[i]*F[i]%P &lt;&lt; "\t"; return 0;&#125;]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数据结构与算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算]]></title>
    <url>%2F2019%2F08%2F16%2Fbit-cal%2F</url>
    <content type="text"><![CDATA[需要掌握的知识： 原码、反码、补码 按位或 按位与 异或 非 移位运算 lowbit的实现 运算符优先级原码、反码、补码原码： 是最简单的机器数表示法。用最高位表示符号位，‘1’表示负号，‘0’表示正号。其他位存放该数的二进制的绝对值。 1010 ： 最高位为‘1’,表示这是一个负数，其他三位为‘010’，即（0 2^2）+（1 2^1）+（0* 2^0）=2（‘^’表示幂运算符）所以1010表示十进制数（-2）。 面临问题： 原码下，正数相加所得结果正确，但是正数和负数相加出错。 反码： 正数的反码还是等于原码，负数的反码就是他的原码除符号位外，按位取反。 3是正数，反码与原码相同，则可以表示为0011-3的原码是1011，符号位保持不变，低三位（011）按位取反得（100）所以-3的反码为1100 面临问题： 正数相加所得结果正确，正负相加所得结果正确，负负相加结果出错。 补码： 正数的补码等于他的原码，负数的补码等于反码+1。 上述给出的是补码的求法，补码的真正定义是什么？为什么要这样定义？ 采用补码的表示方式的好处，一是可以将减法转化为加法运算，简化运算复杂度；二是可以让符号位作为数值直接参与运算，所得结果仍然是正确的，即符号位无需单独处理。 按位或、与、异或、非在c语言中，是将一个十进制整数（一般情况下）转化为二进制位，然后再对二进制数的每一位对应进行或、与、异或、非操作。 位移运算位移运算分为左移和算数右移，其中左移是指在二进制表示下把所有位数字同时向左移动一位，高位越界后舍弃，低位以0补充。其中越界是指，int型变量一般仅有32位，如果左移后超过了32位则舍弃超过的部分。算数右移是指在二进制补码表示下把数字同时向右移动，高位以符号位填充，低位越界后舍弃。算数右移等于除以2向下取整，（-5）&gt;&gt;1 = -3 , 3 &gt;&gt; 1 = 2。可以发现算数右移并不等同于c语言中的整数/2，值得一提的是c语言中的整数/2是“除以2向0取整”。逻辑右移是在补码表示下把所有数字同时右移，高位以0补充，低位越界后舍弃，但是C++没有规定实现方式，一般编译器都会实现算数右移。 lowbit的实现定义： lowbit( n )是取出非负整数 n 在二进制表示下最低位的 1 以及它后面的0所构成的十进制数值。实现：若 n &gt; 0，且第 k 位是1，第 0 ~ k-1 位都是0。先将n按位取反，那么第 k 位变成了0，第 0 ~k 位变成了1。再令n = n+1，那么显然通过一系列进位，第 0~k-1 位都变成了0，而第 k 位又变成了1。我们注意到，最初的 n ，与最终的n只有第 0~k 位相同，更高的位都恰好相反（举个例子推导试试），于是将它们按位与就得到了 0~k 位的数值，这个值就是我们所求的答案。 运算符优先级不确定就加括号！！位移运算最好加括号！百度百科，运算符优先级表]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维st表]]></title>
    <url>%2F2019%2F08%2F16%2Fst2%2F</url>
    <content type="text"><![CDATA[摘要我们知道一维的st表在经过预处理后可以在O(1)时间内查询任意区间的极值，虽然其是离线算法，但胜在代码短小易写。而在二维RMQ（区间最值查询）问题中，我们依然可以采用st算法解决问题，只不过我们需要从一维拓展到二维，当然适用范围依然是离线。二维st表仍然是用倍增思想，如果理解了一维的st表，那么对于二维的也不难理解。 问题描述给定一个n* n的矩阵以及一个整数b和k，共有k次询问，每次询问给出边长为b的子矩阵的左上角的行和列(r,c)，请回答该子矩阵内的最大值和最小值的差是多少。 算法思路变量定义：st[r][c][k] 存放以(r , c)为左上角的边长为$2^k$个元素的矩阵的最大值。a[n][n] 用来存放矩阵中的元素。 查询操作：假设我们的st表已经更新完毕，此时st[r][c][k] 中存放的是以(r , c)为左上角的边长为$2^k$ 的矩阵内的最大值，那么对于一个查询(a , b , c) 即查询以(a , b)为左上角，边长为 c 的矩阵内的最大值该如何处理呢？显然和一维一样，由于我们的st表中存放的区间长度是2的次方项，因此如果边长并不恰好是2的次方项，那么就无法通过一次访问st表求得，需要通过几个重叠区间得出结果。在二维RMQ中，就体现为将一个大矩阵查询分为4个小矩阵查询。下面我们具体来讲一下如何划分查询区间。假设我们要查询的是以（a，b）为左上角，边长为 c 的矩阵内的最大值，那么假设 $k = log_2^c$ 向下取整，那么显然st[a][b][k]是一个如下图(a)中显示的一个小矩阵。 那么显而易见，st[a][b+c-(1&lt;&lt;k)+1][k]正如（b）中的蓝色矩形一样覆盖了以右上角为顶点的矩阵。同理，我们共需要四个矩形来覆盖整个大矩形，如（c）所示。因此对于任意边长的正方形，我们都可以计算出其覆盖面积的最大值。因为求极值操作是允许区间重叠的( [1 , 10] 的最大值可以由[1 , 6] 的最大值和[2 , 10]的最大值得出 )，因此上述划分方法虽有区间重叠，但对最终答案没有影响（求和则不行）。总结起来，若设最终要求的答案为ans，则：12345令t1 = st[a][b][c];令t2 = st[a][b+c-(1&lt;&lt;k)+1][c];令t3 = st[a+c-(1&lt;&lt;k)+1][b][c];令t4 = st[a+c-(1&lt;&lt;k)+1][b+c-(1&lt;&lt;k)+1][c];ans = max&#123;t1 , t2 , t3 , t4&#125;； 因此我们得证了，利用上述定义的st表，确实可以在常数时间内求出目标矩阵的最大值。 更新st表（预处理）我们在一开始就提到过，st表是离线算法， 即不支持修改操作，因此以此预处理之后便只能进行查询。预处理时间复杂度为$O(N^2log_2N)$。预处理用到了动态规划的思想。更新也是同样的道理，更新一个大矩形，需要用到4个小矩形。状态转移方程如下： st[i][j][k] = Max( st[i][j][k-1] , st[i+(1&lt;&lt;k-1)][j][k-1] , st[i][j+(1&lt;&lt;k-1)][k-1] , st[i+(1&lt;&lt;k-1)][j+(1&lt;&lt;k-1)][k-1]); 为什么这个式子成立呢？如果从式子上看，$2^{k-1} + 2^{k-1} = 2^k$，因此俩个小区间可以更新一个大区间，拓展到二维上呢，就是4个小矩阵更新一个大矩阵。如果用图来描述，就如（d）所示，四个小矩形构成一个大矩形，而大矩形的边长是小矩形的2倍。于是我们就可以通过四个小矩阵的值来更新大矩阵的值。 例题 HAOI2007理想的正方形解题思路：本题就是一个二维RMQ问题的裸题，和上述模型不同的是，其是一个长a宽b的矩形，而非正方形。不管是矩形还是正方形，我们的更新和查询都是划分为4个子矩阵来更新或查询，因此只需对代码稍作改变即可，基本没太大变化，预处理都是$O(N^2logN)$，查询也都是O(1)。 代码示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;const int N = 1010;int a[N][N],n,m,len,Log[N];int st[3][N][N][15];//0最小，1最大值 int max(int a,int b,int c,int d)&#123; int mx = a;if(mx &lt; b) mx = b;if(mx &lt; c) mx = c;if(mx &lt; d) mx = d; return mx;&#125;int min(int a,int b,int c,int d)&#123; int mi = a;if(mi &gt; b) mi = b;if(mi &gt; c) mi = c;if(mi &gt; d) mi = d; return mi;&#125;void init()&#123; for(int i = 2;i &lt; N;i++) Log[i] = Log[i/2]+1; for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) st[0][i][j][0] = st[1][i][j][0] = a[i][j]; for(int k = 1;k &lt;= 12;k++)&#123; for(int i = 1;i + (1&lt;&lt;k)-1 &lt;= n;i++)&#123; for(int j = 1;j + (1&lt;&lt;k)-1 &lt;= m;j++)&#123; int t1 = st[0][i][j][k-1]; int t2 = st[0][i+(1&lt;&lt;(k-1))][j][k-1]; int t3 = st[0][i][j+(1&lt;&lt;(k-1))][k-1]; int t4 = st[0][i+(1&lt;&lt;k-1)][j+(1&lt;&lt;k-1)][k-1]; st[0][i][j][k] = min(t1,t2,t3,t4); t1 = st[1][i][j][k-1]; t2 = st[1][i+(1&lt;&lt;(k-1))][j][k-1]; t3 = st[1][i][j+(1&lt;&lt;(k-1))][k-1]; t4 = st[1][i+(1&lt;&lt;k-1)][j+(1&lt;&lt;k-1)][k-1]; st[1][i][j][k] = max(t1,t2,t3,t4); &#125; &#125; &#125;&#125;int ask(int r,int c,int len)&#123; int k = Log[len]; int t1 = st[0][r][c][k]; int t2 = st[0][r+len-(1&lt;&lt;k)][c][k]; int t3 = st[0][r][c+len-(1&lt;&lt;k)][k]; int t4 = st[0][r+len-(1&lt;&lt;k)][c+len-(1&lt;&lt;k)][k]; int mi = min(t1,t2,t3,t4); t1 = st[1][r][c][k]; t2 = st[1][r+len-(1&lt;&lt;k)][c][k]; t3 = st[1][r][c+len-(1&lt;&lt;k)][k]; t4 = st[1][r+len-(1&lt;&lt;k)][c+len-(1&lt;&lt;k)][k]; int mx = max(t1,t2,t3,t4); //printf("%d %d\n",mx,mi); return mx - mi;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;len); for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) scanf("%d",&amp;a[i][j]); init(); int ans = 0x3f3f3f3f; for(int i = 1;i &lt;= n-len+1;i++)&#123; for(int j = 1;j &lt;= m-len+1;j++)&#123; int tmp = ask(i,j,len); ans = ans &lt; tmp?ans:tmp; &#125; &#125; printf("%d\n",ans); return 0;&#125; 结束语大家可以发现我们的二维st表建立在正方形矩阵查询的基础上的，因此st表仅三个维度，即st[r][c][k] 代表以(r , c) 为左上角的边长为$2^k$的矩阵的极值；但如果所给矩阵以及所求矩阵并不是正方形而是普通矩形，那就要增加一个维度，即st[r][c][k1][k2] 表示以（r，c）为左上角，长为$2^{k1}$高为$2^{k2}$的矩阵的极值，其更新方法与本文所介绍的类似，都是通过4个子矩阵来更新，查询也是通过4个子矩阵来查询最终答案。]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求a的大幂对P取模]]></title>
    <url>%2F2019%2F08%2F16%2Fbigpow%2F</url>
    <content type="text"><![CDATA[有如下问题：求2^n mod (1e9+7)，其中1&lt; n &lt; 10^100000。 首先明确一下此类问题的几种算法，首先朴素算法，即暴力循环求解，是O(N)复杂度，适用范围应该是n小于1000000；然后是快速幂算法，效率是O(log N)，适用于n小于2^100000级别的；然后就是上面的例题了，由于范围是10^100000，即使是快速幂也不可能在期望时间内解决，这时候需要另辟蹊径。 费马小定理： 对于质数P，任意的整数a，若满足GCD(a,P) = 1，则有：$a^p \equiv a (mod \,p)$ 主要思路：回到上述例题，可知 P 即1e9+7，这是个素数。而 a 是 2 ，很明显 2 也是素数，所以GCD(a , P ) = 1，满足费马小定理的条件。那么我们想提高2^n计算的效率，就绕不开减小n的大小，我们接下来就利用费马小定理来减少幂n的大小。 首先费马小定理的一个小变形：$a^{(P-1)} \equiv 1 (mod \,P)$ 接下来对2^n进行变形：2^n = 2^{ x * (P-1)} * 2^k ，而根据费马小定理，显然 $2^{x * (P-1)} mod\,P = 1 mod \,P$ ，于是 $2^n mod\,P= 2^k$ ，其中k = n%(P-1)。此时k小于P，即小于1e9+7，可以使用快速幂解决。 注意： 值得注意的是，10^100000 最大是1后面有100000个0，需要用字符串存，在转化为整数时利用模运算规则，边转化边取模。 代码示例： 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;const int M = 1e9+7;typedef long long ll;ll qpow(ll a,ll b)&#123; ll res = 1; while(b)&#123; if(b&amp;1) res = res*a%M; a = a*a%M; b &gt;&gt;= 1; &#125; return res; &#125;ll solve(string x)&#123; ll M1 = M-1; ll k = x[0]-'0'; for(int i = 1;x[i];i++) k = (k*10+x[i]-'0')%M1; ll ans = qpow(2,k); return ans%M;&#125;int main()&#123; string n; while(cin &gt;&gt; n &amp;&amp; n != "0")&#123; printf("%lld\n",solve(n)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强连通分量]]></title>
    <url>%2F2019%2F08%2F16%2Ftarjan%2F</url>
    <content type="text"><![CDATA[摘要强连通分量常用于缩点，是图论中一个重要的知识点。本文首先介绍了强连通分量的相关定义以及其应用范围，然后将着重介绍两种求强连通分量的算法：Kosaraju算法以及Tarjan算法，它们的时间复杂度都是O(n+m)（n：顶点数，m：边数）。其中Kosaraju算法思想简单，操作方便，易于理解与代码实现，但是性能以及拓展性上比Tarjan略逊一筹；本文将会逐一介绍这两种算法的思想以及实现步骤，最后会以例题的形式给出代码模板。 相关定义在有向图G中，如果两个顶点u，v间存在一条 u 到 v 的路径且也存在一条 v 到 u 的路径，则称这两个顶点u，v 是强连通的（strongly connected）。如果有向图G的任意两个顶点都强连通，则称G是一个强连通图。有向非强连通图的极大强连通子图，称为强连通分量（strongly connected components）。 极大强连通子图： G是一个极大强连通子图，当且仅当G是一个强连通子图且不存在另一个强连通子图G’，使得 G 是 G’ 的真子集。 强连通分量的应用若将有向图中的强连通分量都缩为一个点，则原图会形成一个DAG（有向无环图），如图1所示:图1：虚线部分构成一个强连通分量（图片来自ccf的博客） 强连通分量的常见用途有两个： 有向图的缩点。 解决2-SAT问题。 Kosaraju 算法Kosaraju算法的时间复杂度是O(n+m)，基于两次DFS的有向图强连通子图算法。该算法共分为三步： 第一步，对原有向图G进行DFS，记录节点访问完的顺序d[i] , d[i] 表示第 i 个访问完的节点是d[i]；第二步，选择具有最晚访问完的顶点，对反向图GT 进行DFS，删除能够遍历到的顶点，这些顶点构成的一个强连通分量。第三步，如果还有顶点没有删除，继续第二部，否则算法结束。 代码实现：见附录部分 code-1：Kosaraju算法模板（POJ2186） Tarjan算法Tarjan算法是 Robert Tarjan 发明的一个算法，其时间复杂度也是O(n+m)，但我们之所以在掌握了Kosaraju算法后仍要学习Tarjan算法的主要原因有以下三点： Tarjan算法效率比Kosaraju算法高大概30%，所以Kosaraju可能会被卡常。 Kosaraju算法利用递归实现，可能会爆栈；而Tarjan则不会（因为根本没递归）。 Tarjan算法还可以通过拓展解决求割点、割桥以及2-SAT等问题。 实际上如果出题人有这个想法，那么就不是可能会超时，是一定会超时；不是可能会爆栈，是一定会爆栈，所以还是要掌握该算法的。 基本概念Tarjan算法是基于对图深度优先搜索（DFS）的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个栈，回溯时可以判断栈顶到栈中的节点是否构成一个强连通分量。我们定义DFS过程中遇到的四种边： 树枝边：DFS时经过的边，即DFS搜索树上的边。 前向边：与DFS方向一致，从某个节点指向其某个子孙的边。 后向边：与DFS方向相反，从某个节点指向其某个祖先的边。 横向边：从某个节点指向搜索树中另一子树中的某节点的边。 定义DFN(u) 为节点 u 的搜索次序编号（时间戳），Low(u) 为u 或者u 的子树能够回溯到的最早的栈中节点的DFN值。 根据定义我们可以得出： 如果(u , v)为树枝边，u 为 v 的父节点，则 Low(u) = min{ Low(u) , Low(v) }。 如果(u , v)为后向边或指向栈中节点的横叉边，则Low(u) = min{ Low(u) , DFN(v) }。 当节点u的搜索过程结束后，若DFN(u) = Low(u)，则以u为根的搜索子树上所有还在栈中的节点（即u和栈中在u之后的所有节点）是一个强连通分量，可退栈。通俗的说，若u为强连通分量的根，那么它的子孙中的最高最先应该就是它本身。 算法的主要过程数组的初始化： 当首次搜索到点 u 时，DFN(u)为节点u的搜索次序编号（时间戳）。堆栈： 将u压入堆栈。更新Low(u)： 如果（u，v）为树枝边（v不在栈中），u为v的父节点，则Low(u) = min{Low(u) , Low(v)}。 如果（u，v）为后向边或者指向栈中节点的横叉边（v在栈中），则Low(u) = min{ Low(u) DFN(v)}。 如果u的子树已经全部遍历后Low(u) = DFS(u)，则将u和栈中在u之后的所有节点 弹出栈。这些出栈的元素组成一个强连通分量。 继续搜索（或许会更换搜索的起点，因为整个有向图可能分为多个不连通的部分），直到所有点被遍历。 代码实现见附录部分code-2：POJ2182（Tarjan算法） 参考资料 董永建，信息学竞赛一本通提高版，福州：福建教育出版社，2018.6，155-178 秋叶拓哉，挑战程序设计竞赛第2版，北京：人民邮电出版社，2013.6，320-324 附录code-1：Kosaraju算法模板（POJ2182）求所有“红牛”总数。（红牛即所有牛的偶像）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/******************************************************************* 最后修改：2019/8/15 Valenshi 使用说明： 用数组表示邻接表,分别建立了正图和反图; 只适用于节点从1~n的题型,切记若干节点编号是0~n-1会死循环! 主函数：scc(),用于求所有强连通分量,O(N+M),答案存放在kos数组。 *******************************************************************/#include&lt;cstdio&gt;#include&lt;cstring&gt;const int N = 1e4+10;const int M = 5e4+10;int head[N],ver[M],nex[M],tot; //邻接表存放有向图int rhead[N],rver[M],rnex[M],rtot;//存放反图int vis[N],kos[N];//访问标记;节点所属联通分量标号int ts[N],tc; //时间戳, dfs访问时的顺序;tc为当前"时间"void addEdge(int x,int y)&#123; /* 建立一条从x-&gt;y的有向边 , 同时在反图添加一条从y-&gt;x的有向边*/ ver[++tot] = y,nex[tot] = head[x], head[x] = tot; rver[++rtot] = x,rnex[rtot] = rhead[y],rhead[y] = rtot;&#125;void dfs(int x)&#123; /*给节点x以及它的子孙打上时间戳*/ vis[x] = true; for(int i = head[x] ;i ;i = nex[i])&#123; int y = ver[i]; if(!vis[y]) dfs(y); &#125; ts[++tc] = x; //第tc个回溯的是点x&#125;void rdfs(int x,int k)&#123; /* 找出属于第k个强连通分量的所有点 */ vis[x] = true;kos[x] = k; for(int i = rhead[x];i ;i = rnex[i])&#123; int y = rver[i]; if(!vis[y]) rdfs(y,k); &#125;&#125;int n,m; //点的个数,编号为1~n;int scc()&#123; /* 将原图分为若干强连通分量,并返回个数 */ memset(vis,0,sizeof vis);tc = 0; for(int i = 1;i &lt;= n;i++) if(!vis[i]) dfs(i); memset(vis,0,sizeof vis); int k = 0; for(int i = tc;i &gt; 0;i--) if(!vis[ts[i]]) rdfs(ts[i],++k); return k;&#125;/*********************************** 以下为POJ2186解题代码 ***********************************/int A[N],B[N];void solve()&#123; int k = scc(); //备选答案总数 int y = 0,sum = 0; for(int i = 1;i &lt;= n;i++)&#123; if(kos[i] == k)&#123; y = i;sum++; &#125; &#125; //检查是否从所有点可达 memset(vis,0,sizeof vis); rdfs(y,0); //代码重用 for(int i = 1;i &lt;= n;i++)&#123; if(!vis[i])&#123; sum = 0;break; &#125; &#125; printf("%d\n",sum);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1,x,y;i &lt;= m;i++)&#123; scanf("%d%d",&amp;x,&amp;y); addEdge(x,y); &#125; solve(); return 0;&#125; code-2：POJ2182（Tarjan算法模板）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/*************************************************************** 最后更新：2019/8/16 ValenShi 使用说明： 1.记得初始化辅助数组dfn[],co[],head[], 以及"数组指针" ,top,tot,num,col ; 2.每个辅助数组具体作用见注释; 3.节点范围是1~n,若是0~n-1会死循环,可更改head[]初始值解决。 ***************************************************************/ #include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;const int N = 1e4+10;const int M = 1e5+10;/* 邻接表存有向图 */int head[N],ver[M],nex[M],tot;inline void addEdge(int x,int y)&#123; ver[++tot] = y,nex[tot] = head[x],head[x] = tot;&#125;/***************************************** Tarjan算法及其辅助数组： Stack[]为栈,top为栈顶指针; dfn[]为节点的时间戳,num为对应的"时间"; co[]为节点所在的强连通分量的编号,col对应编号; ******************************************/ int n,m;int Stack[N],top;int dfn[N],low[N],num,co[N],col;void Tarjan(int u)&#123; dfn[u] = low[u] = ++num; Stack[++top] = u; for(int i = head[u];i ;i = nex[i])&#123; int v = ver[i]; if(!dfn[v])&#123; Tarjan(v); low[u] = min(low[u],low[v]); &#125;else if(!co[v]) low[u] = min(low[u],dfn[v]); &#125; if(low[u] == dfn[u])&#123; co[u] = ++col; while(Stack[top] != u)&#123; co[Stack[top]] = col; top--; &#125; top--; &#125;&#125;int chudu[N];/*用来记录每个强连通分量的出度 */ void solve()&#123; num = col = top = 0;// memset(dfn,0,sizeof dfn);// memset(co,0,sizeof co);// memset(chudu,0,sizeof chudu); for(int i = 1;i &lt;= n;i++) if(!dfn[i]) Tarjan(i); int ans = 0,tcnt = 0; /*ans存放答案,tcnt表示出度为0的强连通分量的个数*/ for(int i = 1;i &lt;= n;i++)&#123; for(int j = head[i];j ;j = nex[j])&#123; int y = ver[j]; if(co[i] != co[y]) chudu[co[i]]++; /*i所在的强连通分量的出度+1 */ &#125; &#125; int tcol = 1;/*tcol为出度为0的强连通分量的编号*/ for(int i = 1;i &lt;= col;i++) if(!chudu[i]) tcnt++,tcol = i; for(int i = 1;i &lt;= n;i++) if(co[i] == tcol) ans++; if(tcnt &gt; 1) puts("0"); else printf("%d\n",ans);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1,u,v;i &lt;= m;i++)&#123; scanf("%d%d",&amp;u,&amp;v); addEdge(u,v); &#125; solve(); return 0;&#125;]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[差分约束系统]]></title>
    <url>%2F2019%2F08%2F12%2Fchafen%2F</url>
    <content type="text"><![CDATA[算法简介差分约束系统是一种特殊的N元一次不等式组，它包含N个变量$X_1 - X_N$以及M个约束条件，每个约束条件都是由两个变量作差构成的，形如$X_i - X_j &lt;= C_k$，其中$C_k$是常数（可以为负），1&lt;= i , j &lt;= N, 1 &lt;= k &lt;= M。我们要解决的问题是：求一组解，$X_1 = a_1, X_2 = a_2 ,… , X_N = a_N$使得所有约束条件都得到满足。 差分约束系统的每个约束条件$X_i - X_j &lt;= C_k$ 可以变形为$X_i &lt;= X_j + C_k$，这与单源最短路中的三角不等式 dis[ y ] &lt;= dis[ x ] + z非常类似，因此可以把每个变量X_i 看作有向图中的一个节点 i ，对于每个约束条件$X_i - X_j &lt;= C_k$ ， 从节点j 向节点 i 连一条长度为 $C_k$ 的有向边。 注意到如果集合A是一组解，那么A+d也是一组解（作差后d被消掉）。 设dis[0] = 0，以0为起点求单源最短路，若图中存在负环则差分约束系统无解。否则，$X_i = dis[i]$ 就是差分约束系统的一组解。 在某些题目中，$X_i - X_j &gt;= C_k$，仍可以看作是从 j 到 i 连成长度为 $C_k$的有向边，只是改为计算单源最长路径，若图中存在正环则无解。当然也可以不等式两边同时取负，使得变换成标准形式。 结论差分约束是基于三角不等式的一个推广。关键在于根据题意构造出恰当的状态，建立状态间的不等关系，并证明满足不等式的一个解与原问题一一对应，然后便可以利用SPFA算法求解。其优点是不等式关系明显，易于理解，缺点是适用性窄。 例题模板Zju1420 出纳员问题题意简述：有一家24小时营业的超市，需要雇佣一批出纳员。一天中每个小时需要出纳员的最少数量为R0,R1,R2,…,R23。有N个人申请这项工作，每个申请者，从一个特定时刻Ti,开始连续工作恰好8个小时。(Ti为整数，且0&lt;=Ti&lt;=23 )。你的任务是计算出需要雇佣出纳员的最少数目，满足在每一时刻k，至少有Ri名出纳员在工作。 解题思路：真的有点难想啊，首先我们要假设num[i] 为 i 时刻能够开始工作的人数，x[i] 为实际雇佣人数，那么x[i] &lt;= num[i] 。而R[i]是i 时刻至少需要的人数，这由题目给出。我们令s[i] = x[i] + x[i-1] + … + x[1] ，显然我们就会得到关于 s 和 num 的一组不等式，如果想要答案正确，需要找到所有隐含的条件： s[i] - s[i-1] &gt;= 0 //(0 &lt;= i &lt;= 23)s[i-1] - s[i] &gt;= -num[i] // (0&lt;=i&lt;=23)s[i] - s[i-8] &gt;= r[i] //(8&lt;=i&lt;=23)s[i] - s[i+16] &gt;= r[i] - s[23] // (0 &lt;= i &lt;= 7) 注意到，s[23]本是未知数，但是我们将它作为常数处理，具体做法是我们遍历s[23]的所有可能的值，并依次进行一次SPFA，尝试找寻雇佣最小人数 且使得不等式组成立的可能。 注意如果 i 从0开始，那么邻接表存有向图，head节点就不能初始化为0，防止死循环超时。 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int t,n,R[30],num[30];const int N = 1e5+10;const int INF = 0x3f3f3f3f;int head[N],ver[N],edge[N],nex[N],tot;int dis[100],vis[100],ts[100];void addEdge(int x,int y,int z)&#123; ver[++tot] = y,edge[tot] = z; nex[tot] = head[x],head[x] = tot;&#125;queue&lt;int&gt; q;bool SPFA(int s)&#123; /* 返回此时是否有解 */ while(!q.empty()) q.pop(); memset(vis,false,sizeof vis); memset(ts,0,sizeof ts); for(int i = 0;i &lt; 100;i++) dis[i] = -INF; q.push(0);dis[0] = 0; vis[0] = true;ts[0] = 1; while(!q.empty())&#123; int x = q.front(); q.pop(); vis[x] = false;ts[x]++; if(ts[x] &gt; 24) return false; for(int i = head[x];i ;i = nex[i])&#123; int y = ver[i], z = edge[i]; if(dis[y] &lt; dis[x] + z)&#123; dis[y] = dis[x] + z; if(!vis[y]) q.push(y),vis[y] = true; &#125; //printf("%d %d %d\n",x,y,dis[x]); &#125; &#125; return dis[24] == s;&#125;bool solve(int z)&#123; /* 返回当s[24] = z时是否有解*/ memset(head,0,sizeof head);tot = 1; addEdge(0,24,z); for(int i = 1;i &lt;= 24;i++) addEdge(i-1,i,0), addEdge(i,i-1,-num[i]); for(int i = 9;i &lt;= 24;i++) addEdge(i-8,i,R[i]); for(int i = 1;i &lt;= 8;i++) addEdge(i+16,i,R[i]-z); return SPFA(z);&#125;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; memset(num,0,sizeof num); for(int i = 1;i &lt;= 24;i++) scanf("%d",R+i); scanf("%d",&amp;n); bool flag = true; for(int i = 1,x;i &lt;= n;i++) scanf("%d",&amp;x),num[x+1]++; for(int i = 0;i &lt;= n;i++) if(solve(i))&#123; printf("%d\n",i),flag = false; break; &#125; if(flag) puts("No Solution"); &#125; return 0;&#125; 参考资料 董永建，信息学竞赛一本通提高版，福州：福建教育出版社，2018.6，155-161]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pollard_rho算法]]></title>
    <url>%2F2019%2F08%2F11%2Fpollard-rho%2F</url>
    <content type="text"><![CDATA[Pollard’s rho算法摘要Pollar’s Rho算法是一种用于分解质因数的算法，对于一个被分解的数N，假设N的最小质因数为p（$p \neq N$），那么Pollar’s Rho算法能够在$O(\sqrt N * α(N))$的期望时间复杂度内将N分解为两个不是1的数的乘积，其中α(N)是求解两个数的gcd时间复杂度，并且该算法对于空间要求很低。 首先要明确的是，Pollar’s Rho 算法是随机算法，其基于Miller-Rabin算法，一般在求大整数的唯一分解时会用到，因为 试除法 $^{[1]}$的$O(\sqrt N)$复杂度太高。 本文将首先从算法的适用模型讲起，详细介绍算法流程，最后会给出一道例题以及详细注释了的代码模板，当然还有模板的使用说明。 [1]试除法：一种将整数唯一分解成质因数乘积的方法，时间复杂度为$O(\sqrt N)$ 算法简介该算法最早于1975年由John M. Pollard提出，而Richard Brent于1980年提出了改进版本。虽然不是目前最快的算法，但它要比试除法快上多个量级。实现它的思想同样可以用于其他地方。 问题模型： 给定一个整数n，试着将n分解为若干素数相乘的形式。n小于$2^{60}$。 分析： 如果用试除法，显然时间复杂度过高，现在我们希望得到一个快速的方法；类比大素数判断的Miller-Rabin算法，Miller-Rabin算法依靠着费马小定理以及二次检测定理实现了快速判断一个大整数是否为素数的算法，实际上对于大整数的唯一分解也同样有着类似的巧妙的算法，就是本文介绍的Pollard’s rho算法。 算法思想基本思路：对于给定的一个整数n，显然如果n为素数（Miller-Rabin算法判断），那么算法结束，返回唯一素因子n。 否则，pollard’s rho算法会试着找到当然数n的一个因子a（a并不一定是素数），然后递归 Pollard_rho( a ) 和 Pollard_rho( n/a ) ，即将n分为了两个部分，将原问题变成了规模更小的两个子问题。 如何求因子a？一般情况下可能会本能的想到枚举，但这样过于耗时。寻找因子是该算法中最重要的一步，该算法中采用随机化算法来查找因子a。假设此时n仅有2个因子 p 和 q，那么如果我们用随机数来找n的因子，成功率为1/n。接下来我们思路是如何提升成功率。 寻找一个因子a，等价于寻找是否存在k个数，使得其中有$x_i - x_j = a$，由于生日悖论 我们可以得知当k = $\sqrt N$时，该概率是50%，所以我们将可能性从$\frac{1}{n}$提升到了$\sqrt{\frac{1}{n}}$。 但不幸的是对于10位的整数，k = 1e5时，仍要做$k^2 = 10^{10}$次比较，幸运的是，还有更好的方法。 我们仍然选取k个数：$x_1,x_2,…,x_k$，但我们不再询问是否存在$x_i - x_j$可以整除n，转而询问是否存在 $gcd( x_i - x_j , n) &gt; 1$ 的情况。换句话说，我们问$x_i - x_j$和n是否存在一个平凡的最大公约数。 如果我们询问有多少个整数能整除n，那么答案显然只有两个：p和q。但是如果我们问有多少个数使得gcd($x_i-x_j$) &gt; 1，答案便很多了，如：p, 2p, 3p, 4p, … , (q-1)p , q , 2q ,…,(p-1)q。准确的说，有p+q-2个。 所以，一个简单的策略如下： 在区间[2 , n-2]中随机选 k 个数，$x_1,x_2,x_3,…,x_k$。 判断是否存在gcd($x_i - x_y$,n) &gt; 1，若存在，gcd($x_i - x_y$,n) 是n的一个因子（p或q）。 但是这样还有一个问题，就是我们大约要选取$n^{1/4}$个数，数量还是太大，以至于不能存放在内存中。 Pollard’s rho算法的解决策略：为了解决无法储存太多数的问题，Pollard’s rho Algorithm只将两个数存放在内存中。具体思路是：我们并不随机生成k个数并两两比较，而是一个一个地生成并检查连续的两个数。反复执行这个步骤并希望能够得到我们想要的数。 我们使用一个函数来生成伪随机数。换句话说，我们不断使用一个函数f来生成（可以这样形容）随机数。当然并不是所有的函数都能这样做，但是有一个函数可以：&emsp;&emsp;&emsp;&emsp;$f(x) = (x^2 + a) mod N$（其中的 a 可以用随机数生成，当然这不是讨论的重点。）我们从$x_1 = 2$开始，让$x_2 = f(x_1) , x_3 = f(x_2),…….$，通项为：$x_{n+1} = f(x_n)$于是顺着这个策略，依据上述分析，不断判断gcd($x_n - x_{n-1}$, n)是否大于1即可。 存在的问题：大多情况下，这种算法是可以正常运行的，但是对于某些数据，会出现无线的死循环，原因在于函数f存在自环。于是问题变成了“如何判断环的出现”。一种方法是记录所有出现过的数，当然这会耗费大量内存，故舍弃；另一种方法是Floyd发明的算法，这里可以举一个有趣的例子说明“假设A和B在一个很长的圆形轨道上走，那么我们如何判断B是否走完一圈呢？我们可以让B的速度是A的二倍，他们同时出发，当B第一次追上A，就知道B至少已经走了一圈”，同样的道理运用到该算法中，框架如下：123456789a = 2;b = 2;while(b != a)&#123; a = f(a); //一倍速 b = f(f(b));//二倍速 p = GCD(|b-a| , n); if(p &gt; 1) return &quot;Found factor: p&quot;; &#125;return &quot;Failed&quot;; 算法流程简单梳理一下，给出主要框架而不涉及理论证明。假设 n 为待分解的数，我们将分解出来的所有因子存放在factors[110]数组中，当然存放的是无序的素因子。findFac( long long n) 函数：负责将 n 分解成素因子相乘的形式，并将结果存放在factors数组中。 如果n本身就是素数，那么将n存放在factor便可结束并返回。 如果n不是素数，那么通过 pollard_rho()函数 找到n的一个因子p(不一定是素因子)，递归findFac(p)和findFac(n/p) pollard_rho(long long x, long long a)函数：返回x的一个因子（不一定是素数），若失败则返回x。利用Floyd发明的类似“二倍速的算法”，具体参考上述伪代码。 注： 当然还有一些辅助函数，例如快速幂、Miller-Rabin算法、欧几里得算法等。 算法模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/*--------------------------------------------- POJ 1811 最后更新：2019/8/11 说明：该代码包含了取随机值函数rand()以及求最小值函数min() 注：适用范围是2^61,至少要保证中间结果不会溢出long long (中间结果最多是2*n) ----------------------------------------------*/#include&lt;cstdio&gt;#include&lt;cstdlib&gt; #include&lt;iostream&gt;typedef long long ll;/*--------------------------------------------- 利用 Miller-Rabin进行素性测试 ----------------------------------------------*/int testnum[] = &#123;2,7,61,3,5,11,13,19&#125;;ll fmul(ll a,ll b,ll p)&#123; /*返回a * b % p*/ a %= p,b %= p; //防止超出精度 ll res = 0; while(b)&#123; if(b&amp;1) res += a, res %= p; a &lt;&lt;= 1; //a = a*2 if(a &gt;= p) a %= p; b &gt;&gt;= 1; //b = b/2 &#125; return res;&#125;ll qpow(ll a,ll b,ll p)&#123; /*返回a^b % p*/ ll res = 1; while(b)&#123; if(b&amp;1) res = fmul(res,a,p); a = fmul(a,a,p); b &gt;&gt;= 1; &#125; return res;&#125;bool isPrime(ll n)&#123; /*Miller-Rabin判定x是否为素数*/ if(n == 2) return true; if(n &lt; 2 || n%2 == 0) return false; ll d = n-1, a, x, y;int t = 0; while((d&amp;1) == 0) d &gt;&gt;= 1,t++; for(int i = 0;i &lt; 7;i++)&#123; a = testnum[i]; if(n == a) return true; x = qpow(a,d,n); for(int j = 0;j &lt; t;j++)&#123; y = fmul(x,x,n); if(y == 1 &amp;&amp; x != 1 &amp;&amp; x != n-1) return false; x = y; &#125; if(x != 1) return false; &#125; return true;&#125;/*--------------------------------------------- 利用 pollard rho 算法进行质因数分解 ----------------------------------------------*/ll factors[110]; //用来存放被分解的因数(无序)int tot = 0; //因子个数ll gcd(ll a,ll b)&#123; /* 返回a和b的最大公约数 */ if(a == 0) return 1; if(a &lt; 0) return gcd(-a,b); while(b)&#123; ll t = a%b; a = b; b = t; &#125; return a;&#125;ll pollard_rho(ll x,ll c)&#123; /* 返回 x 的一个因子或 x 本身 */ ll i = 1,k = 2; ll tx = rand()%x; ll y = tx; while(true)&#123; i++; tx = (fmul(tx,tx,x)+c)%x; ll d = gcd(y-tx,x); if(d != 1 &amp;&amp; d != x) return d; if(y == tx) return x; //寻找失败 if(i == k) y = tx, k += k; &#125;&#125;void findFac(ll n)&#123; /* 对 n 进行质因数分解 */ if(isPrime(n))&#123; factors[++tot] = n; return ; &#125; ll p = n; /* 通过pollard_rho算法找到 n 的一个因子 p */ while(p &gt;= n) p = pollard_rho(p,rand()%(n-1)+1); findFac(p); //递归分解 findFac(n/p);&#125;int main()&#123; int t;ll n,ans; scanf("%d",&amp;t); while(t--)&#123; scanf("%lld",&amp;n); if(isPrime(n)) puts("Prime"); else&#123; tot = 0; ans = 1e18; findFac(n); for(int i = 1;i &lt;= tot;i++) ans = std::min(ans,factors[i]); printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数据结构与算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[划分树模板]]></title>
    <url>%2F2019%2F08%2F11%2Fhfs%2F</url>
    <content type="text"><![CDATA[划分树笔记问题模型： 对于给定的n个元素的序列A，有m次询问，每次询问给L ，R，K，请求出位于[L,R]内第K大的数。 解题思路：朴素算法：用快速排序。由于我们有m次询问，而每次询问区间左右端点是不同的，故如果对每个询问进行排序，我们在得到答案后还需要将序列恢复原状。按照快速排序的效率O(nlgn)，m次询问就是O(mnlgn)。如果m和n都很大，效率就低的可怜。划分树：由于划分树是基于线段树的一种数据结构，所以先回忆一下线段树。线段树是将一个区间划分成若干单元区间，并用二叉树结构储存，因而可以快速修改和查询。划分树是对一个序列进行划分，每个序列有两个子序列，左子序列中的元素不大于右子序列所有元素。如果我们用一个数组tree[25][MAXN]来存放每层对应位置的元素；创建toLeft[25][MAXN]，其中toLeft[dep][i]表示第dep层第1~i个元素有多少个进入左子序列。假设我们原始序列区间为[L,R]（初始时是[1,n]），而我们要找到[l,r]中第k大的数; 设cnt = toLeft[r] - toLeft[l-1]，那么说明[l,r]区间内前cnt小的数都在左子序列，所以我们下一步就可以根据k和cnt的大小关系选择走左子序列或右子序列，直至找到该元素。 建树：建树思路：建树过程很简单，和线段树类似，将一个大区间划分成若干单位区间，这里单位区间是只有一个元素时。加上我们之前说了，划分树的 左子区间所有元素 小于 右区间的元素，而为了树的平衡（平衡才是效率的保证！），所以我们可以取一个中位数，将当前区间中所有小于中位数的放在左子序列，反之放在右子序列。如此反复二分递归直至当前区间只有一个元素终止。之前我们开数组时，只开了25层，即tree[25][MAXN]，因为如果我们的树构建的足够好（左右子树元素个数相近），那么1e5规模下树顶多20层。（这里我将树的术语和序列、区间混用，因为我们是用数组模拟建树，所以本质上没什么不同，重要的是逻辑结构而不是物理结构）中位数不唯一：我们说了左右子树元素个数相近的树才是最够好的树，因为这样树的深度最小，而我们查询操作和树的深度成正比。如果中位数唯一，那么很显然左右子区间元素个数最多相差1；如果不唯一，根据我们的定义，左子区间放小于中位数的数，这样可能造成左右子区间元素个数相差过大（考虑1，2，2，2，2，2，2，2，3），所以我们需要一个策略来在这种情况下保证数仍然平衡。想要树平衡，只需让左右子树元素个数相近就行了，假设当前区间有N个元素，那么就要分给左子区间N/2个，剩下的分给右区间。所以我们设same = N/2，如果我们将当前区间所有小于中位数的元素都分给了左子区间，但是same仍不为0，那么我们就要再分same个中位数给左子区间，然后再将剩下的数分给右子区间。如此一来左子区间元素个数为same，右子区间也为N-same，最大相差1。 查询：对于查询，我们需要知道6个信息：当前区间的左右端点[L,R]，需要查询的区间[l,r]，当前区间所在的层数dep，以及k。我们想知道在区间[L,R]内的小区间[l,r]内第k大的数是谁。设cnt = toLeft[dep][r] - toLeft[dep][l-1]，那么说明[l,r]区间内前cnt小的数都在左子序列，所以我们下一步就可以根据k和cnt的大小关系选择走左子序列或右子序列，直至找到该元素。具体实现时，我们还需要考虑L和R如何变化，以及子区间内l和r以及k如何变化（即如何缩小可行区间），详情请参照代码理解。 代码模板：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* 划分树模板 创建于：2019/4/10 最后更新：2019/4/10 */ const int MAXN = 100100;int tree[20][MAXN];//表示每层每个位置的值 int toLeft[20][MAXN]; //已经排好序的数 //toLeft[dep][i]为dep层[1,i]有几个节点分到左子区间 int sorted[MAXN];//当前序列的左右端点、层数 void build(int l,int r,int dep)&#123; if(l == r) return; int mid = (l+r)/2; int same = mid - l + 1;//用于处理多个中位数相等 for(int i = l;i &lt;= r;i++) if(tree[dep][i] &lt; sorted[mid]) same--; int lpos = l; int rpos = mid+1; for(int i = l;i &lt;= r;i++)&#123; if(tree[dep][i] &lt; sorted[mid]) tree[dep+1][lpos++] = tree[dep][i]; else if(tree[dep][i] == sorted[mid] &amp;&amp; same &gt; 0)&#123; tree[dep+1][lpos++] = tree[dep][i]; same--; &#125;else&#123; tree[dep+1][rpos++] = tree[dep][i]; &#125; toLeft[dep][i] = toLeft[dep][l-1] + lpos - l; &#125; build(l,mid,dep+1); build(mid+1,r,dep+1);&#125;//查询区间第K大的数，[L,R]是大区间，[l,r]是要查询的小区间 int query(int L,int R,int l,int r,int dep,int k)&#123; if(l == r) return tree[dep][l]; int mid = (L+R)/2; int cnt = toLeft[dep][r] - toLeft[dep][l-1]; if(cnt &gt;= k)&#123; int newl = L + toLeft[dep][l-1] - toLeft[dep][L-1]; int newr = newl + cnt - 1; return query(L,mid,newl,newr,dep+1,k); &#125;else&#123; int newr = r + toLeft[dep][R] - toLeft[dep][r]; int newl = newr - (r-l-cnt); return query(mid+1,R,newl,newr,dep+1,k-cnt); &#125;&#125;int main()&#123; int n,m;//n个元素，m次询问 scanf("%d%d",&amp;n,&amp;m); for(int i = 1;i &lt;= n;i++)&#123; scanf("%d",&amp;tree[0][i]); sorted[i] = tree[0][i]; &#125; sort(sorted+1,sorted+n+1); build(1,n,0); //左闭右闭 int s,t,k; while(m--)&#123; scanf("%d%d%d",&amp;s,&amp;t,&amp;k); //在1~n位置中找到s~t位置内第k大的数 printf("%d\n",query(1,n,s,t,0,k)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cdq分治]]></title>
    <url>%2F2019%2F08%2F11%2Fcdq%2F</url>
    <content type="text"><![CDATA[CDQ分治笔记1.结论 CDQ分治可以用来解决偏序问题，尤其对于三维偏序问题适用。 CDQ分治重要思想：计算一个子问题对另一个子问题的贡献。 CDQ分治的优劣：写起来较为简单，对时空有很大的优化；缺点是必须离线操作。 2.二维偏序问题2.1逆序对逆序对: &emsp;&emsp;设 A 为一个有 n 个数字的有序集 (n&gt;1)，其中所有数字各不相同。如果存在正整数 i, j 使得 1 ≤ i &lt; j ≤ n 而且 A[i] &gt; A[j]，则 这个有序对称为 A 的一个逆序对，也称作逆序数。 例如，数组（3，1，4，5，2）的逆序对有(3,1),(3,2),(4,2),(5,2)，共4个。所谓逆序对的问题，即对给定的数组序列，求其逆序对的数量。 逆序对求解:&emsp;&emsp;正如我们在归并排序章节所接触的那样，我们可以通过模仿归并排序来求解逆序对，具体请复习归并排序相关内容。&emsp;&emsp;在用归并排序过程中，我们求逆序对的过程可以看作：找到一对数，使得 i &lt; j , 且 a[i] &gt; a[j]。这里实际上是二位偏序问题，因为我们涉及到两个维度的比较，即下标大小（默认升序）和值。在用归并思想求逆序对，我们是根据”左区间的下标必然小于右区间的下标“这个结论来归并统计逆序对的，也就是说我们忽略了“下标”这个维度的影响，将二维偏序问题降到了一维。逆序对问题的启发:&emsp;&emsp;现在我们将问题给出：“求所有满足a &lt; a0 且 b &gt; b0的有序对和”。&emsp;&emsp;我们可以发现上述问题和逆序对有相似处也有不同之处。相似在于他们都是求偏序问题，具体说都是求二维偏序问题；不同之处在于逆序对问题中，数组下标是默认升序的，故可以直接归并求解，而上述问题并没有说所有数对按照什么规则排序，说白了其就是乱序的。&emsp;&emsp;但实际上我们考虑到二维偏序问题，由于我们是在一个数对集合（假设为S）中找所有满足a &lt; a0 且 b &gt; b0的有序对和的集合T，那么S集合内元素的排序规则实际上对最终结果集合T毫无影响，所以我们可以将S集合内的数对按照a升序排列，这样就将二维比较降到一维，接下来就可以类似求逆序对一样使用归并思想求解了。如下表所示，一个是按照a升序排列，一个是乱序，其最终结果相同表1：S集合中数对按照a升序排列 a 1 2 3 4 5 b 4 3 2 5 1 表2：S集合中数对乱序排列 a 1 3 5 4 2 b 4 2 1 5 3 结果集合T: a b a0 b0 1 4 2 3 1 4 3 2 2 3 3 2 1 4 5 1 2 3 5 1 3 2 5 1 4 5 5 1 2.2 CDQ分治求二维偏序&emsp;&emsp;如果上面的问题你看懂了，那么其实二维的CDQ分治你就已然了解了。将上述问题的解题思路总结起来，就是：先按照一维排序，再按照另一维归并求结果集合T。 在上述做法中，我们的核心思想是使得一个维度（假设为a）对最终结果变得毫无影响，这样我们就只需要在另一维（假设为b）考虑比较即可，此时就可以用归并了。 2.3 二维偏序问题的拓展&emsp;&emsp;我们在上述讨论的是求满足条件的有序对集合T的问题。但我们可以拓展一下，如果我们将一个有序对看作某个数据的下标，（一个数据有俩个属性组成码）那么我们是不是就可通过求解满足条件的集合T，并通过集合T中的所有有序对，找到对应的数据呢？是的，我们可以通过归并的方法来快速找到我们想要的数据集合。考虑如下问题： 给定一个N个元素的序列A，初始值全部为0，对这个序列进行以下两种操作： 操作1：格式为1 x k，把位置x的元素加上k（位置从1标号到N）。 操作2：格式为2 x y，求出区间[x,y]内所有元素的和。 解题思路：&emsp;&emsp;上述问题是树状数组的裸题，但我们用来练习CDQ分治，并进一步了解其思想。考虑到给我们的操作集合（设为Q）是有先后顺序的（例如先修改，再查询，那么我们就要先修改值再查询），我们假设其到来的时间为time，那么Q集合中所有元素就都是按照time属性默认升序的了。 但是仅仅一个time属性还不足以表示所有操作，我们再考虑给每个操作加一个属性：pos来代表操作的位置。那么每个操作就可由time和pos来唯一标识， 至于操作是什么操作（是操作1还是操作2？）暂不探究。&emsp;&emsp;如此一来每个操作q，都有一个下标来唯一标识它。 那么我们就只需先执行time小的，pos靠前的操作，就可以得到答案。（举个例子：假设有俩个操作，1.修改位置2上的值为4，2.求位于区间[1,3]所有数的和。那么我们肯定要先执行1，再执行2）而此时我们又遇到了一个麻烦，操作2区间查询，涉及到两个位置，所以我们可以考虑将操作2区间查询操作分为两个部分，一个是操作a：减去当前位置前缀和；另一个是操作b：加上当前位置的前缀和。&emsp;&emsp;那么我们新建一个结构体Node{ int type,pos,val; } 来代表Q集合中的一个操作。其可能有三种情况，type = 1时代表修改操作，此时将pos位置上的元素+val。type = 2时代表减去pos位置上前缀和的操作，type = 3时表示加上当前位置上前缀和的操作；而对于2、3两种操作，val为着查询答案所在的下标，如此一来就可以将减去前缀和操作和加上前缀和操作结果累加在同一个位置。如此一来我们就可以通过归并来快速求解。代码示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int MAXN = 500050;const int MAXM = 500050;const int MAXQ = MAXN*3;typedef long long ll;struct Node&#123; int type,pos; ll val; Node(int type,int pos,ll val):type(type),pos(pos),val(val)&#123;&#125; Node()&#123;&#125; bool operator &lt; (Node b) const &#123; if(pos == b.pos) return type &lt; b.type; return pos &lt; b.pos; &#125;&#125;;int n,m;int aidx = 0,qidx = 0;Node query[MAXQ];Node tmp[MAXQ];ll ans[MAXQ];void CDQ(int l,int r)&#123; if(l &gt;= r-1) return; //左闭右开嘛 int mid = (l+r)/2; CDQ(l,mid); CDQ(mid,r); int p = l,q = mid,k = 0; ll sum = 0; while(p &lt; mid &amp;&amp; q &lt; r)&#123; if(query[p] &lt; query[q])&#123; if(query[p].type == 1) sum += query[p].val; tmp[k++] = query[p++]; &#125;else&#123; int x = query[q].val; if(query[q].type == 2) ans[x] -= sum; else if(query[q].type == 3) ans[x] += sum; tmp[k++] = query[q++]; &#125; &#125; while(p &lt; mid) tmp[k++] = query[p++]; //这里不用再累加修改的值，因为用不到了啊 while(q &lt; r)&#123; //这里还需将我们累加的结果进行运算，我们规定就是要累加左区间，查询右区间嘛 int x = query[q].val; if(query[q].type == 2) ans[x] -= sum; else if(query[q].type == 3) ans[x] += sum; tmp[k++] = query[q++]; &#125; for(int i = 0;i &lt; k;i++) query[i+l] = tmp[i]; &#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int x; for(int i = 1;i &lt;= n;i++)&#123; scanf("%d",&amp;x); query[qidx++] = Node(1,i,x); &#125; for(int i = 0;i &lt; m;i++)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); if(a == 1)&#123; query[qidx++] = Node(a,b,c); &#125;else&#123; query[qidx++] = Node(2,b-1,aidx); query[qidx++] = Node(3,c,aidx); aidx++; &#125; &#125; CDQ(0,qidx); for(int i = 0;i &lt; aidx;i++) printf("%lld\n",ans[i]); return 0;&#125; 3.三维偏序问题3.1 例题 &emsp;&emsp;已知有n个元素，每个元素有三个属性（ai,bi,ci），现在问存在多少个元素，使得ai &lt; aj 且 bi &lt; bj 且 ci &lt; cj？设f(i) 为对于每个i，满足条件的j的个数。 解题思路：&emsp;&emsp;和之前的二维偏序问题不同的是，此时我们需要对三个维度进行比较，回想一下对于二维我们的处理方法：先对其中一个维度进行排序，然后采用归并的方法来对第二个维度进行统计。&emsp;&emsp;如果我们还像之前那样操作如何呢？我们按照a进行排序，然后再利用归并对左边区间和右边区间进行合并（我们这里用归并里的说法），在合并的过程中，我们用和求逆序对类似的方法，比较第二个元素（即b）的大小，此时遇到了一个问题：如何处理c。这里我介绍的方法是在处理c时用树状数组，树状数组是用来快速求前缀和，并支持快速单点修改的一个数据结构，所以我们可以用树状数组来存放小于c的元素的个数，如此一来每次在对右区间进行查找所有小于ci的cj的个数即可。 （因为aj默认小于ai，所以当bj]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[st表（一维）]]></title>
    <url>%2F2019%2F08%2F11%2Fst%2F</url>
    <content type="text"><![CDATA[摘要ST表是一个用来处理区间最值查询（Range Maximum/Minimum Query）的离线算法。该算法分为离线预处理O(n log n)和查询O(1)两个部分，其用到了倍增的思想。某个区间查询问题是否适用ST表，关键在于其进行的操作是否允许区间重叠，例如max(a,b,c) = max{max(a,b),max(b,c)}就可以用ST表维护，而区间和问题则不能维护。 问题描述给定一个长度为n的序列，有m次询问，每次给定区间[L , R]，求区间内最大值。 算法思路定义st表我们设 st[i][j] 为从 i 开始的 2^j 个数中的最大值。假设这n个数存放的序列a中，根据定义 st[i][j] = max{a[k] | i &lt;= k &lt;= i+2^j - 1}。查询操作假设我们已经更新完st表（下文会讲如何在O(n log n)时间内更新），那么我们应该如何利用上述定义的st表查询[L , R]内的最大值呢？根据我们上述st表的定义，我们发现，我们能在st表中查询的区间（假设为[a,b]）都只能从某个位置a开始向后$2^k-1$个区间（k是自然数），所以如果a-b 并不恰好等于 $2^k$，那么多出来的部分（即$[a+2^k , b]$）我们并不能直接求出来，只能用类似的方法求出$[b-2^k+1,b]$的最大值，那么最终[a,b]的最大值不就是以上两段区间的max吗？当然这里的k要取使得$a+2^k &lt; b$成立的最大值，即$log_2^{b-a+1}$。举个例子，求[2 , 10]的最大值可以拆分为求[2 , 9]的最大值和[3 , 10]的最大值。于是查询操作（查询[L , R] ）就顺利成章的是max(st[L][k] , st[R-(1&lt;&lt;k) + 1][k])。预处理我们在上述证明了查询操作确实是O(1)的，所以如果我们真的能按照st表定义的那样去更新它，那么该算法就真正的完成了。更新st表用到了动态规划的思想。更新中仍然用到了倍增的思想，使得更新操作从O(n^2)优化到了O(n log n)，初始状态st[x][0] = a[x]，st[x][j] = max(st[x][j-1] , st[x + (1&lt;&lt;(j-1)) ][j-1])。其思想和上述重叠查询类似，不再赘述。但是要注意更新顺序，因为其中 j （第二维）才是阶段，而第一维 x 是状态，所以对于 j 的循环要放在最外层。 代码示例123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;int n,m;const int N = 1e5+10;int a[N],st[N][25],Log[N];//2^20就过一百万了，完全够用 //初始化st表 void init()&#123; Log[1] = 0;//预处理log函数 for(int i = 2;i &lt;= n+1;i++) Log[i] = Log[i/2]+1; for(int i = 1;i &lt;= n;i++) st[i][0] = a[i]; for(int j = 1; (1&lt;&lt;j) &lt;= n;j++)&#123; //涉及到位运算多加括号! for(int i = 1;i + (1&lt;&lt;(j-1)) &lt;= n;i++)&#123; st[i][j] = max(st[i][j-1],st[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125;&#125;int ask(int l,int r)&#123; int k = Log[r-l+1]; int mx = max(st[l][k],st[r-(1&lt;&lt;k)+1][k]); //printf("%d %d\n",k,mx); return mx;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1;i &lt;= n;i++) scanf("%d",a+i); init(); for(int i = 1,l,r;i &lt;= m;i++)&#123; scanf("%d%d",&amp;l,&amp;r); printf("%d\n",ask(l,r)); &#125;&#125;]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A* 与 IDA*]]></title>
    <url>%2F2019%2F08%2F11%2FIDA%2F</url>
    <content type="text"><![CDATA[IDA*虽然剪枝在较快找到接近最优解的解时能够有效减少状态数，但是在尚未找到较好的解时，依然会尝试许多不必要的状态。虽然我们在下界比最优解更大时可以剪枝，但是不知道最优解的话就没法做到了。因此，我们可以不直接去求最优解，而是改成通过搜索判断是否有不超过某个x的解。把x从0开始每次增加1，那么首次找到解时的x就是最优解。这样，搜索过程中就不会访问那些下界比最优解更大的状态了。将程序改成判断是否有不超过某个x的解，只需要在下界超过x时，停止搜索就好了，代码几乎没有什么变动。考虑平凡下界的情况（即使得所有状态都满足的下界），此时，程序就会像宽度优先搜索一样，按照距离初始状态的远近顺序访问各个状态。这被称为迭代加深搜索（IDDFS，Interative Deepening Depth-First Search）。而像这样通过估算下界提前剪枝优化后的算法则称为IDA* 。它通常可以表述如下： 给出状态v到目标状态的距离下界的估算函数h（v）。 令x = 0。 堆满足d（v） + h（v） &lt;= x的状态进行深度优先搜索，判断是否有不超过x的解（d(v) 表示初始状态到目标状态的距离）。 如果找到解，则x就是最优解，程序结束。 否则，将x增加1并回到第3步。 IDA* 中所访问的状态总是满足d(v) + h(v) &lt;= 最优解，而h(v)的估值越接近到目标状态的实际距离，则搜索所经过的状态数就越少。 可能会有一个疑问，就是上述x不断+1再判断是否有解的过程和二分搜索很类似，那能否用二分搜索来做呢？不能，因为随着x的增大，搜索状态是指数级上升，所以x要越小越好（即使搜索了x从1~1000，也比搜索一次x = 1100要快）。 A *正如深度优先算法可以利用下界优化一样，宽度优先搜索和 Dijkstra 算法也可以利用下界优化。只要将优先队列中的键改成 d(v) + h(v) 就可以了，其中 d(v) 是初始状态到状态 v 的距离，h(v) 是到目标状态的距离下界。这种算法称为A * 。 需要注意的是，与宽度优先搜索和 Dijkstra 算法不同，在选用某些下界进行估算的情况下，优先队列顶端的元素对应的 d(v) 未必已经是初始状态到 v 的最短距离。 如果对于所有的边（u，v）都有cost(u , v)+h(u) - h(v) &gt;= 0成立，那么第一次取出某个节点时，对应的 d(v) 就一定是最短距离。 A 与 IDA 的比较A 和IDA 分别是针对宽度优先搜索和深度优先搜索的算法。我们可也i很容易地把深度优先搜索改写成IDA ，同样也可以很容易的把宽度优先搜索或者Dijkstra改写成A 。 当然，不仅在代码上改写容易，它们也各自继承了一些改写前算法的特点。例如，IDA 基本不怎么花费内存，而A 则要花费关于搜索空间的线性的内存。另一方面，可以通过不同路径达到同一状态时，IDA 可能会重复多次经过某些状态而导致效率一落千丈，而A 通过选取合适的下界则可以保证每个状态至多检查一次。 通常来说，随着搜索深度的增加，搜索空间的大小呈指数级别增长。所以，虽然IDA * 不断增加递归深度限制的过程重复搜索了很多状态，但总的访问状态数和最后一次访问状态数还是同一数量级的。]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笛卡尔树]]></title>
    <url>%2F2019%2F08%2F11%2Fcartesin%2F</url>
    <content type="text"><![CDATA[摘要笛卡尔树（Cartesian Tree）是一种树形数据结构。由于其具有二叉搜索树和堆的性质，如果以一棵笛卡尔树对应一段区间的话，那么整段区间的极值就是根节点A，同时又满足A的左子树对应极值左边区间，右子树对应右边区间。这样递归定义，就会将一个区间划分若干段。而笛卡尔树之所以具有上述性质我们会在接下来讲解。本文首先介绍笛卡尔树的概念以及它具有的性质，然后介绍如何来构造一棵笛卡尔树，当然，对笛卡尔树结构的分析也是必不可少的。 笛卡尔树的概念笛卡尔树（Cartesian Tree）是一种同时满足堆性质和二叉搜索树性质的一棵二叉树。因此笛卡尔树的树根对应着该树的极值（堆性质），并且对其中序遍历得到的是原序列一段连续的区间（二叉搜索树性质）。我们假设利用一个整数序列A：a1~an 建立笛卡尔树，那么树上每个节点有2个键值，idx（下标）和 val（值）。我们使树上每个节点的idx满足二叉搜索树性质，而val满足堆性质，于是笛卡尔树就建成了。 笛卡尔树具有的性质如果我们以A序列建立一棵笛卡尔树的话，显然笛卡尔树具有如下性质： 父亲节点的键值val均小于（或大于）其左右子节点的键值。 节点的左儿子idx比其小，右儿子的idx比其大。中序遍历即为原序列A。 上述两条性质分别是堆和二叉搜索树的性质，而我们通过对两个键值进行不同约束，使得这两种数据结构结合在了一起，使得我们可以很轻松的求出一段区间的极值。 类似笛卡尔树的数据结构有树堆（Treap），它也是将二叉搜索树和堆结合在一起，只不过其是利用堆来维持搜索树不至于退化严重，并没有利用其来求极值。因此，我们可以对比理解。 如何建立笛卡尔树对于给定序列A，建立一棵笛卡尔树的时间复杂度为O(N)。首先，如果类似于Treap中插入操作来建立一棵笛卡尔树的话，时间复杂度是O(N* log N)，但是由于给定序列的下标idx是递增的，因此我们可以利用单调栈在线性时间内建树。 首先考虑对于一棵已经建好的子树$T_i$，对于新来的节点x = Node(idx = i+1，val = value)，其一定是要沿着当前节点的根一路向右走，直至找到合适的位置。假设我们把节点x插入到最右边，那么首先可知在idx维度是合法的，但是其val并不一定比起父亲节点要大（假设这颗笛卡尔树是小根堆），因此如果x.val 小于其父亲的val，那么就需要交换位置，同理，就像在Treap中一样一直交换到合适的位置。 而如果我们栈S中存放的是当前最右边子树（实际上就是一个节点）的根节点y，那么如果x位置合法，则将x压入S，作为y的右子树，此时x成为了新的根节点；如果x不合法，则将栈顶元素弹出，再与下一个节点比较，直至找到合法位置再将x压入，而弹出的节点则应该放在节点x的左边。（如果弹出不止一个节点，则应该作为x节点的左子树） 而每个点进栈和出栈至多一次，因此时间复杂度是O(N)。 建立一棵保存区间最小值的笛卡尔树具体步骤如下： 将待插入节点 x 与当前栈顶元素比较，若其val大于当前栈顶元素，则作为栈顶元素的右儿子，并入栈，插入下一个元素，否则转2。 若待插入节点 x 的 val 小于当前栈顶元素，则将栈顶元素弹出，不断重复直至栈顶元素的 val 小于节点 x 的val，此时最后一个弹出的栈顶元素作为节点 x 的左儿子。 当所有节点插入完毕后，栈底节点则为这颗笛卡尔树的根节点。 当然上述判断栈是否为空的步骤并未加上，实际书写代码时应该注意这点。 代码示例我们以HDU1506为例。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;const int N = 1e5+10;int a[N],tot = 0,n;typedef long long ll;ll ans;ll max(ll a,ll b)&#123; return a &lt; b?b:a;&#125;struct Node&#123; int idx,val; //下标、权值 int l,r,par; //左儿子、右儿子、父亲节点的编号 Node()&#123;&#125; Node(int idx,int val) :idx(idx),val(val)&#123; l = r = par = 0; &#125;&#125;t[N];int BuildTree()&#123; for(int i = 1;i &lt;= n;i++)&#123; int k = i-1; while(t[k].val &gt; t[i].val) k = t[k].par; t[i].l = t[k].r;//k的右子树作为i的左子树 t[k].r = i; //i作为k的右子树 t[i].par = k; //i的父亲是k t[t[i].l].par = i;//i的左子树的父亲是i // printf("%d %d\n",i,k); &#125; return t[0].r;//最终树的根节点的编号 &#125;int dfs(int rt)&#123; //printf("%d\n",rt); if(rt == 0) return 0; ll sz = 1; sz += dfs(t[rt].l); sz += dfs(t[rt].r); ans = max(ans,sz*(t[rt].val)); return sz;&#125;void solve()&#123; for(int i = 0;i &lt;= n;i++) t[i] = Node(i,a[i]); tot = ans = 0; int rt = BuildTree(); dfs(rt); printf("%lld\n",ans);&#125;int main()&#123; while(scanf("%d",&amp;n) &amp;&amp; n)&#123; for(int i = 1;i &lt;= n;i++) scanf("%d",a+i); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组区间修改+区间查询]]></title>
    <url>%2F2019%2F08%2F11%2FBIT2%2F</url>
    <content type="text"><![CDATA[数组数组区间修改+区间查询在之前整理树状数组笔记时，已经将单点修改以及区间查询写的很清楚了。树状数组本质上就是一个可以在线 快速查询前缀和，并可以快速更新数值并维护的数据结构。我们喜欢用树状数组是因为其代码简单易记，出错率低，并且效率还不错。 理论推导如果涉及单点修改、区间查询，那么代码很简单。但是如果是区间修改，就需要做一些改变了。首先进行如下推导：（前置知识：前缀和、差分数组）假设数组a是存放初始数据，sum存放a数组的前缀和，而b数组为差分数组，即每当为[l,r]位置所有元素+val时，b[l]+= val,b[r] -= val。而sumb为b数组的前缀和数组，这样sumb[i]就存放着a[i]修改值。那么很显然最后a[i]的值为a[i]+sumb[i]，即初始值+修改值。此时再来考察a数组的前缀和，sum[i]存放的是a[1]+a[2]+…+a[i]，（请注意a数组始终未作改变，其改变的值存放在sumb数组中），很显然我们要求的结果(数组a的最终前缀和) ans = sum[ i ]+\sum_{j = 1}^i sumb[ j ]又由于 sumb[i] = \sum_{ j = 1}^i b[j]所以 ans = sum[i] + \sum_{j = 1}^i \sum_{k = 1}^j b[k]至此我们已经抛弃了sumb这个保存b数组前缀和的数组，ok吗？我们得到的公式是根据一个常量数组sum和一个不断被修改的b数组来求ans的。（注：这里ans为a数组的最终前缀和）如果上面的公式没有问题，接下来我们的目标就是求b数组的二重和式。 来变形： \sum_{j = 1}^i \sum_{k = 1}^j b[k] = \sum_{j = 1}^i (i - j + 1)* b[j] = (i +1)\sum_{j = 1}^ib[j] - \sum_{j = 1}^i j* b[j]首先，这个公式变换是常用套路，如果有问题可以自己用矩阵求和来推一下。其次，变换成这个公式的好处是我们只需维护 j * b[j] 的前缀和就可以直接求出a数组修改后的前缀和了。 具体实现：具体操作是，我们建立两个树状数组c0和c1。其中c0是用来求b[j]前缀和的，而c1是用来求j * b[j]前缀和的。那么对于每个区间修改（为[l,r]上所有数字+val），我们执行4个操作： 在树状数组c0中，把位置l上的数 + val。 在树状数组c0中，把位置r+1上的数 - val。 在树状数组c1中，把位置l上的数 + l* val。 在树状数组c1中，把位置r+1上的数 -（r+1）* val 另外，sum数组存放序列a的原始前缀和。所以每次查询[l,r]前缀和，当然还是拆分成求[1,r]和[1,l-1]的前缀和，二者相减。写成式子如下： (sum[r] + (r+1) * ask(c0,r) - ask(c1,r) ) - (sum[l-1] + l * ask(c0,l-1) - ask(c1,l-1) )代码示例：这里以POJ3468为例：1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;const int MAXN = 1e5+10;typedef long long ll;ll c[2][MAXN];ll a[MAXN],sum[MAXN];int n,m;void add(int k,int x,int y)&#123; for(;x &lt;= n;x += x&amp;-x) c[k][x] += y;&#125;ll ask(int k,int x)&#123; ll ans = 0; for(;x;x -= x&amp;-x) ans += c[k][x]; return ans;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1;i &lt;= n;i++) scanf("%lld",a+i); for(int i = 1;i &lt;= n;i++) sum[i] += sum[i-1] + a[i]; while(m--)&#123; char op[10]; int l,r,val; scanf("%s",op); if(op[0] == 'C')&#123; scanf("%d%d%d",&amp;l,&amp;r,&amp;val); add(0,l,val); add(0,r+1,-val); add(1,l,l*val); add(1,r+1,-(r+1)*val); &#125; else&#123; scanf("%d%d",&amp;l,&amp;r); ll ans = sum[r] + (r+1)*ask(0,r) - ask(1,r); ans -= sum[l-1] + l*ask(0,l-1) - ask(1,l-1); printf("%lld\n",ans); &#125; &#125; return 0;&#125; 参考书目： 《算法竞赛进阶指南》.李煜东.P200]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组模板1]]></title>
    <url>%2F2019%2F08%2F11%2FBIT%2F</url>
    <content type="text"><![CDATA[测试地址：洛谷P3374模板说明书： 本模板仅使用单点修改以及查询前缀和，其他用途需按需修改。 本模板建树采用了将初始值当成修改值插入的方法，复杂度O（NlgN）代码示例： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const int MAXN = 500050;int n,m;int a[MAXN],c[MAXN];void init()&#123; //初始化函数，顺便离线以下lowbit数组 memset(a,0,sizeof a); memset(c,0,sizeof c);&#125;void add(int x,int y)&#123; for(;x &lt;= n;x += x&amp;-x) c[x] += y;&#125;ll ask(int x)&#123; ll ans = 0; for(;x;x -= x&amp;-x) ans += c[x]; return ans;&#125;int main()&#123; init(); scanf("%d%d",&amp;n,&amp;m); for(int i = 1;i &lt;= n;i++) scanf("%d",a+i); for(int i = 1;i &lt;= n;i++) add(i,a[i]); for(int i = 1;i &lt;= m;i++)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); if(a == 1) add(b,c); else printf("%lld\n",ask(c)-ask(b-1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分算法模板]]></title>
    <url>%2F2019%2F08%2F11%2Ferfen%2F</url>
    <content type="text"><![CDATA[摘要之前整理的二分搜索模板在对找x的前驱、后继以及实数域上的二分都有各自不同的代码，其中一些小细节需要我们不断去测试修改最终得以实现不遗漏且保证答案正确性。而现在我们可以将上述几种不同的二分搜索代码整合在一起，对于不同的使用情况只需稍微修改一下“精度”即可。 代码模板1234567int low = 0,high = n; while(low &lt;= high)&#123; int mid = (low + high)/2; if(check(mid)) low = mid+1; else high = mid-1; //EPS &#125; return high; 使用说明当循环退出时，一定是low &gt; high，或者说low = high + EPS。若是求大于x的最小值，由于每次是mid位置的数大于x时收缩high的值，于是最终一定是high不满足条件时退出，故答案应该在low。若是求小于x的最大值，由于每次是mid位置的数小于x时收缩low的值，因此最后一定是low偏离正确答案，即high上是答案。而对于实数域上的问题，对EPS进行精度约束即可，一般比所求精度小10倍即可。]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[倍增求LCA]]></title>
    <url>%2F2019%2F08%2F11%2Flca%2F</url>
    <content type="text"><![CDATA[LCA：即求一棵有根树中两个节点的最近公共祖先。 树上倍增法树上倍增法是一个很重要的算法。除了求LCA外，在很多问题中都有广泛应用。设F[x,k]表示x的2^k倍祖先，即从x向根节点走2^k步到达的节点。特别的，若该节点不存在，则令F[x,k] = 0。F[x,0]就是x的父节点，除此之外，对于任意的1 &lt;= k &lt;= log n，F[x,k] = F[F[x,k-1],k-1]。这就类似于一个动态规划的过程，“阶段”就是节点的深度。因此，我们可以对树进行广度优先遍历，按照层次顺序，在节点入队之前，计算它在F数组中相应的位置。以上部分是预处理，时间复杂度为O(N log N)，之后可以多次对不同的x，y计算LCA，每次询问的时间复杂度为O(log N)。算法步骤： 设d[x] 表示 x 的深度。设 d[x] &gt;= d[y] （否则可以交换x，y）。 用二进制拆分思想，把 x 向上调整到与 y 同一深度。 若此时 x = y，说明已经找到了LCA，LCA就等于y。 用二进制拆分思想，把x，y同时向上调整，并保持深度一致且二者不相会。 此时x，y必定只差一步就相会了，他们的父节点F[x,0]就是LCA。 代码模板： HDU2586 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;cstring&gt;const int N = 2*41000;int head[N],ver[N],nex[N],edge[N],tot = 0;int deep[N],anc[N][25],dis[N];void swap(int &amp;x,int &amp;y)&#123;x ^= y;y^=x;x^=y;&#125;void addEdge(int x,int y,int z)&#123; ver[++tot] = y,edge[tot] = z; nex[tot] = head[x],head[x] = tot;&#125;void dfs(int x)&#123; /* 1.初始化anc数组， 2.初始化deep数组 3.初始化dis数组 以上三个都可以通过dfs来实现 */ for(int i = 1;i &lt;= 22;i++) anc[x][i] = anc[anc[x][i-1]][i-1]; for(int i = head[x]; i;i = nex[i])&#123; int y = ver[i],z = edge[i]; if(dis[y] || y == 1) continue;//防止重复访问 deep[y] = deep[x]+1; dis[y] = dis[x] + z; anc[y][0] = x; dfs(y); &#125;&#125;int Lca(int u,int v)&#123; /* 先把深度调到一致，再按照二进制拆分思想找寻最近公共祖先 */ if(deep[u] &lt; deep[v]) swap(u,v); //u是较深的节点 for(int i = 22;i &gt;= 0;i--)&#123; if(deep[anc[u][i]] &gt;= deep[v]) u = anc[u][i]; &#125; if(u == v) return u; for(int i = 22;i &gt;= 0;i--)&#123; if(anc[u][i] != anc[v][i])&#123; u = anc[u][i]; v = anc[v][i]; &#125; &#125; return anc[u][0];&#125;int ask(int u,int v)&#123; return dis[u] + dis[v] -2*dis[Lca(u,v)];&#125;int main()&#123; int t,n,m; scanf("%d",&amp;t); while(t--)&#123; memset(dis,0,sizeof dis); memset(deep,0,sizeof deep); memset(anc,0,sizeof anc); memset(head,0,sizeof head);//head也要初始化 scanf("%d%d",&amp;n,&amp;m);tot = 0; for(int i = 1,x,y,z;i &lt; n;i++)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); addEdge(x,y,z); addEdge(y,x,z); &#125; dfs(1); for(int i = 1,x,y;i &lt;= m;i++)&#123; scanf("%d%d",&amp;x,&amp;y); printf("%d\n",ask(x,y)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高度数组与最长公共前缀]]></title>
    <url>%2F2019%2F08%2F10%2Flcp%2F</url>
    <content type="text"><![CDATA[摘要本文是关于后缀数组的一个拓展，问题模型来自于最长公共前缀（Longest Common Prefix Array）问题，我们为解决该模型，在后缀数组的基础上设计了一个精巧的数组——高度数组（lcp），同时由于该数组在处理各类字符串相关问题时有着较好的用途，因此值得掌握。 本文将直接从高度数组讲起，假设读者具有后缀数组的基础知识。首先本文会介绍高度数组的定义以及用途，接着讲解如何在O(N)时间内求出高度数组，最后将介绍高度数组的应用。 高度数组（LCP Array ，Longest Common Prefix Array）所谓的高度数组，指的是由后缀数组中相邻两个后缀的最长公共前缀（LCP）的长度组成的数组。记后缀数组为sa，高度数组为lcp，则有后缀S[ sa[i]… ] 与 S[sa[i+1] … ] 的最长公共前缀的长度为lcp[i] 。我们可以在O(n)时间内高效地求得高度数组，有了高度数组，后缀数组将成为一个更加有力的工具。高度数据虽然计算简单，但非常巧妙，使用了类似尺取法的技巧。记rank[i] 为位置 i 开始的后缀在后缀数组中的顺序，即有rank[ sa[i] ] = i。 构造方法我们从位置0的后缀开始，从前往后依次计算后缀S[i…]与后缀S[sa[rank[i]-1]…]（即后缀数组中的前一个后缀）的最长公共前缀的长度。此时，假设我们已经求得了位置 i 对应的高度h_i，那么我们可以证明位置 i+1 对应的高度应该不小于h_i-1。 为什么呢？记k = sa[rank[i] - 1] ，已知后缀S[i…]和S[k…]的头部h_i个字符是相等的，那么后缀S[i+1…]和S[k+1…]分别是二者去除首字符的结果，所以它们头部h_i-1个字符是相等的。虽然在后缀数组中，S[i+1…]前面一个元素未必就是S[k+1…]，但即便如此，公共前缀的长度也是只增不减的。因此，只要从h_i-1开始检查，计算最长公共前缀的长度就好了。 代码模板因为高度最多增加n次，所以总的时间复杂度为O(n)。如果把这个问题当作位置i对应的区间是[i,i+h)的尺取法来看，就很容易理解。区间的左右端点始终不会向左移，并且是不超过n的整数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6+10;int n,k;char str[N];/* sa[i]表示排名为i的后缀起始位置是多少 rank[i]表示起始位置是i的串排名是多少 rank[sa[i] ] = i , sa[rank[i] ] = i,rank与sa互逆 */ int sa[N],rank[N],tmp[N],lcp[N];//比较(rank[i],rank[i+k])和(rank[j],rank[j+k]) bool compare_sa(int i,int j)&#123; if(rank[i] != rank[j]) return rank[i] &lt; rank[j]; int ri = i+k &lt;= n ? rank[i+k] : -1; int rj = j+k &lt;= n ? rank[j+k] : -1; return ri &lt; rj;&#125;//计算字符串S的后缀数组 void construct_sa(char* S,int sa[])&#123; n = strlen(str); //初始长度为1，rank直接取字符的编码 for(int i = 0;i &lt;= n;i++)&#123; sa[i] = i; rank[i] = i &lt; n ? S[i] : -1; &#125; //利用对长度为k的排序结果对长度为2k的排序 for(k = 1;k &lt;= n;k *= 2)&#123; sort(sa,sa+n+1,compare_sa); tmp[sa[0]] = 0; for(int i = 1;i &lt;= n;i++) tmp[sa[i]] = tmp[sa[i-1]] + (compare_sa(sa[i-1],sa[i])?1:0); for(int i = 0;i &lt;= n;i++) rank[i] = tmp[i]; &#125; &#125;//最长公共前缀模板,其中sa为后缀数组,求得结果存放在lcp void construct_lcp(char *S,int sa[],int lcp[])&#123; int n = strlen(S); for(int i = 0;i &lt;= n;i++) rank[sa[i]] = i; int h = 0;lcp[0] = 0; /*lcp[i] 表示起始位置为sa[i]与 起始位置为sa[i+1]的串的最长公共前缀长度*/ for(int i = 0;i &lt; n;i++)&#123; int j = sa[rank[i]-1]; /*此处j表示排在"以i开始的后缀"前面一名的子串的起始位置*/ if(h &gt; 0) h--; for(;j + h &lt; n &amp;&amp; i+h &lt; n;h++)&#123; if(S[j+h] != S[i+h]) break; &#125; /*h为以i开头的后缀与以j开头的后缀的"最长公共前缀"的长度*/ lcp[rank[i]-1] = h; /*于是以j开头的后缀 与以i开头的后缀 的 最长公共前缀的长度 被存放在lcp[rank[i]-1]中,因为lcp定义的就是: lcp[k] 为排名为i的后缀与排名为i+1的后缀的最长公共前缀的长度*/ &#125;&#125;int main()&#123; while(scanf("%s",str) != EOF)&#123; construct_sa(str,sa); construct_lcp(str,sa,lcp); for(int i = 1;i &lt;= n;i++) printf("%d ",lcp[i]); puts(""); &#125; return 0;&#125; 参考资料 秋叶拓哉，挑战程序设计竞赛第2版，北京：人民邮电出版社，2013.6，378-381]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组笔记]]></title>
    <url>%2F2019%2F08%2F10%2Fsa%2F</url>
    <content type="text"><![CDATA[什么是后缀数组字符串后缀（Suffix）指的是从字符串的某个位置开始到其末尾的字符串子串。我们认为原串和空串也是后缀。反之，从字符串开头到某个位置的字符串子串则称为前缀。 后缀数组（Suffix Array）指的是将某个字符串的所有后缀按字典序排序后得到的数组。不过数组中并不需要直接保存所有的后缀字符串，只要记录对应的起始位置就好了。 后缀数组的计算假设我们要计算长度为n的字符串S的后缀数组。最朴素的做法就是直接把所有后缀进行排序，将n个长度为O(n)的字符串进行排序的时间复杂度为O(N^2logN)。而如果灵活运用所有的字符串都是S的后缀这一性质，就可以得到更高效的算法。下面介绍一种由Manver和Myers发明的O(N log N)复杂度的算法。 该算法的基本思想是倍增。首先计算从每个位置开始的长度为2的子串的顺序，再利用这个结果计算长度为4的子串的顺序，接下来计算长度为8的子串的顺序，不断倍增，直到长度大于等于n就得到了后缀数组。下面，我们用 S[i , k] 表示从位置i开始的长度为k的字符串子串。 其中，剩余字符不足k个时，表示的是从位置 i 开始到字符串末尾的子串。 要计算长度为 2 的子串顺序，只要排序两个字符组成的数对就好了。现在假设已经求得了长度为 k 的字串的顺序，要求长度为 2k 的子串顺序。记$rank_k$为S[i , k] 在所有排好序的长度为k的子串中是第几小的。要计算长度为 2k 的子串的顺序，就只要对两个rank组成的数对进行排序就好了。我们通过对rank_k(i) 与 rank_k(j+k) 的数对的比较来 替代对 S[i , 2k] 和 S[j , 2k] ，比较randk_k(i+k)和rank_j(j+k)就相当于比较S[i+k , k] 和 S[j+k , k] 。所以，我们可以这样高效的比较长度为 2k 的子串 ，并将它们排序。 算法模板该代码共用到了三个数组，tmp , sa , rank；其中tmp数组是用来临时存放新计算的rank的，而 sa[i] 则存放的当前长度为k时字典序第 i 小的字符起始位置是sa[i]。1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6+10;int n,k;char str[N];int sa[N],rank[N],tmp[N];//比较(rank[i],rank[i+k])和(rank[j],rank[j+k]) bool compare_sa(int i,int j)&#123; if(rank[i] != rank[j]) return rank[i] &lt; rank[j]; int ri = i+k &lt;= n ? rank[i+k] : -1; int rj = j+k &lt;= n ? rank[j+k] : -1; return ri &lt; rj;&#125;//计算字符串S的后缀数组 void construct_sa(char* S,int sa[])&#123; n = strlen(str); //初始长度为1，rank直接取字符的编码 for(int i = 0;i &lt;= n;i++)&#123; sa[i] = i; rank[i] = i &lt; n ? S[i] : -1; &#125; //利用对长度为k的排序结果对长度为2k的排序 for(k = 1;k &lt;= n;k *= 2)&#123; sort(sa,sa+n+1,compare_sa); tmp[sa[0]] = 0; for(int i = 1;i &lt;= n;i++) tmp[sa[i]] = tmp[sa[i-1]] + (compare_sa(sa[i-1],sa[i])?1:0); for(int i = 0;i &lt;= n;i++) rank[i] = tmp[i]; &#125; &#125;int main()&#123; while(scanf("%s",str) != EOF)&#123; construct_sa(str,sa); for(int i = 1;i &lt;= n;i++) printf("%d ",sa[i]+1); puts(""); &#125; return 0;&#125; 例题POJ3518：Sequence测试地址题意简述：给定 N 个数字组成的序列$A_1 , A_2 , … , A_n$。其中$A_1$比其它数字都大。现在要把这个序列分成三个子段，并将每段分别反转，求能得到的字典序最小的序列是什么？要求分得的每段都不为空。解题思路：确定第一段是很简单的，因为第一个数最大，所以肯定旋转后要在末尾，所以只要把A数组倒置后求后缀数组，取字典序最小且合法的后缀，即为第一段的答案。这里的合法是指剩下的元素个数要大于2，不然没法分成3段。 然后要想把剩余的部分分成两段。不过这次的两端并不是独立的，不能简单的比较前半部分的字典序取最小者。不过，将序列分割成两端再分别反转得到的序列，可以看作是两个原序列拼接后得到的新序列中的某个子串反转后得到的序列。因此，只需要计算拼接后的序列的后缀数组，从中选择字典序尽量小并且合法的即可。 比如：从ABCDE中选俩段反转后字典序最小。等同于从EDCBAEDCBA中选择一个字典序最小的合法子串。 代码示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 2e5+20;const int INF = 0x3f3f3f3f;int A[N],rev[2*N],sa[2*N];int n,k,m,tmp[2*N],rank[2*N];bool compare_sa(int i,int j)&#123; if(rank[i] != rank[j]) return rank[i] &lt; rank[j]; int ri = i+k &lt;= n ? rank[i+k]:-INF-1;//这里不要搞错 int rj = j+k &lt;= n ? rank[j+k]:-INF-1; return ri &lt; rj;&#125;//注意A的下标是[0,len)的 void construct_sa(int A[],int len,int sa[])&#123; n = len; for(int i = 0;i &lt;= n;i++)&#123; sa[i] = i; rank[i] = i &lt; n ? A[i] : -INF; &#125; for(k = 1;k &lt;= n;k *= 2)&#123; sort(sa,sa+n+1,compare_sa); tmp[sa[0]] = 0; for(int i = 1;i &lt;= n;i++) tmp[sa[i]] = tmp[sa[i-1]] + (compare_sa(sa[i-1],sa[i])?1:0); for(int i = 0;i &lt;= n;i++) rank[i] = tmp[i]; &#125;&#125;void solve()&#123; reverse_copy(A,A+m,rev); construct_sa(rev,m,sa); int p1,p2; //考虑一下p1需要满足的条件 for(int i = 1;i &lt;= m;i++)&#123; p1 = m-sa[i]; if(p1 &gt;= 1 &amp;&amp; m-p1 &gt;= 2) break; &#125; reverse_copy(p1+A,A+m,rev); reverse_copy(p1+A,A+m,rev+m-p1); construct_sa(rev,2*(m-p1),sa); //考虑p2的范围 for(int i = 1;i &lt;= 2*(m-p1);i++)&#123; p2 = sa[i]; if(p2 &gt; 0 &amp;&amp; p2 &lt; m-p1) break; &#125; reverse(A,A+p1); //输出答案 for(int i = 0;i &lt; p1;i++) printf("%d\n",A[i]); for(int i = p2;i &lt; p2+m-p1;i++) printf("%d\n",rev[i]);&#125;int main()&#123; scanf("%d",&amp;m); for(int i = 0;i &lt; m;i++) scanf("%d",A+i); solve(); return 0;&#125; 参考资料 秋叶拓哉，挑战程序设计竞赛第2版，北京：人民邮电出版社，2013.6，378-381]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Miller_Rabin模板]]></title>
    <url>%2F2019%2F08%2F08%2FMiller-Rabin%2F</url>
    <content type="text"><![CDATA[摘要Miller-Rabin素性测试是一种用来检验一个数 Q 是否为素数的随机算法。其时间复杂度为$O(log^3Q)$。其正确性为 $1-4^{-k}$ 其中 k 为检验次数。该算法原本是由Gary Lee Miller 基于广义黎曼猜想发明，后经由Micheal O.Rabin改为不依赖该假设的随机化算法。该算法的高效基于费马小定理 以及 二次探测法 ，本文将首先简单介绍这两个基本理论，而后给出算法流程以及代码模板。 问题模型例1：给定一个数Q，请判断其是否为素数(1e10 &lt; Q &lt; 1e14)。 解题思路：判断一个数是否为素数，我们有在此之前是有$O(\sqrt{N})$的解题策略的，当然也有O(N)求出1~N所有素数的线性筛法，但是对于在1e10级别的待测数Q，这两者都显得过于低效，难以达到我们期望的效果。Miller-Rabin算法是一种快速的大素数判断算法，判断每个素数仅需$O(log^3Q)$的时间，对于判断大素数而言有着令人满意的效率，因此我们可以采用该算法。 费马小定理与二次探测法费马小定理： $a^{p-1} \equiv 1(mod p)$其中 p 是素数时费马小定理才一定成立。于是得以得到“ p 是素数”是“费马小定理成立”的充分不必要条件。即存在一个数 p ，使得$a^{p-1} \equiv 1(mod p)$，但p不是素数。本来我们是仅根据“p 是否能使得费马小定理成立”来判断 p 是否为素数，但这样错误率有点高，于是便有了二次探测法。 二次探测法： 如果 p 是一个素数，且 0 &lt; x &lt; p，则方程$a^2 \equiv1(mod p)$的解为 a = 1 或 a = p - 1。 证明：易得：$a^2 - 1 \equiv 0(mod p)$所以 $(a+1)(a-1)\equiv0(mod p)$所以 $p|(a-1)(a+1)$又因为p是质数所以 a = 1 或 a = p-1 注：其中 | 为整除符号，代表 p 能整数(a-1)(a+1)或者(a-1)(a+1)能被 p 整除。 算法流程有了费马小定理，我们的算法模型就初步成型了，即测试一个数是否满足费马小定理来判断其是否可能为素数。假设这个数通过了费马小定理的测试，那么其有可能为素数，于是对其进行二次探测，如果仍然通过，则是素数的可能就很大（就可以基本认定其为素数），有效的提高了正确率。但是由于我们的费马小定理对于底 a 是没有要求的，因此我们需要多挑几个底来做测试，提高算法正确性。网上有些结论，对于4,759,123,141以内的数，都可以通过以2，7，61为底的Miller-Rabin算法来进行判断。不过常用的还是取随机数，取k次正确率就是$1-4^{-k}$，在出题人不知道你的随机数是多少的情况下，还是很难hack掉你的。 现在，如果有一个大于 2 的质数 n，令n-1 = 2^s * d，其中 d 为奇数，则根据费马小定理，如果a不能被素数 n 整除，则a^{n-1} \equiv 1 (mod n)。于是可以推出： a^d\equiv1(mod n) 或者 a^2 \equiv 1 (mod n)，a^{2^r * d}\equiv n-1(mod \:n)，0 &lt;= r &lt; s，其中a为任意自然数。于是我们只需找到一个a，满足a^{n-1} \neq1(modn)或者存在一个自然数r(0&lt;= r &lt;s)，使得a^{2^r * d} \neq n-1(modn)，就可以说明 n 一定不是素数。 伪代码：isPrime(n):&emsp;1.如果n为偶数，返回false；&emsp;2.求出d、t，d为n-1去掉所有因子2后的值，同样的，t为n-1中因子2的个数；&emsp;3.取一个随机数a，令x = a^d mod n；&emsp;4.对于所有的 r (0 &lt;= r &lt; t)，令y = a^{2^r * d} mod n，即y = x * x mod n，若y = 1，则根据二次探测定理，x必须为1或n-1，否则n不是素数，返回false；&emsp;5.若x != 1，则不满足费马小定理，返回false，否则走3或返回true。 算法模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* API： fuml(a,b,p)返回 a*b%p 的值,在中间结果溢出longlong时使用 qpow(a,b,p)返回 a^b%p 的快速幂函数 isPrime(n)将在O(log^3 n)时间内判断出n是否为素数，并返回结果 typedef long long ll 头文件：cstdilb, */typedef long long ll;int testnum[] = &#123;2,7,61,3,5,7,11,13,17,19&#125;;ll fmul(ll a,ll b,ll p)&#123; /*return a*b%p*/ ll res = 0; while(b)&#123; if(b&amp;1) res = (res+a)%p; a = (a+a)%p; b &gt;&gt;= 1; &#125; return res; &#125;ll qpow(ll a,ll b,ll m)&#123; /*return a^b %m*/ ll res = 1; while(b)&#123; if(b&amp;1) res = fmul(res,a,m); a = fmul(a,a,m); b &gt;&gt;= 1; &#125; return res;&#125;bool isPrime(ll n)&#123; if(n == 2) return true; if(n &lt; 2 || n%2 == 0) return false; ll d = n-1 , a, x, y; int t = 0; while((d&amp;1) == 0) d &gt;&gt;= 1,t++; //此时b为没有因子2的奇数 for(int i = 0;i &lt; 3;i++)&#123; a = testnum[i]; if(n == a) return true; /*以本身为底是一定不成立的哦,需特判*/ x = qpow(a,d,n); /*我们要使得所有的a(^(2^r)*d)都满足二次探测定理*/ for(int j = 0;j &lt; t;j++)&#123; y = fmul(x,x,n); if(y == 1 &amp;&amp; x != 1 &amp;&amp; x != n-1) return false; x = y; &#125; if(x != 1) return false; /*不满足费马小定理*/ &#125; return true; /*当x=n-1，或b为奇数时返回true*/ &#125; 参考资料 算法设计编程实验，吴永辉，北京：机械工业出版社，2013，79-80]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性基]]></title>
    <url>%2F2019%2F07%2F26%2Fxxj%2F</url>
    <content type="text"><![CDATA[摘要线性基类似于线性空间中基底的一个概念。而在这里，线性基特指用来处理“集合为非负整数，运算为异或”的一类问题。在线性代数中有线性无关和极大线性无关组的概念，这里的线性基与之类似。首先本文会从理论上介绍线性基所具有的性质以及其构造方法，接着会介绍线性基的常见操作以及其适用的问题范围。最终以例题讲解结束。 什么是线性基线性基是一种特殊的基，它通常出现在异或运算中，它的意义为：通过原集合的某一最小子集S1使得S1内元素相互异或得到的值域与原集合S相互异或得到的值域相同。如果按照线性代数中的说法，也可以表述为：通过S1内元素的组合异或可以得到原集合S中所有的元素。那么S-S1其实就是冗余元素了，因为这些元素都可以通过线组合异或S1中的元素得到。 线性基的性质下文中“最高位”若无特殊说明，皆指二进制下所有值为1的最高位，如10110的最高位就是第4位（从右向左是第0~4位）。 线性基没有异或和为0的子集。 线性基的异或集合中每个元素的异或方案唯一（与性质1等价）。 线性基中的元素通过组合异或得到的值域和原集合组合异或得到的值域相同。 线性基中每个基的二进制最高位不同。 如果线性基是满线性基，则它的异或集合为区间$[1,2^n-1]$（n个基）。 性质5很好证明，就像8个二进制位可以表示的范围是$[0,2^8-1]$，而我们这里的线性基不包含0，因此就是$[1 , 2^n-1]$。 性质4也是显而易见的。根据我们线性基的定义，其是原集合的最小子集，若有俩个最高位p（二进制从右向左第p位）上为1，那么它们对值域的贡献重复了，就不符合最小子集这一性质了。 性质3不需要解释了吧。性质1也很简单，我们线性基中是没有0向量的，而又由于性质4，所以不可能组合出0向量。 对于性质2的证明：如果我们要从线性基中挑若干个基异或得到x，那么假设$a_1$ xor $a_2$ xor … xor $a_p$ =$b_1$ xor $b_2$ xor … xor $b_q$ = x，那么显然$a_1$ xor $a_2$ xor … xor $a_p$ xor$b_1$ xor $b_2$ xor … xor $b_q$ = 0。与性质1矛盾，故性质2成立。 至此我们简单却正确的证明了上述5个性质的正确性。 线性基的构造方法要给出个结论①： 若向量组中有a和b，那么若把b替换为a xor b，替换前后向量组中的向量线性组合得到的空间相同。证明：若c = a xor b，用c替代b，这样原向量组从 a、b 变成了 a 、c；而a、c可以得到a、a xor c，即 a、b，因此a、c向量组实际等于a、b。 我们知道二进制位从右向左是低位到高位，现在我们从左向右遍历每一个数x的二进制位，下同。假设待插入线性基集合中的元素为x。 由于性质4，所以若 x 当前位置p上为1，它要么作为最高位为 p 的基，要么就乖乖的把第p位消为0，转而看看能不能当最高位为 p-1的基。而这里消掉 x 第 p 位的方法是与当前最高位为 p 的元素异或，依据上述结论①，显然这样消正确的，不会影响最终结果。 假设我们已经有基：1010、101，那么如果想插入1110，首先已经有1010了，所以其不能做最高位为3的基，于是消掉变为0110，又发现不能作为最高位为2的基，转而看看第1位，发现可以，于是他就成了10。这样我们就有了最高位是1、2、3 的基。 于是我们又发现我们只需根据性质4，记录最高位为 p 的数是多少就可以了，于是用一维数组P[ i ]来表示最高位为 i 的数是多少。 伪代码： 12345678for( j = 最高位; j &gt;= 0 ; j-- )&#123; if(x的第j位为1)&#123; if(线性基中有最高位为第 j 位的元素P[ j ])&#123; x = P[j] xor x; break; &#125;else P[j] = x; &#125;&#125; 线性基的常用操作插入：正如上述伪代码所述，插入一个数x，其时间复杂度为O(log x)。 删除： 首先我们可以注意到上述做法构造出来的线性基很难支持删除操作。合并线性基： 将一个线性基中的所有基用插入操作插入另一个线性基。时间复杂度为O(log n)。存在性查询： 可以发现，如果 x 无法插入，那么显然说明线性基可以构造出来x。O(log n)。求线性基能够组成的最大值： 从高位到低位扫描，如果异或该位的基后可以使得答案变大，则异或。O(log n)。求线性基表出的最小值： 从低位向高位找，第一个基就是答案。求第k小值： 我们之所以无法用上述构造方法构造出的线性基解决这题的原因在于，我们只保证了每个线性基最高位不同，却并未保证每个位上都有唯一的一个1，即1000000100000001是合法的线性基，但是00000001是最小的，而次小的却不是10000001，而是00000001 xor 10000001。于是我们可以考虑用类似高斯消元的方法来使得其满足“只要存在最高位为 p 的基，那么其它基的第 p 位都不能为1。”这样就可以通过 将k拆分成二进制位，如果拆分后第 i 位为1，就将ans与线性基中最高位为 i 的基异或，这样就能求出第 k 小。 例题练习2019 Multi-University Training Contest 1 — Operation测试地址 题意简述： 给定一个具有 n 个元素的数组，有两种操作： 在[l , r] 中选择一些数，使之异或和最大，输出最大值。 在数组最后添加一个数。 解题思路：首先如果不看操作2，那么显然操作1就是求区间内最大异或和问题。对于这样的问题，我们可以对于每个位置p记录最靠近其的前30个位置的线性基，当然这样并不能保证记录的线性基一定在[p - 30 , p ]内，所以在查询时也要筛掉位置在[l , r]外的基。说到这儿自然就又引入了一个记录每个基在原数组中的位置的数组pos。于是通过pos[N][30]和f[N][30]我们就可以在O(30)时间内查询，完成操作1。对于操作2呢，我们要想的是如何更新 f 和 pos 数组。那么当插入一个新的元素 x 时，显然其所在位置为n+1（n为插入前元素总数），那么f[n+1][0~30]和f[n][0~30]不同之处就在于新元素 x 要更新原有线性基，使得最靠左的基被靠右（因为我们求最大异或和，一定是靠右位置的基优先被选择，所以如果俩个基的贡献相同，就用靠右的替代靠左的）的基更新即可。 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;iostream&gt;int t,n,m,lastans = 0;const int N = 5e5+10;int a[N],f[N][40],pos[N][40];void Query(int l,int r)&#123; int ans = 0; for(int i = 30;i &gt;= 0;i--)&#123; if(pos[r][i] &gt;= l)&#123; //并不是f[r][30]所有元素都是在[l,r]内的 if((ans^f[r][i]) &gt; ans) ans ^= f[r][i]; &#125; &#125; printf("%d\n",ans); lastans = ans;&#125;void Append(int tot,int x)&#123; int nex = tot; for(int i = 0;i &lt;= 30;i++) f[tot][i] = f[tot-1][i],pos[tot][i] = pos[tot-1][i]; for(int i = 30;i &gt;= 0;i--) if((1&lt;&lt;i)&amp;x)&#123; if(!f[tot][i])&#123;f[tot][i] = x;pos[tot][i] = nex;return;&#125; if(pos[tot][i] &lt; nex)&#123; /*找到最左边的那个基， 这样不断替换最终最左边的基被挤出去 nex是目前最靠左的位置*/ std::swap(x,f[tot][i]); std::swap(nex,pos[tot][i]); &#125; x ^= f[tot][i]; &#125;&#125;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; lastans = 0; scanf("%d%d",&amp;n,&amp;m); for(int i = 1;i &lt;= n;i++) scanf("%d",a+i),Append(i,a[i]); for(int i = 1,op,l,r,x;i &lt;= m;i++)&#123; scanf("%d",&amp;op); if(op == 0)&#123; scanf("%d%d",&amp;l,&amp;r); l ^= lastans;r ^= lastans; l %= n;r %= n; l++;r++; if(l &gt; r) std::swap(l,r); Query(l,r); &#125;else&#123; scanf("%d",&amp;x); x ^= lastans; Append(++n,x); &#125; &#125; &#125; return 0;&#125; 参考资料 小蜜蜂的博客 lzw4896s的博客 ouuan的博客]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Treap]]></title>
    <url>%2F2019%2F07%2F25%2FTreap%2F</url>
    <content type="text"><![CDATA[Treap是是英文Tree和Heap的合成词，又称树堆。树堆是指具有随机附加域，且附加域满足堆性质的二叉搜索树。它属于平衡树的一种，主要是为了克服二叉搜索树易退化的情况。Treap利用“随机”来创造平衡条件，我们在插入每个节点时，除了其值val，我们还给它随机附加一个权值dat，使得权值val满足BST性质，而dat满足二叉堆性质。如此一来我们就保证了树的深度，使得检索、插入、求前驱、后继以及删除节点的时间复杂度都是O(log N)。例题： 普通平衡树BZOJ3224您需要写一种数据结构，来维护一些数，其中需要提供以下操作： 插入数值x 删除数值x（若有多个相同的数，应只删除一个） 查询数值x的排名（若有多个相同的数，应输出最小的排名） 查询排名为x的数值 求数值x的前驱（前驱定义为小于x的最大的数） 求数值x的后继（后继定义为大于x的最小的数） 解题思路：这是一道平衡树的模板题，我们需要做的操作是在线的增删查，且查询分为四种。我们采用Treap解决。根据题意，数据种可能有相同的数值，我们可以给每个节点增加一个域cnt，用来记录该节点的“副本数“，初始为1。若插入已存在是数值，就直接把该”副本数“加1。在删除时，减少该副本数，当减为0时删除该节点。如此就解决了关键码相同的问题。对于查询排名，我们可以给每个节点新增一个域size，记录以该节点为根的子树中所有节点的”副本数“之和。与线段树一样，我们需要在插入或者删除时从下往上更新size。另外，在发生旋转操作时，也需要修改size。最后，在检索BST基础上，通过判断左右子树size的大小，选择适当的一侧递归，就很容易查询排名了。 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int SIZE = 100010;struct Treap &#123; int l, r; // 左右子节点在数组中的下标 int val, dat; // 节点关键码、权值 int cnt, size; // 副本数、子树大小&#125; a[SIZE]; // 数组模拟链表int tot, root, n, INF = 0x7fffffff;int New(int val) &#123; a[++tot].val = val; a[tot].dat = rand(); a[tot].cnt = a[tot].size = 1; return tot;&#125;void Update(int p) &#123; a[p].size = a[a[p].l].size + a[a[p].r].size + a[p].cnt;&#125;void Build() &#123; New(-INF), New(INF); root = 1, a[1].r = 2; Update(root);&#125;int GetRankByVal(int p, int val) &#123; if (p == 0) return 0; if (val == a[p].val) return a[a[p].l].size + 1; if (val &lt; a[p].val) return GetRankByVal(a[p].l, val); return GetRankByVal(a[p].r, val) + a[a[p].l].size + a[p].cnt;&#125;int GetValByRank(int p, int rank) &#123; if (p == 0) return INF; if (a[a[p].l].size &gt;= rank) return GetValByRank(a[p].l, rank); if (a[a[p].l].size + a[p].cnt &gt;= rank) return a[p].val; return GetValByRank(a[p].r, rank - a[a[p].l].size - a[p].cnt);&#125;void zig(int &amp;p) &#123; int q = a[p].l; a[p].l = a[q].r, a[q].r = p, p = q; Update(a[p].r), Update(p);&#125;void zag(int &amp;p) &#123; int q = a[p].r; a[p].r = a[q].l, a[q].l = p, p = q; Update(a[p].l), Update(p);&#125;void Insert(int &amp;p, int val) &#123; if (p == 0) &#123; p = New(val); return; &#125; if (val == a[p].val) &#123; a[p].cnt++, Update(p); return; &#125; if (val &lt; a[p].val) &#123; Insert(a[p].l, val); if (a[p].dat &lt; a[a[p].l].dat) zig(p); // 不满足堆性质，右旋 &#125; else &#123; Insert(a[p].r, val); if (a[p].dat &lt; a[a[p].r].dat) zag(p); // 不满足堆性质，左旋 &#125; Update(p);&#125;int GetPre(int val) &#123; int ans = 1; // a[1].val==-INF int p = root; while (p) &#123; if (val == a[p].val) &#123; if (a[p].l &gt; 0) &#123; p = a[p].l; while (a[p].r &gt; 0) p = a[p].r; // 左子树上一直向右走 ans = p; &#125; break; &#125; if (a[p].val &lt; val &amp;&amp; a[p].val &gt; a[ans].val) ans = p; p = val &lt; a[p].val ? a[p].l : a[p].r; &#125; return a[ans].val;&#125;int GetNext(int val) &#123; int ans = 2; // a[2].val==INF int p = root; while (p) &#123; if (val == a[p].val) &#123; if (a[p].r &gt; 0) &#123; p = a[p].r; while (a[p].l &gt; 0) p = a[p].l; // 右子树上一直向左走 ans = p; &#125; break; &#125; if (a[p].val &gt; val &amp;&amp; a[p].val &lt; a[ans].val) ans = p; p = val &lt; a[p].val ? a[p].l : a[p].r; &#125; return a[ans].val;&#125;void Remove(int &amp;p, int val) &#123; if (p == 0) return; if (val == a[p].val) &#123; // 检索到了val if (a[p].cnt &gt; 1) &#123; // 有重复，减少副本数即可 a[p].cnt--, Update(p); return; &#125; if (a[p].l || a[p].r) &#123; // 不是叶子节点，向下旋转 if (a[p].r == 0 || a[a[p].l].dat &gt; a[a[p].r].dat) zig(p), Remove(a[p].r, val); else zag(p), Remove(a[p].l, val); Update(p); &#125; else p = 0; // 叶子节点，删除 return; &#125; val &lt; a[p].val ? Remove(a[p].l, val) : Remove(a[p].r, val); Update(p);&#125;int main() &#123; Build(); cin &gt;&gt; n; while (n--) &#123; int opt, x; scanf("%d%d", &amp;opt, &amp;x); switch (opt) &#123; case 1: Insert(root, x); break; case 2: Remove(root, x); break; case 3: printf("%d\n", GetRankByVal(root, x) - 1); break; case 4: printf("%d\n", GetValByRank(root, x + 1)); break; case 5: printf("%d\n", GetPre(x)); break; case 6: printf("%d\n", GetNext(x)); break; &#125; &#125;&#125; 参考书目： 《算法竞赛进阶指南》李煜东.P229]]></content>
      <categories>
        <category>ACM学习笔记</category>
      </categories>
  </entry>
</search>
